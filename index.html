<!DOCTYPE html><HTML lang="en"><HEAD> 
<!-- Copyright (c) 2024 Antti Saarenheimo

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<META charset="utf-8"> 
<META http-equiv="Cache-Control" content="no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate">
<META http-equiv="pragma" content="nocache"> 
<TITLE>Seasonal Pumped Thermal Energy Storage</TITLE> 
<!--link href="bootstrap.min.css" rel="stylesheet" type="text/css"/-->
<LINK href="index_files/jquery-ui.css" rel="stylesheet"> 
<SCRIPT src="index_files/jquery-1.11.0.min.js"></SCRIPT>
<SCRIPT src="index_files/jquery-migrate-1.2.1.min.js"></SCRIPT>
<SCRIPT src="index_files/jquery-ui.js"></SCRIPT>
<SCRIPT src="coolprop.js"></SCRIPT>
<!--SCRIPT type="javascript">
	console.log("typeof Module="+(typeof Module));
</SCRIPT-->
<style>
td {
	text-align:right; 
	font-family: Verdana;
	font-size: 60%;
	color: black;
}
th {
	font-family: Verdana;
	font-size: 60%;
	font-weight: bold;
	color: black;
}
</style>
</HEAD> 
<BODY onload="drawTpDiagram()">

<DIV><H3>Pumped Thermal Energy Storage Simulator - powered by Coolprop&nbsp;&nbsp;&nbsp; <a href="TeraPTES_en.pdf">Feasibility study</a>&nbsp;&nbsp;&nbsp; <a href="TeraPTES_fi.pdf">Feasibility study in finnish</a></H3></DIV>
<!--ul class="nav nav-tabs" id="myTab" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home" type="button" role="tab" aria-controls="home" aria-selected="true">Design parameters</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="storage-tab" data-bs-toggle="tab" data-bs-target="#storage" type="button" 
	onClick="drawOnlyStorage()" role="tab" aria-controls="storage" aria-selected="false">Storage</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="diagrams-tab" data-bs-toggle="tab" data-bs-target="#diagrams" type="button" 
		onClick="drawTpDiagram()" role="tab" aria-controls="diagrams" aria-selected="false">TP-diagram</button>
  </li>
</ul-->
<div class="tab-content" id="myTabContent">
  <div class="tab-pane show active" id="home" role="tabpanel" aria-labelledby="home-tab">
<DIV><LABEL>FluidName:</LABEL>
	<SELECT id="name" onchange="setGasMassFlowFor1200MW(this)"><OPTION>Argon</OPTION><!--OPTION>CarbonDioxide</OPTION--><OPTION>Helium</OPTION><OPTION>Hydrogen</OPTION><OPTION>Methane</OPTION><OPTION selected>Nitrogen</OPTION><!--OPTION>CarbonDioxide</OPTION--><!--OPTION>R134a</OPTION><OPTION>Water</OPTION-->
	</SELECT><BUTTON onClick="drawTpDiagram()">Draw storage, T-P diagram and compressors</BUTTON>
	<!--BUTTON onClick="drawOnlyStorage()">Redraw storage</BUTTON--> 
	<BUTTON onClick="calcDiagrams()">Draw the selected diagrams</BUTTON> 
	<!--<INPUT id="noDistrictHeat" checked type="checkbox" value="true"><LABEL>Use stored liqued nitrogen to maximize electric output</LABEL>-->
	<!--BUTTON 
	onClick="zoomToTpDiagram(10)">Zoom to T-P diagram</BUTTON> <INPUT id="zoom" type="float" value="10"-->
</DIV>
<DIV>
	<DIV>
		<LABEL>Mass flow of main turbins (kg): </LABEL><INPUT size="4" id="dischargeMassFlow" type="float" value="1645" onchange="metricsChanged()">
		<LABEL>Number of power units: </LABEL><INPUT id="numberOfUnits" type="text" value="4" size="2" maxlength="2" onchange="metricsChanged()">
		<INPUT id="powerOnly" type="checkbox" checked value="1"><LABEL>Optimize for power only</LABEL>
		<INPUT id="dischargeMassFlowRange" type="checkbox"><LABEL>Draw diagram for Gross turbin work MW: </LABEL><INPUT size="4" id="dischargeMassFlowFrom" type="float" value="400"> - <INPUT size="4" id="dischargeMassFlowTo" type="float" value="4000">
	</DIV>

<!--	<LABEL>Gross turbin work MW: </LABEL><INPUT size="4" id="grossWorkOut" type="float" value="1400" onchange="metricsChanged()">
	<INPUT id="grossWorkOutRange" type="checkbox"><LABEL>Draw diagram for Gross turbin work MW: </LABEL><INPUT size="4" id="grossWorkOutFrom" type="float" value="600"> - <INPUT size="4" id="grossWorkOutTo" type="float" value="8000">
-->
</DIV>
<DIV>
	<LABEL>Storage size million ton: </LABEL><INPUT size="4" id="storageSizeMTon" type="float" value="25" onchange="metricsChanged()">
	<INPUT id="hpStorageSize" type="checkbox"><LABEL>Draw diagram for Plow</LABEL><INPUT style="width:2em" size="2" VALUE="48" id="pLowStorageSize"/><LABEL>kPa and range:</LABEL><INPUT size="4" id="hpStorageSizeFrom" type="float" value="10"> - <INPUT size="4" id="hpStorageSizeTo" type="float" value="60">
</DIV>
<DIV>
	<LABEL>P high/low: </LABEL><INPUT size="4" id="highToLowPressureRatio" type="float" value="26" onchange="metricsChanged()">
	<LABEL>P low kPa: </LABEL><INPUT size="4" id="targetPLow" type="float" value="96" onchange="metricsChanged()"> 
	<!--LABEL>P high/low (in discharge): </LABEL><INPUT size="4" id="highToLowPressureRatio" type="float" value="25" onchange="metricsChanged()">
	<LABEL>P low kPa (in discharge): </LABEL><INPUT size="4" id="targetPLow" type="float" value="95" onchange="metricsChanged()"--> 
	<INPUT id="pRatioRange" type="checkbox" checked><LABEL>Draw diagram for P low </LABEL><INPUT style="width:2em" size="2" VALUE="48" id="pLowPressureRatio"/><LABEL> kPa in P1/P2 range:</LABEL><INPUT size="4" id="pRatioFrom" type="float" value="10"> - <INPUT size="4" id="pRatioTo" type="float" value="50">
</DIV>
<DIV>
	<LABEL>T high (Kelvins): </LABEL><INPUT size="4" id="tHigh" type="float" value="1173"> 
	<INPUT id="tHighRange" type="checkbox"><LABEL>Draw diagram for T high (K) range:</LABEL>
	<INPUT size="4" id="tHighFrom" type="float" value="800"> - <INPUT size="4" id="tHighTo" type="float" value="1500">
</DIV>
<DIV>
	<LABEL>Turbin stage efficiency: </LABEL>
	<INPUT size="4" title="95-97% is the upper efficiency for a modern industrial size turbin" id="tEfficiency" type="float" value="0.97"> 
	<LABEL>Stage efficiency of cryogenic compressor: </LABEL>
	<INPUT size="4" title="Industrial size cryogenic turbins do not yet exist, but hot turbins can be scaled down to cryogenic temperatures" id="cLowEfficiency" type="float" value="0.955"> 
	<INPUT id="tEffRange" type="checkbox"><LABEL>Draw diagram for turbin and compressor stage efficiencies </LABEL><INPUT size="4" id="tEfficiencyFrom" type="float" value="0.90"> - <INPUT size="4" id="tEfficiencyTo" type="float" value="0.97"></Div>
<DIV>
	<LABEL>Compressor efficiency: </LABEL>
	<INPUT size="4" title="94-95% is a typical efficiency range for a a modern industrial size compressor stage" id="cEfficiency" type="float" value="0.955"> 
	<LABEL>Stage efficiency of cryogenic turbin: </LABEL>
	<INPUT size="4" title="Industrial size cryogenic turbins do not yet exist, but hot turbins can be scaled down to cryogenic temperatures" id="tLowEfficiency" type="float" value="0.97"> 
	<!-- powerOnly option produces worse power back % than the combined power ????-->
	<a href="https://www.renk.com/en/products/turbo-high-speed/vacuum-gearbox-systems/het">Vacuum gear efficiency: </a><INPUT size="4" id="gearEfficiency" type="float" value="0.993"> 
	<LABEL>Generator efficiency: </LABEL><INPUT size="4" id="generatorEfficiency" type="float" value="0.99"> 
	<LABEL>Frequency converter efficiency: </LABEL><INPUT size="4" id="frequencyConverterEfficiency" title="For the heat pump and cold compressor startup" type="float" value="0.97"> 
	<!--INPUT size="4" id="cEfficiencyFrom" type="float" value="0.87"><INPUT size="4" id="cEfficiencyTo" type="float" value="0.93"-->
</Div>
<DIV>
	<LABEL>HP storage density tn/m3:</LABEL><INPUT size="3" id="rockDensityHp" type="float" value="3.0" onchange="metricsChanged()">, Cp J/g:<INPUT size="3" id="hpCp" type="float" value="0.90" onchange="metricsChanged()">
	<LABEL>LP storage density tn/m3:</LABEL><INPUT size="3" id="rockDensityHp" type="float" value="2.8" onchange="metricsChanged()">, Cp J/g:<INPUT size="3" id="lpCp" type="float" value="0.84" onchange="metricsChanged()">
	<!--LABEL>Gravel density in the storage (tn/m3): </LABEL><INPUT size="4" id="gravelDensity" type="float" value="2.1" onchange="metricsChanged()"-->
	<LABEL>Insulation gravel porosity: </LABEL><INPUT size="4" id="insGravelPorosity" type="float" value="0.5" onchange="metricsChanged()">
	<LABEL>Open pit angle: </LABEL><INPUT size="2" id="maxOpenPitAngle" type="float" value="73" onchange="metricsChanged()">
	<LABEL>Max top fill angle: </LABEL><INPUT size="2" id="maxTopFillAngle" type="float" value="70" onchange="metricsChanged()">
</DIV>
<DIV>
	<LABEL>Max relative pressure drop in pipes: </LABEL><INPUT size="4" id="maxPressureDrop" type="float" value="0.01" onchange="metricsChanged()">
	<!--LABEL>Average cost of insulation, gas isolation and borders €/m2: </LABEL><INPUT size="4" id="costOfSurfaceM2" type="float" value="1200" onchange="metricsChanged()"-->
	<LABEL>Max heat leak out W/m&#xB2;: </LABEL><INPUT size="3" style="width:3em" id="maxHeatFlowOut" type="float" value="20" onchange="metricsChanged()">
	<LABEL>U value of stone wool+gravel mix W/mK: </LABEL><INPUT size="4" style="width:4em" id="uOfGravelrockwoolMix" type="float" value="0.1" onchange="metricsChanged()">
</DIV>
<!--DIV>  You cannot remelt vulcanized rubber and max temp on vulcanaized rubber is about 200 Celsius 
	<LABEL>Gas enclosed inside: </Label>
	<INPUT type="radio" id="isolatedWithRecycledRubber" value="rubber" checked onclick="document.getElementById('isolatedWithSteel').checked=false"><label>Melted recycled tire rubber+gravel, the temperature range 223 K - </label><Input type="float" id="maxRubberTemp" size="3" value="673"><span> K<span>
	<INPUT type="radio" id="isolatedWithSteel" value="steel" onclick="document.getElementById('isolatedWithRecycledRubber').checked=false"><label>Steel</label>
</DIV-->
<DIV>
	<LABEL>Average cost of construction work, insulation and gas isolation €/m2: </LABEL><INPUT size="4" id="costOfSurfaceM2" type="float" value="1200" onchange="metricsChanged()">
	<LABEL>Cost of open pit mining €/m3: </LABEL><INPUT size="4" id="costOfMiningM3" type="float" value="12" onchange="metricsChanged()">
	<LABEL>Max hot rock strength (MPa): </LABEL><INPUT size="2" id="maxHotRockPressureMPa" type="float" value="100" onchange="metricsChanged()">
</DIV>
<DIV>
	<LABEL>Cost of turbomachinery power €/kW: </LABEL><INPUT size="4" id="tcCostOfKW" type="float" value="40" onchange="metricsChanged()">
	<LABEL>Costs of power plant and generator €/kW: </LABEL><INPUT size="4" id="otherCostOfKW" type="float" value="200" onchange="metricsChanged()">
	<!--LABEL>Cost of generator €/kW: </LABEL><INPUT size="4" id="generatorCostOfKW" type="float" value="50" onchange="metricsChanged()"-->
	<LABEL>Cost of heat exchage €/kW: </LABEL><INPUT size="4" id="heCostOfKW" type="float" value="40" onchange="metricsChanged()">
</DIV>
<!--DIV>
	<INPUT id="cryogenicCooling" checked title="pLow gas cooled to saturation temperature with heat pump" type="checkbox" value="true">
	<LABEL>Set T low equal to Saturation temperature in P low with heat pump</LABEL>
	<INPUT id="motorGenerator" checked title="Compressors and turbins share the same axle and motor-generator" type="checkbox" value="true">
	<LABEL>Compressors and turbins share the same axle and motor-generator</LABEL>
	<INPUT id="showEnthalpyAndInternalEnergy" title="" type="checkbox" value="true">
	<LABEL>Show the mass specific enthalpy (J/g) and entropy (J/g/K) lines</LABEL>
</DIV-->
<DIV>
	<LABEL>Low pressure gravel min/max:</LABEL><INPUT id="gravelMinLp" type="float" value="40" size="3" maxlength="3"onchange="metricsChanged()">/
	<INPUT id="gravelMaxLp" type="float" value="120" size="3" maxlength="3"onchange="metricsChanged()">
	<LABEL>Porosity:</LABEL><INPUT id="gravelPorosityLp" onfocus="porositySet=true" type="float" size="4" maxlength="4" onchange="metricsChanged()">
	<BUTTON onClick="metricsChanged(); calcPressureDropInGravel('Lp')">Pressure drop</BUTTON><LABEL id="expectedPDropLp"></LABEL>
</DIV>
<DIV>
	<LABEL>High pressure gravel min/max:</LABEL><INPUT id="gravelMinHp" type="float" value="5" size="3" maxlength="3" onchange="metricsChanged()">/
	<INPUT id="gravelMaxHp" type="float" value="70" size="3" maxlength="3" onchange="metricsChanged()">
	<LABEL>Porosity:</LABEL><INPUT id="gravelPorosityHp" type="float" onfocus="porositySet=true" size="4" maxlength="4" onchange="metricsChanged()">
	<BUTTON onClick="metricsChanged(); calcPressureDropInGravel('Hp')">Pressure drop</BUTTON><LABEL id="expectedPDropHp"></LABEL>
</DIV>

<!-- these hidden old values are set based on the values of hpStorageSizeRockM3, highToLowPressureRatio, rockDensity, gravelDensity, insGravelDensity -->
<!--INPUT size="6" id="radius" type="hidden" value="150">
<INPUT size="6" id="pHigh_kPa" type="hidden" value="2500"> 
<INPUT size="6" id="pLow_kPa" type="hidden" value="100"-->
<!-- onclick="$('#heatPumpValues').css('display', this.checked ? 'block' : 'none')"  -->
<!--DIV id="heatPumpValues" style="display:none"><LABEL>Heat pump Turbin Tin (K)</LABEL><INPUT size="6" type="float" id="heatPumpTurbinTin" value="313">
<LABEL>Heat pump Compressor Tin (K)</LABEL> <INPUT size="6" type="float" id="heatPumpCompressorTin" value="300"></DIV-->
<!--DIV><INPUT size="6" id="adjustedCompressorPlow" title="Adjust compressor low tempreature" type="checkbox" value="true"><LABEL
>Adjust hot compressor's P low to set its Tin the same as turbin Tout</LABEL></DIV-->
	</div>
	<div class="tab-pane fade" id="storage" role="tabpanel" aria-labelledby="storage-tab">
		<canvas id="myPicture" width="1000" height="800" style="border:1px solid #000000;display:none"></canvas>
	</div>
	<div class="tab-pane fade" id="diagrams" role="tabpanel" aria-labelledby="diagrams-tab">
		<div>
			<INPUT id="showEnthalpyAndInternalEnergy" title="" type="checkbox" value="true" onClick="if (this.checked) drawTpDiagram()">
			<LABEL>Show the mass specific enthalpy (J/g) and entropy (J/g/K) lines</LABEL>
		<div>
		<canvas id="myCanvas" width="1000" height="800" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram0" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram1" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram2" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram3" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram4" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<DIV id="compressorDesignParams" style="display:none">
			<DIV>
				<LABEL>Flow coefficient</LABEL><INPUT size="5" type="float" id="flowCoefficient" value="0.50"/>
				<LABEL>Stage loading coefficient:</LABEL><INPUT size="5" type="float" id="stageLoadingCoefficient" value="0.25"/>
			</DIV>
			<DIV>
				<LABEL>Hub/Tip ratio from:</LABEL><INPUT type="float" size="4" id="hubToTipRatio" value="0.65"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMax" value="0.85"/>
				<LABEL>Aspect ratio of main compressor:</LABEL><INPUT type="float"  size="4" id="aspectRatio" value="1.5" title="Optimal AR value depends on blade thickness/heigh, if 0.02 => AR:1.3-1.9, if 0.07 => AR:0.78-1.14"/><!--LABEL>Aspect ratio of cyro compressor:</LABEL><INPUT type="float"  size="4" id="aspectRatioCyro" value="5"-->
				<LABEL>Solidity c/s:</LABEL><INPUT type="float"  size="4" id="solidity" value="2" title="Chord spacing: chord length/distance between chords"/>
				<!--LABEL>Blade thickness/chord:</LABEL><INPUT type="float"  size="4" id="t2cInMiddleFlow" value="0.01" title="Maximum allowed average thickness/chort in the middle flow"/-->
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScale"><OPTION value="0">Default</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
				<LABEL>Number of units:</LABEL><INPUT size="2" id="cUnits2" value="4"/>
				<!--LABEL>Number of stages with constant power:</LABEL><INPUT size="2" type="float" id="cStages" value=""/-->
			</DIV>
			<DIV>
				<LABEL>Max allowed hot compressor/turbin blade stress MPa (eg. stress to give plastic 0.2% strain in 3000h)</LABEL><INPUT size="4" type="float" id="cStressMaxMPa" value="456"/>
				<LABEL>Max uncooled blade temperature K</Label><INPUT size="4" type="float" id="tempStressMaxMPa" value="923"/>
					<!-- blade is 
					<!--INPUT size="4" type="float" id="cStressMaxMPa2" value="134"/><Span>MPa in</span>
					<INPUT size="4" type="float" id="tempStressMaxMPa2" value="1088"/><Span>K, see: </span-->
					<a href="https://www.specialmetals.com/documents/technical-bulletins/nimonic-alloy-105.pdf">Nimonic 105</a>
					<a href="https://www.specialmetals.com/documents/technical-bulletins/nimonic/">Nimonic alloys</a>
					<!-- assume unlimited cooling-->
					<!--LABEL>Blade cooling up to K: </LABEL><INPUT size="3" type="float" id="bladeCoolingK" value="400"/-->
			</DIV>
			<DIV>
				<Label>Hot compressor type:</Label>
				<input id="hotCompressorTypeConstantH" name="hotCompressorType" type="radio" checked value="constantH"><Label>Constant number of stages and shafts with equal power:</label><INPUT size="5" type="float" id="cStages" value="15"/>
				<input id="hotCompressorTypeConstantVrel" name="hotCompressorType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeed" value="0.815"/><!--LABEL>Subsonic &lt; 0.9 &lt;= Transonic &lt;= 1.2 &lt; Supersonic</LABEL-->
			</DIV>
			<DIV>
				<LABEL>Max allowed steady stress of cryogenic compressor/turbin blades MPa</LABEL><INPUT size="4" type="float" id="cStressMaxMPaCold" value="350"/>
					<a href="https://nickelinstitute.org/media/1723/materialsforcryogenicservice_engineeringpropertiesofausteniticstainlesssteel_4368_.pdf">Cryogenic austenitic steels</a>
			</DIV>
			<DIV>
				<Label>Cryogenic compressor type:</Label>
				<input id="coldCompressorTypeConstantH" name="coldCompressorType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power:</label><INPUT size="5" type="float" id="cColdStages" value="15"/>
				<input id="coldCompressorTypeConstantVrel" name="coldCompressorType" type="radio" checked value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeedCold" value="0.845"/>
			</DIV>
			<DIV>
				<LABEL>Shaft bearing space mm:</LABEL><INPUT size="2" type="float" id="bearingsSpace" type="float" value="2"/>
				<!-- https://en.wikipedia.org/wiki/Maraging_steel, https://en.wikipedia.org/wiki/Aermet, https://en.wikipedia.org/wiki/Ultimate_tensile_strength -->
				<LABEL>Shaft steel ultimate tensile strength MPa (650-2400): </LABEL><INPUT size="4" type="float" id="shaftStrength" type="float" value="2400"
					title="The shaft is cooled, so all ultimate strength steels are available, e.g. Maraging steel"/>
				<LABEL>Min shaft pipe wall mm</LABEL><INPUT size="2" type="float" id="minShaftPipeWidth" type="float" value="4"/>
				<BUTTON onClick="redrawCompressors()">Redraw compressors</BUTTON>
			</DIV>
		</DIV>
		<canvas id="hotCompressorImage" style="border:1px solid #000000;display:none;"></canvas>
		<table id="hotCompressorData"> </table> 
		<canvas id="coldCompressorImage" style="border:1px solid #000000;display:none"></canvas>
		<table id="coldCompressorData"> </table> 
	</div>
</div>
<!--
<table style="border:1px">
<thead>
<tr>
	<th colspan="11">Calculate Gas turbin properties</th><th><button onclick="calcTurbin(this)">Calc</button></th>
	<th colspan="5">Compressor</th>
	<th colspan="4">Turbin</th>
	<th colspan="3">Lost</th>
</tr>
<tr>
	<th>Type</th>
	<th>Power MW</th>
	<th>Flow kg/s</th>
	<th>Efficiency %</th>
	<th>T In °C</th>
	<th title="Temperature in heat exchanger">T Out °C</th>
	<th>P ratio</th>
	<th>Heat Rate kJ/kWh</th>
	<th>Other loss %</th>
	<th>C stage eff</th>
	<th>C-Efficiency</th>
	<th>Power MW</th>
	<th>T-efficiency</th>
	<th>Power MW</th>
	<th>Heat out MW</th>
	<th>Kinetic out MW</th>
	<th>Other MW</th>
</tr>
</thead>
<tbody id="turbinCalculator">
<tr>
	<td><input size="4" type="text" style="width:100px"  value="Mitsubishi M701JAC (2018)" id="Type"/></td>
	<td><input size="4" type="text" style="width:40px<INPUT id="448" id="netPowerMWTurbin"/></td>
	<td><input size="4" type="text" style="width:40px<INPUT id="765" id="outFlowTurbin"/></td>
	<td><input size="4" type="text" style="width:40px" value="44.0" id="totalEfficiency"/></td>
	<td><input size="4" type="text" style="width:40px" value="15" id="tInCompressor"/></td>
	<td><input size="4" type="text" style="width:40px" value="663" id="tOutTurbin"/></td>
	<td><input size="4" type="text" style="width:40px" value="25" id="pRatioTurbin"/></td>
	<td><input size="4" type="text" style="width:40px" value="8295" id="heatRateTurbin"/></td>
	<td><input size="4" type="text" style="width:40px" value="9" id="otherLossTurbin"/></td>
	<td><input size="4" type="text" style="width:40px" value="95" id="compressorStageEfficiency"/></td>
	<td id="compressorEfficiency"></td>
	<td id="compressorWork"></td>
	<td id="otherLossMW"></td>
	<td><input size="4" type="text" value="1.27/2.7" id="tOutHubTip"/></td>
	<td id="turbinEfficiency"></td>
	<td id="turbinWorkProduced"></td>
	<td id="heatOut"></td>
	<td id="otherLossMW"></td>
</tr>
</tbody>
</table>
-->
<SCRIPT>
function calcTurbin()
{
// experimental code to analyze Mitsubishi M701JAC (2018), input values are customized to match with known facts
	var props =  {};
	var methaneHeatValue =  55.5*1000000;  // heat value of CH4 +butane and ethane traces J/kg
	var flowOut = props.flowOut=getFloatParam('outFlowTurbin');
	var netPower = props.netPower=getFloatParam('netPowerMWTurbin')*1000000;
	var efficiency = props.efficiency=getFloatParam('totalEfficiency')/100;
	var grossPower = props.grossPower = netPower / efficiency;
	var tOut = props.tOut=getFloatParam('tOutTurbin')+273;
	//var naturalGasFlowIn = props.naturalGasFlowIn=getFloatParam('naturalGasIn');
	var tIn = props.tIn=getFloatParam('tInCompressor',15)+273;
	//var tHigh = props.tHigh=getFloatParam('tHighTurbin',1600)+273;
	//var internalCooling = props.internalCooling=getFloatParam('internalCooling')/100;
	var pRatio = props.pRatio=getFloatParam('pRatioTurbin');
	var pDrop = 1; // props.pDrop=1-getFloatParam('pDropTurbin')/100;
	var otherLoss = props.otherLoss=getFloatParam('otherLossTurbin')/100;
	var compressorStageEfficiency = props.otherLoss=getFloatParam('compressorStageEfficiency')/100;
	
	var heatRate = props.heatRate = getFloatParam('heatRateTurbin');
	var naturalGasFlowIn = props.naturalGasFlowIn = (netPower*heatRate/3600)/(methaneHeatValue*0.977);
	var methaneIn = 0.977*naturalGasFlowIn;  
	var nitrogenIn = 0.016*naturalGasFlowIn;
	var co2In = 0.007*naturalGasFlowIn;
	var naturalGasMix = [['Methane', 'Nitrogen', 'CarbonDioxide'], [0.977, 0.016, 0.007], [16, 28, 44], [0,0,0] ];
	const naturalGasMixName = getMixName(naturalGasMix); // 'Methane[0.977000]&CarbonDioxide[0.007000]&Nitrogen[0.016000]';
	//const naturalGasMixName = 'Methane[0.977000]&Nitrogen[0.016000]&CarbonDioxide[0.007000]'; // getMixName(naturalGasMix);
	const pLowIn = 101325*pDrop;
	const pHighOut = pLowIn*pRatio;
	const pHighIn = pHighOut*pDrop;
	const pLowOut = 101325/pDrop;
	const vaporPercent = props.vaporPercent = Module.HAPropsSI('W','T',tIn,'P',pLowIn,'R',0.5);
	var airMixIn = [['Nitrogen', 'Oxygen', 'Argon', 'Water'], [0.781, 0.209, 0.009, vaporPercent],[28,32,40,18],[0,0,0,0]]; // typical humidity?
	fixSum(airMixIn);

	var dryAirMixIn = [['Nitrogen', 'Oxygen', 'Argon'], [0.782, 0.209, 0.009], [28, 32, 40], [0,0,0]] ; // typical humidity?
	var airFlowIn = props.airFlowIn = flowOut - naturalGasFlowIn;
	var heatProduced = props.heatProduced = methaneIn * methaneHeatValue;
	var tHigh = 1650 + 273;
	const dryAirMixName = getMixName(dryAirMixIn);

	if (!otherLoss) otherLoss = 0;
	
	//CH4(16) + 2*O2(32) => CO2(44) + 2*H2O(18)  (80 == 80)
	const oxygenUsed = methaneIn * 2 * 32/16;	
	const co2Mol = 44; // 12+2*16 // Module.PropsSI('M', null, null, null, null, 'CarbonDioxide');
	const waterMol = 18; // Module.PropsSI('M', null, null, null, null, 'Water');
	const co2Produced = (oxygenUsed + methaneIn)*co2Mol/(co2Mol + 2 * waterMol)+ co2In;
	const vaporProduced = (oxygenUsed + methaneIn) * 2 * waterMol/(co2Mol + 2 * waterMol);
	var mixOut = [['CarbonDioxide','Nitrogen', 'Water', 'Oxygen', 'Argon'], [0, 0, 0, 0, 0], [44, 28, 18, 32, 40], [0, 0, 0, 0, 0]];
	mixOut[1][0] = (co2In + co2Produced)/flowOut;				// co2 content
	mixOut[1][1] = (airMixIn[1][0]*airFlowIn+nitrogenIn)/flowOut;	// Nitrogen content
	mixOut[1][2] = (airMixIn[1][3]*airFlowIn+vaporProduced)/flowOut;	// wapor content
	mixOut[1][3] = (airMixIn[1][1]*airFlowIn-oxygenUsed)/flowOut;	// unused oxygen 
	mixOut[1][4] = airMixIn[1][2]*airFlowIn/flowOut;		// Argon
	fixSum(mixOut);
	
	props.hOut = mixPropWithTP('H', 'T', tOut, 'P', pLowOut, mixOut );
	//props.hTotalOut = props.hOut*flowOut;
	//props.heatOut = (props.hOut*flowOut-heatIn);
	//props.kineticOut = 1 - props.heatOut - efficiency - otherLoss;
	//props.speedOut = Math.sqrt(2 * props.kineticOut*grossPower/(flowOut*10));
	props.hNGasLow = mixPropWithTP('H', 'T', tIn, 'P', pLowIn, naturalGasMix );
	props.hNGasHigh = getMixH100WithS('T', tIn, 'P', pLowIn, pHighOut, naturalGasMix )/ 0.80;
	props.naturalGasCompressionWork = (props.hNGasHigh-props.hNGasLow)*naturalGasFlowIn;

	// returns the enthalpy of water vapor
	//props.hAirInHA = Module.HAPropsSI('H', 'T', tIn, 'P', pLowIn, 'R',0.5);
	//props.hDryAirInDelta100 = Module.PropsSI('H', 'T', tIn+100, 'P', pLowIn, 'Air') - Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air');
	//props.hMyDryAirInDelta100 = Module.PropsSI('H', 'T', tIn+100, 'P', pLowIn, dryAirMixName) - Module.PropsSI('H', 'T', tIn, 'P', pLowIn, dryAirMixName);
	//props.hAirInDelta100 = mixPropWithTP( 'H', 'T', tIn+100, 'P', pLowIn, airMixIn ) - mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, airMixIn );
	props.hAirIn = Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air');
	props.hAirInOWN = mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, airMixIn );
	props.hTotalIn = props.hNGasLow*naturalGasFlowIn + props.hAirIn*airFlowIn;
	props.hTotalHigh = props.hTotalIn + heatProduced;
	
	
	if (!tHigh) {
		props.hHigh = props.hTotalHigh/flowOut;
		props.tHigh = mixPropWithTP('T', 'H', props.hHigh, 'P', pHigh, mixOut ); 
		tHigh = props.tHigh;
	}
	else 
	{
		props.hHigh = mixPropWithTP('H', 'T', tHigh, 'P', pHighIn, mixOut );
		console.log("calulated tHigh="+props.tHigh+", given tHigh:"+tHigh );
	}
	//var tInHubTip = props.tInHubTip = getHubTip('tInHubTip', mixPropWithTP('D','T', tHigh, 'P', pHighIn, mixOut), flowOut);
	var tOutHubTip; // = props.tOutHubTip = getHubTip('tOutHubTip', mixPropWithTP('D','T', tOut, 'P', pLowOut, mixOut), flowOut);
	props.hOut_tIn = mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, mixOut );
	// approximation, we assme the in and out gas mixes to have the same enthalpy in the same tIn (probably not true)
	props.heatOut = (props.hOut-props.hOut_tIn)*flowOut;
	props.tInHeatExchange = props.tOut;
	//props.kineticOut = tOutHubTip.kineticEnergyW;
	//props.cooling = grossPower - netPower - props.heatOut - props.kineticOut - otherLoss*grossPower;
	{
//console.log(tOut+" K: cooling"+grossPower+" - "+netPower+" - "+props.heatOut+" - "+props.kineticOut+" - "+(otherLoss*grossPower)+"="+props.cooling);
		// impossible, we have a wrong exit temperature value => fix it
		var cooling = 0;
//console.log("testResult( "+cooling+", "+(tOut/2)+", +"+tOut);
		testResult( 0, tOut, tOut/2, grossPower*0.002, function(t) {
			tOut = t;
			tOutHubTip = props.tOutHubTip = getHubTip('tOutHubTip', mixPropWithTP('D','T', t, 'P', pLowOut, mixOut), flowOut);
			props.kineticOut = tOutHubTip.kineticEnergyW;
			props.hOut = mixPropWithTP('H', 'T', t, 'P', pLowOut, mixOut);
			props.heatOut = (props.hOut-props.hOut_tIn)*flowOut + props.kineticOut;
			props.cooling = grossPower - netPower - props.heatOut - otherLoss*grossPower;
//console.log(t+" K: cooling: "+props.cooling+"="+grossPower+" - "+netPower+" - "+props.heatOut+" - "+props.kineticOut+" - "+(otherLoss*grossPower));
			return props.cooling;
		});
		console.log("Fixed tOut from "+props.tOut+" to "+tOut+" K");
		props.tOut = tOut;
		props.cooling = 0;
	}
	
	// We know the stage efficiency of best high end compressors to be 0.95, calclulate the adiabatic efficiency
	var compressorEfficiency = props.compressorEfficiency = doAdiabaticProcessWithS('Nitrogen',pLowIn, pHighOut, tIn, compressorStageEfficiency, null).efficiency;
	props.hCompressedAir100OWN = getMixH100WithS('T', tIn, 'P', pLowIn, pHighOut, airMixIn );
	props.sDryAirIn = Module.PropsSI('S', 'T', tIn, 'P', pLowIn, 'Air' );
	props.hCompressedAir100 = Module.PropsSI('H', 'S', props.sDryAirIn, 'P', pHighOut, 'Air' );	// ignore vaport content
	props.compressorWork = (props.hCompressedAir100OWN-props.hAirInOWN)*airFlowIn/compressorEfficiency;
	props.hCompressedAirOWN = (props.hCompressedAir100OWN-props.hAirInOWN)/compressorEfficiency + props.hAirInOWN;

	// Actual tHigh is 
	var hHighActual = props.hHighActual = props.hOut_tIn+(grossPower+props.compressorWork+props.naturalGasCompressionWork)/flowOut;
	var tHighActual = props.tHighActual = getMixTempAtHP( hHighActual, pHighIn, tHigh/2, tHigh, mixOut );

	var hOut100 = props.hOut100 = getMixH100WithS('T', tHighActual, 'P', pHighIn, pLowOut, mixOut );

	props.entalpyAt1650C = (props.hHigh - props.hOut)*flowOut;
	props.turbinEthalpyUsed = (hHighActual - props.hOut)*flowOut;
	props.turbinWorkProduced = netPower + grossPower*otherLoss + props.compressorWork + props.naturalGasCompressionWork;
	props.turbinEfficiency = props.turbinWorkProduced/props.turbinEthalpyUsed;
	props.turbinEfficiencyWithKineticLoss = props.turbinWorkProduced/(props.turbinEthalpyUsed+props.kineticOut);

	//props.sAirIn = Module.HAPropsSI('S', 'T', tIn, 'P', pLowIn, 'R',0.5 );
	//props.sDryAirIn = Module.PropsSI('S', 'T', tIn, 'P', pLowIn, 'Air' );
	//props.sAirVaporIn = Module.HAPropsSI('S', 'T', tIn, 'P', pLowIn, 'R', 0.5);
	//props.hAirIn = Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air' );
		//getMixH100WithS( 'T', tIn, 'P', pLowIn, pHighOut, airMixIn );
/*https://www.mhi.co.jp/technology/review/pdf/e503/e503001.pdf 
	props.compressorWork = props.turbinWorkProduced - netPower - otherLoss*grossPower - props.naturalGasCompressionWork;
console.log((props.compressorWork/1000000)+" = "+(props.turbinWorkProduced/1000000)+" - "+(netPower/1000000)+" - "+(otherLoss*grossPower/1000000)+" - "+(props.naturalGasCompressionWork/1000000));
	props.hCompressedAir = (props.compressorWork/airFlowIn) + props.hAirIn;
	props.tCompressedAir = Module.PropsSI('T', 'H', props.hCompressedAir, 'P', pHighOut, 'Air' );
	props.tCompressedAirOWN = getMixTempAtHP(props.hCompressedAir, pHighOut, 500, 1200, airMixIn );
	// null == props.tCompressedAir = Module.HAPropsSI('T', 'H', props.hCompressedAir, 'P', pHigh, 'W', vaporPercent );
	//props.tCompressedDryAir = Module.PropsSI('T', 'H', props.hCompressedAir, 'P', pHighOut, 'Air' );
*/
	//props.tCompressedAirOWN = getMixTempAtHP(props.hCompressedAirOWN, pHighOut, 500, 1200, airMixIn );
	//var cInHubTip = props.cInHubTip = getHubTip('cInHubTip',mixPropWithTP('D', 'T', props.tCompressedAirOWN, 'P', pLowIn, airMixIn), airFlowIn);
	//var cOutHubTip = props.cOutHubTip = getHubTip('cOutHubTip', mixPropWithTP('D','T', props.tCompressedAir, 'P', pHighOut, airMixIn), airFlowIn);

	//props.compressorEfficiency = (props.hCompressedAir100-props.hAirIn)/((props.hCompressedAir - props.hAirIn) - cOutHubTip.kineticEnergyW/airFlowIn);

	//props.mixOut = mixOut;
	console.log(JSON.stringify(props, null, 2 ));
}

function getHubTip(id,density,massFlow) {
	var hubTip = {};
	const val = document.getElementById(id).value;
	var slash = val.indexOf('/');
	hubTip.hub = parseFloat(val.substring(0,slash));
	hubTip.tip = parseFloat(val.substring(slash+1));
	hubTip.area = (hubTip.tip*hubTip.tip-hubTip.hub*hubTip.hub)*Math.PI;
	if (density && massFlow) {
		hubTip.volume = massFlow / density;
		hubTip.speed = hubTip.volume/hubTip.area;
		hubTip.kineticEnergyW = 0.5*massFlow*10*hubTip.speed*hubTip.speed;
	}
	return hubTip;
}
function fixSum(mix) {
	var sum = 0, moleSum = 0;
	for (i = 0; i < mix[0].length; i++) {
		sum += mix[1][i];
		moleSum += mix[2][i];
	}
	for (i = 0; i < mix[0].length; i++) {
		mix[1][i] = mix[1][i] / sum;		// by weight
		mix[3][i] = mix[1][i]*mix[2][i]/moleSum; // by volume
	}
	return sum;
}


function getMixName(mix ) {
	var s = '', error='';
	var i;
	var sum = fixSum(mix);
	if (sum != 1) error = " Scaled to sum="+sum;
	for (i = 0; i < mix[0].length; i++) {
		var fraction = ''+mix[1][i];
		if (fraction.length > 8) fraction = fraction.substring(0,8);
		else while (fraction.length<8) fraction = fraction + '0';
		s = s + (i > 0 ? '&' : '') + mix[0][i]+'['+fraction+']';
	}
//console.log(s+error);
	return s;
}

/**
	An extension of Dalton's law of additive pressures to include the statement that the internal energy, enthalpy, 
	and entropy of a mixture of gases are equal to the sum of the internal energies, enthalpies, and entropies the 
	individual constituents would have if each existed alone at the same temperature and volume. 
=> Use T and P to get D(|gas), use D(|gas) and T to get H, S  etc.
*/
function mixPropWithTP( outProp, tName, t, pName, p, mix ) {
	var i, outVal = 0;
	for (i = 0; i < mix[0].length; i++) {
		if (mix[0][i] == 'Water' && tName=='T' && t<380) {
			if (outProp == 'D') {
				var d = Module.PropsSI( 'D', 'T', tName=='T' ? t : p, 'Q', 1, 'Water' )/2;  // R=0.5
				outVal += d;
			}
			else if (outProp == 'H') {
				var x = Module.PropsSI( outProp+'|gas', tName, t, pName, p*mix[3][i], mix[0][i] )*mix[1][i];
				if (x == Infinity) {
					console.log("Module.PropsSI( "+outProp+'|gas'+", "+tName+", "+t+", "+pName+", "+p*mix[3][i]+", "+mix[0][i]+" )*"+mix[1][i]+"="+x);
					x = Module.PropsSI( outProp+'|gas', tName, t, pName, p*mix[3][i], mix[0][i] )*mix[1][i];
				}
				if (x == Infinity) {
					console.log( "Module.PropsSI("+outProp+", "+tName+", "+t+", "+pName+", "+p+", "+mix[0][i]+")="+x);
				}
				if (x < 2256471) {	// not yet vapor!
					// its liquid => vaporize it
					x += 2256471.5924066794;
				}
				if (x != Infinity) {
					outVal += x*mix[1][i];
				}
			}
		}
		else {
//console.log("Module.PropsSI( '"+outProp+"', '"+tName+"', "+t+", '"+pName+"', "+p+", '"+mix[0][i]+"' ) * "+mix[1][i]);
			if (outProp == 'H') {
				outVal += Module.PropsSI( outProp, tName, t, pName, p*mix[3][i], mix[0][i])* mix[1][i];
			}
			else {
				outVal += Module.PropsSI( outProp, tName, t, pName, p, mix[0][i])* mix[1][i];
			}
		}
	}
//console.log("outVal="+outVal);
	return outVal;
}

function getMixTempAtHP( h, p, tMin, tMax, mix ) {
	return testResult( h, tMin, tMax, h*0.01, function(t) {
		const h = mixPropWithTP('H', 'T', t, 'P', p, mix);
//console.log("h(t="+t+",p="+p+")="+h);
		return h;
	});
}

function getMixH100WithS( inProp1, inValLow1, inProp2, inValLow2, inValHigh2, mix ) {
	var i, outVal = 0;
	var all = '';
	for (i = 0; i < mix[0].length; i++) {
		const s = (mix[0][i] == 'Water' && inProp1=='T' && inValLow1<380) ? 
			Module.HAPropsSI( 'S', inProp1, inValLow1, inProp2, inValLow2, 'W', mix[1][i])
			: Module.PropsSI( 'S', inProp1, inValLow1*(inProp1 == 'P' ? mix[3][i]:1), inProp2, inValLow2*(inProp2 == 'P' ? mix[3][i]:1), mix[0][i] );
if (!s || s == Infinity) {
	console.log("Module.HAPropsSI('S'"+inProp1+", "+inValLow1+", "+inProp2+", "+inValLow2+", "+'W'+", "+mix[1][i]+"="+s);
}
else {
		outVal += Module.PropsSI( 'H', 'S', s, inProp2, inValHigh2*(inProp2 == 'P' ? mix[3][i]:1), mix[0][i])*mix[1][i];
/*		if (mix[0][i] == 'Water') {
			console.log("Water h(s="+s+", "+inProp2+"="+inValLow2+")="+Module.PropsSI( 'H', 'S', s, inProp2, inValLow2, mix[0][i])+"=>"+
					Module.PropsSI( 'H', 'S', s, inProp2, inValHigh2, mix[0][i]));
		}*/
}
//		all += mix[0][i]+"*"+mix[1][i]+'_';
	}
//console.log("Module.PropsSI( '"+inProp1+"', "+inValLow1+", '"+inProp2+"', "+inValLow2+", '"+inValHigh2+"', '"+all+"')="+outVal);
	return outVal;
}

	// See http://www.coolprop.org/coolprop/HighLevelAPI.html
	const FIRST_ITEM = true;
	const LAST_ITEM = false;
	var LOST_AS_HEAT = 0.05;

	const isCylinder = false; // getBooleanParam( 'shapeCylinder', true );
	const isCone = true; // getBooleanParam( 'shapeCylinder', true );

	//var extraCompressionHeat = 0.09;
	var name="Nitrogen";
	var generatorLocation = 'GROUND';		// TOP, GROUND, MIDDLE, BOTTOM
	var coldExpanderLocation = 'SAME';	// or BOTTOM
	var chargeLevel = 0.5; // 0 - 1
	var pLowParam = null;
	var dischargeMassFlowValue = null;
	
	//var turbinStages;
	//var compressorStages;
	//var zoomedTurbinStages;
	//var cZoomedTurbinStages = 2;
	//var maxSteamWetness = 0;
	//var impulseTurbineefficiency = 0.90;
	var pTransformer = {};

	//drawOnlyStorage();

	function setGasMassFlowFor1200MW(select) {
		const gas = $(select).val();
		var massFlow = 1645;
		$("#tHigh").val('1173');		// default mass flow
		$("#cStressMaxMPa").val('456');	// default Nimonic 105 3000h 0.2 proof tensile strength when cooled to 923 K
		$("#tempStressMaxMPa").val("923");
		if (gas == 'Nitrogen') massFlow = 1645;
		else if (gas == 'Argon') massFlow = 3509;
		else if (gas == 'Hydrogen') {
			massFlow = 200;
			if (parseInt($("#tHigh").val()) > 1000) {
				//$("#tempStressMaxMPa").val("700"); // ~max temp for maraging 2400 steel
				$("#tHigh").val('700');
				$("#cStressMaxMPa").val('1800');
			}
		}
		else if (gas == 'Helium') massFlow = 250;
		else if (gas == 'Methane') {
			if (parseInt($("#tHigh").val()) > 625) {
				$("#tHigh").val('625');
				$("#cStressMaxMPa").val('1800');
			}
			massFlow = 2152;
		}
		$('#dischargeMassFlow').val(massFlow);
	}
	var porositySet = false;
	function calcPressureDropInGravel(type, speed, visc, density, length, p, t ) {
		var porosity = 0;
		var gravelDensity;
		const min = getFloatParam( "gravelMin"+type, 0 );
		const max = getFloatParam( "gravelMax"+type, 0 );
		if (metrics) metrics["gravelMin"+type] = min;
		if (metrics) metrics["gravelMax"+type] = max;
		const minPorosity = (2.65-2.2)/2.65;
		const maxPorosity = 0.55;
		porosity = getFloatParam( "gravelPorosity"+type, 0 );
		if (porosity>0) {
			if (porosity>maxPorosity || porosity < minPorosity) {
				alert("Porosity must be in typical range for compacted gravel:"+minPorosity+"-"+maxPorosity);
				porosity = 0;
			}
			porositySet = false;
		}
		if (porosity == 0) {
			gravelDensity = 1.5 + (2.1-1.5)*(1-min/max);
			porosity = (2.65-gravelDensity)/2.65;
		}
		else {
			gravelDensity = 2.65*(1 - porosity);
		}
		if (metrics){
			if (type == 'Hp') {
				metrics.gravelDensity = gravelDensity;
				metrics.hpGravelPorosity = porosity;
			}
			else if (type == 'Lp') {
				metrics.lpGravelDensity = gravelDensity;
				metrics.lpGravelPorosity = porosity;
			}
		}
		// sort: 6/12, n=0.51 => (9.7±6.3)·10-8 m2
		// sort: 20/40, n=0.40 => (9±6)·10-8 m2
		// y=x*visc/k + x^2*c*visc/k = (1638±289)x²+(200±124)x   => 200 = 0.000018/0.00000009, c ~= 8.2
		// sort 6/12: y=(2976±366)x²+(185±120)x => 187 = 0.000018/0.000000097, c = 2976/185 ~= 16.1
		// Calclulated for 6/12, n=0.51: y=2141*x²+715*x, turbulent part quite near, but Laminar part 4*actual!
		// => Calcluates too high pressure drops for small particle sizes and low speed
		// deltaP/L = x*a + x^2*b
		var a = 200;	// laminar flow part
		var b = 1630;	// turbulent flow part
if (min==0) min=0.0001; // 0.1mm
//console.log("min="+min+", max="+max+", porosity="+porosity+", gravelDensity="+gravelDensity);
		// When v=inlet speed in free space (m/2), L=distance (m), Dp=smallest particle diameter (m), n=porosity, density=fluid density kg/m3
		// wiki Ergun_equation:  deltaP=v*(150*visc*L/Dp^2)*(1-n)^2/n^3+v^2*(1.75*L*density/Dp)*(1-n)/n^3
		// Darcy-Forchheimer
		// Darcy–Forchheimer equation is best for gravels, but its values k and c must be measured for each case.
		// So we use Ergun equation extension for turbulent flows to scale the known values 
		// https://www.researchgate.net/publication/322140487_Behaviour_study_of_airflow_through_gravels_based_on_laboratory_experimentation_and_contrast_with_FEM_models
		// gravel sort: 20/40, n=0.40:  (1638±289)x²+(200±124)x
		// Test: 
		const dE = 0.03; // (0.02+0.04) / 2
		const dEfective = (min + max)/2000;	// https://publications.vtt.fi/julkaisut/muut/2013/VTT-R-00257-13.pdf: 0.25-10mm => efective particle size: 0.65mmm
		a = a *(Math.pow(dE,2)/Math.pow(dEfective,2))*(Math.pow(0.4,3)/Math.pow(porosity,3))*(Math.pow(1-porosity,2)/Math.pow(1-0.4,2));
		b = b *(dE/dEfective)*(Math.pow(0.4,3)/Math.pow(porosity,3))*((1-porosity)/(1-0.4));
		if (visc) {
			a = a*visc/0.000018;
			b = b*visc/0.000018;
		}
		if (density) {
			b = b*density/1.8;// air density 1.8 kg/m3
		}
		if (typeof speed === 'undefined') {
			$("#expectedPDrop"+type).text("y="+Math.round(b)+"*x²+"+Math.round(a)+"*x, (porosity of compacted gravel: "+myRound(porosity,2)+")");
		}
		else if (speed) {
			var ret = speed*a + speed*speed*b;	// pressure drop/L: Pa/m
			if (length) ret = ret * length;
			return ret;
/*
//console.log(type+" pressure drop="+ret+", (v:"+speed+",visc:"+visc+",d:"+density+",L:"+length+")=>a:"+a+", b:"+b+", effective diameter:"+dEfective);
			// All preceeding formulas assumes ambient temperature (~300 K).  Pressure drop transform enhalpy to kinetic energy that keeps the gas flowing. 
			// What is the enthaply needed to keep the flow at contant speed at 300 K?
			const s300K = Module.PropsSI('S', 'P', p, 'T', 300, name); 
			const hDrop = Module.PropsSI('H', 'P', p, 'T', 300, name) - Module.PropsSI('H', 'P', p-ret, 'S', s300K, name);
			// The same enthalpy is needed also in the catual temperature
			const s = Module.PropsSI('S', 'P', p, 'T', t, name); 
			const h = Module.PropsSI('H', 'P', p, 'T', t, name); 
			const p2 = Module.PropsSI('P', 'H', h-hDrop, 'S', s, name); 
console.log(Math.round(t)+": pressure drop at ambient temp:"+ret+", actual pressure drop: "+(p-p2));
			return Number.isFinite(p2) ? p-p2 : ret;
*/
		}
	}
	
	// Steam saturation is not an adibatic process.  Instead the wetness and released enthalpy is calculated using constant entropy.
	// It probably needs much higher pressure drop than abiabatic expansion with high cp/cv
	// https://www.e3s-conferences.org/articles/e3sconf/pdf/2021/28/e3sconf_pgsge2021_03055.pdf
	function logSatValues( pStart, name )
	{
		var hV = Module.PropsSI('H','P',pStart,'Q',1,name); 
		var hL = Module.PropsSI('H','P',pStart,'Q',0,name); 
		var sV = Module.PropsSI('S','P',pStart,'Q',1,name); 
		var sL = Module.PropsSI('S','P',pStart,'Q',0,name); 
		var cp = Module.PropsSI('C','P',pStart,'Q',1,name); 
		var cv = Module.PropsSI('CVMASS','P',pStart,'Q',1,name); 
		var cpL = Module.PropsSI('C','P',pStart,'Q',0,name); 
		var cvL = Module.PropsSI('CVMASS','P',pStart,'Q',0,name); 
		var t = Module.PropsSI('T','P',pStart,'Q',1,name); 
		console.log(name+" staturation values in "+pStart+" Pa: t="+t+" K, hSat="+((hV-hL)/1000)+", cpV/cvV="+(cp/cv)+", cpL/cvL="+(cpL/cvL)+", sV="+sV+", sL="+sL
			+", valuesOf("+(t+0.001)+")="+JSON.stringify(getValuesMin(name,t+0.001,pStart)));
	}

	function printRow( isTurbin, v, vSum ) 
	{
	 	if (typeof v === 'undefined') {
			return '<tr><th title="Turbin Inlet/Outlet temperature">T(in-out) K</th><th title="Inlet/Outlet pressure">P(in-out) kPa</th>'+
			(isTurbin ? '<th title="Work done by generator">Work done kJ/kg</th><th title="Reheating of fluid by PCHE before next stage">Reheating kJ/kg</th><th title="Inlet pressure devided by outlet pressure">Pin/POut</th>'+
			'<th title="1 - (Compressor work)/(Turbin work) in this pressure range">Stage efficiency</th>' : '<th>Work consumed kJ/kg</th><th>Cooling kJ/kg</th><th>POut/Pin</th>')+
			'<th title="Inlet-outlet density of fluid ">D(in-out) kg/m3</th><th>Speed of sound (in-out) m/s</th>'+
			'<th>Entropy In - Out J/g/K</th><th  title="Min/max specific heat ratio">cp/cv (min-max)</th><th title="Specific heat in constant presure in temp range">cp ave kJ/K</th>'+
			'<th  title="Viscosity">Visc(in-out) μPa/s</th><th>Conductivity(out) mW/m-K</th></tr>';
		}
		else {
			if (vSum) {
				if (v.workProduced) vSum.workProduced = (vSum.workProduced ? vSum.workProduced : 0) + v.workProduced;
				if (v.workConsumed) vSum.workConsumed = (vSum.workConsumed ? vSum.workConsumed : 0) + v.workConsumed;
				if (v.heating) vSum.heating = (vSum.heating ? vSum.heating : 0) + v.heating;
				if (v.cooling) vSum.cooling = (vSum.cooling ? vSum.cooling : 0) + v.cooling;
/*
				if (typeof v.items === 'undefined') {
					console.trace("Step data missing:"+JSON.stringify(v));
					return '';
				}
*/
			}
			return "<tr>"+printCell( 3, v.tIn, v.tOut )+printCell( 1, v.pIn/1000, v.pOut/1000 )+
				(isTurbin ? printCell( 1, v.workProduced/1000)+printCell( 1, v.heating/1000)+printCell( 3, v.pIn/v.pOut)+printCell(2, v.stageEfficiency)
					: printCell( 1, v.workConsumed/1000)+printCell( 1, v.cooling/1000)+printCell( 3, v.pOut/v.pIn))+
				printCell( 1, v.dIn, v.dOut )+printCell( 1, v.sosIn, v.sosOut )+printCell( 3, v.sIn/1000, v.sOut/1000)+
				γRange( v.items ) + cpAve( v.items ) + printCell( 1, v.vIn*1000000, v.vOut*1000000)+printCell( 1, v.tcOut*1000)+"</tr>";
		}
	}
	function getInputParam( id, defValue ) {
		var ret = $('#'+id).val();
//console.log("$('#"+id+"').val()="+ret+", default="+defValue+"=> ret="+(ret ? ret : defValue));
		return ret ? ret : defValue;
	}

	function getFloatParam( id, defValue ) {
		var ret = $('#'+id).val();
//console.log("$('#"+id+"').val()="+ret+", default="+defValue+"=> ret="+(ret ? ret : defValue));
		return ret ? parseFloat(ret) : defValue;
	}
	function getIntParam( id, defValue ) {
		var ret = $('#'+id).val();
		return ret ? parseInt(ret) : defValue;
	}

	function getBooleanParam( id, defValue ) {
		if (document.getElementById(id)) {
			return $('#'+id).prop('checked');
		}
		else {
			return defValue;
		}
	}



	function printCell( roundTo, f1, f2 )
	{
		if (Number.isNaN(f1)) return '<td></td>';
		if (typeof f2 == 'undefined') {
			return '<td>'+myRound( f1, roundTo )+'</td>';
		}
		else if (f2 == 'bold') {
			'<td><span style="font-weight: bold;">'+myRound( f1, roundTo )+'</span></td>';
		}
		else {
			return '<td>'+myRound( f1, roundTo )+' - '+myRound( f2, roundTo )+'</td>';
		}
	}
	
	// 
	//	Use equal internal energies S to get enthalpy of 100% efficience, recalc S with the actual enthalpy
	//
	function doAdiabaticProcessWithS( name, pFrom, pTo, tFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		var hFrom = Module.PropsSI('H', 'P', pFrom, 'T', tFrom, name);
//console.log(name+": t="+tFrom+", p="+pFrom+" => h="+hFrom);
		return doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone );
	}

	// P1 and P2 have the same enthalpy and P1 is wet, but P2 may or may not be wet
	function getWetnessOfP2( name, P1, P2, wetnessOfP1 )
	{
		const hLiqC = Module.PropsSI('H', 'P', P1, 'Q', 0, name);
		const hGasC = Module.PropsSI('H', 'P', P1, 'Q', 1, name);
		const hLiqE = Module.PropsSI('H', 'P', P2, 'Q', 0, name);
		const hGasE = Module.PropsSI('H', 'P', P2, 'Q', 1, name);
		const h = hGasC*(1-wetnessOfP1) + hLiqC*wetnessOfP1;
				
		// h = hGasE*(1-wetnessE) + hLiqE*wetnessE  = hGasE + (hLiqE-hGasE)*wetnessE
		// => wetnessE = (h-hGasE) / (hGasE-hLiqE)
		const wetnessOfP2 = (h - hGasC) / (hGasE-hLiqE);		// wetnessE
		return wetnessOfP2<0 ? 0 : wetnessOfP2;
	}

	// The wax wetness of turbin/compressor (15%) seems to create more problems than it solves
	function doWetAdiabaticProcessWithS( name, pFrom, pTo, wetness, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		const hLiq = Module.PropsSI('H', 'P', pFrom, 'Q', 0, name);
		const hGas = Module.PropsSI('H', 'P', pFrom, 'Q', 1, name);
//console.log(name+": hLiq="+hLiq+", hGas="+hGas+", wetness="+wetness);
		var hFrom = hGas - (hGas-hLiq)*wetness;
		var stage = doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone );
		stage.massFlow = 1/(1-wetness);
		if (stage.workConsumed) stage.workConsumed *= stage.massFlow;
		if (stage.workProduced)  stage.workProduced *= stage.massFlow;
		return stage;
	}

	function doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		var curP = pFrom;
		var pStep = pFrom > pTo ? 0.96 : 1.04;
		var isCompression = pFrom < pTo; 
		const sFrom = Module.PropsSI('S', 'P', pFrom, 'H', hFrom, name);
		var tFrom = Module.PropsSI('T', 'P', pFrom, 'H', hFrom, name);
		var sCur = sFrom;
		var hPrev = hFrom;
		var curT = tFrom;
		var items = [];
		var hCooled = 0;
//if (tMin) console.log("tMin="+tMin);
		var v = {};
		v.p = pFrom;
		v.t = tFrom;
		v.s = sCur;
		v.h = hPrev;
console.log("doAdiabaticProcessWithS "+pFrom+"=>"+pTo+", vIn="+JSON.stringify(v)+"; efficiency="+efficiency);
		items.push(v);
		var loops = 1;
		var exitNow = false;
		
		while (!exitNow) 
		{
			curP = curP * pStep;
			if (isCompression && curP >= pTo) {
				curP = pTo;	
				exitNow = true;
			}
			else if (!isCompression && curP <= pTo) {
				curP = pTo;
				exitNow = true;
			}
			v = {};
			var hCur = Module.PropsSI('H', 'P', curP, 'S', sCur, name);

			if (tMax)
			{
				const tIdeal = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
				if (tIdeal >= tMax) {
					exitNow = true;
					hCur = Module.PropsSI('H', 'T', tMax, 'S', sCur, name);
					curP = Module.PropsSI('P', 'T', tMax, 'S', sCur, name);
				}
			}
			if (tMin) {
				const tIdeal = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
				if (tIdeal <= tMin) {
//console.log(tIdeal+" <= "+tMin);
					exitNow = true;
					//v.tIdeal = tMin;
					var testH = Module.PropsSI('H', 'T', tMin, 'S', sCur, name);
					if (testH != 'Infinity') {
						hCur = testH;
						curP = Module.PropsSI('P', 'T', tMin, 'S', sCur, name);
					}
				}
			}
			//v.hIdeal = hCur;
			if (hCur) {
				if (isCompression) {
					hCur = (hCur-hPrev)*(1-efficiency) + hCur;
				}
				else {
					hCur = (hPrev-hCur)*(1-efficiency) + hCur;
				}
			}
			curT = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
			hPrev = hCur;
			sCur = Module.PropsSI('S', 'P', curP, 'H', hCur, name);  // adjusted by efficiency
			v.p = curP;
			v.t = curT;
			v.s = sCur;
			v.h = hCur;
			if (v.p && v.t && v.s && v.h) {
				items.push(v);
			}
			else {
				console.log(name+":Unexpected values: v="+JSON.stringify(v)+", items:"+JSON.stringify(items));
				console.trace(dbgTitle+": pFrom="+pFrom+", pTo="+pTo+", hFrom="+hFrom+", efficiency="+efficiency);
				//console.log("all items: "+JSON.stringify(items));
				break;
			}
			if (typeof pfAreWeDone === 'function') {
				if (pfAreWeDone( v, items )) {
					exitNow = true;
				}
			}
			if (items.length > 1000) {
				//console.log("Too many steps, v="+JSON.stringify(v));
				break;
			}
		}
		return newCycleDataI( name, items, efficiency, 1, hCooled, dbgTitle );
	}
	function newCycleData( name, stage, massFlow )
	{
		return newCycleDataI( name, stage.items, stage.stageEfficiency, massFlow, stage.hCooled, stage.dbgTitle );
	}
	var baseMachinerySizeIndex = 7000;	// used to scale the cost of calculated turbins and compressors to 1/25 bar, stage efficiency 0.92

	function addCycleDataI( stage1, stage2, dbgTitle )
	{
		var stage = stage1;
		stage.pOut = stage2.pOut;
		stage.tOut = stage2.tOut;
		stage.hOut = stage2.hOut;
		stage.sOut = stage2.sOut;
		stage.workConsumed	+= stage2.workConsumed;
		stage.efficiency *= stage2.efficiency; 
		stage.dOut = stage2.dOut;
		stage.flowOut = stage2.flowOut;
		stage.viscOut = stage2.viscOut;
//console.log(dbgTitle+": items1: "+JSON.stringify(stage1.items)); 
//console.log(dbgTitle+": items2: "+JSON.stringify(stage2.items)); 
		const items = stage.items;
		if (dbgTitle) {
			stage.items = null;
			console.log(dbgTitle+": "+JSON.stringify(stage)); //+", last="+JSON.stringify(last));
		}
		stage.items = items.concat(stage2.items);
		return stage;
	}

	function newCycleDataI( name, items, stageEfficiency, massFlow, hCooled, dbgTitle )
	{
		var stage = {};
		if (dbgTitle) stage.dbgTitle = dbgTitle;
		const last = items[items.length-1];
		const first = items[0];
		const pFrom = first.p;
		const pTo = last.p;
		last.d = Module.PropsSI('D', 'P', last.p, 'H', last.h, name);
		first.d = Module.PropsSI('D', 'P', first.p, 'H', first.h, name);
		stage.stageEfficiency = stageEfficiency;
		stage.pIn = stageEfficiency > 1 ? last.p : first.p;
		stage.pOut = stageEfficiency > 1 ? first.p : last.p;
		stage.tIn = stageEfficiency > 1 ? last.t : first.t;
		stage.tOut = stageEfficiency > 1 ? first.t : last.t;
		stage.hIn = stageEfficiency > 1 ? last.h : first.h;
		stage.hOut = stageEfficiency > 1 ? first.h : last.h;
		stage.hCooled = hCooled;
		stage.sIn = stageEfficiency > 1 ? last.s : first.s;
		stage.sOut = stageEfficiency > 1 ? first.s : last.s;
		stage.isForward = (stageEfficiency <= 0 && pFrom > pTo) || (stageEfficiency > 0 && pFrom < pTo);
		stage.massFlow = massFlow;		// 1 == 1000 kg
		const idealWork = Math.abs(Module.PropsSI('H', 'P', stage.pOut, 'S', stage.sIn, name) - stage.hIn) + stage.hCooled;
		if (stage.hOut > stage.hIn) {
			stage.workConsumed = ((stage.hOut+stage.hCooled) - stage.hIn);
			stage.efficiency = idealWork / stage.workConsumed; 
		}
		else {
			stage.workProduced = (stage.hIn - stage.hOut);
			stage.efficiency = stage.workProduced / (idealWork);
		}
		stage.dIn = Module.PropsSI('D', 'P', stage.pIn, 'H', stage.hIn, name); 
		stage.dOut = Module.PropsSI('D', 'P', stage.pOut, 'H', stage.hOut, name);
		stage.flowIn = 1000 / stage.dIn ;
		stage.flowOut = 1000 / stage.dOut;
		stage.viscIn = Module.PropsSI('V', 'P', stage.pIn, 'H', stage.hIn, name); 
		stage.viscOut = Module.PropsSI('V', 'P', stage.pOut, 'H', stage.hOut, name);
		if (dbgTitle) {
			console.log(dbgTitle+": "+JSON.stringify(stage)); //+", last="+JSON.stringify(last));
		}
//if (tMin) console.log(JSON.stringify(last));
		stage.items = items;
		stage.getRelativeSize = function() {
			return 1;
		}
		return stage;
	}
	function getStageStep(stageEfficiency) {
		if (stageEfficiency >= 0.94) return 1.04;
		if (stageEfficiency >= 0.93) return 1.045;
		if (stageEfficiency >= 0.92) return 1.05;
		if (stageEfficiency >= 0.915) return 1.06;
		if (stageEfficiency >= 0.91) return 1.07;
		if (stageEfficiency >= 0.905) return 1.08;
		if (stageEfficiency >= 0.90) return 1.09;
		if (stageEfficiency >= 0.89) return 1.10;
		if (stageEfficiency >= 0.88) return 1.12;
		return 1.13;
	}

	function myRoundAsExponent( num, c ) {
		var exp = 0;
		while (num > 10) {
			num = num / 10;
			exp++;
		}
		return myRound(num, c)+' EXP'+(exp < 10 ? '0'+exp : ''+exp);
	}
	
	function myRound( num, c) {
		if (typeof num === 'undefined') return '';
		if (!num) return num;
		var ret = '';
		if (typeof c === 'undefined') {
			if (num < 1) c = 3;
			else if (num < 10) c = 2;
			else if (num < 100) c = 1;
			else c = 0;
		}
		if (c == 0) return Math.round(num)+'';
		else if (c == 1) ret += Math.round( ( num + Number.EPSILON ) * 10 ) / 10;
		else if (c == 2) ret += Math.round( ( num + Number.EPSILON ) * 100 ) / 100;
		else if (c == 3) ret += Math.round( ( num + Number.EPSILON ) * 1000 ) / 1000;
		else if (c == 4) ret += Math.round( ( num + Number.EPSILON ) * 10000 ) / 10000;
		else if (c == 5) ret += Math.round( ( num + Number.EPSILON ) * 100000 ) / 100000;
		else ret += Math.round( ( num + Number.EPSILON ) * 1000000 ) / 1000000;
		const iDot = ret.lastIndexOf('.');
		var cZeros;
		if (iDot == -1) {
			ret += '.';
			cZeros = c;
		}
		else {
			cZeros = c - ((ret.length-1)-iDot);
		}
		while (cZeros > 0) {
			ret += '0';
			cZeros--;
		}
		return ret;
	}
	function getValuesMin( name, curT, curP )
	{
			var v = {};
			v.p = curP;
			v.t = curT;
			v.h = Module.PropsSI('H', 'P', v.p, 'T', v.t, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'T', v.t, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'T', v.t, name)
			v.γ = v.cp/v.cv; 
			//const k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', curP, 'T', curT, name );
			// v.γ = 1+1/k;   // wrong value!
			return v;
	}
	function getSatValuesMin( name, curP, curS )
	{
			var v = {};
			v.p = curP;
			v.s = curS;
			v.t = Module.PropsSI('T', 'P', curP, 'Q', 1, name)
			v.h = Module.PropsSI('H', 'P', curP, 'S', curS, name)
			v.hGas = Module.PropsSI('H', 'P', curP, 'Q', 1, name)
			v.hLiq = Module.PropsSI('H', 'P', curP, 'Q', 0, name)
        	v.cp = Module.PropsSI('C', 'P', curP, 'Q', 1, name)
			v.cv = Module.PropsSI('CVMASS', 'P', curP, 'Q', 1, name)
			v.γ = v.cp/v.cv; 
			return v;
	}

	function getValues( name, curT, curP )
	{
			var v = {};
			v.p = curP;
			v.t = curT;
			v.h = Module.PropsSI('H', 'P', v.p, 'T', v.t, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'T', v.t, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'T', v.t, name)
			v.cpAve = v.cp / 1000;
			v.cvAve = v.cv / 1000;
			v.deltaH = 0;
			v.rho = Module.PropsSI('D', 'P', v.p, 'T', v.t, name)
			v.tc = Module.PropsSI('CONDUCTIVITY', 'P', v.p, 'T', v.t, name)
			v.sos = Module.PropsSI('SPEED_OF_SOUND', 'P', v.p, 'T', v.t, name)
			v.z = Module.PropsSI('Z', 'P', v.p, 'T', v.t, name)
			v.v = Module.PropsSI('VISCOSITY', 'P', v.p, 'T', v.t, name)
			v.pip=Module.PropsSI('PIP', 'P', v.p, 'T', v.t, name)
			v.Prandtl=Module.PropsSI('Prandtl', 'P', v.p, 'T', v.t, name)
			//v.tSat=Module.PropsSI('T', 'P', v.p, 'Q', 0, name) 
			v.k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', v.p, 'T', v.t, name)
			v.γ = v.cp/v.cv; //1+1/v.k;
			return v;
	}
	function getValuesPH( name, curP, curH )
	{
			var v = {};
			v.p = curP;
			v.h = curH;
			v.t = Module.PropsSI('T', 'P', v.p, 'H', curH, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'H', curH, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'H', curH, name)
			v.cpAve = v.cp / 1000;
			v.cvAve = v.cv / 1000;
			v.deltaH = 0;
			v.rho = Module.PropsSI('D', 'P', v.p, 'H', curH, name)
			v.tc = Module.PropsSI('CONDUCTIVITY', 'P', v.p, 'H', curH, name)
			v.sos = Module.PropsSI('SPEED_OF_SOUND', 'P', v.p, 'H', curH, name)
			v.z = Module.PropsSI('Z', 'P', v.p, 'H', curH, name)
			v.v = Module.PropsSI('VISCOSITY', 'P', v.p, 'H', curH, name)
			v.pip=Module.PropsSI('PIP', 'P', v.p, 'H', curH, name)
			v.Prandtl=Module.PropsSI('Prandtl', 'P', v.p, 'H', curH, name)
			v.k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', v.p, 'H', curH, name)
			v.γ = v.cp/v.cv; //1+1/v.k;
			//v.γ = 1+1/v.k;
			return v;
	}
	const marginX = 22;
	const marginY = 10;
	var cWidth, cheight, height, width;
	var minTemp, maxTemp, minPressure, maxPressure;
	var yLog = 1;
	
	function tToX( t ) {
		return Math.abs(marginX + (cWidth)*(t - minTemp)/(maxTemp-minTemp));
	}
	function pToY( p ) {
		//return Math.abs(marginY + (cheight)*Math.pow((maxPressure - p)/(maxPressure-minPressure), yLog));
		if (pTransformer.lowFrom) {
			p = pTransformer.lowTo + (p - pTransformer.lowFrom) / (pTransformer.highFrom - pTransformer.lowFrom) * (pTransformer.highTo - pTransformer.lowTo);
		}
		return Math.abs(marginY + (cheight)*(maxPressure - p)/(maxPressure-minPressure));
	}

	function logMoveTo( ctx, x, y ) {
		console.log("x="+x+", y="+y);
		ctx.moveTo( x, y );
	}

	var pTriplePoint, tTriplePoint;
	const motorGenerator = getBooleanParam('motorGenerator', true);

	function drawTpDiagram() {
		if (typeof Module.PropsSI === 'undefined') {
console.log("Waiting coolprop to init ...");		
			setTimeout( drawTpDiagram, 300 );
		}
		else {
			metrics = {};
			pLowParam = null;
			dischargeMassFlowValue = null;
			drawIt(true);
		}
	}
	function drawOnlyStorage() {
		if (typeof Module.PropsSI === 'undefined') {
console.log("Waiting coolprop to init ...");		
			setTimeout( drawOnlyStorage, 300 );
		}
		else {
			metrics = {};
			pLowParam = null;
			dischargeMassFlowValue = null;
			drawIt(false);
		}
	}
	
	function drawIt(drawTpDiagram) {
		name = getInputParam('name', 'Nitrogen' );
		pCrit = Module.PropsSI('PCRIT', '', 0, '', 0, name)
		tCrit = Module.PropsSI('TCRIT', '', 0, '', 0, name);
		tTriplePoint = Module.PropsSI('T_TRIPLE', '', 0, '', 0, name);
		pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, name);
		minTemp = tTriplePoint - 0.5;
		minPressure =  000000; //pTriplePoint * 0.98;

		const cryogenicCooling = true; //getBooleanParam('cryogenicCooling', true);
		const adjustedCompressorPlow = false; //getBooleanParam('adjustedCompressorPlow');
		var tHigh = getFloatParam('tHigh', 1033);
/*		if (name == 'Methane' && tHigh > 625) {
			tHigh = 625;
			$("#tHigh").val('625');
		}*/
		var tLow = getFloatParam('tLow', 273);
		var tEfficiency = getFloatParam('tEfficiency', 0.90);
		var cEfficiency = getFloatParam('cEfficiency', tEfficiency);
		var tLowEfficiency = getFloatParam('tLowEfficiency', tEfficiency);
		var cLowEfficiency = getFloatParam('cLowEfficiency', cEfficiency);
		var hotCycle = []
		var coldCycle = []
		metricsChanged();
		if (getMetrics() == null) return;
		var pHigh = metrics.pHigh; // getFloatParam('pHigh_kPa', 5000) *  1000;
		var pLow = metrics.pLow; // getFloatParam('pLow_kPa', 25) * 1000;
		maxPressure = pHigh * 18 / 14;
		maxTemp = tHigh+100; //1100; // tCrit < 200 ? 400 : tCrit + 200;

		const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, true );
if (cycleData == null) return;
		
		var tSatInMinP = Module.PropsSI('T', 'P', pLow, 'Q', 0, name);
		console.log("Liquid storage, tSat:"+tSatInMinP+", K, D="+Module.PropsSI('D', 'P', pLow, 'T', tSatInMinP-0.01, name)+" kg/m3, h="+
			Module.PropsSI('H', 'P', pHigh, 'T', tSatInMinP-0.01, name));
/*
		const pTest = 20000;
		const tSatIn20kPa = Module.PropsSI('T', 'P', pTest, 'Q', 0, name);
		const hLiquid = Module.PropsSI('H', 'P', pTest, 'T', tSatIn20kPa-0.01, name);
		const hGas = Module.PropsSI('H', 'P', pTest, 'T', tSatIn20kPa+0.01, name);
		const hSaturation=hGas-hLiquid;
		const pTop = pTest*243;
		var tTopP, hTopP=hLiquid;
		while ((tTopP = Module.PropsSI('T', 'P', pTop, 'H', hTopP, name)) == 'Infinity') hTopP += 1000;
		var tTopOut = Module.PropsSI('T', 'P', pTop, 'H', hTopP+hSaturation, name)	// 0.8 because of extra heat by heatpump compressor and expander with 0.92 efficiency
		
		console.log("Liquid storage, p=20 kPa, tSat:"+tSatIn20kPa+", K,  D_liq="+Module.PropsSI('D', 'P', pTest, 'T', tSatIn20kPa-0.01, name)+" kg/m3, "+
			"D_gas="+Module.PropsSI('D', 'P', pTest, 'T', tSatIn20kPa+0.1, name)+" kg/m3, h_Liq="+(hLiquid/1000)+" J/g"
			+", hSaturation="+(hSaturation/1000)+" J/g, P="+pTop/1000+" kPa =>  "+tTopP+" K => "+tTopOut+" K, D: "
			+ Module.PropsSI('D', 'P', pTop, 'T', tTopP, name )+" kg/m3 => "+Module.PropsSI('D', 'P', pTop, 'T', tTopOut, name )+" kg/m3, deltaH="+(hTopP-hLiquid)/1000+" J/g") ;
*/
/*
		const pHeHigh = 20000000;  // is 200 bar OK?
		const tColdHeOut = tSatIn20kPa-5;		// 5 K diff to limit PCHE size
		const hColdHeOut = Module.PropsSI('H', 'P', pHeLow, 'T', tColdHeOut, 'Hydrogen');
		const tColdHeIn = Module.PropsSI('T', 'P', pHeLow, 'H', hColdHeOut-hSaturation, 'Hydrogen');
		const sColdHeOut = Module.PropsSI('S', 'P', pHeLow, 'T', tColdHeOut, 'Hydrogen');
		const sColdHeIn = Module.PropsSI('S', 'P', pHeLow, 'T', tColdHeIn, 'Hydrogen');

		console.log("Hydrogen heat pump pLow="+(pHeLow/1000)+" kPa;"+tColdHeIn+" K => "+tColdHeOut+" K"+
					 ", D: "+Module.PropsSI('D', 'P', pHeLow, 'H', hColdHeOut-hSaturation, 'Hydrogen')+" kg/m3 => "+Module.PropsSI('D', 'P', pHeLow, 'H', hColdHeOut, 'Hydrogen')+" kg/m3");
		const orgName = name;
*/	
//: TBD: Triple point ja jäätymispiste tulee ottaa huomioon typen nesteytyksessä

		if (drawTpDiagram) {
			iDrawBraytonCycle( "myCanvas", hotCycle, coldCycle, cycleData);
		}
		cycleData.hotCycle = hotCycle;
		cycleData.coldCycle = coldCycle;
drawStorage( 'myPicture', getMetrics(), cycleData );
	}
/*
Obsolate function, we now calclulate dimensions from the known volumes

function iterateBelowGroundLPheight( metrics)
{
	const maxDiff = 2000;
	const r = metrics.r;
	// V=V3 * 3 * 4 / PI + 4*r*r*r
	// JA kartion kulma 30 astetta, saadaan:
	// r=leikattava sisäkartion säde, koska kolmiolla s*s=r*r+h*h ja koska komion kulma on 30 niin 2*r=s, saadaan h = sqrt(3*r*r);
	// => Poisleikattavan sisäkartion tilavuus Vs=r*r*PI*sqrt(3*r*r)/3;
	const Vcut = r*r*Math.PI*Math.sqrt(3*r*r)/3;
	var x = r/3, loop = 0, testV, h2, r2;

console.log("Cut height: "+Math.sqrt(3*r*r)+", Vcut="+Vcut+", V3="+metrics.V3);	
	
	while (loop<100) {
		r2 = r+x;
		h2 = Math.sqrt(3*r2*r2);
		testV = (r2*r2*Math.PI*h2)/3 - Vcut;
		const diff = testV - metrics.V3;
		if (Math.abs(diff) <= maxDiff) break;
		if (testV > metrics.V3) {
			if (Math.abs(diff)<50000) {
				x -= 0.01
			}
			else if (Math.abs(diff)<500000) {
				x -= 0.1
			}
			else {
				x -= 1;
			}
		}
		else {
			if (Math.abs(diff)<50000) {
				x += 0.01
			}
			else if (Math.abs(diff)<500000) {
				x += 0.1
			}
			else {
				x += 1;
			}
		}
//console.log(loop+":r="+r2+", h="+h2+", diff="+(testV - metrics.V3)+", testV="+testV);
		loop++;
	}
	var ret = {};
	ret.loop = loop;
	ret.r = r2;
	ret.h = h2 - Math.sqrt(3*r*r); // leikatun osan korkeus
	ret.V3 = (r2*r2*Math.PI*h2/3)-Vcut;
	return ret;
}
*/
var metrics = {};

function metricsChanged() {
console.log("metricsChanged()..");	
	metrics = {};
	//getMetrics();
}

function getCone( V )//, concreteMaxStrengthMPa, weightMPa )
{
	var ret = {};
	// configurable angle, it may be up to 75 (or 80)
	ret.maxAngle = getFloatParam('maxOpenPitAngle', 60 );
	/*
		V = h*PI/3*(rTop*rTop + rTop*rBottom + rBottom*rBottom);
		If rBottom=rTop/2 and h=rTop/2*tan(maxAngle) =>
		 h = Math.tan(Math.PI*dome.maxAngle/180)*(rTop/4)
	*/
	maxHotRockPressureMPa
	
	if (metrics.pHighActual && (metrics.pHigh < metrics.pHighActual || metrics.dome.prevAdjustment)) {
		// rBottom = rTop*(1/(1 + pHigh/pHighActual));
		// =>  1 + pHigh/pHighActual = rTop / rBottom;
		// => pHigh/pHighActual = rTop / rBottom - 1;
		// => pHighActual = pHigh/(rTop / rBottom - 1);
		const maxAngleTan = Math.tan(Math.PI*ret.maxAngle/180);
		const pHigh = metrics.pHigh;
		var pHighActual = metrics.pHighActual;
		if (metrics.dome.prevAdjustment) {
			pHighActual = pHighActual / metrics.dome.prevAdjustment; // hBottomUnAdjusted / metrics.dome.hBottom; // adjuste it to 'unadjusted' value
		}
		/*	hBottom = pHigh/pHighActual * maxAngleTan*(rTop/2);
			rBottom = rTop*(1/(1 + pHigh/pHighActual)) 
			V = hBottom * PI / 3 (rTop*rTop + rTop*rBottom + rBottom*rBottom);
			V = pHigh/pHighActual * maxAngleTan*(rTop/2) * PI / 3 * (rTop*rTop + rTop*rTop*(1/(1 + pHigh/pHighActual))  + rTop*(1/(1 + pHigh/pHighActual))*rTop*(1/(1 + pHigh/pHighActual))) 
			V = pHigh/pHighActual * maxAngleTan*(1/2) * PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual))) * rTop^3
			rTop = pow( V / (pHigh/pHighActual * maxAngleTan*(1/2) * PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual))), 1/3)
		*/
//  metrics.maxHotRockPressureMPa
		ret.vCave = V;
		ret.rTop = Math.pow(V/(pHigh/pHighActual * maxAngleTan*(1/2) * Math.PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual)))), 1/3);
		ret.rTopTEST = Math.pow(V/((Math.tan(Math.PI*ret.maxAngle/180)/2)*Math.PI/3*(1 + 1/2 + 1/4)), 1/3);
		ret.rBottom = ret.rTop*(1/(1 + pHigh/pHighActual));
		ret.hBottom  = pHigh/pHighActual * maxAngleTan*(ret.rTop/2);
		ret.prevAdjustment = pHigh/pHighActual;
console.log("Prev HP storage:"+JSON.stringify(metrics.dome));
console.log("HP height adjusted by ration: "+(pHigh/pHighActual)+" => ret:"+JSON.stringify(ret));
	}
	else {
		ret.rTop = Math.pow(V/((Math.tan(Math.PI*ret.maxAngle/180)/2)*Math.PI/3*(1 + 1/2 + 1/4)), 1/3);
		ret.rBottom = ret.rTop/2; //1.5;
console.log("Set first time rTop="+ret.rTop);
	}
	ret.s = ret.rTop*2;
	ret.topArea = Math.PI*ret.rTop*ret.rTop;
	ret.vCaveTop = 0;
	ret.side = (ret.rTop - ret.rBottom) / Math.cos(Math.PI*ret.maxAngle/180);
	if (typeof ret.hBottom === 'undefined') ret.hBottom = Math.sqrt(ret.side*ret.side - ret.rBottom*ret.rBottom);		// leikatun kartion korkeus kärkeen
	ret.sideArea = Math.PI*ret.side*(ret.rTop + ret.rBottom);
	ret.vCave = V;
	return ret;
}

function getAverageRockHeatCapasitykJinKg(tLow, tHigh )
{
	// Measured specific heat capacities for nonporous rock samples seems to decrease linearily between 293-773 K and to be constant above it
	// we assume the the decrease continue in same rate below 293 K°C
	const rockHeatCapasityAt293K = tHigh > 773 ? metrics.hpCp : metrics.lpCp;
	const rockHeatCapasityAbove773K = rockHeatCapasityAt293K*1.3/0.8;
	
	const rockHeatCapasityDecreaseBy1K = (rockHeatCapasityAbove773K - rockHeatCapasityAt293K) / (773-293);
	const tLowRockHeatCapasity = rockHeatCapasityAt293K + (tLow-293)*rockHeatCapasityDecreaseBy1K;
	
	if (tHigh > 773) {
		ret = (((tLowRockHeatCapasity+rockHeatCapasityAbove773K)/2)*(773-tLow) + (tHigh - 773)*rockHeatCapasityAbove773K) / (tHigh - tLow);
	}
	else {
		const tHighRockHeatCapasity = rockHeatCapasityAt293K + (tHigh-293)*rockHeatCapasityDecreaseBy1K;
		ret = (tLowRockHeatCapasity+tHighRockHeatCapasity)/2;
	}
console.log("***getAverageRockHeatCapasitykJinKg("+tLow+","+tHigh+")="+ret+", rockHeatCapasityAbove773K="+rockHeatCapasityAbove773K+", tLowRockHeatCapasity="+tLowRockHeatCapasity);
	return ret;
}

function getTotalHeatLost()
{
	// the actual power is stored into hp storage, the low pressure storage losses are 
	return metrics.maxHeatFlowOut * metrics.highPressureStorageSurfaceArea; 
	// + metrics.lowPressureStorageSurfaceArea);
}

function getMetrics(pRatio, storageSize) {
	if (metrics && metrics.rGround && typeof pRatio === 'undefined' && typeof hpStorageSizeRockMm3 === 'undefined') return metrics;
	const tHigh = getFloatParam('tHigh', 1033);
	metrics.tHigh = tHigh;

	var storageMetrics = {
		heatPumpCompressorTin : 313, // getFloatParam("heatPumpCompressorTin", 313);	// 40 Celsius
		coolingWaterTemp : 283, // getFloatParam("heatPumpCompressorTin", 313);	// 40 Celsius
		cUnits : getIntParam('numberOfUnits', 4 ), 
		heatExchangeDeltaT : 2,  // // 2 K difference in heat exchange
		//heatPumpHighP : 5000000, // 5MPa==50 bar == 20MPa==200 bar
		heatPumpHighP : 3000000, // 3MPa=30bar, 5MPa==50 bar == 20MPa==200 bar
		<!-- these hidden old values are set based on the values of hpStorageSizeRockM3, highToLowPressureRatio, rockDensity, gravelDensity, insGravelDensity -->
		storageSizeTons : (storageSize ? storageSize : getFloatParam('storageSizeMTon', 20 )) * 1000000,	
		ins : getFloatParam('highPressureInsulationM', 10 ), // in meters
		maxHpGravelExpansion : getFloatParam('maxHpGravelExpansion', 0.05 ), 
		lpGravelExpansionIn100K :  getFloatParam('lpGravelExpansionIn100K', 0.001 ),
		costOfSurfaceM2 : getFloatParam('costOfSurfaceM2', 1000 ),
		costOfMiningM3 : getFloatParam('costOfMiningM3', 12 ),
		generatorCostOfKW : getFloatParam('generatorCostOfKW', 0),
		tcCostOfKW : getFloatParam('tcCostOfKW', 50),		// cost of tubin or compressor power
		heCostOfKW : getFloatParam('heCostOfKW', 50),		// cost of heat exchangers  
		otherCostOfKW: getFloatParam('otherCostOfKW', 50),	// all other power plant cost
		rockDensityHp : getFloatParam('rockDensityHp', 3.0 ), 
		rockDensityLp : getFloatParam('rockDensityLp', 2.8 ), 
		highToLowPressureRatio : (pRatio ? pRatio : getFloatParam('highToLowPressureRatio', 25 )),	
		pRatioTolerance : getFloatParam('pRatioTolerance_kPa', 100)*1000,	// by default about 1 bar tolerance before the deck starts to rise by pressure
		//gravelDensity : getFloatParam('gravelDensity', 2.1 ),	// high density because it makes storage more compact and aboslute pressure drop does not matter in a high pressure
		//lpGravelDensity : getFloatParam('lpGravelDensity', 2.1 ),	// high density because it makes storage more compact and aboslute pressure drop does not matter in a high pressure
		hpCp : getFloatParam('hpCp', 1.0),
		lpCp : getFloatParam('hpCp', 0.9),
		//rockHeatCapasityAt293K : getFloatParam('rockHeatCapasityAt293K', 0.8)*1000, // kJ/kg/K  at 293K !!!
		//rockHeatCapasityAbove773K : getFloatParam('rockHeatCapasityAbove773K', 1.3 )*1000, // kJ/kg/K  (Cp increases from 20C to 500C and then stabilize 
		maxPartLiquid : 0.01,   // spefic value is calculated later
		maxTopFillAngle : getFloatParam('maxTopFillAngle', 50),
		maxHotRockPressureMPa: getFloatParam('maxHotRockPressureMPa', 200),
		maxHeatFlowOut : getFloatParam('maxHeatFlowOut', 20),	// W/m^2
		powerAndHeat : !getBooleanParam('powerOnly', false ),
		gearEfficiency : getFloatParam('gearEfficiency', 0.993 ), 
		frequencyConverterEfficiency : getFloatParam('frequencyConverterEfficiency', 0.97 ), 
		generatorEfficiency : getFloatParam('generatorEfficiency', 0.99 ),
		uOfGravelrockwoolMix : getFloatParam('uOfGravelrockwoolMix', 0.1)	// W/(T * m)	// heat flows in gravel is mainly by radiation => bichar blocks it
		
		//concreteMaxStrengthMPa : 80	// for a very high quality rock-filled concrete could have >90 MPa
	};
	metrics = storageMetrics;
	metrics.tEfficiency = getFloatParam('tEfficiency', 0.97);
	metrics.cEfficiency = getFloatParam('cEfficiency', metrics.tEfficiency);
	metrics.tLowEfficiency = getFloatParam('tLowEfficiency', metrics.tEfficiency);
	metrics.cLowEfficiency = getFloatParam('cLowEfficiency', metrics.cEfficiency);
	metrics.insGravelDensity = getFloatParam('insGravelPorosity', 0.5) * metrics.rockDensityHp;	// low density to minimize the pressure drop in low pressure
	calcPressureDropInGravel('Lp');
	calcPressureDropInGravel('Hp');

	metrics.pLow = getFloatParam( pLowParam ? pLowParam : 'targetPLow', 102 ) * 1000;
	metrics.pHigh = metrics.pLow * metrics.highToLowPressureRatio;

	const tExternal = 273;

	//maxHeatFlowOut = deltaT * uOfGravelrockwoolMix/ins =>
	metrics.ins = (tHigh-tExternal)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;

	metrics.externalEclosure = true; // document.getElementById('isolatedWithRecycledRubber').checked;
	metrics.maxTempOfEnclosure = tHigh; 	// assume max temp for steel 
	//metrics.externalEclosure ? getFloatParam('maxRubberTemp', 673) : tHigh; 	// assume max temp for steel
	
	//if (metrics.ins == 10) metrics.ins = metrics.ins*tHigh/1030; // scale the Insulation layer to the default, THIS IGNORES TE
	
	// Let's fix the dome rock temperature to approximately 300 or 750K, we assume insulation k value of cave top is 10 times of 10m gravel Insulation in the bottom lp storage
	//const	hpInsulationBoundaryTemp = isCone ? tHigh : 300;
	const tSat = Module.PropsSI('T', 'P', metrics.pLow, 'Q', 0, name);
	const cEfficiency= getFloatParam('cEfficiency', 0.92);
	const ccEfficiency= getFloatParam('ccEfficiency', 0.92);
	const mainCompressor = doAdiabaticProcessWithS( name, metrics.pHigh, metrics.pLow, tHigh, 1/cEfficiency,null );
	const coldCompressor = doAdiabaticProcessWithS( name, metrics.pLow, metrics.pHigh, tSat+0.01, ccEfficiency, null );

	const tc = getEnergyLevelChangeOf1000KgGasFlow( mainCompressor, coldCompressor );
	metrics.lpGravelPart = tc.lpGravelWeight / (tc.lpGravelWeight + tc.hpGravelWeight);
	metrics.hpGravelPart = tc.hpGravelWeight / (tc.lpGravelWeight + tc.hpGravelWeight);

	metrics.caveTopInsulation = 0;
	metrics.insCaveBottom = (280-coldCompressor.tIn)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	
	// scale the low pressure insulation layer for its lower temps but check also the tLow temp diff between 70K and 300K
	// in the middle we lose energy from both directions == multiply by 2
	metrics.lpInsForLowTBottom = 1.5*(tHigh-tSat)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;  // 2*
	const lpInsForLowTBottom = metrics.lpInsForLowTBottom;
	const lpInsForHighT = (mainCompressor.tIn-280)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	const lpInsForLowT = (280-tSat)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	metrics.insLpSides = lpInsForHighT > lpInsForLowT ? lpInsForHighT : lpInsForLowT;

	var h, loop = 0;
	var scaledToVolume = 0;
	var sizeMultiplier = 1;
	
	// The low and high pressure storages have the same weight.  The weight of low pressure storage must contain the high pressure.
	// So the high pressure defines the depth and volume of the high pressure storage.  
	// V1 = the high pressure cylider rock volume needed to contains pHigh pressure == 

	// this estimation was based on radius=150 and insulation layer=10, 
	//Loop again: expected density=2 <> calclulated density=1.8343575910031746 or 1.973478029020575<>2.0375
	metrics.hpExpectedAverageDensity = (metrics.gravelDensity * 3 + metrics.insGravelDensity) / 4;	// very near to the actual value when high pressure insulation layer is 10 m
	var lpExpectedV3AverageGravelDensity = (metrics.gravelDensity * 6 + metrics.insGravelDensity) / 7;	// This applies below ground!
	
	metrics.hpGravelPartActual = metrics.hpGravelPart;
	for (;;) {
		// the mined volume 
		metrics.actualV1 =  metrics.storageSizeTons * metrics.hpGravelPartActual / metrics.hpExpectedAverageDensity;
		// hp storage size as rock m3
		metrics.V1 = metrics.storageSizeTons * metrics.hpGravelPartActual/metrics.rockDensityHp;
		// V1 is the dense base rock volume needed above to contain the pressure, 
		// V2 = the rock volume to contain the expansion of gravel in the high pressure cylinder,
		// 		== the volume exceeding the high pressure storage because of gravel fill
		metrics.V2 = metrics.actualV1 - metrics.V1;
		// the mined volume above the high pressure cylinder
		metrics.V3 = metrics.storageSizeTons * (1-metrics.hpGravelPartActual)/metrics.rockDensityLp - metrics.V2;
		metrics.totalMiningVolume = metrics.actualV1 + metrics.V3;
		metrics.rockDensity = metrics.storageSizeTons/metrics.totalMiningVolume;

		if (metrics.V2 < 0 || metrics.V3<0) {
			console.log("Bad values:\r\n"+JSON.stringify(metrics, null, 2)); 
			return null;
		}
		
		// volume above ground

		metrics.isCylinder = isCylinder;
		
		{
			var dome = getCone(metrics.actualV1);
			metrics.domeThickness = 0; // dome.thickness2;
			metrics.rCylinder = dome.rTop; 
//console.log("Actual dome width="+caveS+": "+caveVolume+"=> scaleLength="+dome.scaleLength+", dome="+JSON.stringify(dome));
			
			// next we calclulate 1. insulation layer in the side and bottom. 2 the volume extension reserve in the top of cave 3. the actual storage volume 
			// 1. Kartion halkaisija pienenee 2*10/sin(60)
			const xWidthHpInsulation = metrics.ins/Math.sin(Math.PI*dome.maxAngle/180) 
			dome.rTopI = dome.rTop - xWidthHpInsulation;
			//  dome.rBottomI = dome.rBottom - (dome.rTop-dome.rTopI);	// equal insulation everywhere
			dome.hBottomI = dome.hBottom - metrics.insCaveBottom;
			metrics.pHighStorageHeight = dome.hBottomI;
			// dome.rBottomI = dome.rBottom - xWidthHpInsulation; 
			dome.rBottomI = dome.rBottom * dome.rTopI / dome.rTop;	// better insulation in the top?
			metrics.dome = dome;
			// Rock temperature about 300K,  bottom temp 200K => 100K diff, in the side the difference is tHigh-300 => bottom insulation should be ins*100/(tHigh-300)
			// when h is the same => V1/V2=r1*r1/r2*r2 => V2 = V1*r2*r2/r1*r1
			//const r1 = dome.s/2, r2=dome.sActual/2;
			//metrics.insHp = metrics.ins*100/(tHigh-300);
			metrics.highPressureInsulationMVolume = dome.vCave * (1 - dome.rTopI*dome.rTopI/(dome.rTop*dome.rTop)) + Math.PI * dome.rBottomI*dome.rBottomI*metrics.insCaveBottom;
			metrics.topInsulationVolume = 0; //isCone ? dome.rTopI*dome.rTopI*Math.PI*metrics.caveTopInsulation :
			//dome.vCaveTop * (1- Math.pow(dome.r-(1+metrics.caveTopInsulation),3)/Math.pow(dome.r,3));	// min 1 m free space!
			metrics.highPressureStorageVolume = (dome.vCave - metrics.highPressureInsulationMVolume);
			metrics.rCaveBottom = dome.rBottom;

			// for simplicity we assume the percentage of insulation of the total volume to be the same in high and low pressures storages
			metrics.hpAverageGravelDensity = // total high pressure height 
				(metrics.highPressureStorageVolume * metrics.gravelDensity +  metrics.highPressureInsulationMVolume*metrics.insGravelDensity) / dome.vCave;
/*
			metrics.actualV1 = dome.vCave;
			metrics.totalMiningVolume = metrics.actualV1 + metrics.V3;

			// V2 = the rock volume to contain the expansion of gravel in the high pressure cylinder,
			// 		== the volume exceeding the high pressure storage because of gravel fill
			metrics.V2 = metrics.actualV1 - metrics.V1;

			// the mined volume above the high pressure cave
			metrics.V3 = metrics.V1 - metrics.V2;
			if (metrics.V2 < 0 || metrics.V3<0) {
				console.log("Bad values:\r\n"+JSON.stringify(metrics, null, 2)); 
				return null;
			}
*/
			// the volume above ground has no insulation layer, so its density that of the compacted gravel density
			metrics.lpExpectedV3AverageGravelDensity = lpExpectedV3AverageGravelDensity;
//			metrics.V4 = ((metrics.V1-metrics.V3)  + metrics.V3 * (1 - lpExpectedV3AverageGravelDensity/metrics.rockDensity))
//						* metrics.rockDensity / metrics.lpGravelDensity;
			metrics.V4 = ((metrics.V3) * (1 - lpExpectedV3AverageGravelDensity/metrics.rockDensityLp))+
							+ metrics.actualV1 * (1 - metrics.hpExpectedAverageDensity/metrics.rockDensityHp) * metrics.rockDensityLp/metrics.lpGravelDensity;
		
/*console.log(metrics.V4+" = ("+metrics.V1+" * "+(1 - metrics.hpAverageGravelDensity/metrics.rockDensity)+" + "+metrics.V3+" * "+(1 - lpExpectedV3AverageGravelDensity/metrics.rockDensity)+")"+
						"* "+(metrics.rockDensity / metrics.lpGravelDensity));*/

			// hMin = hBelow + hAbove;
			// V3 = PI*rGround*rGround*hBelow/3 - ;
			//metrics.extDome = getExternalDome45( dome, metrics.dome.thickness2 );
			//metrics.extDomeIns = getExternalDome45( dome, metrics.dome.thickness2+metrics.ins );
			metrics.rOpenBottom = metrics.dome.rTop; 
			metrics.rTop = metrics.dome.rTopI;

			// V3 + extDome.volume = PI/3*rGround*rGround*hBelow*rGround/(rGround-rTop) - PI/3*rTop*rTop*hBelow*rGround/rTop;
			// V3 + extDome.volume = (PI/3*rGround*rGround*rGround/(rGround-rTop) - PI/3*rTop*rTop*rGround/rTop)*hBelow;
			// hBelow = (V3 + extDome.volume) / (PI/3*(rGround*rGround*rGround/(rGround-rTop) - rTop*rTop*rGround/rTop));
			var V3 = metrics.V3; // + metrics.extDome.volume;
			testResult( V3, metrics.rTop, dome.rTop*2, 0.005*V3,
					function (h) { 
						metrics.rGroundBelow = h;
						metrics.hBelow = Math.tan(Math.PI*dome.maxAngle/180)*(metrics.rGroundBelow-dome.rTop);
//console.log("metrics.rGroundBelow="+metrics.rGroundBelow+", metrics.hBelow="+metrics.hBelow);
						return Math.PI/3*metrics.hBelow*(Math.pow(metrics.rGroundBelow,2)+metrics.rGroundBelow*dome.rTop+Math.pow(dome.rTop,2));
					});
			
			// Check first if side angle is less or equal to maxTopFillAngle
			// because of 45 angle:  rGround = ;
			// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * hTop / 3;
			// when hTop = hGround*rTop/rGround =>
			// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * (hGround*rTop/rGround) / 3;
			// => hGround = 3 * (V4 - extDome.volume) / (PI * rGround * rGround - PI * rTop * rTop * rTop/rGround)
			var rGround = metrics.rGroundBelow;
			var hGround = 3 * (metrics.V4)/(Math.PI * rGround * rGround - Math.PI * metrics.rTop * metrics.rTop * metrics.rTop/rGround);
			var actualAngleRad = Math.atan2(hGround,rGround); // atan2(y,x)
console.log("rGround="+rGround+", hGround="+hGround+", "+actualAngleRad+"<="+(Math.PI*metrics.maxTopFillAngle/180)+"?");
			if (actualAngleRad <= (Math.PI*metrics.maxTopFillAngle/180)) {
				metrics.rGround = rGround;
				metrics.hAbove = hGround * (rGround-metrics.rTop)/rGround;
				metrics.topFillAngleRad = actualAngleRad;
				metrics.topFillTan = Math.tan(actualAngleRad);
			}
			else {
				// We first check if metrics.rGroundBelow==metrics.rGround
				metrics.topFillAngleRad = Math.PI*metrics.maxTopFillAngle/180;
				metrics.topFillTan = Math.tan(metrics.topFillAngleRad);
				// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * hTop / 3;
				// and hGround = rGround * topFillTan, hTop = rTop * topFillTan;
				// V4 = extDome.volume + PI * rGround * rGround * rGround * topFillTan / 3 - PI * rTop * rTop * rTop * topFillTan / 3;
				// => rGround = pow( 3 * (V4 - extDome.volume)/(PI* topFillTan) + rTop * rTop * rTop, 1/3);
				metrics.rGround = Math.pow( 3 * (metrics.V4)/(Math.PI*metrics.topFillTan) + metrics.rTop * metrics.rTop * metrics.rTop, 1/3);
				metrics.hAbove = (metrics.rGround - metrics.rTop)*metrics.topFillTan;
			}
metrics.checkedV4=metrics.hAbove*Math.PI/3*(metrics.rGround*metrics.rGround+metrics.rGround*metrics.rTop+metrics.rTop*metrics.rTop);
			metrics.toSideX = function (deltaY) { return deltaY/ this.topFillTan;}
			metrics.toSideY = function (deltaX) { return deltaX * this.topFillTan;}
			
			var x = metrics.rGround - metrics.rTop; 
			metrics.sideAbove =  Math.sqrt( metrics.hAbove * metrics.hAbove + x * x );
			metrics.gasEnclosureFromHpTop = lpInsForLowTBottom - lpInsForLowTBottom * (metrics.maxTempOfEnclosure - tSat)/(tHigh - tSat);
			metrics.pHighActual = (metrics.lpGravelDensity*10000)*(metrics.hAbove+metrics.hBelow - lpInsForLowTBottom)+(metrics.insGravelDensity*10000)*
				(lpInsForLowTBottom - metrics.gasEnclosureFromHpTop);
//OK: rubber use case adapts the storage size a little bi smaller => higher pHigh
//console.log("pHighActual:"+metrics.pHighActual+" = "+(metrics.lpGravelDensity*10000)+"*"+(metrics.hAbove+metrics.hBelow - lpInsForLowTBottom)+"+"+(metrics.insGravelDensity*10000)+"*"+(lpInsForLowTBottom - metrics.gasEnclosureFromHpTop));

/*
			if (metrics.pHighActual < metrics.pHigh && scaledToVolume) {
				const hBelow  = (metrics.pHigh-(metrics.insGravelDensity*10000)*(metrics.caveTopInsulation+lpInsForLowTBottom))/(metrics.lpGravelDensity*10000)+lpInsForLowTBottom-metrics.hAbove;
				const rGroundBelow = metrics.dome.rTop + (hBelow/Math.tan(Math.PI*dome.maxAngle/180));
				// V3 + extDome.volume = PI/3*rGround*rGround*hBelow*rGround/(rGround-rTop) - PI/3*rTop*rTop*hBelow*rGround/rTop
				const V3 = hBelow * Math.PI/3*(rGroundBelow*rGroundBelow + rGroundBelow*metrics.rTop + metrics.rTop*metrics.rTop);
console.log("Adjusted V3:"+metrics.V3+"=>"+V3+", hBelow:"+metrics.hBelow+"=>"+hBelow+", rGroundBelow:"+metrics.rGroundBelow+"=>"+rGroundBelow);
				metrics.V3 = V3;
				metrics.hBelow = hBelow;
				metrics.rGroundBelow = rGroundBelow;
			}
*/
/*
			metrics.topDome = getMetricsOfDome45(metrics.V4);
			metrics.sideAbove = metrics.topDome.r*Math.PI / 4;	// path from 45 to 90
			metrics.hAbove = metrics.topDome.h;
			metrics.rGround = metrics.topDome.s / 2;
			// h = height of V3, hTot = distance to virtual end of cone
			// V3 = PI*rGround*rGround*hTot/3 - PI*rOpenBottom*rOpenBottom*(hTot-h)/3
			// hTot = h * rGround / (rGround-rOpenBottom);
			// => V3 = PI*rGround*rGround*h * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(h * rGround * (rGround-rOpenBottom)-h)/3
			// => V3/h = PI*rGround*rGround * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(rGround * (rGround-rOpenBottom)-1)/3
			// => h = V3/(PI*rGround*rGround * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(rGround * (rGround-rOpenBottom)-1)/3);
			metrics.hBelow = 3 * metrics.V3/(Math.PI*metrics.rGround*metrics.rGround * metrics.rGround / (metrics.rGround-metrics.rOpenBottom)  
						- Math.PI*metrics.rOpenBottom*metrics.rOpenBottom*(metrics.rGround / (metrics.rGround-metrics.rOpenBottom)-1));
			metrics.rTop = 0;
console.log("Vtest="+(Math.PI*metrics.rGround*metrics.rGround*metrics.hBelow));
*/
			metrics.hCylinder = dome.hBottom;

			x = metrics.rGroundBelow - metrics.rOpenBottom; 
			metrics.sideBelow = Math.sqrt( metrics.hBelow * metrics.hBelow + x * x );
			var sinX = metrics.hBelow / metrics.sideBelow;
			var sinXRad = Math.asin(sinX);

			// 
			if (isCone) {
				//metrics.extDomeIns.hActual = 0;
				metrics.hBelowActual = metrics.hBelow - lpInsForLowTBottom;
				//metrics.extDomeIns.rTopActual = metrics.extDomeIns.rTop;
			}
			/*
			else {
				const outside = (metrics.extDomeIns.r-dome.r)*Math.sin(sinXRad-Math.PI/4);
				const rads = Math.asin(outside/metrics.extDomeIns.r);
				metrics.extDomeIns.rads = Math.PI/4+2*rads; 	// why???, it is double otherwise
				metrics.extDomeIns.hActual = metrics.extDomeIns.r * (1-Math.sin(metrics.extDomeIns.rads));
	// this is shit:
	//metrics.hBelow + dome.r*Math.sin(Math.PI/4) - metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads);
	//console.log("diff="+(dome.r*Math.sin(Math.PI/4))+"-"+(metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads))+"="+(dome.r*Math.sin(Math.PI/4) - metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads)));
				metrics.extDomeIns.rTopActual =
					metrics.rOpenBottomActual = metrics.extDomeIns.r * Math.cos(metrics.extDomeIns.rads);
				metrics.hBelowActual = metrics.hCylinder + metrics.hBelow -
					(metrics.dome.hBottom+metrics.dome.hTop-metrics.dome.r+metrics.extDomeIns.r-metrics.extDomeIns.hActual);
			}*/
			
			// V3 = hBelow * rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - hBelow * (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3;
			// => V3 = hBelow * (rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3);
			// => hBelow = V3 / (rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3);
			//metrics.hBelow = metrics.V3 / (metrics.rGroundBelow / (metrics.rGroundBelow-metrics.rOpenBottom) * metrics.rGroundBelow * metrics.rGroundBelow * Math.PI / 3 - 
			//				(metrics.rGroundBelow / (metrics.rGroundBelow-metrics.rOpenBottom) - 1)*metrics.rOpenBottom*metrics.rOpenBottom*Math.PI/3);
			x = (metrics.rGroundBelow-metrics.insLpSides/sinX);
//console.log(x+"=("+metrics.rGroundBelow+"-"+sinX+"*"+metrics.insLpSides);
			// V1/V2==pow(r1,3)/pow(r2,3) => V2 = V1*pow(r2,3)/pow(r1,3)
			metrics.caveSide = dome.side  + metrics.domeThickness;
			metrics.rGroundBelowActual = x;
			metrics.rOpenBottomActual = metrics.rGroundBelowActual - (metrics.hBelowActual/Math.tan(Math.PI*metrics.dome.maxAngle/180));
			if (isCone) {
				metrics.sideBelowActual = metrics.sideBelow*(1-(metrics.rOpenBottomActual-metrics.rOpenBottom)/(metrics.rGroundBelow-metrics.rOpenBottom));
				metrics.vLpInsulation = Math.PI*metrics.sideBelowActual*(metrics.rGroundBelow+metrics.rOpenBottomActual)*metrics.insLpSides
										+ Math.PI*lpInsForLowTBottom*metrics.rOpenBottomActual*metrics.rOpenBottomActual;
			}
			/*else {
				metrics.vLpInsulation = metrics.V3 - metrics.V3*Math.pow(x,3)/Math.pow(metrics.rGroundBelow,3) 
					+ metrics.extDome.area*metrics.ins; // approximation, but good enough for us
			}*/
			metrics.lpV3AverageGravelDensity = (metrics.lpGravelDensity *(metrics.V3-metrics.vLpInsulation) + metrics.vLpInsulation*metrics.insGravelDensity) / metrics.V3;
			metrics.highPressureStorageSurfaceArea = dome.topArea + Math.PI*dome.rBottomI*dome.rBottomI*Math.PI + dome.sideArea;
			metrics.lowPressureStorageSurfaceArea = //metrics.extDome.area + // area of top dome
													Math.PI*metrics.rTop*metrics.rTop+
													Math.PI*metrics.sideAbove*(metrics.rGround+metrics.rTop) + // side above ground
													Math.PI*metrics.sideBelow*(metrics.rGroundBelow+metrics.rOpenBottom);+ // side below ground
													Math.PI*metrics.rOpenBottom*metrics.rOpenBottom;
			metrics.maxHpGravelExpansionUpM = (metrics.highPressureStorageVolume*metrics.maxHpGravelExpansion)
				/(Math.PI*metrics.dome.rTopI*metrics.dome.rTopI);
			// we assume lp gravel to shrink 
			// it's simpler not to expand cone inside ball segment => cone height won't change
			// 15 MPa*25 =>
		}

/*
//console.log("metrics.testV3 = "+(metrics.rGroundBelow*metrics.rGroundBelow*Math.PI*h/3)+" - "+(metrics.rCylinder*metrics.rCylinder*(h*metrics.rCylinder/metrics.rGroundBelow)*Math.PI/3)+", h="+h);
metrics.testV3 = metrics.rGroundBelow*metrics.rGroundBelow*Math.PI*h/3 - metrics.rCylinder*metrics.rCylinder*(h*metrics.rCylinder/metrics.rGroundBelow)*Math.PI/3;
console.log("V3-testV3="+(metrics.V3-metrics.testV3));
if (Math.abs(metrics.V3-metrics.testV3)>10) {
	console.log("Test failed:"+JSON.stringify(storageMetrics)); 
	return;
}*/
		metrics.lowPressureStorageVolume = metrics.V4 + metrics.V3 - metrics.vLpInsulation;
//console.log(metrics.lowPressureStorageVolume+" = "+metrics.V4+" + "+metrics.V3+" - "+metrics.vLpInsulation);
		var hpGravelPartNow = metrics.highPressureStorageVolume*metrics.gravelDensity
				/(metrics.highPressureStorageVolume*metrics.gravelDensity + metrics.lowPressureStorageVolume*metrics.lpGravelDensity);
console.log("Math.abs("+hpGravelPartNow+"-"+metrics.hpGravelPart+")="+Math.abs(hpGravelPartNow-metrics.hpGravelPart)+", metrics.hpGravelPartActual="+metrics.hpGravelPartActual);
		var hpGravelPartAdjusted = false;
		if (Math.abs(hpGravelPartNow-metrics.hpGravelPart)>0.005) {
			hpGravelPartAdjusted = true;
			var old = metrics.hpGravelPartActual;
			if (hpGravelPartNow > metrics.hpGravelPart) {
//console.log(metrics.hpGravelPartActual+"*("+(1-(hpGravelPartNow-metrics.hpGravelPart))+"="+(metrics.hpGravelPartActual*(1-(hpGravelPartNow-metrics.hpGravelPart))));;
				metrics.hpGravelPartActual = metrics.hpGravelPartActual*(1-(hpGravelPartNow-metrics.hpGravelPart));
			}
			else {
//console.log(metrics.hpGravelPartActual+"*("+(1+(metrics.hpGravelPart+hpGravelPartNow))+"="+(metrics.hpGravelPartActual*(1+(metrics.hpGravelPart-hpGravelPartNow))));;
				metrics.hpGravelPartActual = metrics.hpGravelPartActual*(1+(metrics.hpGravelPart-hpGravelPartNow));
			}
console.log("hpGravelPartNow="+hpGravelPartNow+"=> adjusted hpGravelPartActual: "+old+"=>"+metrics.hpGravelPartActual);
		}
		
		if (!metrics.hpAverageGravelDensity || !metrics.hpExpectedAverageDensity || !metrics.lpV3AverageGravelDensity) {
if (!metrics.hpAverageGravelDensity) console.log("metrics.hpAverageGravelDensity="+metrics.hpAverageGravelDensity);
else if (!metrics.hpExpectedAverageDensity) console.log("metrics.hpExpectedAverageDensity="+metrics.hpExpectedAverageDensity);
else if (!metrics.lpV3AverageGravelDensity) console.log("metrics.lpV3AverageGravelDensity="+metrics.lpV3AverageGravelDensity);
console.log("Bad values:"+JSON.stringify(storageMetrics, null, 2)); 
alert("Internal error");
return null;
		}
		else if (Math.abs(metrics.hpAverageGravelDensity-metrics.hpExpectedAverageDensity)<0.01 && Math.abs(metrics.lpV3AverageGravelDensity-lpExpectedV3AverageGravelDensity)) {
//console.log("metrics.pHighActual="+metrics.pHighActual+"="+(metrics.lpGravelDensity*10000)+"*("+metrics.hAbove+"+"+metrics.hBelow+"-"+lpInsForLowTBottom+")+"+(metrics.insGravelDensity*10000)+"*("+metrics.caveTopInsulation+"+"+lpInsForLowTBottom);

console.log(metrics.pHigh+" < "+metrics.pHighActual+"?");
			// readjust depth and height if more that 2% too much weight 
			if (loop < 10 && metrics.pHigh < metrics.pHighActual && (metrics.pHighActual-metrics.pHigh) > metrics.pHigh*0.02) {
				loop++;
console.log(loop+": Adjust LP storage weight to match high pressure, hpGravelPartAdjusted="+hpGravelPartAdjusted);
				continue;
			}
			else if (metrics.pHighActual < metrics.pHigh && (metrics.pHighActual - metrics.pHigh) > metrics.pRatioTolerance*0.05) {  // exceeds by more than 5% the set safe margin
			{
					storageSizeTons = metrics.storageSizeTons;
					metrics.storageSizeTons = metrics.storageSizeTons * sizeMultiplier * Math.pow(metrics.pHigh/metrics.pHighActual, 3);
console.log("Scaled size from "+storageSizeTons+" to "+metrics.storageSizeTons+", sizeMultiplier="+sizeMultiplier);
					scaledToVolume++;
					metrics.pHighActual = 0; 	// no adjustement when we increase the size
					sizeMultiplier *= 1.02;		// increase the min size by small steps...
			if (loop++ > 10) {
console.log(JSON.stringify(storageMetrics)); 
				alert("Cannot resolve expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity);
				return null;
			}
console.log(loop+": Increase storage size");
					continue;	// retry the loop
				}
			}
			else if (hpGravelPartAdjusted) {
				if (loop++ > 10) {
console.log(JSON.stringify(storageMetrics)); 
					console.error("Too many adjustments of metrics.hpGravelPartActual="+metrics.hpGravelPart+"=>"+metrics.hpGravelPartActual);
					return null;
				}
			}
			metrics.lpAverageGravelDensity = 
				(metrics.V4 * metrics.lpGravelDensity + metrics.lpGravelDensity *(metrics.V3-metrics.vLpInsulation) + metrics.vLpInsulation*metrics.insGravelDensity) / (metrics.V4 + metrics.V3);
			break;
		}
		else {

console.log("Loop again: expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity+" or "+metrics.lpV3AverageGravelDensity+"<>"+lpExpectedV3AverageGravelDensity);
			if (loop++ > 20) {
console.log(JSON.stringify(storageMetrics, null, 2)); 
				alert("Cannot resolve expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity);
				return null;
			}
			metrics.hpExpectedAverageDensity = metrics.hpAverageGravelDensity;
			lpExpectedV3AverageGravelDensity = metrics.lpV3AverageGravelDensity;
console.log(loop+": Adjusting average densities");
		}
	}
	if (metrics.pHigh > metrics.pHighActual) {
		metrics.pLow = metrics.pLow*metrics.pHighActual / metrics.pHigh;
		metrics.pHigh = metrics.pHighActual;
	}
	/*
	metrics.testV4 = metrics.rGroundBelow*metrics.rGround*metrics.rGround*Math.PI/3 - metrics.rTop*metrics.rTop*metrics.rTop*Math.PI/3;
	console.log("V4-testV4="+(metrics.V4-metrics.testV4));
	if (Math.abs(metrics.V4-metrics.testV4)>10) {
		console.log("Test failed:"+JSON.stringify(storageMetrics)); 
		return;
	}*/

//console.log("pHighStorageHeight="+Math.round(metrics.pHighStorageHeight)+", highPressureStorageVolume Mm3="+Math.round(metrics.highPressureStorageVolume/1000000)+
//		", hpAverageGravelDensity="+myRound(metrics.hpAverageGravelDensity,2));
		// Above ground expansion of gravel V4:

	// TBD: chargeLevel = 0 - 1		// charge level of hot storage
	// Hight<0 == below => decrease the in/out pressure, height>0 == above => increments in/out pressure
	if (generatorLocation == 'TOP') {
		metrics.pipeFromColdCompressor = metrics.rCylinder + metrics.hCylinder + metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;
		metrics.heightOfColdCompressorOut = -(chargeLevel * metrics.hCylinder + metrics.hBelow + metrics.hAbove);
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = -(1-chargeLevel) * (metrics.hBelow+metrics.hAbove-20+5);	// 20 m insulation in the bottom and 5 m in the top
		metrics.heightAboveColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove-20+5);
		metrics.pipeToColdCompressor = (metrics.hBelow+metrics.hAbove-20+5) + 20; // height and some extra

		metrics.heightOfMainTurbinIn = -(metrics.hBelow+metrics.hAbove+15);	// 10 m insulation, 5 m for machinery
		metrics.pipeToMainTurbin = (metrics.hBelow+metrics.hAbove+15)+50;	// some extra
		metrics.heightOfMainTurbinOut = -10;	// 5 m insulation and some extra 
		metrics.pipeFromMainTurbin = 20;	// height and some extra 
	}	
	else if (generatorLocation == 'GROUND') {
		metrics.pipeFromColdCompressor = metrics.sideBelow + metrics.caveSide + 50;
		metrics.heightOfColdCompressorOut = -chargeLevel * metrics.hCylinder+metrics.domeThickness+metrics.hBelow;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder+metrics.domeThickness+metrics.hBelow;
		metrics.heightOfColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove) - metrics.hAbove;
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove) + metrics.hAbove;
		metrics.pipeToColdCompressor = metrics.sideBelow + 50;
		metrics.heightOfMainTurbinIn = metrics.hBelow + metrics.domeThickness;	// 
		metrics.pipeToMainTurbin = metrics.sideBelow + metrics.domeThickness + metrics.rOpenBottom + 20;	// some extra
		metrics.heightOfMainTurbinOut = 20;
		metrics.pipeFromMainTurbin =  20;	// height and some extra 
	}
	else if (generatorLocation == 'MIDDLE') {
		metrics.pipeFromColdCompressor = metrics.caveSide + 50;
		metrics.heightOfColdCompressorOut = -chargeLevel * metrics.hCylinder;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove);		// insulation
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeToColdCompressor = metrics.rOpenBottom + 20;

		metrics.heightOfMainTurbinIn = -10;	// 
		metrics.pipeToMainTurbin = metrics.rCylinder + 20;	// some extra
		metrics.heightOfMainTurbinOut = metrics.hBelow + metrics.hAbove;
		metrics.pipeFromMainTurbin = metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;	// height and some extra 
	}
	else if (generatorLocation == 'BOTTOM') {
		metrics.pipeFromColdCompressor = metrics.rCylinder + 20;
		metrics.heightOfColdCompressorOut = (1-chargeLevel) * metrics.hCylinder;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = metrics.hCylinder + chargeLevel * (metrics.hBelow+metrics.hAbove);
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeToColdCompressor = metrics.rCylinder + metrics.hCylinder + 20;

		metrics.heightOfMainTurbinIn = metrics.hCylinder;
		metrics.pipeToMainTurbin = metrics.caveSide + metrics.rCylinder + 20;	// some extra
		metrics.heightOfMainTurbinOut = metrics.hCylinder + metrics.hBelow + metrics.hAbove;
		metrics.pipeFromMainTurbin = metrics.caveSide +  metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;	// height and some extra 
	}
	
	if (coldExpanderLocation == 'BOTTOM') {
		metrics.pipeToColdExpander = metrics.rCylinder + 20;
		metrics.heightOfColdExpanderIn = (1-chargeLevel) * metrics.hCylinder;
		metrics.heightAboveColdExpanderIn = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdExpanderOut = metrics.hCylinder + chargeLevel * (metrics.hBelow+metrics.hAbove);
		metrics.heightAboveColdExpanderOut = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeFromColdExpander = metrics.rCylinder + metrics.hCylinder + 20;
	}
	else {
		metrics.pipeToColdExpander = metrics.pipeFromColdCompressor; 
		metrics.heightOfColdExpanderIn = metrics.heightOfColdCompressorOut;
		metrics.heightAboveColdExpanderIn = metrics.heightAboveColdCompressorOut;
		metrics.heightOfColdExpanderOut = metrics.heightOfColdCompressorIn; 
		metrics.heightAboveColdExpanderOut = metrics.heightAboveColdCompressorIn; 
		metrics.pipeFromColdExpander = metrics.pipeToColdCompressor;
	}
	metrics.heightOfMainCompressorOut = metrics.heightOfMainTurbinIn;
	metrics.pipeToMainCompressor = metrics.pipeFromMainTurbin;
	metrics.heightOfMainCompressorIn = metrics.heightOfMainTurbinOut;
	metrics.pipeFromMainCompressor = metrics.pipeToMainTurbin;

	// Kartion vaipan pinta-ala = PI * r * s, jossa s = sqrt(r*r + h*h), 
	// Leikatun kartion vaipan apinta.ala = PI * r * s - PI * r2 * s2, jossa r2 ja s2 ovat leikatun kartion säde ja sivun pituus
console.log(JSON.stringify(storageMetrics, null, 2)); 
/*
	if (typeof pRatio === 'undefined' && typeof hpStorageSizeRockMm3 === 'undefined') {
		document.getElementById('pHigh_kPa').value = metrics.pHigh/1000;
		document.getElementById('pLow_kPa').value = metrics.pLow/1000;
		document.getElementById('radius').value = metrics.rCylinder;
		document.getElementById("storageDimensions").text = 
"pHigh: "+Math.round(metrics.pHigh/1000)+" kPa, pLow: "+Math.round(metrics.pLow/1000)+" kPa. Low pressure storage above ground height: "+Math.round(metrics.hAbove)+" m and top radius: "+Math.round(metrics.rTop)
+".<br>Its ground level radius: "+Math.round(metrics.rGround)+" and below ground depth: "+Math.round(metrics.hAbove)
+" m.<br>High pressure storage (cylinder) radius: "+Math.round(metrics.rCylinder)+" m, height: "+Math.round(metrics.hCylinder)+"m and its average density: "+myRound(metrics.hpAverageGravelDensity,2);
console.log("heightBelow="+Math.round(metrics.hBelow));
console.log("heightAbove ground="+Math.round(metrics.hAbove)+" m");
console.log("lowPressure storage height="+Math.round(metrics.hBelow+metrics.hAbove)+" m" );
console.log("highPressureStorageSurfaceArea="+Math.round(metrics.highPressureStorageSurfaceArea));
console.log("lowPressureStorageSurfaceArea="+Math.round(metrics.lowPressureStorageSurfaceArea));
	}
*/
	return metrics;
}	

	function getColdStoragePressureDrop(partOfTotalLength, visc, gasDensity, flow, rActual, p, t) {
		const r = rActual ? rActual : metrics.rCylinder;
		const x1 = flow / (r * r * Math.PI);
		const L1 = (metrics.hBelowActual+metrics.hAbove)*partOfTotalLength;
		return calcPressureDropInGravel('Lp', x1, visc, gasDensity, L1, p, t );
/*
		const porosity = 1 - metrics.hpAverageGravelDensity/metrics.rockDensity;	// free space in gravel between 0-1
		const Re = gasDensity * x1 * 0.015 / (visc*porosity);
//console.log("Reynold's number in low pressure storage:"+Re);
		// Darcy's law: deltaP = L*Q*visc/(-k*A);	
		return L1 * visc/0.000018*(1927*x1*x1+324*x1)*gasDensity/1.2;	// scale air deinity 1.2 kg/m3 to the actual density
*/
	}
	function getHotStoragePressureDrop(partOfTotalLength, visc, gasDensity, flow, rActual, p, t) {
		const r = rActual ? rActual : (partOfTotalLength > 0.5 ? (metrics.dome.rTopI+2*metrics.dome.rBottomI)/3 : (metrics.dome.rTopI*2+metrics.dome.rBottomI)/3);  // worst case
		const L1 = metrics.dome.hBottomI*partOfTotalLength;
		const x1 = flow / (r * r * Math.PI);
		return calcPressureDropInGravel('Hp', x1, visc, gasDensity, L1, p, t );
/*
		const porosity = 1 - metrics.gravelDensity/metrics.rockDensity;	// free space in gravel between 0-1
		const Re = gasDensity * x1 * 0.003 / (visc*porosity);
console.log("Reynold's number in high pressure storage:"+Re);
		// Darcy's law: deltaP = L*Q*visc/(-k*A);	
		return L1 * visc/0.000018*(3342*x1*x1+305*x1)*gasDensity/1.2;	// scale air density 1.2 kg/m3 to the actual density
*/
	}
	function getPipePressureDrop(visc, density, flow, diameter, length, height, heightAbove, densityAbove ) {
		const epsilon = getFloatParam("epsilon", 0.025); 	// for steel, structural or forged (0.0025 drawn tube, but pipe diameter is too big for that
		flow = flow / metrics.cUnits;
		const speed = flow / (Math.PI*diameter*diameter/4);
		// Renolds number: 
		const Re = density*speed*diameter / visc;	// Reinolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
		// Darcy–Weisbach friction factor by Tkachenko, Mileikovskyi 2020 for 2320 <= Re <= 1000000000
		const A0 = -0.79638*Math.log(epsilon/(diameter*8.208) + 7.3357/Re);
		const A1 = Re*(epsilon/diameter) + 9.3120665*A0;
		const f = Math.pow((8.128943+A1)/(8.128943*A0-0.86859209*A1*Math.log(A1/(3.7099535*Re))), 2);
if (height) console.log( "9.81*"+density+"*"+height+"="+ (9.81*density*height));
if (densityAbove) console.log("9.81*"+densityAbove+"*"+heightAbove+"="+(9.81*densityAbove*heightAbove));

		// Pressure drop with Darcy–Weisbach friction factor f:  
		return f*length/diameter*density*Math.pow(speed,2)/2  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
			   + (height ? 9.81*density*height : 0) 		//	Head-loss form: deltaP=g*density*height 
			   - (densityAbove ? 9.81*densityAbove*heightAbove : 0);
	}
	function getHeadLossPT( p, t, height ) {
		const density = Module.PropsSI('D', 'P', p, 'T', t, name);
		return 9.81*density*height;
	}
	function getHeadLoss( density, height ) {
		return 9.81*density*height;
	}
	
	function getPipeDiameterAndPressureDrop(visc, flow, density, length, maxPressureDrop, pipeDiameter, maxSpeed)  { // height, heightAbove, densityAbove, )
		// Heuristic search of pipe diameter and pressure drop for a turbulent flow in a steel pipe having the diameter a few meters
		flow = flow / metrics.cUnits;
		const epsilon = getFloatParam("epsilon", 0.025); 	// for steel, structural or forged (0.0025 drawn tube, but pipe diameter is too big for that
		var deltaP;
		var diameter = pipeDiameter ? pipeDiameter : 4;	// start with 2m
		if (maxSpeed) {
			diameter = Math.pow(flow*4/(Math.PI * maxSpeed), 0.5);
		}
//console.log("flow="+flow+", maxSpeed="+maxSpeed+", diameter="+diameter+", pipeDiameter="+pipeDiameter);
		var prevDiameter = 2;
		{
			var loop
			for (loop = 1; loop < 50; loop++) {
				const speed = flow / (Math.PI*diameter*diameter/4);
				// Renolds number: 
				const Re = density*speed*diameter / visc;	// Reinolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
				// Darcy–Weisbach friction factor by Tkachenko, Mileikovskyi 2020 for 2320 <= Re <= 1000000000
				const A0 = -0.79638*Math.log(epsilon/(diameter*8.208) + 7.3357/Re);
				const A1 = Re*(epsilon/diameter) + 9.3120665*A0;
				const f = Math.pow((8.128943+A1)/(8.128943*A0-0.86859209*A1*Math.log(A1/(3.7099535*Re))), 2);
				// Pressure drop with Darcy–Weisbach friction factor f:  
				deltaP=f*length/diameter*density*Math.pow(speed,2)/2;  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
				if (pipeDiameter) break; // the diameter is already set by the charge loop
	//console.log(loop+":diameter="+diameter+", length="+length+"=> deltaP="+deltaP);
				if (Math.round(deltaP) == maxPressureDrop) break;
				else if (deltaP < maxPressureDrop) {
					if (maxSpeed) break;
					if ((maxPressureDrop-deltaP)/maxPressureDrop < 0.2) break;
				}
				diameter = diameter * Math.pow(deltaP/ maxPressureDrop,1/4);	// 
			}
		}
		var ret = {};
//if (height) console.log( "9.81*"+density+"*"+height+"="+ (9.81*density*height));
//if (densityAbove) console.log("9.81*"+densityAbove+"*"+heightAbove+"="+(9.81*densityAbove*heightAbove));
		ret.maxPressureDrop = maxPressureDrop;
		ret.pressureDrop = deltaP;
				   //+ (height ? 9.81*density*height : 0) 		//	Head-loss form: deltaP=g*density*height 
				   //- (densityAbove ? 9.81*densityAbove*heightAbove : 0)
				   ;
		ret.diameter = diameter;
		ret.flow = flow;
		ret.speed = flow / (diameter*diameter*Math.PI/4);
//console.log(loop+": ret="+JSON.stringify(ret));
		return ret;
	}

	function calcDiagrams() {
		metrics = {};
		//const cEfficiencyFrom = getFloatParam('cEfficiencyFrom', 0.87);
		//const cEfficiencyTo = getFloatParam('cEfficiencyTo', 0.93);
		const tEfficiencyFrom = getFloatParam('tEfficiencyFrom', 0.87);
		const tEfficiencyTo = getFloatParam('tEfficiencyTo', 0.93);
console.log("tEfficiencyTo="+tEfficiencyTo);
		const pRatioFrom = getIntParam('pRatioFrom', 10);
		const pRatioTo = getIntParam('pRatioTo', 50);
		const hpStorageSizeFrom = getFloatParam('hpStorageSizeFrom', 10);
		const hpStorageSizeTo = getFloatParam('hpStorageSizeTo', 50);
		const tHighFrom = getIntParam('tHighFrom', 800);
		const tHighTo = getIntParam('tHighTo', 900);
		const cryogenicCooling = true; // getBooleanParam('cryogenicCooling');
		const adjustedCompressorPlow = false; //getBooleanParam('adjustedCompressorPlow');

		const tEfficiency= getFloatParam('tEfficiency', 0.92);
		const cEfficiency= getFloatParam('cEfficiency', 0.92);

		const tHigh = getFloatParam('tHigh', 1033);
		const tLow = getFloatParam('tLow', 273);
		//const pHigh = getFloatParam('pHigh_kPa', 2500) *  1000;
		//const pLow = getFloatParam('pLow_kPa', 100) * 1000;
		
		if (!getMetrics()) {
			return;
		}
		const pHigh = metrics.pHigh;
		const pLow = metrics.pLow;
	
		var xVals, bottomLines, arrayOfyVals, yTitles, topTitle;
		xVals = [], bottomLines = [], arrayOfyVals = [], yTitles =  [];
		yTitles.push("€/kWh");
		bottomLines.push("Cost of storage €/kWh");
		yTitles.push("€/kW");
		bottomLines.push("Cost of capasity €/kW");
		yTitles.push("%");
		bottomLines.push("Discharged as electricity %");
		yTitles.push("TWh");
		bottomLines.push("Stored electricity TWh");
		bottomLines.push("Stored District heat TWh");
		bottomLines.push("Extra available District heat above 50°C TWh");
		
		var extra = [];
		var extra2 = [];
		if (document.getElementById('tEffRange').checked)
		{																																																																																			
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			var eff = tEfficiencyFrom;
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			xVals = [];
			while ((eff - tEfficiencyTo)<0.01) {
				var hotCycle = []
				var coldCycle = []
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, eff, eff, cryogenicCooling, adjustedCompressorPlow, false, eff, eff );
				xVals.push(eff);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				eff += 0.01;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
//console.log("extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram0', xVals, '', arrayOfyVals, yTitles, "1. Turbin and Compressor stage efficiency from "+tEfficiencyFrom+" to "+tEfficiencyTo
					+", tHigh:"+tHigh+" K, pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
						(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million ton", bottomLines );
			document.getElementById('tEffRange').checked = false;
		}

		if (document.getElementById('tHighRange').checked)
		{
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			var t = tHighFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			while (t <= tHighTo) {
				var hotCycle = []
				var coldCycle = []
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, t, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(t);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				t += 50;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
console.log(xVals.length+"="+extra.length+"="+extra2.length+", extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram1', xVals, 'K', arrayOfyVals, yTitles, "2. Hot storage temperature from "+tHighFrom+" K to "+tHighTo+" K"
					+", pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million ton", bottomLines );
			document.getElementById('tHighRange').checked = false;
		}
		var p;
		if (document.getElementById('pRatioRange').checked)
		{
			p = pRatioFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			xVals = [];
			extra = [];
			extra2 = [];
			xVals = [];
			var sizeFrom = 0;
			var log = '';
			pLowParam = "pLowPressureRatio";
			while (p <= pRatioTo) {
				var hotCycle = []
				var coldCycle = []
				metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
				metrics = getMetrics(p);
				if (!metrics) return;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, metrics.pHigh, metrics.pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				if (!sizeFrom) sizeFrom = Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000);
				xVals.push(p);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
//log += "pRatio:"+p+", size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+"\n";
				if (p == pRatioTo) break;
				p *= 1.15;
				if (p > pRatioTo) p = pRatioTo;
			}
			pLowParam = null;
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
//console.log("xVals="+JSON.stringify(xVals));
//console.log("arrayOfyVals="+JSON.stringify(arrayOfyVals));
			const sizeTo = Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000);
			drawDiagram4Y( 'diagram2', xVals, 'pHigh/pLow', arrayOfyVals, yTitles, "3. High/Low pressure ratio from "+pRatioFrom+" to "+pRatioTo
					+", tHigh:"+tHigh+" K, pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+(sizeTo != sizeFrom ? (sizeFrom+" - "+sizeTo) : sizeTo)+" million ton", bottomLines );
			metrics = {};
			document.getElementById('pRatioRange').checked = false;
//console.log(log);
		}
		if (document.getElementById('hpStorageSize').checked)
		{
			p = hpStorageSizeFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			pLowParam = "pLowStorageSize";
			while (p <= hpStorageSizeTo) {
				var hotCycle = []
				var coldCycle = []
				metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
				if (!getMetrics(null, p)) return;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, metrics.pHigh, metrics.pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(p);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(null);
				arrayOfyVals[2].push(null);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				p += 2;	// increment by 500 000 m3
				document.getElementById('hpStorageSize').checked = false;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
			drawDiagram4Y( 'diagram3', xVals, 'Mm3', arrayOfyVals, yTitles, "4. Hot storage size from "+hpStorageSizeFrom+" to "+hpStorageSizeTo+" Mm3"
					+", tHigh:"+tHigh+" K, pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa", bottomLines );
			pLowParam = null;
			metrics = {};
		}
		if (document.getElementById('dischargeMassFlowRange').checked)
		{
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			const dischargeMassFlowFrom = getFloatParam('dischargeMassFlowFrom', 600);
			const dischargeMassFlowTo = getFloatParam('dischargeMassFlowTo', 6000);
			var t = dischargeMassFlowFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			while (t <= dischargeMassFlowTo) {
				var hotCycle = []
				var coldCycle = []
				dischargeMassFlowValue = t;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(t);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				t += 400;
			}
			dischargeMassFlowValue = null;
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
console.log(xVals.length+"="+extra.length+"="+extra2.length+", extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram4', xVals, 'MW', arrayOfyVals, yTitles, "5. Main turbins mass flow from "+dischargeMassFlowFrom+" kg to "+dischargeMassFlowTo+" kg"
					+", pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million ton", bottomLines );
			document.getElementById('dischargeMassFlowRange').checked = false;
		}
	}
	function getActualTempAtP( t, pFrom, pTo ) {
		const h = Module.PropsSI('H', 'P', pFrom, 'T', t, name);
		return Module.PropsSI('T', 'P', pTo, 'H', h, name);
	}

	function getEnergyLevelChangeOf1000KgGasFlow( hotCompressor, coldCompressor ) 
	{
			var tc = {};
			// The volume changing the temperature in second for 1000kg mass flow in high pressure storage
			tc.hpGravelVolume = (hotCompressor.hOut - coldCompressor.hOut) / 
				(1000*metrics.gravelDensity*getAverageRockHeatCapasitykJinKg(coldCompressor.tOut,hotCompressor.tOut)*(hotCompressor.tOut-coldCompressor.tOut));
			tc.hpGravelWeight = tc.hpGravelVolume * metrics.gravelDensity;
			tc.hpGasVolume = tc.hpGravelVolume *(metrics.rockDensityHp-metrics.gravelDensity)/metrics.rockDensityHp;
			tc.hpGasCharged = tc.hpGasVolume * hotCompressor.dOut;
			tc.hpGasDischarged = tc.hpGasVolume * coldCompressor.dOut;
			tc.hpStorageChange = tc.hpGasVolume * (coldCompressor.dOut - hotCompressor.dOut);
			// We must assume, that extra heat of turbin out will sooner or later cooled to compressor in temperature, BUT low pressure may rise until then!!!
			tc.lpGravelVolume = (hotCompressor.hIn - coldCompressor.hIn) / 
				(1000*metrics.lpGravelDensity*getAverageRockHeatCapasitykJinKg(coldCompressor.tIn,hotCompressor.tIn)*(hotCompressor.tIn-coldCompressor.tIn));
			tc.lpGravelWeight =  tc.lpGravelVolume * metrics.lpGravelDensity;
			tc.lpGasVolume = tc.lpGravelVolume*(metrics.rockDensityLp-metrics.lpGravelDensity)/metrics.rockDensityLp;
			tc.lpGasDischarged = tc.lpGasVolume * hotCompressor.dIn;
			tc.lpGasCharged = tc.hpGasDischarged + tc.lpGasDischarged - tc.hpGasCharged;	
			tc.lpDensityCharged = tc.lpGasCharged / tc.lpGasVolume;
			// actualDensity = x * dLiquid + (1-x) * dGas 
			// => x = (actualDensity - dGas) / (dLiquid - dGas);
			tc.dLiq = Module.PropsSI('D', 'T', coldCompressor.tIn, 'Q', 0, name);
			tc.dGas = Module.PropsSI('D', 'T', coldCompressor.tIn, 'Q', 1, name);
			tc.maxPartLiquid = (tc.lpDensityCharged - tc.dGas)/(tc.dLiq - tc.dGas);
			
			tc.lpStorageChange = tc.lpGasVolume * (hotCompressor.dIn - coldCompressor.dIn);
			tc.changeKg = tc.hpStorageChange + tc.lpStorageChange;
console.log("tc="+JSON.stringify(tc, null, 2));
			return tc;
	}

	function doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, showLog, ctEfficiency, ccEfficiency )
	{
		const metrics = getMetrics();
		if (!metrics) return;
		if (typeof ctEfficiency === 'undefined') ctEfficiency= getFloatParam('tLowEfficiency', tEfficiency);
		if (typeof ccEfficiency === 'undefined') ccEfficiency= getFloatParam('cLowEfficiency', cEfficiency);
		const dischargeMassFlow = dischargeMassFlowValue ? dischargeMassFlowValue : getFloatParam('dischargeMassFlow', 2000);
		const maxPressureDrop = getFloatParam('maxPressureDrop', 0.01);
		const maxOutSpeed = getFloatParam('maxMainTurbinOutSpeed', 100);  // 20 m/s=> kinetic energy 0.025%, 30=>~0.055%, 40m/s=>0.1%
		const powerAndHeat = metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false );
/*
		metrics.pipeToColdExpander = metrics.pipeFromColdCompressor; 
		metrics.heightOfColdExpanderIn = metrics.heightOfColdCompressorOut;
		metrics.heightAboveColdExpanderIn = metrics.heightAboveColdCompressorOut;
		metrics.heightOfColdExpanderOut = metrics.heightOfColdCompressorIn; 
		metrics.heightAboveColdExpanderOut = metrics.heightAboveColdCompressorIn; 
		metrics.pipeFromColdExpander = metrics.pipeToColdCompressor;
	metrics.heightOfMainCompressorOut = metrics.heightOfMainTurbinIn;
	metrics.pipeToMainCompressor = metrics.pipeFromMainTurbin;
	metrics.heightOfMainCompressorIn = metrics.heightOfMainTurbinOut;
	metrics.pipeFromMainCompressor = metrics.pipeToMainTurbin;
*/
		const pLowInCompressor = pLow;
		var pHighInTurbin = pHigh*(1-maxPressureDrop)+getHeadLossPT(pHigh, tHigh, metrics.heightOfMainTurbinIn) ;
		var tHighActual = getActualTempAtP( tHigh, pHigh, pHighInTurbin );
		if (!powerAndHeat) {
			const testMainCompressor = doAdiabaticProcessWithS( name, pHigh, pLow, tHighActual, 1/cEfficiency,showLog ? "Hot compressor TEST" : null );
			const testMainTurbin = doAdiabaticProcessWithS( name, pHigh, pLow/4, tHighActual, tEfficiency, showLog ? "Hot turbin TEST" : null, null, testMainCompressor.tIn );
			pLow = metrics.pLow = testMainTurbin.pOut;
			metrics.pLowCompressor = pLowInCompressor;
		}
		else {
			metrics.pLowCompressor = 0;
		}
		var pHighFromCompressor = pHigh*(1+maxPressureDrop)+getHeadLossPT(pHigh, tHigh, metrics.heightOfMainTurbinIn);
		var pLowInTurbin = generatorLocation == 'TOP' || generatorLocation == 'GROUND' ? pLow : pLow * (1-maxPressureDrop);	// we do not know out density yet???
		var mainTurbin = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin, tHighActual, tEfficiency, showLog ? "Hot turbin" : null );

		if (generatorLocation != 'TOP' && generatorLocation != 'GROUND') {
			pLowInTurbin = (pLow + getHeadLoss(mainTurbin.dOut, metrics.heightOfMainTurbinOut)) * (1-maxPressureDrop);
			mainTurbin = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin, tHighActual, tEfficiency, showLog ? "Hot turbin" : null );
		}
		const turbinMassFlow = dischargeMassFlow/1000; // grossWorkOut*1000/mainTurbin.workProduced;
		mainTurbin.massFlow = turbinMassFlow;

		//  Main turbin process producing the gross electricity
		hotCycle.push(mainTurbin)
		const compressorMassFlow = powerAndHeat ? turbinMassFlow/1.255 : turbinMassFlow/1.142;/// APPROXIMATION TO CALC THE PRESSURE DROPS!!!
		// Main charge process, the compression from warm pLow => hot pHigh calculated as reverse turbin, because we we know only the high temperature
		if (true) { //cryogenicCooling) {
			var mainCompressor = doAdiabaticProcessWithS( name, pHighFromCompressor, pLowInCompressor, tHighActual, 1/cEfficiency,showLog ? "Hot compressor" : null, null, powerAndHeat ? null : mainTurbin.tOut )
			mainCompressor.massFlow = compressorMassFlow;
			hotCycle.push(mainCompressor)

			// First the rough approximations of cold expansion and compression 
			const tSatInMinP = Module.PropsSI('T', 'P', pLowInCompressor, 'Q', 0, name);
			var coldExpander = doAdiabaticProcessWithS( name, pLowInCompressor, pHigh, tSatInMinP+0.1, 1/ctEfficiency, showLog ? "Cold turbin" : null);
			coldExpander.massFlow = compressorMassFlow;
			var coldCompressor = doAdiabaticProcessWithS( name, pLow, pHigh, tSatInMinP+0.1, ccEfficiency, showLog ? "Cold compressor" : null); //, null, null, coldExpander.tIn );
			coldCompressor.massFlow = turbinMassFlow;

			var dischargePDrops = {};
/*  
The first version produced bullshit:
  "diameterPipeToColdCompressor": 0.07152092219983532,
  "diameterPipeFromColdCompressor": 142.74082452368916,
  "diameterPipeToHotTurbin": 0.04853111548244174,
*/
			var ret = getPipeDiameterAndPressureDrop( coldCompressor.viscIn, coldCompressor.flowIn*coldCompressor.massFlow, coldCompressor.dIn, 
													 metrics.pipeToColdCompressor, maxPressureDrop*coldCompressor.pIn,  0, 25);
			coldCompressor.diameterIn = ret.diameter;
			dischargePDrops.diameterPipeToColdCompressor = ret.diameter;
			dischargePDrops.speedInPipeToColdCompressor = ret.speed;
			dischargePDrops.toColdCompressor = ret.pressureDrop 
											  + getHeadLoss( coldCompressor.dIn, metrics.heightOfColdCompressorIn )
											  + getHeadLoss( mainCompressor.dIn, metrics.heightAboveColdCompressorIn );
			
			// getPipeDiameterAndPressureDrop(visc, flow, density, length, maxPressureDrop,height, heightAbove, densityAbove, pipeDiameter, maxSpeed)
			ret = getPipeDiameterAndPressureDrop( coldCompressor.viscOut, coldCompressor.flowOut*coldCompressor.massFlow, coldCompressor.dOut, 
															metrics.pipeFromColdCompressor, maxPressureDrop*coldCompressor.pOut, 0, 25);
			coldCompressor.diameterOut = ret.diameter;
			dischargePDrops.diameterPipeFromColdCompressor = ret.diameter;
			dischargePDrops.speedInPipeFromColdCompressor = ret.speed;
			dischargePDrops.fromColdCompressor = ret.pressureDrop
											  + getHeadLoss( coldCompressor.dOut, metrics.heightOfColdCompressorOut )
											  + getHeadLoss( mainCompressor.dOut, metrics.heightAboveColdCompressorOut );

			ret = getPipeDiameterAndPressureDrop( mainTurbin.viscIn, mainTurbin.flowIn*mainTurbin.massFlow, mainTurbin.dIn, 
     											  metrics.pipeToMainTurbin, maxPressureDrop*pHigh);
			mainTurbin.diameterIn = ret.diameter;
			dischargePDrops.diameterPipeToHotTurbin = ret.diameter;
			dischargePDrops.speedInPipeToHotTurbin = ret.speed;
			dischargePDrops.toMainTurbin = ret.pressureDrop
											  + getHeadLoss( mainTurbin.dIn, metrics.heightOfMainTurbinIn )

			ret = getPipeDiameterAndPressureDrop( mainTurbin.viscOut, mainTurbin.flowOut*mainTurbin.massFlow, mainTurbin.dOut, 
     											  metrics.pipeFromMainTurbin, 
												  // we have to decrease the allowed pressure drpm, because out pipe may be very short => out speed 160 m/s => 2% efficiency drop
												  maxPressureDrop/10*pLow);
			if (ret.speed > maxOutSpeed) {  //  && name!='Hydrogen' && name!='Helium'
				ret = getPipeDiameterAndPressureDrop( mainTurbin.viscOut, mainTurbin.flowOut*mainTurbin.massFlow, mainTurbin.dOut, 
													  metrics.pipeFromMainTurbin, 
													  maxPressureDrop/10*pLow, 0, maxOutSpeed);
			}
			mainTurbin.diameterOut = ret.diameter;
			dischargePDrops.diameterPipeFromHotTurbin = ret.diameter;
			dischargePDrops.speedInPipeFromHotTurbin = ret.speed;
			dischargePDrops.fromMainTurbin = ret.pressureDrop
										  + getHeadLoss( mainTurbin.dOut, metrics.heightOfMainTurbinOut )

			dischargePDrops.inColdStorage = getColdStoragePressureDrop(0.45, coldCompressor.viscIn, coldCompressor.dIn, coldCompressor.flowIn*coldCompressor.massFlow, metrics.rGroundBelowActual, 
												pLow, coldCompressor.tIn) +
											// most of distance mainCompressor dIn and viscIn applies: 
										   getColdStoragePressureDrop(0.55, mainCompressor.viscIn, mainCompressor.dIn, mainTurbin.flowOut*mainTurbin.massFlow, 
												(metrics.rGround+3*metrics.rTop)/4, 
												pLow, mainCompressor.tIn);
			dischargePDrops.inHotStorage = getHotStoragePressureDrop(0.7, coldCompressor.viscOut, coldCompressor.dOut, coldCompressor.flowOut*coldCompressor.massFlow, 
												(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3, 
												pHigh, coldCompressor.tOut) +	// approximation
										  getHotStoragePressureDrop(0.3, mainTurbin.viscIn, mainTurbin.dIn, mainTurbin.flowIn*mainTurbin.massFlow,
												(9*metrics.dome.rTopI+3*metrics.dome.rBottomI)/12, 
												pHigh, mainCompressor.tOut);	
console.log("dischargePDrops:"+JSON.stringify(dischargePDrops, null, 2));
			metrics.dischargePDrops = dischargePDrops;
			var chargePDrops = {};
			// same pipes, main turbin flow is bigger, so the discharge flow defines the pipe diameters
			chargePDrops.diameterPipeFromColdExpander = dischargePDrops.diameterPipeToColdCompressor;
			chargePDrops.diameterPipeToColdExpander = dischargePDrops.diameterPipeFromColdCompressor;
			chargePDrops.diameterPipeFromHotCompressor = dischargePDrops.diameterPipeToHotTurbin;
			mainCompressor.diameterOut = chargePDrops.diameterPipeFromHotCompressor;
			chargePDrops.diameterPipeToHotCompressor = dischargePDrops.diameterPipeFromHotTurbin;
			mainCompressor.diameterIn = chargePDrops.diameterPipeToHotCompressor;
			chargePDrops.inColdStorage = getColdStoragePressureDrop(0.55, mainCompressor.viscIn, mainCompressor.dIn, mainCompressor.flowIn*mainCompressor.massFlow,
												(metrics.rGround+3*metrics.rTop)/4,
												pLow, mainCompressor.tIn)+
										 getColdStoragePressureDrop(0.45, coldExpander.viscOut, coldExpander.dOut, coldExpander.flowOut*coldExpander.massFlow, 
												metrics.rGroundBelowActual, pLow, coldCompressor.tIn);
			chargePDrops.inHotStorage = getHotStoragePressureDrop(0.7, coldCompressor.viscOut, coldCompressor.dOut, coldCompressor.flowOut*coldCompressor.massFlow,
												(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3,
												pHigh, coldCompressor.tOut) +	// approximation
										getHotStoragePressureDrop(0.3, mainCompressor.viscIn, mainCompressor.dIn, mainCompressor.flowIn*mainCompressor.massFlow,
												(9*metrics.dome.rTopI+3*metrics.dome.rBottomI)/12,
												pHigh, mainCompressor.tOut);	
			ret = getPipeDiameterAndPressureDrop( coldExpander.viscIn, coldExpander.flowIn*coldExpander.massFlow, coldExpander.dIn,
     											  metrics.pipeToColdExpander, maxPressureDrop*pHigh, chargePDrops.diameterPipeToColdExpander);
			coldExpander.diameterIn = ret.diameter;
			chargePDrops.diameterPipeToColdExpander = ret.diameter;
			chargePDrops.speedInPipeToColdExpander = ret.speed;
			chargePDrops.toColdExpander = ret.pressureDrop
										  + getHeadLoss( coldExpander.dIn, metrics.heightOfColdExpanderIn )
										  + getHeadLoss( mainTurbin.dIn, metrics.heightAboveColdExpanderIn );

																		
			// coldCompressor out values apply to the cold side of high pressure storage
			ret = getPipeDiameterAndPressureDrop( coldExpander.viscOut, coldExpander.flowOut*coldExpander.massFlow, coldExpander.dOut,
     											  metrics.pipeFromColdExpander, maxPressureDrop*pLowInCompressor, chargePDrops.diameterPipeFromColdExpander);
			coldExpander.diameterOut = ret.diameter;
			chargePDrops.diameterPipeFromColdExpander = ret.diameter;
			chargePDrops.speedInPipeFromColdExpander = ret.speed;
			chargePDrops.fromColdExpander = ret.pressureDrop
										  + getHeadLoss( coldExpander.dOut, metrics.heightOfColdExpanderOut )
										  + getHeadLoss( mainTurbin.dOut, metrics.heightAboveColdExpanderOut );

			ret = getPipeDiameterAndPressureDrop( mainCompressor.viscOut, mainCompressor.flowOut*mainCompressor.massFlow,  mainCompressor.dOut,
       											  metrics.pipeToMainTurbin, maxPressureDrop*pHigh, mainCompressor.diameterOut );
			chargePDrops.speedInPipeFromMainCompressor = ret.speed;
			chargePDrops.fromMainCompressor = ret.pressureDrop
											  + getHeadLoss( mainCompressor.dOut, metrics.heightOfMainCompressorOut );

			ret = getPipeDiameterAndPressureDrop( mainCompressor.viscIn, mainCompressor.flowIn*mainCompressor.massFlow,  mainCompressor.dIn,
       											  metrics.pipeFromMainTurbin, maxPressureDrop*pLow, mainCompressor.diameterIn );
			chargePDrops.speedInPipeToMainCompressor = ret.speed;
			chargePDrops.toMainCompressor = ret.pressureDrop
											  + getHeadLoss( mainCompressor.dIn, metrics.heightOfMainCompressorIn );
console.log("chargePDrops:"+JSON.stringify(chargePDrops, null, 2));
			metrics.chargePDrops = chargePDrops;
			metrics.dischargePDrops = dischargePDrops;
/*
"rockDensity":2.65,"gravelDensity":2.1,"insGravelDensity":1.6,"rockHeatCapasity":0.8,"hpAverageGravelDensity":2.0019739765394906,*/
			// gas budjet in turbin case: 
			const tc = getEnergyLevelChangeOf1000KgGasFlow( mainCompressor, coldCompressor);
			metrics.maxPartLiquid=tc.maxPartLiquid;
			metrics.lpGasVolume = tc.lpGasVolume;
/*{
	const mainTurbinTest = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin/2, tHighActual, tEfficiency, showLog ? "TEST Hot turbin" : null, null, mainCompressor.tIn );
	const coldCompressorTest = doAdiabaticProcessWithS( name, mainTurbinTest.pOut, pHighInTurbin,  coldCompressor.tIn, ccEfficiency, showLog ? "TEST Cold compressor" : null);
	const dCold = dInTP = Module.PropsSI('D', 'T', mainTurbinTest.tOut, 'P', mainTurbinTest.pOut, name);
	const lpGasVolume = metrics.lpGravelPorosity*metrics.lowPressureStorageVolume;
	const hotDiff = (lpGasVolume*(mainCompressor.dIn-mainTurbinTest.dOut));
	const coldDiff = (lpGasVolume*(coldCompressor.dIn-dCold));
	console.log("Pin/Pout="+(mainTurbinTest.pIn/mainTurbinTest.pOut)+" lpGasVolume="+lpGasVolume+", hotDiff:"+hotDiff+", changeTime:"+(hotDiff/2000)+", coldDiff="+coldDiff+". changeTime:"+(coldDiff/2000));
	//console.log(JSON.stringify(mainTurbinTest,null,0));
}*/


/* cc == tc => tc.changeKg/1000 is the wetness
			var cc = {};
			// we must ignore here all cooled coldExpander in values and use the actuak hp storage values of coldCompressor out !!!
			cc.hpGravelVolume = (hotCycle[1].hOut - coldCompressor.hOut) / (1000*metrics.gravelDensity*metrics.rockHeatCapasity*(hotCycle[1].tOut-coldCompressor.tOut))
			cc.hpGasVolume = cc.hpGravelVolume*(metrics.rockDensity - metrics.gravelDensity)/metrics.rockDensity;
			cc.hpStorageChange = cc.hpGasVolume * (hotCycle[1].dOut - coldCompressor.dOut);
			cc.lpGravelVolume = (hotCycle[1].hIn - coldExpander.hOut) / (1000*metrics.insGravelDensity*metrics.rockHeatCapasity*(hotCycle[1].tIn-coldExpander.tOut));
			cc.lpGasVolume = cc.lpGravelVolume*(metrics.rockDensity-metrics.insGravelDensity)/metrics.rockDensity;
			cc.lpStorageChange = cc.lpGasVolume * (coldExpander.dOut-hotCycle[1].dIn);
			cc.changeKg = cc.lpStorageChange + cc.hpStorageChange;
console.log("cc="+JSON.stringify(cc));
*/
			// What is the required wetness to keep nitrogen in balance: what is the net gas weight change in charge and recharge
			// (should be the same)
			// The calclulated the pressure drops must be adjusted in the cold side pressures
			
			// The cold expander outP > cold compressor inP, but the low pressure cold storage tempreature must be that of compressor. 
			// So we must increase the wetness of cold expander to have the same enthalpy  
			const pLowColdCompressor = pLow - dischargePDrops.inColdStorage - dischargePDrops.toColdCompressor;
			const pHighColdCompressor = pHigh + dischargePDrops.inHotStorage + dischargePDrops.fromColdCompressor;
			const pLowColdExpander = pLowInCompressor + chargePDrops.inColdStorage + chargePDrops.fromColdExpander;
			const pHighColdExpander = pHigh - chargePDrops.inHotStorage - chargePDrops.toColdExpander;

			var wetness = Math.abs(tc.changeKg/1000);		// wetness in discharge!
			const wetnessOfColdExpander = powerAndHeat ? getWetnessOfP2( name, pLowColdCompressor, pLowColdExpander, wetness ) : wetness;
console.log(pLowColdExpander+"+", "+"+pHighColdExpander+", "+wetnessOfColdExpander+", wetness="+wetness);
// 97341.00906709408+ +2473574.4313408597, 0.0033383167053469896, wetness=0.0033383167053469896
			const coldExpander2 = doWetAdiabaticProcessWithS( name, pLowColdExpander, pHighColdExpander, wetnessOfColdExpander, 1/ctEfficiency, showLog ? "Cold turbin" : null);
			coldExpander2.diameterIn = coldExpander.diameterIn;
			coldExpander2.diameterOut = coldExpander.diameterOut;
			coldExpander = coldExpander2;
			coldExpander2.items[0].wetness = wetnessOfColdExpander;	// 1st because in reversed order!
			coldExpander2.wetness = wetnessOfColdExpander;
			
			var tCooled = 0;
			if (!powerAndHeat) {
				wetness = getWetnessOfP2( name, pLowColdExpander, pLowColdCompressor, wetness );
				if (wetness == 0) {
					tCooled = Module.PropsSI('T', 'P', pLowColdCompressor, 'H', coldExpander2.hOut, name);
				}
console.log("Cold compressor tIn: "+coldExpander2.tOut+"=>"+tCooled+", wetness="+wetness );
			}
			const coldCompressor2 = tCooled ? 
				doAdiabaticProcess( name, pLowColdCompressor, pHighColdCompressor, coldExpander2.hOut, ccEfficiency, showLog ? "Cold compressor" : null) :
				//doAdiabaticProcessWithS( name, pLowColdCompressor, pHighColdCompressor, tCooled, ccEfficiency, showLog ? "Cold compressor" : null) :
				doWetAdiabaticProcessWithS( name, pLowColdCompressor, pHighColdCompressor, wetness, ccEfficiency, showLog ? "Cold compressor" : null); //, null, null, coldExpander.tIn );
			coldCompressor2.diameterIn = coldCompressor.diameterIn;
			coldCompressor2.diameterOut = coldCompressor.diameterOut;
			coldCompressor2.wetness = wetness;
			coldCompressor = coldCompressor2;
			coldCompressor2.items[0].wetness = wetness;
			coldExpander2.massFlow = compressorMassFlow;
			coldCompressor2.massFlow = turbinMassFlow;
			coldCycle.push(coldCompressor2); 
			coldCycle.push(coldExpander2);
			// TBD: The pressure drop in pipe does not change the enthalpy.  There is probably a small change in temperature, but we ignore it for now

//			const testRun = doAdiabaticProcessWithS( name, pHigh, pLow, hotCycle[0].tOut+5, tEfficiency, null);
//			testRun.massFlow = (hotCycle[0].hOut - hotCycle[1].hIn)/(testRun.hIn-testRun.hOut);
//console.log("SecondTurbin: "+JSON.stringify(testRun));

			coldCycle.push(doAdiabaticProcessWithS( name, metrics.heatPumpHighP, metrics.heatPumpHighP/10, coldCycle[0].tOut, ctEfficiency, showLog ? "Heat pump turbin" : null, null, coldExpander.tIn-2 )) // -2 to heat exchanger smaller
			// Heat exchange coldExpander.tOut-2 <=> 
			var heatPumpPin = coldCycle[2].pOut;
			if (!powerAndHeat) {
				// split 
				const pRelSplit = Math.sqrt(metrics.heatPumpHighP/heatPumpPin);
				const pCool = heatPumpPin*pRelSplit;
				const splitOne = doAdiabaticProcessWithS( name, heatPumpPin, pCool, metrics.coolingWaterTemp, ccEfficiency, null );
				const splitTwo = doAdiabaticProcessWithS( name, pCool, metrics.heatPumpHighP, metrics.coolingWaterTemp, ccEfficiency, null );
				splitOne.pRelSplit = pRelSplit;
				coldCycle.push(addCycleDataI( splitOne, splitTwo, showLog ? "Heat pump compressor" : null  ));
			}
			else {
				coldCycle.push(doAdiabaticProcessWithS( name, heatPumpPin, metrics.heatPumpHighP, powerAndHeat ? metrics.heatPumpCompressorTin : metrics.coolingWaterTemp, ccEfficiency, showLog ? "Heat pump compressor" : null ))
			}
//X  TBD:  Laske lämpöpumpun massavirta ja sen h-kerroin x,  teho MW == h * x / 1000, 1 == 1000 kg> 
		}
/*
		else if (adjustedCompressorPlow) {
			hotCycle.push(doAdiabaticProcessWithS( name, pHigh, pLow, tHigh, 1/ccEfficiency, null, hotCycle[0].tOut, showLog ? "Hot compressor" : null))
			const coldExpander = doAdiabaticProcessWithS( name, pHigh, hotCycle[1].pIn, tLow, ctEfficiency, showLog ? "Cold turbin" : null )
			coldCycle.push(doAdiabaticProcessWithS( name, pLow, pHigh, coldExpander.tOut, ccEfficiency ))
			coldCycle.push(coldExpander)
		}
		else {
			hotCycle.push(doAdiabaticProcessWithS( name, pHigh, pLow, tHigh, 1/ccEfficiency,showLog ? "Hot compressor" : null))
			const coldExpander = doAdiabaticProcessWithS( name, pHigh, pLow, tLow, ctEfficiency, showLog ? "Cold turbin" : null )
			coldCycle.push(doAdiabaticProcessWithS( name, pLow, pHigh, coldExpander.tOut, ccEfficiency, showLog ? "Cold compressor" : null ))
			coldCycle.push(coldExpander)
		}
*/		
		const cycleData = {};

		if (cryogenicCooling && coldCycle.length>2) {
			const hAfterCooling = Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[0].tOut-metrics.heatExchangeDeltaT, name);
			const hAfterHeating = Module.PropsSI('H', 'P', metrics.heatPumpHighP, 'T', (powerAndHeat ? metrics.heatPumpCompressorTin : metrics.coolingWaterTemp)+metrics.heatExchangeDeltaT, name);
			const cooling = (coldCycle[0].hOut - coldCycle[1].hIn) * coldCycle[1].massFlow;	// We must use the massFlow in charge!!!
//console.log(cooling+" = "+coldCycle[0].hOut+" * "+coldCycle[0].massFlow+" - "+coldCycle[1].hIn+" * "+coldCycle[1].massFlow);
			cycleData.cooling = cooling;
//console.log("hAfterCooling="+hAfterCooling+" ("+(coldCycle[0].tOut-metrics.heatExchangeDeltaT)+" K,"+coldCycle[2].pOut+")");
/*console.log("coldCycle[3].hIn="+coldCycle[3].hIn+" ("+coldCycle[3].tIn+","+coldCycle[3].pIn+")");
console.log("=="+(coldCycle[3].hIn-hAfterCooling));
console.log("hAfterHeating="+hAfterHeating+" ("+(heatPumpCompressorTin+heatExchangeDeltaT)+","+coldCycle[3].pOut+")");
console.log("- coldCycle[2].hIn="+coldCycle[2].hIn+" ("+coldCycle[2].tIn+","+coldCycle[2].pIn+")");
console.log("=="+(hAfterHeating - coldCycle[2].hIn));*/
			cycleData.internalExtraCooling = (hAfterHeating - coldCycle[2].hIn) - (coldCycle[3].hIn-hAfterCooling);
			coldCycle[2].massFlow = coldCycle[3].massFlow = cooling/(hAfterCooling - coldCycle[2].hOut - cycleData.internalExtraCooling);
			cycleData.heatPumpNetWorkIn = (coldCycle[3].workConsumed-coldCycle[2].workProduced) * coldCycle[2].massFlow/metrics.frequencyConverterEfficiency;
//console.log("***** cycleData.heatPumpNetWorkIn1000="+cycleData.heatPumpNetWorkIn1000+"= "+cycleData.heatPumpNetWorkIn+" / "+coldCycle[1].massFlow);
			cycleData.heatPumpNetWorkIn1000 = cycleData.heatPumpNetWorkIn / coldCycle[1].massFlow;
			cycleData.heatPumpFrequencyConverterLoss1000 = cycleData.heatPumpNetWorkIn1000 * (1-metrics.frequencyConverterEfficiency);
			cycleData.heatPumpHeating = (powerAndHeat ? 1 : 2)*(coldCycle[3].hOut - hAfterHeating) * coldCycle[2].massFlow;
			cycleData.heatPumpHeating1000 = cycleData.heatPumpHeating / coldCycle[1].massFlow;
			cycleData.heatPumpCooling = cooling;
			cycleData.heatPumpHeatExchange = (hAfterHeating - coldCycle[2].hIn) * coldCycle[2].massFlow;
			//cycleData.heatPumpHeatExchange1000 = (cycleData.heatPumpHeatExchange + cooling + cycleData.heatPumpHeating)/ coldCycle[1].massFlow;
//console.log( "Heat pump: mass flow: "+Math.round(coldCycle[2].massFlow*1000)+", hAfterCooling="+hAfterCooling+", coldCycle[2].hOut="+coldCycle[2].hOut);
		}
		else {
			cycleData.cooling = 0;
			cycleData.heatPumpNetWorkIn = 0;
			cycleData.heatPumpHeating = 0;
			cycleData.heatPumpCooling = 0;
			cycleData.heatPumpHeatExchange = 0;
			cycleData.heatPumpNetWorkIn1000 = 0;
		}
		// scale heatPumpNetWorkIn to charge massFlow=1
		cycleData.workConsumed1000 = (hotCycle[1].workConsumed/metrics.gearEfficiency 
									 -coldCycle[1].workProduced*metrics.gearEfficiency*metrics.gearEfficiency) / metrics.generatorEfficiency;
		cycleData.gearLoss1000 = hotCycle[1].workConsumed*(1-metrics.gearEfficiency) + coldCycle[1].workProduced*(1 - metrics.gearEfficiency*metrics.gearEfficiency);
		cycleData.generatorLoss1000 = cycleData.workConsumed1000 * (1-metrics.generatorEfficiency);
//console.log("gearLoss: "+cycleData.gearLoss+" = "+(hotCycle[1].workConsumed*(1 - metrics.gearEfficiency))+" + "+(coldCycle[1].workProduced*(1 - metrics.gearEfficiency*metrics.gearEfficiency)));
		cycleData.workConsumed1000 += cycleData.heatPumpNetWorkIn1000; 	
		cycleData.workProduced1000 = (hotCycle[0].workProduced*metrics.gearEfficiency
									  - coldCycle[0].workConsumed/(metrics.gearEfficiency*metrics.gearEfficiency)) 
									  * metrics.generatorEfficiency;
		cycleData.gearLoss1000 += hotCycle[0].workProduced*(1-metrics.gearEfficiency) + coldCycle[0].workConsumed*(1 - metrics.gearEfficiency*metrics.gearEfficiency); 
//console.log("gearLoss2: "+cycleData.gearLoss+" = "+(hotCycle[0].workProduced*(1-metrics.gearEfficiency))+" + "+(coldCycle[0].workConsumed*(1 - metrics.gearEfficiency*metrics.gearEfficiency)));
		cycleData.generatorLoss1000 += cycleData.workProduced1000 * (1-metrics.generatorEfficiency);
		cycleData.totalLoss1000 = cycleData.heatPumpHeating1000 + cycleData.gearLoss1000 + cycleData.generatorLoss1000 + cycleData.heatPumpFrequencyConverterLoss1000;
		cycleData.efficiency =  cycleData.workProduced1000 / cycleData.workConsumed1000;

		if (motorGenerator) {
			const workProduced0 = hotCycle[0].workProduced * hotCycle[0].massFlow*metrics.gearEfficiency;
			const workConsumed0 = coldCycle[0].workConsumed * coldCycle[0].massFlow/metrics.gearEfficiency;
			const workConsumed1 = hotCycle[1].workConsumed * hotCycle[1].massFlow/(metrics.gearEfficiency*metrics.gearEfficiency);
			const workProduced1 = coldCycle[1].workProduced * coldCycle[1].massFlow*metrics.gearEfficiency*metrics.gearEfficiency;
			const netWorkOut = (workProduced0-workConsumed0)*metrics.generatorEfficiency;
			const netWorkIn = (workConsumed1 - workProduced1)/metrics.generatorEfficiency; // + cycleData.heatPumpNetWorkIn;

			const scaleToTurbinMassFlow = netWorkOut / netWorkIn;
//			const scaleToTurbinMassFlow = ((hotCycle[0].workProduced*metrics.gearEfficiency-coldCycle[0].workConsumed/(metrics.gearEfficiency*metrics.gearEfficiency))*hotCycle[0].massFlow*metrics.generatorEfficiency) //
//				/ ((hotCycle[1].massFlow*(hotCycle[1].workConsumed/metrics.gearEfficiency-coldCycle[1].workProduced*(metrics.gearEfficiency*metrics.gearEfficiency)))/ metrics.generatorEfficiency); //
//console.log("(("+hotCycle[0].workProduced+"-"+coldCycle[0].workConsumed+")*"+hotCycle[0].massFlow+")/("+hotCycle[1].massFlow+"*("+hotCycle[1].workConsumed+"-"+coldCycle[1].workProduced+"))");
//console.log("hotCycle[0].massFlow="+hotCycle[0].massFlow+", hotCycle[1].massFlow="+hotCycle[1].massFlow+", scaleToTurbinMassFlow="+scaleToTurbinMassFlow);
			coldCycle[1].massFlow *= scaleToTurbinMassFlow;
			hotCycle[1].massFlow *= scaleToTurbinMassFlow;
			coldCycle[2].massFlow *= scaleToTurbinMassFlow;
			coldCycle[3].massFlow *= scaleToTurbinMassFlow;
			cycleData.heatPumpNetWorkIn *= scaleToTurbinMassFlow;
			cycleData.heatPumpHeating *= scaleToTurbinMassFlow;
			cycleData.heatPumpCooling *= scaleToTurbinMassFlow;
			cycleData.heatPumpHeatExchange *= scaleToTurbinMassFlow;
console.log("hotCycle[0].massFlow="+hotCycle[0].massFlow+", hotCycle[1].massFlow="+hotCycle[1].massFlow+", scaleToTurbinMassFlow="+scaleToTurbinMassFlow+
			",  coldCycle[0].massFlow="+coldCycle[0].massFlow+", coldCycle[1].massFlow="+coldCycle[1].massFlow+
			",  coldCycle[2].massFlow="+coldCycle[2].massFlow+", coldCycle[2].massFlow="+coldCycle[2].massFlow);
		}
		metrics.insLpSides = metrics.ins*hotCycle[1].tIn/tHigh;

		hotCycle[0].workProduced *= hotCycle[0].massFlow*metrics.gearEfficiency;
		coldCycle[0].workConsumed *= coldCycle[0].massFlow/metrics.gearEfficiency;
		hotCycle[1].workConsumed *= hotCycle[1].massFlow/(metrics.gearEfficiency*metrics.gearEfficiency);
		coldCycle[1].workProduced *= coldCycle[1].massFlow*metrics.gearEfficiency*metrics.gearEfficiency;
		cycleData.totalWork = (hotCycle[1].workConsumed - coldCycle[1].workProduced) + cycleData.heatPumpNetWorkIn;
		cycleData.hotWorkConsumed = hotCycle[1].workConsumed;
		cycleData.netWorkOut = (hotCycle[0].workProduced-coldCycle[0].workConsumed)*metrics.generatorEfficiency;
		cycleData.netWorkIn = (hotCycle[1].workConsumed - coldCycle[1].workProduced)/metrics.generatorEfficiency; // + cycleData.heatPumpNetWorkIn;

		/*
			{"heatPumpCompressorTin":313,"heatExchangeDeltaT":2,"heatPumpHighP":20000000,"r":150,"ins":10,"costOfSurfaceM2":1500,"costOfMiningM3":12,
			"generatorCostOfKW":250,"tcCostOfKW":50,"heCostOfKW":50,"rockDensity":2.65,"gravelDensity":2.1,"insGravelDensity":1.6,"rockHeatCapasity":0.8,
			"V1":6668474.972242486,"totalMiningVolume":13336949.944484971,"hpExpectedAverageDensity":2,"pHighStorageHeight":125,
			"highPressureStorageVolume":6877951.6283572065,"highPressureInsulationMVolume":1957777.7098640874,"hpAverageGravelDensity":1.9892124444444448,
			"V2":2215170.7770067565,"V3":4453304.195235729,"V4":4376186.7005341295,"highPressureStorageSurfaceArea":259181.39392115793,
			"hBelow":71.29999999999998,"hAbove":55.20481933477791,"r2":130.44518066522207,"lowPressureStorageSurfaceArea":318262.12135286065}
		cycleData:{
  "cooling": 49551.11157810138,
  "heatPumpNetWorkIn": 75626.77530681873,
  "heatPumpHeating": 125177.88688492011,
  "heatPumpCooling": 49551.11157810138,
  "heatPumpHeatExchange": 132373.83675519063,
  "efficiency": 0.6606327440961022,
  "totalWork": 709657.4471919491,
  "hotWorkConsumed": 724996.1882342198,
  "netWorkOut": 709657.4471919491,
  "netWorkIn": 634030.6718851303,
  "costOfStorage": 1026208672.2448474,
  "storedElectricity_kWh": null,
  "costOfStorageEkWh": null,
  "costOfPowerKW": 306646249.8139391
}
		*/
		// Heat below 50C cannot be used as District heat
		const hAt323K = Module.PropsSI('H', 'P', hotCycle[1].pIn, 'T', 323, name);
		const hMinDistrictHeat = hotCycle[1].tIn > 323 ? hotCycle[1].hIn : hAt323K;
		cycleData.heatOutInDischarge1000 = (hotCycle[0].hOut- hMinDistrictHeat);
		if (!powerAndHeat || cycleData.heatOutInDischarge1000 < 0) cycleData.heatOutInDischarge1000 = 0;
		cycleData.distictHeatPercent = 100 * (cycleData.heatPumpHeating1000 + cycleData.heatOutInDischarge1000) / cycleData.workConsumed1000;
		cycleData.heatOutInDischarge = cycleData.heatOutInDischarge1000 * hotCycle[0].massFlow;
		cycleData.costOfStorage = metrics.totalMiningVolume * metrics.costOfMiningM3 + (metrics.highPressureStorageSurfaceArea+metrics.lowPressureStorageSurfaceArea)*metrics.costOfSurfaceM2;
		
		// How long it takes to discharge the high pressure storage with gas flow 1000kg* hotCycle[0].massFlow and deltaH = hotCycle[0].hIn - coldCycle[0].hOut;
		cycleData.hpStorageHeatCapacity = 1000*getAverageRockHeatCapasitykJinKg(coldCycle[0].tOut,hotCycle[0].tIn)*metrics.highPressureStorageVolume*1000*metrics.gravelDensity*(hotCycle[0].tIn-coldCycle[0].tOut);
//"dischargeTimeS": 3492.9504982300864, ??????
		cycleData.dischargeTimeS = cycleData.hpStorageHeatCapacity / ((hotCycle[0].hIn - coldCycle[0].hOut) * 1000 * hotCycle[0].massFlow); // 
		cycleData.storedElectricity_kWh = cycleData.netWorkOut * cycleData.dischargeTimeS / 3600;
		cycleData.storedDistrictHeat_kWh = cycleData.heatOutInDischarge * cycleData.dischargeTimeS / 3600;
		cycleData.storedEnergy_kWh = cycleData.storedElectricity_kWh + cycleData.storedDistrictHeat_kWh;
		cycleData.extraAvailableDistrictHeat_kWh = (hAt323K < hMinDistrictHeat ? (hMinDistrictHeat-hAt323K) : 0) * hotCycle[0].massFlow * cycleData.dischargeTimeS / 3600;
		cycleData.costOfStoragekWh = cycleData.costOfStorage / (cycleData.storedElectricity_kWh + cycleData.storedDistrictHeat_kWh);

		if (cryogenicCooling) {
			coldCycle[3].workConsumed = coldCycle[3].workConsumed * coldCycle[2].massFlow;
			coldCycle[2].workProduced = coldCycle[2].workProduced * coldCycle[2].massFlow;
		}
		cycleData.costOfMachineryKW = metrics.generatorCostOfKW + 
			(metrics.tcCostOfKW * (hotCycle[0].workProduced*hotCycle[0].getRelativeSize() + 
								   coldCycle[0].workConsumed*coldCycle[0].getRelativeSize() + 
								   hotCycle[1].workConsumed*hotCycle[1].getRelativeSize() + 
								   coldCycle[1].workProduced*coldCycle[1].getRelativeSize() + 
					(cryogenicCooling ? (coldCycle[3].workConsumed*coldCycle[3].getRelativeSize() + 
										 coldCycle[2].workProduced*coldCycle[2].getRelativeSize()) : 0))  + 
			metrics.heCostOfKW * (cycleData.heatPumpHeating + cycleData.cooling + cycleData.heatPumpHeatExchange + (hotCycle[0].hOut - hotCycle[1].hIn) * hotCycle[0].massFlow))
			/ cycleData.netWorkOut;
console.log("*****"+tHigh+": metrics.otherCostOfKW="+metrics.otherCostOfKW+", cycleData.costOfMachineryKW="+cycleData.costOfMachineryKW);
		cycleData.costOfPowerKW = metrics.otherCostOfKW + cycleData.costOfMachineryKW;
		cycleData.costOfPower = cycleData.costOfMachineryKW * cycleData.netWorkOut;
		cycleData.costOfPlant = metrics.otherCostOfKW * cycleData.netWorkOut;

		if (motorGenerator) {
			cycleData.efficiency = cycleData.netWorkOut/(cycleData.heatPumpNetWorkIn+cycleData.netWorkIn)*hotCycle[1].massFlow/hotCycle[0].massFlow;
		}
		//cycleData.efficiencyOfCapital = cycleData.netWorkOut / cycleData.totalWork;
		// cycleData.kWhPerTonGross = (hotCycle[0].hIn - hotCycle[0].hOut) / 3600;  // h == J/kg = 
		//if (showLog) 
		console.log("cycleData:"+JSON.stringify(cycleData, null, 2));
		return cycleData;
	}
	function getLpExpansion( cycleData, length ) {
		return length * (cycleData.hotCycle[1].tIn-cycleData.coldCycle[1].tOut)/metrics.lpGravelExpansionIn100K;
	}
	
	function getHeatExchangeWidth(tHigh, tLow, p, r, massFlow, gravelMinMM, gravelMaxMM, porosity, deltaT ) 
	{
		// First calculate the area/m3
		var m3A = 0;
		const gravelMax = gravelMaxMM/1000; 
		const gravelMin = gravelMinMM/1000;
		const dStep = (gravelMax - gravelMin)/10;
		const massFlowM2 = massFlow * 1000 / (Math.PI * r * r);
		var pD;
		for (pD = gravelMin; pD<gravelMax; pD += dStep) {
			m3A += (4 * Math.PI * Math.pow( pD/2, 2) / Math.pow(pD,3))	// number of items having that size
					* Math.pow(pD,3)/(4*Math.PI*Math.pow(pD/2,3)/3);	// ignore the porosity of balls
		}
		m3A = (1-porosity)*m3A/10;
		
		// heat transfer in convection:
		// https://www.engineeringtoolbox.com/convective-heat-transfer-d_430.html,  2 b) approximation for dry air, for air flows 2 - 10 m/s)
		var hcAir;  // low end appromiation for air, we scale it to actual density
		const dAir = 1.13;
		const tStep = (tHigh-tLow)/10;
		while (!isFinite(Module.PropsSI('H', 'T', tLow, 'P', p, name))) tLow += 0.1;
		// returns h as J/kg
		const deltaStepQm2 = massFlowM2*(Module.PropsSI('H', 'T', tHigh, 'P', p, name) - Module.PropsSI('H', 'T', tLow, 'P', p, name)) / 10;
		
		var t;
		var width = 0;
		for (t = tHigh; t > tLow; t-= tStep/2) {
			const dInTP = Module.PropsSI('D', 'T', t, 'P', p, name) / dAir;		// scale hcAir to actual density
			const v = massFlowM2 / dInTP;
			// https://pubmed.ncbi.nlm.nih.gov/36074290/
			// The average convective heat and mass transfer coefficients varied between 2.64 and 8.30 W/m2 °C and 0.0025 to 0.0076 m/s for temperature ranges, at the different air velocities, respectively.
			// forced flow
			hcAir = 12.12 - 1.16*v + 11.6*Math.pow(v,0.5);
			// Q = h*A == hcAir*dInTP*m3A*length*deltaT
			// => length = Q/(hcAir*dInTP*m3A*deltaT)
			width += deltaStepQm2 / (hcAir*dInTP*m3A*deltaT);
		}
//console.log( "width="+width+", m3A="+m3A+", massFlowM2="+massFlowM2+", deltaStepQm2="+deltaStepQm2+", deltaT="+deltaT);
//console.log("getHeatExchangeWidth("+tHigh+', '+tLow+', '+p+', '+r+', '+massFlow+', '+gravelMinMM+', '+gravelMaxMM+', '+porosity+', '+deltaT+")="+width); 
		return width;
	}
		
	var traceXY = false;
	var xyLog = '';
	function toX( dg, val ) {
		var ret = dg.baseX ? Math.abs(dg.baseX + val*dg.meterToPixels) 
				: Math.abs(dg.marginX + (dg.cWidth)*(val - dg.minX)/(dg.maxX-dg.minX));
		if (traceXY) xyLog += ', ('+ret;
		return ret;
	}

	function toY( dg, val ) {
		var ret = dg.baseY ? dg.baseY + (dg.cheight - val*dg.meterToPixels) 
			: dg.marginTop + (dg.cheight)*(dg.maxY-val)/(dg.maxY-dg.minY);
		if (traceXY) xyLog += ','+ret+')';
		return ret;
	}
	function minMaxVal( dg, vals, minMax ) {
		if (typeof minMax === 'undefined') {
			minMax = {};
			minMax.min = minMax.max = vals[0];
		}
		var i;
		for (i = 1; i < vals.length; i++) {
			if (vals[i] == null) continue;
			if (vals[i] > minMax.max) minMax.max = vals[i];
			if (vals[i] < minMax.min) minMax.min = vals[i];
		}
		const maxSteps = dg.maxSteps ? dg.maxSteps : 5;
/*
		var diff = minMax.max - minMax.min;
		var multiplier = 1;
		
		for (;;) {
			if (diff < 10) {
				diff *= 10;
				multiplier *= 10;
			}
			else if (diff > 100) {
				diff /= 10;
				multiplier /= 10;
			}
			else {
				break;
			}
		}
		minMax.min = Math.floor(minMax.min * multiplier / 10) / multiplier * 10;
		minMax.max = Math.floor((minMax.max+10) * multiplier / 10) / multiplier * 10;
*/
		minMax.step = (minMax.max - minMax.min) / maxSteps;
		return minMax;
	}
/*

{"heatPumpCompressorTin":313,"heatExchangeDeltaT":2,"heatPumpHighP":20000000,
"r":150,
"ins":10,
"costOfSurfaceM2":1000,
"costOfMiningM3":12,"generatorCostOfKW":250,"tcCostOfKW":50,"heCostOfKW":50,
"rockDensity":2.65,"gravelDensity":2.1,
"insGravelDensity":1.6,
"rockHeatCapasity":0.8,
"hCylinder":94.33962264150944,
"pHighStorageHeight":81.03962264150944,
"V1":6668474.972242486,"hpExpectedAverageDensity":2,
"highPressureStorageVolume":4990032.269549,
"highPressureInsulationMVolume":1678442.7026934854,
"hpAverageGravelDensity":1.9741509333333331,"V2":1700710.4098415514,
"V3":4967764.562400934,
"V4":6076897.110375681,
"totalMiningVolume":11636239.53464342,
"highPressureStorageSurfaceArea":230284.6690414405,
"hBelow":77.67,
"hAbove":91.20424824550723,
"r2":97.63075175449278,
"lowPressureStorageSurfaceArea":340794.56804748066}
*/
	function workToMW( work, units ) {
		return (units ? Math.round(Math.round(work/1000) / units) : Math.round(work/1000))+' MW';
	}
	function toCelsius( t, speed ) {
		return Math.round(t - 273.15)+"\u2103" + (speed ? myRound(speed,2)+' m/s' : ''); 
	}
	function drawStorage( canvasId, metrics, cycleData, bottomLines ) {
		if (metrics.isCylinder) {
			drawCylinderStorage( canvasId, metrics, cycleData, bottomLines );
		}
		else {
			drawConeStorage( canvasId, metrics, cycleData, bottomLines );
		}
	}
	function testResult( expected, from, to, maxError, calcResult ) {
		var min=from, max=to;
		var testValue = (min + max) / 2;
if (typeof testValue === 'undefined' || typeof expected === 'undefined'  || typeof maxError === 'undefined') 
return confirm(loop+":testValue="+testValue+",  min/max:"+min+"/"+max+", expected:"+expected+", maxError"+maxError);
		var loop=0;
		for (;;) {
			var result = calcResult(testValue);
			if (loop > 10 || Math.abs(expected-result)<= maxError) {
if (loop > 10 && Math.abs(expected-result)>maxError) {
	console.trace(loop+":expected="+expected+", result="+result+", testValue="+testValue+", min/max:"+from+"/"+to+", error:"+Math.abs(expected-result));
	return false;
}
//else console.log(loop+":expected="+expected+", result="+result+", testValue="+testValue+", min/max:"+from+"/"+to+", error:"+Math.abs(expected-result));
				return testValue;
			}
			if (result > expected) max = testValue;
			else min = testValue;
			testValue = (min + max) / 2;
			loop++;
		}
	}

	function centerText( ctx, text, xCenterPx, yPx ) {
		ctx.fillText(text,xCenterPx-ctx.measureText(text).width/2, yPx );
	}
	
	function drawConeStorage( canvasId, metrics, cycleData, bottomLines ) {
		const dg = {};
		var gasName = getInputParam('name', 'Nitrogen' ).toLowerCase();
		const canvas = document.getElementById(canvasId);
		const powerAndHeat = metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false );
		
		var title = Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million gravel ton "+Math.round(cycleData.storedEnergy_kWh/1000000)+" GWh / "+workToMW(cycleData.netWorkOut)+" pumped thermal energy storage";
		// let's keep this very simple, set scale 1 m == 2 px, 
		dg.marginX = 30;
		dg.marginTop = (isCone ? 40 : 180) + (title ? 20 : 0);	// for the facility and pipes
		dg.marginBottom = 10 + (bottomLines ? bottomLines.length * 12 : 0);
		dg.meterToPixels = 2;
		const width = (200+metrics.rGround*2)*dg.meterToPixels + dg.marginX; // 280m == space for turbin pictures
		const height = (metrics.hCylinder+metrics.hBelow+metrics.hAbove)*dg.meterToPixels+dg.marginTop+dg.marginBottom;
		canvas.setAttribute("width", width ); 
		canvas.setAttribute("height", height); 
//console.log("width="+width+", height="+height);
		const ctx = canvas.getContext("2d");
		dg.maxX = metrics.rGround*2;
		dg.minX = 0;
		dg.maxY = metrics.hCylinder+metrics.hBelow+metrics.hAbove+metrics.dome.hTop;
		dg.minY = 0;
		dg.baseX = width/2;
		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black';
		dg.ctx = ctx;
		ctx.font = "10px Arial";
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		dg.width = canvas.getAttribute("width");
		dg.cWidth = dg.width - 2 * dg.marginX;
		dg.height = canvas.getAttribute("height");
		dg.cheight = dg.height - dg.marginTop - dg.marginBottom;
		if (title) {
			ctx.font = "16px arial";
			ctx.fillStyle = 'black'; 
			var x = toX(dg,0)-ctx.measureText(title).width/2;
//console.log("x="+x+", title:"+title);			
			if (x < 0) x = 2;
			ctx.fillText(title, x, 20);
		}
		// Start with rock, https://www.w3schools.com/colors/colors_shades.asp
		const colorRock = '#A9A9A9'; //	
		const colorConcrete = '#CCD1D1';	// ligh gray
		const colorInsulation = '#808080'; // gray, 
		const colorHotHpGravel = '#FFFF00'; //#FFCC00'; 
		const colorColdHpGravel = '#66FFFF';
		const colorWarmLpGravel = '#FFCC99'; 
		const colorHotLpGravel = powerAndHeat ? '#FF9900' : colorWarmLpGravel; 
		const colorColdLpGravel = '#6666FF'; 
		const colorLiquidLpGravel = '#0000FF'; 

		// draw first the base rock
		dg.baseY = dg.marginTop;
		const hGround = metrics.hBelow+metrics.hCylinder
		const groundY = toY(dg,hGround);
		
		var region = new Path2D();
		region.moveTo(0, groundY); 
		region.lineTo(dg.width, groundY); 
		region.lineTo(dg.width, dg.height);
		region.lineTo(0, dg.height);
		region.lineTo(0, groundY); 
		region.closePath();
		ctx.fillStyle = colorRock;
		ctx.fill(region);
		$("#"+canvasId).css('display','block');
//console.log("groundY="+groundY+", dg="+JSON.stringify(dg));
		var y, x;
		/*  Simple cylinder
  "hCylinder": 132.49328067269875,
  "hBelow": 65.61992687447108,
  "hAbove": 66.87335379822768,
  "pHighStorageHeight": 119.19328067269875,
  "rCylinder": 126.75594836325249,
  "rGround": 126.75594836325249,
  "rTop": 126.75594836325249, */
		region = new Path2D();
		// Insulation layer
		region.moveTo(toX(dg,-metrics.rGroundBelow),groundY); 
		region.lineTo(toX(dg,-metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		region.lineTo(toX(dg,-metrics.dome.rBottom), toY(dg,0));
		region.lineTo(toX(dg,metrics.dome.rBottom), toY(dg,0));
		region.lineTo(toX(dg,metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		region.lineTo(toX(dg,metrics.rGroundBelow),groundY); 
		region.closePath();
		//ctx.fillStyle = 'white';
		//ctx.fill(region);
		ctx.fillStyle = colorInsulation;
		ctx.fill(region);

		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.rGround),groundY+2); 
		ctx.lineTo(toX(dg,metrics.rGround),groundY+2); 
		ctx.strokeStyle = colorInsulation;
		ctx.lineWidth = 5;
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.rGround),groundY+4); 
		ctx.lineTo(toX(dg,-metrics.rGroundBelow),groundY+4); 
		ctx.lineTo(toX(dg,-metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		ctx.lineTo(toX(dg,-metrics.dome.rBottom), toY(dg,0));
		ctx.lineTo(toX(dg,metrics.dome.rBottom), toY(dg,0));
		ctx.lineTo(toX(dg,metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		ctx.lineTo(toX(dg,metrics.rGroundBelow),groundY+4);
		ctx.lineTo(toX(dg,metrics.rGround),groundY+4);
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 1;
		ctx.stroke();

		// fill partially overwritten warm gravel in the grave dome in the top
/*
		ctx.lineWidth = 1;
		ctx.fillStyle = 'black';
		ctx.moveTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.hAbove+hGround)); 
		ctx.lineTo(toX(dg,0),y = toY(dg,2*metrics.dome.hTop+metrics.hAbove+hGround));
		ctx.lineTo(toX(dg,-metrics.dome.s/2),toY(dg,metrics.hAbove+hGround));
		ctx.stroke();
*/
		if (!isCone) {
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.dome.s/2),toY(dg,metrics.hAbove+hGround));
			region.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			region.closePath();
			ctx.fillStyle = colorWarmLpGravel;
			ctx.fill(region);
		}
		const freeSpaceOnTop = 0;
		var roofInsulation = metrics.insLpSides; // 1.5 * /metrics.ins; // scale the gravel mix to ordinary insulation and add 50%
		if (roofInsulation<2) roofInsulation = 2;
		const xyAddRoof = (freeSpaceOnTop+roofInsulation);
		const xyAddRoofInsulation = (freeSpaceOnTop+roofInsulation/2); // only half, because it is a line
//console.log("roofInsulation="+roofInsulation+", xyAddRoof="+xyAddRoof+", xyAddRoofInsulation="+xyAddRoofInsulation+", metrics.insLpSides="+metrics.insLpSides);
		// roof insulation
		const pxRoofInsulation = roofInsulation * dg.meterToPixels;
		ctx.lineWidth = pxRoofInsulation;
		ctx.beginPath();
		if (metrics.externalEclosure) {
			if (isCone) {
				ctx.moveTo(toX(dg,-metrics.rTop-1+metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
				ctx.lineTo(toX(dg,metrics.rTop+1-metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+freeSpaceOnTop+roofInsulation/2)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.strokeStyle = 'gray'; 
			ctx.stroke();
			// roof Insulation
			ctx.beginPath();
			if (isCone) {
				ctx.moveTo(toX(dg,-metrics.rTop-metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
				ctx.lineTo(toX(dg,metrics.rTop+metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+1+roofInsulation+freeSpaceOnTop)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
		else {
			ctx.moveTo(toX(dg,-metrics.rGround-1 ),toY(dg,hGround));
			if (isCone) {
				ctx.lineTo(toX(dg,-metrics.rTop-1+metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
				ctx.lineTo(toX(dg,metrics.rTop+1-metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+freeSpaceOnTop+roofInsulation/2)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineTo(toX(dg,metrics.rGround+1),toY(dg,hGround));
			ctx.strokeStyle = 'gray'; 
			ctx.stroke();

			// roof Insulation
			ctx.beginPath();
			ctx.lineWidth =  1;
			ctx.moveTo(toX(dg,-metrics.rGround-3),toY(dg,hGround));
			if (isCone) {
				ctx.lineTo(toX(dg,-metrics.rTop-2+metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
				ctx.lineTo(toX(dg,metrics.rTop+2-metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+1+roofInsulation+freeSpaceOnTop)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineTo(toX(dg,metrics.rGround+3),toY(dg,hGround));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
/*
		ctx.moveTo(toX(dg,0),toY(dg,2*metrics.dome.hTop+metrics.hAbove+hGround)); 
		ctx.lineTo(toX(dg,0),toY(dg,0)); 
		ctx.stroke();
*/
		// 50% charged, 10% turbin out heat => 10% + 40% + 50 - 10m insulation + 
		const insLpX = metrics.insLpSides * metrics.sideBelow / metrics.hBelow;
		var hTop = metrics.hCylinder+metrics.hBelow+metrics.hAbove;
		// tOutGravelV:  0.1*lowPressureStorageVolume = PI * h * h * (r - h/3);
		// 0.3*V/PI = 3*r*x^2 - x^3
//if (!confirm("A, hLpHot="+hLpHot)) return; 
/*
		const rLpHot = Math.sqrt(metrics.dome.r*metrics.dome.r-(metrics.dome.r-hLpHot)*(metrics.dome.r-hLpHot));
		// next "hot" lp gravel in the top of grave "dome"
		region.moveTo(toX(dg,rLpHot),toY(dg,metrics.dome.hTop-dg.hLpHot+metrics.hAbove+hGround)); 
		region.arcTo(toX(dg,0),toY(dg.hLpHot+metrics.dome.hTop+metrics.hAbove+hGround),
					 toX(dg,-rLpHot),toY(dg,metrics.dome.hTop-dg.hLpHot+metrics.hAbove+hGround), metrics.dome.r*dg.meterToPixels);
*/
		var hLpHot; 
		var rLpHot;
		if (isCone) {
			// (hAbove-hX)/hAbove = (rX-rTop)/(rGound-rTop)
			// => rX = (rGound-rTop)*(hAbove-hX)/hAbove+rTop;
			// 0.1*metrics.lowPressureStorageVolume
			const vCut = Math.PI/3*Math.pow(metrics.rTop,2)*metrics.hAbove*(1-metrics.rTop/metrics.rGround);
//console.log("vCut="+vCut);
			hLpHot = testResult( 0.1*metrics.lowPressureStorageVolume, 0, metrics.hAbove, 
						0.001*metrics.lowPressureStorageVolume, 	// max error
						function (h) { 
							const r = metrics.toSideX(h) + metrics.rTop;
//console.log("h="+h+"=>r="+r);
							return Math.PI/3*h*(r*r + r*metrics.rTop + metrics.rTop*metrics.rTop);
						});
			 rLpHot = metrics.toSideX(hLpHot) + metrics.rTop; // angle=45!
			 hLpHot = metrics.hAbove - hLpHot;
//console.log("hLpHot="+hLpHot+", rLpHot="+rLpHot);
		}
		else if (0.1*metrics.lowPressureStorageVolume > metrics.dome.vCaveTop) {
			hLpHot = metrics.dome.hTop;	// ignore the volume in cone
		}
		else {
			hLpHot = testResult( 0.1*metrics.lowPressureStorageVolume, 10, metrics.dome.hTop, 
						0.001*metrics.lowPressureStorageVolume, 	// max error
						function (h) { return Math.PI * h * h * (metrics.dome.r - h/3)});
		}
		region = new Path2D();
		region.moveTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
		region.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
		region.lineTo(toX(dg,-metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.lineTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.closePath();
		ctx.fillStyle = colorWarmLpGravel;
		ctx.fill(region);

		if (powerAndHeat) {
			region = new Path2D();
			if (isCone) {
				region.moveTo(toX(dg,-rLpHot),		toY(dg,hGround+hLpHot));
				region.lineTo(toX(dg,-metrics.rTop),toY(dg,hGround+metrics.hAbove));
				region.lineTo(toX(dg,metrics.rTop),	toY(dg,hGround+metrics.hAbove));
				region.lineTo(toX(dg,rLpHot),		toY(dg,hGround+hLpHot));
			}
			else {
				var asin =  Math.asin((metrics.dome.r-hLpHot)/ metrics.dome.r);
				region.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							metrics.dome.r*dg.meterToPixels, Math.PI+asin, 2*Math.PI-asin);
			}
			region.closePath();
			ctx.fillStyle = colorHotLpGravel;
			ctx.fill(region);

			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.font = "14px serif";
				centerText( ctx, toCelsius(cycleData.hotCycle[0].tOut), toX(dg,0), 
							toY(dg, isCone ? (hGround+hLpHot) : (metrics.hAbove+hGround+metrics.dome.hTop-hLpHot) ));
			}
		}
//if (!confirm("B")) return; 
/*
	Metrics of the cone inside the insulation
	metrics.hBelowActual = (metrics.sideBelow - metrics.sideBelow*metrics.ins/metrics.hBelow)/metrics.sideBe;
	metrics.rGroundBelowActual = x;
	metrics.rOpenBottomActual = metrics.rOpenBottom *(metrics.rGround-metrics.rTop)*(metrics.hBelow-metrics.hBelowActual)/metrics.hBelow
*/
		// always: V4 < V3 and all gravel-insulation in below ground in V3
		// and we can assume, that the high pressure dome and its Insulation is below the 50% level
		var rLpWarmBottom;
		var hLpWarmFromGround;
		var hColdTop;

		var rColdTop;
		const px = metrics.pHigh <= 1000000 ? 10 : (metrics.pHigh < 1500000 ? 12 : 14);
//console.log("px="+px);
		if (metrics.lowPressureStorageVolume/2 < metrics.V4) {
			const coldV4 = metrics.V4 - 0.5*metrics.lowPressureStorageVolume;
			hColdTop = testResult( coldV4, 0, metrics.hAbove/2, 0.01*coldV4,
						function (h) { 
							const r = metrics.rGround - metrics.toSideX(h);
							rColdTop = r;
							return 1/3*Math.PI*h*(r*r + r*metrics.rGround+  Math.pow(metrics.rGround,2));
						});
			region = new Path2D();
			region.moveTo(toX(dg,-rColdTop), toY(dg,hGround+hColdTop));
			region.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
			region.lineTo(toX(dg,rColdTop), toY(dg,hGround+hColdTop));
			region.lineTo(toX(dg,-rColdTop), toY(dg,hGround+hColdTop));
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);
	//if (!confirm("E")) return; 
			var heatExchangeText = '';
			if (cycleData) {
				ctx.fillStyle = 'black';
				ctx.font = px+"px arial";
				//centerText( ctx, ,toX(dg,0), toY(dg,hGround+hColdTop)-40);
				centerText( ctx, toCelsius(cycleData.hotCycle[1].tIn)+', '+getGasFlow('Lp', cycleData.hotCycle[1],LAST_ITEM,rColdTop,metrics.rTop),
					toX(dg,0), toY(dg,hGround+hLpHot)+25);
				centerText( ctx, Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa "+gasName+" gas in "+myRound(metrics.lpGravelDensity*metrics.lowPressureStorageVolume/1000000,1)+" million ton compacted "
								+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" gravel",toX(dg,0), toY(dg,hGround+hLpHot)+25+px);
				const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
									cycleData.hotCycle[1].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
				heatExchangeText = ", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T="+toCelsius(274);
			} 
			ctx.fillStyle = 'black'; 
			ctx.font = "12px arial";
			centerText(ctx, "\u21D1 in charge"+heatExchangeText, toX(dg,0), toY(dg, hGround+hColdTop));

			rLpWarmBottom = metrics.rGroundBelowActual;
			hLpWarmFromGround = 0;
		}
		else {
			metrics.rOpenBottomActual = metrics.rGroundBelowActual - (metrics.hBelowActual/Math.tan(Math.PI*metrics.dome.maxAngle/180));

			const coldV3 = 0.5*metrics.lowPressureStorageVolume;
			const warmV3 = 0.5*metrics.lowPressureStorageVolume - metrics.V4;
			// warmV3 = 1/3*PI*hCone*rGroundActual^2-1/3*PI*(hCone-x)*((rGroundActual*(hCone-x)/hCone)^2;
			var rLpWarmBottom;
			hLpWarmFromGround = testResult( warmV3, 0, metrics.hBelowActual/2, 0.01*warmV3,
						function (h) { 
							const r = metrics.rGroundBelowActual - (h/Math.tan(Math.PI*metrics.dome.maxAngle/180));
							rColdTop = r;
							rLpWarmBottom = r;
							return 1/3*Math.PI*h*(r*r + r*metrics.rGroundBelowActual+  Math.pow(metrics.rGroundBelowActual,2));
						});
	//if (!confirm("C")) return; 
			
	console.log("rLpWarmBottom="+rLpWarmBottom+',hLpWarmFromGround='+hLpWarmFromGround+", metrics.rGroundBelowActual="+metrics.rGroundBelowActual);

	//$("#"+canvasId).css('display','block');
	//return;

			region = new Path2D();
	//traceXY = true;		
			region.moveTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.closePath();
	//console.log(xyLog);
	//traceXY = false; xyLog = '';
			ctx.fillStyle = colorWarmLpGravel;
			ctx.fill(region);
			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.font = px+"px arial";
				//centerText( ctx, toCelsius(cycleData.hotCycle[1].tIn),toX(dg,0), toY(dg,hGround)-40);
				//centerText( ctx, Math.round(metrics.pHigh/1000)+" kPa "+gasName+" gas in "+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" gravel",toX(dg,0), toY(dg,hGround)-20);
				centerText( ctx, toCelsius(cycleData.hotCycle[1].tIn)+', '+getGasFlow('Lp', cycleData.hotCycle[1],LAST_ITEM,rColdTop,metrics.rTop),
					toX(dg,0), toY(dg,hGround+hLpHot)+20);
				centerText( ctx, Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa "+gasName+" gas in "+myRound(metrics.lpGravelDensity*metrics.lowPressureStorageVolume/1000000,1)+" million ton compacted "
								+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" gravel",toX(dg,0), toY(dg,hGround+hLpHot)+20+px);

				const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
									cycleData.hotCycle[1].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
				heatExchangeText = ", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T=1";
			}
			ctx.fillStyle = 'black'; 
			ctx.font = "12px arial";
			if (Math.abs(hLpWarmFromGround) < 6) {
				ctx.fillText("\u21D1 in charge"+heatExchangeText, toX(dg,-metrics.rGround+5), toY(dg, hGround-hLpWarmFromGround));
			}
			else {
				centerText(ctx, "\u21D1 in charge"+heatExchangeText, toX(dg,-40), toY(dg, hGround-hLpWarmFromGround));
			}
		}
		ctx.beginPath();
		ctx.moveTo(toX(dg,metrics.rTop-1.5), toY(dg, hGround+metrics.hAbove));
		ctx.lineTo(toX(dg,metrics.rGround-1.5), toY(dg,hGround));
		ctx.lineTo(toX(dg,metrics.rGround-1.5), toY(dg,hGround)+5);
		ctx.strokeStyle = colorInsulation;
		ctx.lineWidth = 4;
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.rTop+1.5), toY(dg, hGround+metrics.hAbove));
		ctx.lineTo(toX(dg,-metrics.rGround+1.5), toY(dg,hGround));
		ctx.lineTo(toX(dg,-metrics.rGround+1.5), toY(dg,hGround)+5);
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove+2));
		ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
		ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround)+5);
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 2;
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.rTop), toY(dg, hGround+metrics.hAbove+2));
		ctx.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
		ctx.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround)+5);
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 2;
		ctx.stroke();

	//if (!confirm("D")) return; 
	//traceXY = true;
		region = new Path2D();
		region.moveTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
		region.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
		region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
		region.lineTo(toX(dg,rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
		region.lineTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
		region.closePath();
		ctx.fillStyle = colorColdLpGravel;
		ctx.fill(region);
	//console.log(xyLog);
	//traceXY = false; xyLog = '';
		if (cycleData) {
			ctx.fillStyle = 'white'; 
			ctx.font = "14px serif";
			//centerText(ctx, toCelsius(cycleData.coldCycle[1].tOut), toX(dg,0), toY(dg,hGround-hLpWarmFromGround)+40 );
			const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
								cycleData.hotCycle[0].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
			heatExchangeText = ", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T=1";
		}
//if (!confirm("E")) return; 
		
		if (hLpWarmFromGround > 0) {
			ctx.font = "12px arial";
			ctx.fillStyle = 'white'; 
			centerText(ctx, "\u21D3 in discharge"+heatExchangeText, toX(dg,0), toY(dg,hGround-hLpWarmFromGround)+16);
		}
		else {
			ctx.font = "12px arial";
			ctx.fillStyle = 'white'; 
			centerText(ctx, "\u21D3 in discharge"+heatExchangeText, toX(dg,0), toY(dg,hGround+hColdTop)+16);
		}
		ctx.font = "14px arial";
		centerText(ctx,getGasFlow('Lp', cycleData.coldCycle[0],LAST_ITEM,rLpWarmBottom,metrics.rOpenBottomActual), toX(dg,0), toY(dg,hGround-metrics.hBelowActual)-25);

		// always: V4 < V3 and all gravel-insulation in below ground in V3
		// and we can assume, that the high pressure dome and its Insulation is below the 50% level
		var hLiquid = 0, hLiquidStorage=0, rLiquidStorage=0, liquidM3 = 0;
		if (metrics.powerAndHeat) {
			const liquidV3 = metrics.maxPartLiquid/2*metrics.lowPressureStorageVolume; // 50%
			var rLiquid;
			hLiquid = testResult( liquidV3, 0, metrics.hBelowActual/2, 0.01*liquidV3,
						function (h) { 
								const r = metrics.rOpenBottomActual + (h/Math.tan(Math.PI*metrics.dome.maxAngle/180));
								rLiquid = r;
								return 1/3*Math.PI*h*(r*r + r*metrics.rOpenBottomActual+  Math.pow(metrics.rOpenBottomActual,2));
							});
			region = new Path2D();
			region.moveTo(toX(dg,-rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
			region.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
			region.lineTo(toX(dg,-rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
			region.closePath();
			ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
			ctx.fill(region);
		}
		else {
			liquidM3 = metrics.maxPartLiquid*metrics.lowPressureStorageVolume*(metrics.rockDensityLp-metrics.lpGravelDensity)/metrics.rockDensityLp		
			hLiquidStorage = Math.pow(liquidM3, 1/3);
			rLiquidStorage = Math.sqrt(liquidM3/(hLiquidStorage*Math.PI));
console.log("liquidM3="+liquidM3+" => hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
		}
		if (isCone) {
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,-metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			region.lineTo(toX(dg,metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.closePath();
			ctx.fillStyle = colorInsulation;
			ctx.fill(region);
/*
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			ctx.lineTo(toX(dg,metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
*/
			if (powerAndHeat) {
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(toX(dg,-metrics.rGround), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rGroundBelow), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rGroundBelowActual), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual)+1);
				ctx.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual)+1);
				ctx.lineTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
				ctx.lineTo(toX(dg,metrics.rGroundBelow), toY(dg,hGround));
				ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
				ctx.strokeStyle = 'black'; 
				ctx.stroke();
			}
		}
		else 
		{
			const hExtIns = metrics.extDomeIns.h - metrics.ins*Math.cos(Math.PI/4);
			const sExtIns = metrics.extDomeIns.s - 2 * metrics.ins*Math.cos(Math.PI/4);
			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
										(metrics.extDomeIns.r)*dg.meterToPixels, Math.PI+metrics.extDomeIns.rads, 2*Math.PI-metrics.extDomeIns.rads);
			region.lineTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.dome.hBottom));
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, 
						2*Math.PI-Math.PI/4,
						Math.PI+Math.PI/4, 
						true );
			region.closePath();
			ctx.fillStyle = colorInsulation;
			ctx.fill(region);
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
								(metrics.extDomeIns.r)*dg.meterToPixels, Math.PI+metrics.extDomeIns.rads, 2*Math.PI-metrics.extDomeIns.rads);

			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						(metrics.extDome.r)*dg.meterToPixels, Math.PI+Math.PI/4, 2*Math.PI-Math.PI/4);
			region.lineTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.dome.hBottom));
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, 
						2*Math.PI-Math.PI/4,
						Math.PI+Math.PI/4, 
						true );
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			const	rhDeltaTop = metrics.dome.rTop - metrics.dome.rTopI;
			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					metrics.dome.r*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			region.closePath();
			ctx.fillStyle = colorHotHpGravel; 
			ctx.fill(region);
		}
		{
			ctx.font = "12px arial";
			ctx.fillStyle = 'white'; 
			const text = toCelsius(cycleData.coldCycle[1].tOut)+" "+gasName+" gas in gravel"+(powerAndHeat ? ", liquid "+gasName+" max "+Math.round(100*metrics.maxPartLiquid)+"% of volume" : "");
			centerText(ctx, text, toX(dg,0), toY(dg,hGround-metrics.hBelowActual+(powerAndHeat ? 0 : 20)));
		}

		{
//if (!confirm("G")) return; 
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			region.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			region.lineTo(toX(dg,metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.lineTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.closePath();
			ctx.fillStyle = colorHotHpGravel;
			ctx.fill(region);

			//const rhDeltaTopIns = metrics.caveTopInsulation * Math.sin( Math.PI/4);
			//const rhExpansionSpace = rhDeltaTopIns + (metrics.maxHpGravelExpansionUpM/2+1)* Math.sin( Math.PI/4);
		}
		if (!isCone) {
			ctx.lineWidth = metrics.caveTopInsulation * dg.meterToPixels;
			ctx.beginPath();
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					(metrics.dome.r-metrics.caveTopInsulation/2)*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			ctx.strokeStyle = 'black'; 
			ctx.stroke();

			const hExpansion = metrics.maxHpGravelExpansionUpM/2+1;
			ctx.lineWidth = hExpansion * dg.meterToPixels;
			ctx.beginPath();
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					(metrics.dome.r-metrics.caveTopInsulation-hExpansion/2)*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			ctx.strokeStyle = 'white'; 
			ctx.stroke();
		}
//if (!confirm("H")) return; 

		var rColdHpGravel;
		const testVolume = metrics.highPressureStorageVolume/2;
		const hTemp = testResult( testVolume, 0, metrics.dome.hBottomI/2, 0.01*testVolume,
					function (h) { 
						const r = metrics.dome.rTopI - (metrics.dome.rTopI - metrics.dome.rBottomI)*h/metrics.dome.hBottomI;
//console.log("h="+h+", r="+r);
						rColdHpGravel = r;
						return 1/3*Math.PI*h*(r*r + r*metrics.dome.rTopI+  Math.pow(metrics.dome.rTopI,2));
					});

			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.strokeStyle = 'black'; 
				const text2 = "Mass flow "+Math.round(1000*cycleData.hotCycle[1].massFlow)+" kg/s in charge and "+Math.round(1000*cycleData.hotCycle[0].massFlow)+" kg/s in discharge";
				if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel)) {
					if (px > 13) px = 13;
					if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel)) {
						if (px > 12) px = 12;
						if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel)) {
							if (px > 11) px = 11;
						}
					}
				}
				ctx.font = px+"px arial";
				centerText( ctx, toCelsius(cycleData.hotCycle[0].tIn)+', '+getGasFlow('Hp', cycleData.hotCycle[0],FIRST_ITEM,metrics.dome.rTopI,rColdHpGravel), toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px);
				const text3 = Math.round(metrics.pHigh/1000)+" kPa "+gasName+" gas in "+myRound(metrics.gravelDensity*metrics.highPressureStorageVolume/1000000,1)+" million ton compacted "
								+metrics.gravelMinHp+"/"+metrics.gravelMaxHp+" gravel";
//console.log(ctx.measureText(text2+", "+text3).width+" < "+ (rColdHpGravel+metrics.dome.rTopI)*2);
				if (ctx.measureText(text2+", "+text3).width < (rColdHpGravel+metrics.dome.rTopI)*2) {
					centerText( ctx, text2+", "+text3, toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px*2 );
				}
				else {
					centerText( ctx, text2, toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px*2 );
					centerText( ctx, text3, toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px*3);
				}
			}

		const hColdHpGravel = metrics.dome.hBottomI - hTemp;
//console.log("rColdHpGravel="+rColdHpGravel+", hColdHpGravel="+hColdHpGravel);
		region = new Path2D();
		region.moveTo(toX(dg,-rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
		region.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
		region.lineTo(toX(dg,rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.lineTo(toX(dg,-rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.closePath();
		ctx.fillStyle = colorColdHpGravel;
		ctx.fill(region);
//if (!confirm("I")) return; 

		if (false && powerAndHeat) {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			ctx.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			ctx.lineTo(toX(dg,metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.lineTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.closePath();
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
		else {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.dome.rTop)-1, toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop));
			ctx.lineTo(toX(dg,metrics.dome.rTop)+1, toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}

		var heDischargeText = '';
		if (cycleData) {
			ctx.fillStyle = 'black'; 
			ctx.strokeStyle = 'black'; 
			ctx.font = "14px serif";
			centerText( ctx, toCelsius(cycleData.coldCycle[0].tOut)+', '+getGasFlow('Hp', cycleData.coldCycle[0],FIRST_ITEM,rColdHpGravel,metrics.dome.rBottomI),toX(dg,0), toY(dg,hColdHpGravel/2));

			var heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tOut, cycleData.coldCycle[1].tIn, cycleData.hotCycle[1].pOut,rColdHpGravel , 
								cycleData.hotCycle[1].massFlow, metrics.gravelMinHp, metrics.gravelMaxHp, metrics.hpGravelPorosity, 1 );
			heatExchangeText = ", heat exchange area width ~"+myRound(heLength,1)+" m if \u0394T=1";
			heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tOut, cycleData.coldCycle[1].tIn, cycleData.hotCycle[1].pOut,rColdHpGravel , 
								cycleData.hotCycle[0].massFlow, metrics.gravelMinHp, metrics.gravelMaxHp, metrics.hpGravelPorosity, 1 );
			heDischargeText = ", heat exchange area width ~"+myRound(heLength,1)+" m if \u0394T=1";
		}
		ctx.font = "12px arial";
		ctx.fillStyle = 'black'; 
		centerText( ctx, "\u21D3 in charge"+heatExchangeText, toX(dg,0), toY(dg,hColdHpGravel)+16);

		ctx.font = "12px arial";
		ctx.fillStyle = 'black'; 
		centerText( ctx, "\u21D1 in discharge"+heDischargeText, toX(dg,0), toY(dg,hColdHpGravel));

		hTop = hGround;
		const towerH = hTop + 20;
		const towerLeftX = toX( dg, -metrics.rGround - 8 ); 
		const towerRightX = toX( dg, metrics.rGround + 8 ); 

		const yLpTop = towerH, yLpBottom = 2+hTop, yHpTop = towerH-7.5, yHpBottom = hTop+7.5;
		const ctWidth = 20*dg.meterToPixels;
		const hotCompHpX = towerRightX + ctWidth;
		const xTurbinLp = towerLeftX;
		const xTurbinHp = xTurbinLp-ctWidth;
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		//ctx.moveTo(x = towerRightX, y = toY(dg, yLpTop));
		ctx.moveTo(x = towerRightX, toY(dg, yLpBottom));
		ctx.lineTo(x = hotCompHpX, toY(dg,yHpBottom));
		ctx.lineTo(x, toY(dg,yHpTop));
		ctx.lineTo(towerRightX, y = toY(dg, yLpTop));
		ctx.closePath();
		ctx.stroke();

		ctx.font = "bold 14px serif";
		ctx.fillText("Charge unit", towerRightX, y);

		ctx.lineWidth = 15;
		ctx.strokeStyle = colorWarmLpGravel;
/*
		ctx.beginPath();
		ctx.lineTo(towerRightX-ctWidth-8, y);
		ctx.stroke();
*/
		{
			ctx.beginPath();
			var x2;
//console.log("toSideX("+metrics.hAbove+")+"+metrics.rTop+"="+(metrics.toSideX(metrics.hAbove)+metrics.rTop)+"=="+metrics.rGround);
			ctx.moveTo(towerRightX+5, y = toY(dg,(yHpBottom+yHpTop)/2)-4);
			ctx.lineTo(x2 = towerRightX-10, y);
			const pixelsUp = powerAndHeat ? y - toY(dg,hGround+hLpHot-4) : y - (toY(dg,hGround+metrics.hAbove)+7.5);
			ctx.lineTo(x2 = x2-metrics.toSideX(pixelsUp), y-pixelsUp );
			ctx.lineTo(x2-40, y=y-pixelsUp);
			ctx.stroke();

			ctx.lineWidth = 1;
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			y -= 7.5;
			ctx.moveTo(x2-40, y);
			ctx.lineTo(toX(dg, 4), y);
			ctx.stroke();

			ctx.setLineDash([3, 3]);
			ctx.beginPath();
			ctx.moveTo(x2-20, y+15);
			ctx.lineTo(toX(dg, 4), y+4);
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.fillStyle = 'black'; 
			ctx.font = "bold 18px serif";
			ctx.fillText("\u2192", x2-40, y+15);
			ctx.fillText("\u2192", towerRightX-12, toY(dg, yLpBottom+6));
		}
		ctx.fillText("C", towerRightX+10, toY(dg, yLpBottom+4));

		const xColdTurbinLp = x + ctWidth/2;
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x, y = toY(dg, towerH-10 ));
		ctx.lineTo(xColdTurbinLp, y);
		ctx.stroke();

/*
  "diameterPipeFromColdExpander": 4.671124802092986,	9
  "diameterPipeFromHotCompressor": 2.674133432823774,	5
  "diameterPipeToHotCompressor": 7.859972449531066,		15
  "diameterPipeToColdExpander": 2.119501593112965,		4
*/
		ctx.lineWidth = 5;
		ctx.strokeStyle = colorHotHpGravel;
		ctx.beginPath();
		ctx.moveTo(hotCompHpX-3, toY(dg,yHpBottom));
		ctx.lineTo(hotCompHpX-3, y = toY(dg, yHpBottom-11));
		ctx.lineTo(x = toX(dg,metrics.rGroundBelow+2), y );
		{
			const y2 = toY(dg,metrics.dome.hBottomI-1.5);
			var x2 = x - Math.cos(Math.PI*metrics.dome.maxAngle/180)*(y2-y);
			ctx.lineTo(x2, y2 );
			ctx.lineTo(x2=toX(dg,metrics.dome.rTopI-2),y2);
			ctx.stroke();

			ctx.lineWidth = 1;
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(x2, y2+2.5);
			ctx.lineTo(toX(dg,-metrics.dome.rTopI+2), y2+2.5);
			ctx.stroke();
/*
			ctx.beginPath();
			ctx.moveTo(x2-20, y+15);
			ctx.lineTo(toX(dg, 4), y+4);
			ctx.stroke();
*/
			ctx.setLineDash([]);
		}
		ctx.fillStyle = 'black'; 
		ctx.font = "16px serif";
		ctx.fillText("\u2193", hotCompHpX-6, toY(dg,yHpBottom)+16);

		const xColdTurbinHp = xColdTurbinLp + ctWidth/2;
		const yColdLpTop = towerH-5, yColdLpBottom = hTop+5, yColdHpTop = yLpTop-8, yColdHpBottom = yLpBottom+6;

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xColdTurbinLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xColdTurbinHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xColdTurbinLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 12px serif";
		ctx.fillText("T", xColdTurbinLp+4, toY(dg,yColdLpBottom+1));

		ctx.lineWidth = 9;
		ctx.strokeStyle = colorColdLpGravel;
		ctx.beginPath();
		ctx.moveTo(xColdTurbinLp+4, toY(dg,yColdLpBottom+1));
		ctx.lineTo(xColdTurbinLp+4, y = toY(dg, yHpBottom-10)+12);
		ctx.lineTo(toX(dg,metrics.rGroundBelow+8), y );
		const rPipeLpCold = metrics.rOpenBottom + (metrics.hBelow-metrics.hBelowActual)/Math.tan(Math.PI*metrics.dome.maxAngle/180);
		ctx.lineTo(toX(dg,rPipeLpCold+13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
		ctx.lineTo(toX(dg,rPipeLpCold-insLpX),y);
		ctx.stroke();


		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.setLineDash([3, 3]);
		ctx.moveTo(toX(dg,rPipeLpCold-insLpX), y+2.5);
		ctx.lineTo(toX(dg,0), y-2);
		ctx.lineTo(toX(dg,-rPipeLpCold+insLpX), y+2.5);
		ctx.stroke();
		ctx.moveTo(toX(dg,rPipeLpCold-insLpX), y-4.5);
		ctx.lineTo(toX(dg,-rPipeLpCold+insLpX), y-4.5);
		ctx.stroke();
		ctx.setLineDash([]);

		ctx.fillStyle = 'white'; 
		ctx.font = "bold 20px serif";
		ctx.fillText("\u2193", xColdTurbinLp+1, toY(dg,yColdLpBottom-10));

		if (!metrics.powerAndHeat) {
console.log("hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
			ctx.lineWidth = 2;
			ctx.strokeStyle = colorLiquidLpGravel;
			ctx.beginPath();
			ctx.moveTo(xColdTurbinLp+1, toY(dg,yColdLpBottom+1));
			ctx.lineTo(x = xColdTurbinLp+1, y = toY(dg, yHpBottom-30)+12);
			ctx.stroke();
			const x1 = x - dg.meterToPixels*rLiquidStorage*0.5;
			const x2 = x + dg.meterToPixels*rLiquidStorage*1.5;
			const y1 = y;
			const y2 = y+dg.meterToPixels*hLiquidStorage;;

			region = new Path2D();
			region.moveTo(x1, y1);
			region.lineTo(x2, y1);
			region.lineTo(x2, y2);
			region.lineTo(x1,y2);
			region.closePath();
			ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
			ctx.fill(region);
			ctx.fillStyle = 'white'; 
			ctx.font = "12px serif";
			ctx.fillText("Liquid "+gasName, x1, y2-45);
			ctx.fillText("separated", x1, y2-30);
			ctx.fillText("after T-out", x1, y2-15);
			ctx.fillText("Vol "+Math.round(liquidM3)+" m3", x1, y2);

			ctx.fillStyle = 'white'; 
			ctx.font = "bold 12px serif";
			ctx.fillText("\u2193 "+Math.round(cycleData.coldCycle[1].wetness*1000)+" ‰ of gas", xColdTurbinLp-1, y1+12);
		}

		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(xColdTurbinHp-2, toY(dg,yColdHpBottom+1));
		ctx.lineTo(xColdTurbinHp-2, y = toY(dg, yHpBottom-10)+20);
		ctx.lineTo(toX(dg,metrics.rGroundBelow+12), y );
		ctx.lineTo(toX(dg,metrics.dome.rBottom+12), y = toY(dg,metrics.insCaveBottom)-4);
		ctx.lineTo(x = toX(dg,metrics.dome.rBottomI), y);
		ctx.stroke();

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo(toX(dg,metrics.dome.rBottomI), y-2);
		ctx.lineTo(toX(dg,metrics.dome.rBottomI/2), y);
		ctx.stroke();
		ctx.setLineDash([]);

		ctx.fillStyle = 'black'; 
		ctx.font = "bold 16px serif";
		ctx.fillText("\u2191", xColdTurbinHp-6, toY(dg,yColdHpBottom)+20);
		var xGeneratorLeft = xColdTurbinHp + ctWidth/2;
		var xGeneratorRight = xGeneratorLeft + ctWidth*2;
		const xChargeGeneratorRight = xGeneratorRight;

		ctx.lineWidth = 2;
		ctx.strokeStyle = 'white';
		ctx.beginPath();
		ctx.moveTo(xColdTurbinHp-7, toY(dg, yHpBottom-4-18));    
		ctx.lineTo(xColdTurbinHp-7, y = toY(dg, yHpBottom-4-6));
		ctx.lineTo(xGeneratorRight, y );
		ctx.lineTo(xGeneratorRight, y = toY(dg, yHpBottom-4-18));
		ctx.closePath(); //lineTo(xColdTurbinHp-7, y);
		ctx.stroke();
		ctx.font = "bold 12px arial";
		ctx.fillStyle = 'white'; 
		ctx.fillText("Heat exchangers", xColdTurbinHp+6, toY(dg, yHpBottom-4-15.5)-1)
		ctx.fillText(powerAndHeat ? "District heat" : "Cooling water", xGeneratorLeft+25, toY(dg, yHpBottom-30));//toY(dg, yHpBottom-4-13));
		if (cycleData) ctx.fillText(workToMW(cycleData.heatPumpHeating), xGeneratorLeft+25, toY(dg, yHpBottom-30-6));
		if (cycleData) ctx.fillText(workToMW(-cycleData.heatPumpCooling), xColdTurbinHp-17, toY(dg, yHpBottom-30));

		ctx.font = "bold 20px arial";
		ctx.fillStyle = 'red'; 
		ctx.fillText("\u2192",  xGeneratorRight-5, toY(dg, yHpBottom-4-13));
		ctx.fillStyle = 'blue'; 
		ctx.fillText("\u2190",  xGeneratorRight-5, toY(dg, yHpBottom-4-20));


		const genMotUpPx = (yLpTop-yLpBottom)*1.2*2; 
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xColdTurbinHp, y = toY(dg, towerH-10));
		ctx.lineTo(x+ctWidth/4, y);
		ctx.lineTo(x+ctWidth/4, y-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y-genMotUpPx);
		ctx.stroke();

		const xHeatPumpTurbinLp = xGeneratorLeft + ctWidth/4;
		const xHeatPumpTurbinHp = xHeatPumpTurbinLp + ctWidth/2;
/*
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.moveTo(xColdTurbinHp, y);
		ctx.lineTo(xHeatPumpTurbinLp, y);
		ctx.stroke();
*/
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpTurbinLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xHeatPumpTurbinHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xHeatPumpTurbinLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("T", xHeatPumpTurbinLp+4, toY(dg,yColdLpBottom+1));

		ctx.font = "bold 14px serif";
		ctx.fillText("Heat pump",  xHeatPumpTurbinLp, toY(dg,yColdLpTop)-1);

		const xHeatPumpCompressorLp = xHeatPumpTurbinHp+ctWidth/2;
		const xHeatPumpCompressorHp = xHeatPumpCompressorLp + ctWidth/2;

		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(xHeatPumpTurbinLp, y = toY(dg,yColdLpBottom)-3);
		ctx.lineTo(x = xColdTurbinHp+5, y);
		ctx.lineTo(x, y = toY(dg, yHpBottom-10)+20);
		ctx.lineTo(x = xHeatPumpCompressorLp-5, y );
		ctx.lineTo(x, y = toY(dg,yColdLpBottom)-3);
		ctx.lineTo(xHeatPumpCompressorLp, y);
		ctx.stroke();
		//ctx.fillText("\u2190", xColdTurbinHp+3, toY(dg,yColdLpBottom)+4);

		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(x = xHeatPumpCompressorHp-2,toY(dg,yColdHpBottom));
		ctx.lineTo(x, y = toY(dg, yHpBottom-4-8));
		ctx.lineTo(xHeatPumpTurbinHp-2,  y );
		ctx.lineTo(x = xColdTurbinHp+12, y);
		ctx.lineTo(x, y = toY(dg,yColdHpBottom)+16);
		ctx.lineTo(x = xHeatPumpTurbinHp-2,  y );
		ctx.lineTo(x, y= toY(dg,yColdHpBottom));
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 16px serif";
		ctx.fillText("\u2193", xHeatPumpCompressorHp-2-5, toY(dg,yColdHpBottom)+16);
		ctx.fillText("\u2191", x-4, y+18);
		ctx.fillText("\u2193", xColdTurbinHp+1, toY(dg,yColdHpBottom)+18);
		ctx.fillText("\u2191", xHeatPumpCompressorLp-5-4, toY(dg,yColdLpBottom)-3+18);

		ctx.beginPath();
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 5;
		ctx.moveTo(xHeatPumpTurbinHp, y = toY(dg, towerH-10));
		ctx.lineTo(xHeatPumpCompressorLp, y);
		ctx.stroke();

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpCompressorLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xHeatPumpCompressorHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xHeatPumpCompressorLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("C", xHeatPumpCompressorLp+4, toY(dg,yColdLpBottom+1));

		const xHeatPumpMotor = xHeatPumpCompressorHp+ctWidth/4;
		const xHeatPumpMotorEnd = xHeatPumpMotor+ctWidth/3+2;
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpMotor, toY(dg,yColdLpTop));
		ctx.lineTo(x, y = toY(dg, yColdLpBottom));
		ctx.lineTo(x = xHeatPumpMotorEnd, y);
		ctx.lineTo(x, toY(dg,yColdLpTop));
		ctx.lineTo(xHeatPumpMotor, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("M", xHeatPumpMotor+2, toY(dg,yColdLpBottom+1));
		
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.moveTo(xHeatPumpCompressorHp, y= toY(dg, towerH-10));
		ctx.lineTo(xHeatPumpMotor, y);
		ctx.stroke();


		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xGeneratorLeft, toY(dg,yLpTop)-genMotUpPx);
		ctx.lineTo(x, y = toY(dg, yLpBottom)-genMotUpPx);
		ctx.lineTo(x = xGeneratorRight, y);
		ctx.lineTo(x, y = toY(dg, yLpTop)-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y);
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 13px arial";
		ctx.fillText("M / G", xGeneratorLeft+20, toY(dg,yLpBottom+8)-genMotUpPx);
		if (cycleData) ctx.fillText(metrics.cUnits+"*"+workToMW(cycleData.netWorkIn, metrics.cUnits), xGeneratorLeft+5, toY(dg,yLpBottom+1)-genMotUpPx);

		ctx.fillText("Motor-Generator", xGeneratorLeft-10, toY(dg,yLpTop+1)-genMotUpPx);
//		ctx.fillText("Charge", xGeneratorRight+1, toY(dg,yLpBottom+10));
		ctx.font = "bold 20px serif";
		ctx.fillText("\u21DC", xGeneratorRight+1, toY(dg, towerH-14)-genMotUpPx);

		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xTurbinHp, y = toY(dg, yHpTop));
		ctx.lineTo(x, toY(dg,yHpBottom));
		ctx.lineTo(x = xTurbinLp, toY(dg,yLpBottom));
		ctx.lineTo(x, toY(dg,yLpTop));
		ctx.lineTo(xTurbinHp, toY(dg, yHpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 16px serif";
		ctx.fillText("T", xTurbinHp+15, toY(dg, yLpBottom+4));

		ctx.lineWidth = 5;
		ctx.strokeStyle = colorHotHpGravel;
		ctx.beginPath();
		ctx.moveTo(xTurbinHp+3, toY(dg,yHpBottom));
		ctx.lineTo(xTurbinHp+3, y = toY(dg, yHpBottom-11));
		ctx.lineTo(x = toX(dg,-metrics.rGroundBelow-2), y );
		{
			const y2 = toY(dg,metrics.dome.hBottomI-1.5);
			const x2 = x + Math.cos(Math.PI*metrics.dome.maxAngle/180)*(y2-y);
			ctx.lineTo(x2, y2 );
			ctx.lineTo(toX(dg,metrics.dome.rTopI+2),y2);
		}
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "16px serif";
		ctx.fillText("\u2191", xTurbinHp-2, toY(dg,yHpBottom)+16);

		ctx.lineWidth = 15;
		ctx.strokeStyle = colorHotLpGravel;
/*		{
			ctx.beginPath();
			var x2;
			ctx.moveTo(towerRightX+5, y = toY(dg,(yHpBottom+yHpTop)/2)-4);
			ctx.lineTo(x2 = towerRightX-10, y);
			const pixelsUp = y - toY(dg,hGround+hLpHot-4);
			ctx.lineTo(x2 = x2-metrics.toSideX(pixelsUp), y-pixelsUp );
			ctx.lineTo(x2-30, y-pixelsUp);
			ctx.stroke();
		}*/
		{
			ctx.beginPath();
			var x2, y2;
			ctx.moveTo(towerLeftX-5, y2 = toY(dg,(yHpBottom+yHpTop+2)/2));
			ctx.lineTo(x2=towerLeftX+10, y2 );
			const pixelsUp = y2 - (toY(dg,hGround+metrics.hAbove)+7.5);
			ctx.lineTo(x2 = x2+metrics.toSideX(pixelsUp), y2-pixelsUp );
			ctx.lineTo(x2+40, y2-pixelsUp);
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "bold 20px serif";
			ctx.fillText("\u2192", towerLeftX-10, y2+10);

			ctx.lineWidth = 1;
			ctx.strokeStyle = 'black';
			y = y2-pixelsUp - 7.5;
			/*
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(x2+20, y);
			ctx.lineTo(toX(dg, -4), y);
			ctx.stroke();
			*/
			ctx.setLineDash([3, 3]);
			ctx.beginPath();
			ctx.moveTo(x2+17, y+15);
			ctx.lineTo(toX(dg, -4), y+4);
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.fillText("\u2192", x2+40, y2-pixelsUp+10);
		}


		const xColdCompressorLp = xTurbinHp - ctWidth/2;
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.moveTo(xTurbinHp, y = toY(dg, towerH-10));
		ctx.lineTo(xColdCompressorLp, y);
		ctx.stroke();
		const xColdCompressorHp = xColdCompressorLp - ctWidth/2;

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x = xColdCompressorLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xColdCompressorHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xColdCompressorLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 12px serif";
		ctx.fillText("C", xColdCompressorHp+5, toY(dg,yColdLpBottom+1));

		ctx.lineWidth = 9;
		ctx.strokeStyle = colorColdLpGravel;
		ctx.beginPath();
		ctx.moveTo(xColdCompressorLp-4, toY(dg,yColdLpBottom+1));
		ctx.lineTo(xColdCompressorLp-4, y = toY(dg, yHpBottom-10)+12);
		ctx.lineTo(toX(dg,-metrics.rGroundBelow-8), y );
		ctx.lineTo(toX(dg,-rPipeLpCold-13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
		ctx.lineTo(toX(dg,-rPipeLpCold+insLpX),y);
		ctx.stroke();
		ctx.fillStyle = 'white'; 
		ctx.font = "bold 20px serif";
		ctx.fillText("\u2191", xColdCompressorLp-9, toY(dg,yColdLpBottom-10));

		if (!metrics.powerAndHeat) {
//console.log("hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
			ctx.lineWidth = 2;
			ctx.strokeStyle = colorLiquidLpGravel;
			ctx.beginPath();
			ctx.moveTo(xColdCompressorLp-1, toY(dg,yColdLpBottom+1));
			ctx.lineTo(x = xColdCompressorLp-1, y = toY(dg, yHpBottom-30)+12);
			ctx.stroke();
			const x1 = x - dg.meterToPixels*rLiquidStorage*0.5;
			const x2 = x + dg.meterToPixels*rLiquidStorage*1.5;
			const y1 = y;
			const y2 = y+dg.meterToPixels*hLiquidStorage;;

			region = new Path2D();
			region.moveTo(x1, y1);
			region.lineTo(x2, y1);
			region.lineTo(x2, y2);
			region.lineTo(x1,y2);
			region.closePath();
			ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
			ctx.fill(region);
			ctx.fillStyle = 'white'; 
			ctx.font = "12px serif";
			ctx.fillText("Liquid "+gasName, x1, y2-41);
			ctx.fillText("storage", x1, y2-28);
			ctx.fillText("Boiling to C-in", x1, y2-15);
			ctx.fillText("Vol "+Math.round(liquidM3)+" m3", x1, y2);

			ctx.fillStyle = 'white'; 
			ctx.font = "bold 12px serif";
			ctx.fillText("\u2191 "+Math.round(cycleData.coldCycle[1].wetness*1000)+" ‰ of gas", xColdCompressorLp-4, y1+12);
		}
		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(xColdCompressorHp+2, toY(dg,yColdHpBottom+1));
		ctx.lineTo(xColdCompressorHp+2, y = toY(dg, yHpBottom-10)+20);
		ctx.lineTo(toX(dg,-metrics.rGroundBelow-12), y );
		ctx.lineTo(toX(dg,-metrics.dome.rBottom-12), y = toY(dg,metrics.insCaveBottom)-4);
		ctx.lineTo(toX(dg,-metrics.dome.rBottomI), y);
		ctx.stroke();

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.dome.rBottomI), y-2);
		ctx.lineTo(toX(dg,-metrics.dome.rBottomI/4), y);
		ctx.stroke();
		ctx.setLineDash([]);

		ctx.fillStyle = 'black'; 
		ctx.font = "bold 16px serif";
		ctx.fillText("\u2193", xColdCompressorHp-2, toY(dg,yColdHpBottom)+20);

		xGeneratorRight = xColdCompressorHp - ctWidth/2;
		xGeneratorLeft = xGeneratorRight - 2*ctWidth;
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(xColdCompressorHp, y = toY(dg, towerH-10));
		ctx.lineTo(x = xColdCompressorHp-ctWidth/4, y);
		ctx.lineTo(x, y-genMotUpPx);
		ctx.lineTo(xGeneratorRight, y-genMotUpPx);
		ctx.stroke();

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x = xGeneratorLeft, toY(dg,yLpTop)-genMotUpPx);
		ctx.lineTo(x, y = toY(dg, yLpBottom)-genMotUpPx);
		ctx.lineTo(x = xGeneratorRight, y);
		ctx.lineTo(x, y = toY(dg, yLpTop)-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y);
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 13px arial";
		ctx.fillText("M / G", xGeneratorLeft+15, toY(dg,yLpBottom+8)-genMotUpPx);
		if (cycleData) ctx.fillText(metrics.cUnits+"*"+workToMW(cycleData.netWorkOut, metrics.cUnits), xGeneratorLeft+10, toY(dg,yLpBottom+1)-genMotUpPx);
		ctx.fillText("Discharge unit", xColdCompressorHp, toY(dg,yLpTop+1));
		ctx.fillText("Motor-Generator", xGeneratorLeft-10, toY(dg,yLpTop+1)-genMotUpPx);
		
		//ctx.fillText("Discharge", xGeneratorLeft-1-ctx.measureText("Discharge").width, toY(dg,yLpBottom+11));
		ctx.font = "bold 20px serif";
		ctx.fillText("\u21DC", xGeneratorLeft-19, toY(dg, towerH-14)-genMotUpPx);
		
		ctx.font = "20px arial";
		ctx.fillStyle = 'white'; 
		ctx.fillText("bedrock", x = toX(dg,-metrics.rGround-50), y = toY(dg,metrics.dome.hBottom/2));
		ctx.fillText("bedrock",x = toX(dg,metrics.rGround+10), y);
		ctx.font = "14px arial";
		const depth = metrics.hBelow+metrics.hCylinder;
//console.log( depthM+", yPx="+toY(dg,depth))
		ctx.fillText( "-"+Math.round(hGround-metrics.dome.hBottomI)+" m", toX(dg,metrics.dome.rTopI-22), toY(dg,metrics.dome.hBottomI));
		ctx.fillText( "-"+Math.round(depth)+" m", toX(dg,metrics.dome.rBottom+14), toY(dg,0));
		ctx.fillStyle = 'black'; 
		{
			const heightText = "+"+Math.round(metrics.hAbove)+" m";
			ctx.fillText(  heightText, toX(dg,-metrics.rTop)-ctx.measureText(heightText).width-5, toY(dg,hGround+metrics.hAbove));
		}

		ctx.font = "bold 12px arial";
		ctx.fillStyle = 'black'; 
		ctx.fillText("r="+Math.round(metrics.dome.rBottom)+" m \u21A6", toX(dg,0), toY(dg,metrics.insCaveBottom));

		ctx.fillStyle = 'white'; 
		ctx.fillText("r="+Math.round(metrics.dome.rTop)+" m \u21A6", toX(dg,0), toY(dg,metrics.dome.hBottomI));

		ctx.fillStyle = 'white'; 
		if (Math.round(metrics.rGroundBelow) != Math.round(metrics.rGround)) {
			ctx.fillText("r="+Math.round(metrics.rGround)+" m \u21A6", toX(dg,-metrics.rGroundBelow)+15,toY(dg,hGround));
			ctx.fillText("r="+Math.round(metrics.rGroundBelow)+" m \u21A6", toX(dg,-metrics.rGroundBelowActual)+15, toY(dg,hGround-6));
		}
		else {
			if (hLpWarmFromGround > 0) {
				ctx.fillText("r="+Math.round(metrics.rGround)+" m \u21A6", toX(dg,-metrics.rGroundBelow)+15,toY(dg,hGround));
			}
			else {
				ctx.fillText("r="+Math.round(metrics.rGroundBelow)+" m \u21A6", toX(dg,-metrics.rGroundBelowActual)+10, toY(dg,hGround-6));
			}
		}

		ctx.fillStyle = 'black';
		ctx.fillText("r="+Math.round(metrics.rTop)+" m \u21A6", toX(dg,0), toY(dg,hGround+metrics.hAbove)-4);

		ctx.font = "12px arial";
		ctx.fillStyle = 'white'; 
		{
			const txt = "\u2193Gravel weight "+Math.round(metrics.pHighActual/1000)+" kPa";
			ctx.fillText(txt, toX(dg,-metrics.dome.rTop), toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop));
			ctx.fillText("Insulated with sorted gravel+stone wool 50/50 mix", toX(dg,-metrics.dome.rTop)+20+ctx.measureText(txt).width, toY(dg,metrics.dome.hBottomI+5));
		}
		if (powerAndHeat) {
			ctx.beginPath();
			{
				const y1 = toY(dg,hGround+metrics.hAbove)-1;
				const y2 = toY(dg,hGround+hLpHot)-2;
				const x1 = toX(dg,metrics.rTop*0.10);
				const x2 = toX(dg,metrics.rTop)-5;
				const x3 = toX(dg,metrics.rTop+metrics.toSideX(metrics.hAbove-hLpHot+2)+xyAddRoof+4) + 20;
				
				ctx.lineWidth = 1;
				ctx.strokeStyle='black';
				for (x = x1; x < x2; x +=5) {
					ctx.beginPath();
					ctx.moveTo(x, y1);
					ctx.lineTo(x, y2);
					ctx.stroke();
				}
				ctx.lineWidth = 3;
				ctx.strokeStyle='red';
				ctx.beginPath();
				ctx.moveTo(x1, y1+2);
				ctx.lineTo(x3, y1+2);
				ctx.stroke();
				ctx.strokeStyle='blue';
				ctx.beginPath();
				ctx.moveTo(x1, y2);
				ctx.lineTo(x3, y2);
				ctx.stroke();
	/*			
				ctx.moveTo(toX(dg,metrics.rTop+1), y1);
				ctx.lineTo(toX(dg,metrics.rTop+xyAddRoof+4),y);
				ctx.lineTo(toX(dg,metrics.rTop+metrics.toSideX(metrics.hAbove-hLpHot+2)+xyAddRoof+4),y = toY(dg,hGround+hLpHot-2));
				ctx.lineTo( x=toX(dg,metrics.rTop+1+metrics.toSideX(metrics.hAbove-hLpHot+2)),y );
				ctx.closePath();
				ctx.stroke();
	*/
			}
			x=toX(dg,metrics.rTop+1+metrics.toSideX(metrics.hAbove-hLpHot+2));
			/*
			ctx.font = "bold 20px arial";
			ctx.fillStyle = colorHotLpGravel; 
			ctx.fillText("\u21D2", toX(dg,metrics.rTop), toY(dg,hGround+metrics.hAbove-7));
			ctx.fillStyle = colorWarmLpGravel; 
			ctx.fillText("\u21D0", x-5, y+6);
			*/
			ctx.font = "14px arial";
			ctx.fillStyle = 'black'; 
			ctx.fillText((cycleData ? workToMW(cycleData.heatOutInDischarge) : '')+" for heating or combined power", toX(dg,metrics.rTop+xyAddRoof+metrics.toSideX(10)), toY(dg,hGround+metrics.hAbove));
		}
/*
		ctx.font = "20px serif";
		ctx.fillText("\u21DC", xGeneratorLeft-20, toY(dg, towerH-14));
		ctx.fillStyle = 'white'; 
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.2 * lpActH));
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.3 * lpActH));
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.4 * lpActH));
		ctx.fillText("\u21D4", towerLeftX-12, hMaxTopLiquid+4);
		ctx.fillStyle = 'black'; 
		ctx.fillText("\u21D5", toX(dg,metrics.rCylinder)-8, hpStorageTopY+6);
*/

$("#"+canvasId).css('display','block');
return;
}
	
	function drawDiagram4Y( canvasId, xVals, xTitle, arrayOfyVals, yTitles, topTitle, bottomLines ) {
//console.log("X lines...");
		const dg = {};
		const canvas = document.getElementById(canvasId);
		const ctx = canvas.getContext("2d");
		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black'; 
		dg.ctx = ctx;
		dg.ySign = 1;
		ctx.font = "8px Arial";
		dg.marginX = ctx.measureText(yTitles[0]).width + 6;
		dg.marginTop = topTitle ? (topTitle.indexOf(',')>0 ? 50 : 30) : 10;
		dg.baseX = 0;
		dg.baseY = 0;
		dg.marginBottom = 10 + (bottomLines ? bottomLines.length * 10 : 0);
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		dg.width = canvas.getAttribute("width");
		dg.cWidth = dg.width - 2 * dg.marginX;
		dg.height = canvas.getAttribute("height");
		dg.cheight = dg.height - dg.marginTop - dg.marginBottom;
		if (topTitle) {
			ctx.font = "15px serif";
			var subTitle = null;
			const iPos = topTitle.indexOf(',');
			if (iPos>0) {
				subTitle = topTitle.substring(iPos+1);
				topTitle = topTitle.substring(0, iPos);
			}
			textOnWhite(ctx, topTitle, (dg.width-ctx.measureText(topTitle).width) / 2, 17);
			if (subTitle) {
				textOnWhite(ctx, subTitle, (dg.width-ctx.measureText(subTitle).width) / 2, 37);
			}
		}
		const xMinMax = minMaxVal( dg, xVals );
		var yMinMax = minMaxVal( dg, arrayOfyVals[0] );
//console.log("xMinMax="+JSON.stringify(xMinMax)+"yMinMax="+JSON.stringify(yMinMax)); 
		dg.maxX = xMinMax.max + xMinMax.step / 2;
		dg.minX = xMinMax.min - xMinMax.step / 2;
		dg.maxY = yMinMax.max + yMinMax.step / 2;
		dg.minY = yMinMax.min - yMinMax.step / 2;
console.log("dg:"+JSON.stringify(dg));
		ctx.beginPath();
		ctx.setLineDash([]);
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.moveTo(toX(dg,dg.minX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.maxX), toY(dg, dg.minY));
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,dg.minX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.minX), toY(dg, dg.maxY));
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,dg.maxX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.maxX), toY(dg, dg.maxY));
		ctx.stroke();

		var t, x, i;
		ctx.fillStyle = 'grey';
		ctx.strokeStyle = 'grey';
		ctx.font = "8px Arial";
		const height = dg.marginTop + dg.cheight + 10;
		ctx.strokeStyle = 'grey';
//console.log("X- lines...");
		for (t = xMinMax.min; t <= xMinMax.max; t += xMinMax.step) {
			ctx.beginPath();
			ctx.setLineDash([10,10]);
			ctx.moveTo(x = toX(dg, t), toY(dg, dg.minY));
			ctx.lineTo(x, toY(dg, dg.maxY));
			ctx.stroke();
//console.log(t+": ("+x+","+toY(dg, yMinMax.min)+")->("+x+","+toY(dg, yMinMax.max)+")");
			textOnWhite(ctx,''+t, x, height);
		}
		dg.xDone = true;
		if (xTitle) textOnWhite(ctx, xTitle, dg.width-dg.marginX, height);

//console.log("Y- lines...");
		var usedYs = [];
		for (i = 0; i < arrayOfyVals.length; i++) {
			ctx.font = "10px Arial";
			const yVals = arrayOfyVals[i];
			if (yVals[0] == null) continue;
			yMinMax = minMaxVal( dg, yVals );
			
//console.log("yMinMax="+JSON.stringify(yMinMax)); 
			dg.maxY = yMinMax.max + yMinMax.step / 2;
			dg.minY = yMinMax.min - yMinMax.step / 2;
			if (i == 1) {
				ctx.strokeStyle = 'red';
				ctx.fillStyle = 'red'; 
			}
			else if (i == 2) {
				ctx.strokeStyle = 'green';
				ctx.fillStyle = 'green'; 
			}
			else if (i == 3) {
				ctx.strokeStyle = 'blue';
				ctx.fillStyle = 'blue'; 
			}
			else if (i == 4) {
				ctx.strokeStyle = 'purple';
				ctx.fillStyle = 'purple'; 
			}
			var p, y, j;
			var textX;
			
			for (p = yMinMax.min; p <= (yMinMax.max + yMinMax.step/4); p += yMinMax.step) {
				y = toY(dg, p);
				if (i == 0) {
					ctx.beginPath();
					ctx.setLineDash([10,10]);
					ctx.strokeStyle = 'gray';
					ctx.moveTo( toX(dg, dg.minX), y);
					ctx.lineTo( toX(dg, dg.maxX), y);
					ctx.stroke();
					ctx.strokeStyle = 'black';
				}
				const text = ''+myRound(p)
				if (i == 0) {
					textX = dg.marginX - 2 - ctx.measureText(text).width;
					if (textX <= 0) textX = 1;
				}
				else if (i == 1) textX = dg.marginX + 2;
				else if (i == 2) {
					textX =  dg.marginX + dg.cWidth - 2 - ctx.measureText(text).width;
				}
				else if (i == 3) textX = dg.marginX + dg.cWidth + 2;
//console.log(i+": titleX="+textX+", titleY="+(y-1)+", text="+text);
				textOnWhite(ctx, text, textX, y-1);
			}
			if (i == 0) {
				textX = dg.marginX - 1 - ctx.measureText(yTitles[i]).width;
				if (textX <= 0) textX = 1;
			}
			else if (i == 1) textX = dg.marginX + 1;
			else if (i == 2) {
				textX =  dg.marginX + dg.cWidth - 1 - ctx.measureText(yTitles[i]).width;
			}
			else if (i == 3) textX = dg.marginX + dg.cWidth + 1;
			if (i <= 3) {
				textOnWhite(ctx, yTitles[i], textX, dg.marginTop-1);
			}
			if (bottomLines && i < bottomLines.length) {
				ctx.font = "12px Arial";
				if (i < 3) {
					textOnWhite(ctx, bottomLines[i], 10, dg.marginTop + dg.cheight + 30 + 15 * i );
				}
				else {
					textOnWhite(ctx, bottomLines[i], dg.cWidth/2, dg.marginTop + dg.cheight + 30 + 15 * (i-3) );
				}
			}
			ctx.beginPath();
			y = toY(dg,yVals[0]);
//console.log("Y="+Math.round(y));
			if (usedYs.includes(Math.round(y/10))) {
				ctx.setLineDash([]); 
			}
			else {
				ctx.setLineDash([10,10]); 
			}
			usedYs.push(Math.round(y/10));
			//y = Math.round(toY(dg,yVals[0]));
			//var dashStart = usedYs.includes(y) ? 14.14 : 0;
			//usedYs.push(y);
			//ctx.moveTo(toX(dg,xVals[0])+dashStart, y + y > yVals[1] ? -dashStart : dashStart);
			ctx.moveTo(toX(dg,xVals[0]), y);
//console.log(i+": x="+toX(dg,xVals[0])+", y="+toY(dg,yVals[0]));
			for (j = 1; j < yVals.length; j++) {
				if (j == xVals.length) break;
				ctx.lineTo(toX(dg,xVals[j]), toY(dg,yVals[j]));
//console.log(i+": x="+toX(dg,xVals[j])+", y="+toY(dg,yVals[j]));
			}
			ctx.stroke();
			if (j < yVals.length) {
				var yFrom = xVals.length;
				var yTo = yFrom + xVals.length;
				ctx.strokeStyle = 'purple';
				ctx.fillStyle = 'purple'; 
				ctx.beginPath();
				ctx.moveTo(toX(dg,xVals[0]), toY(dg,yVals[j]));
				for (; j < yTo; j++) {
					ctx.lineTo(toX(dg,xVals[j-yFrom]), toY(dg,yVals[j]));
//console.log(i+": x="+toX(dg,xVals[j-yFrom])+", y="+toY(dg,yVals[j]));
				}
				ctx.stroke();
				if (bottomLines && (i+1) < bottomLines.length) {
					textOnWhite(ctx, bottomLines[i+1], dg.cWidth/2, dg.marginTop + dg.cheight + 30 + 15 * (i-2) );
				}
				if (j < yVals.length) {
					yFrom = xVals.length*2;
					yTo = yFrom + xVals.length;
					ctx.strokeStyle = 'orange';
					ctx.fillStyle = 'orange'; 
					ctx.beginPath();
					ctx.moveTo(toX(dg,xVals[0]), toY(dg,yVals[j]));
					for (; j < yVals.length; j++) {
						ctx.lineTo(toX(dg,xVals[j-yFrom]), toY(dg,yVals[j]));
//console.log(j+": yVal="+yVals[j]+", x="+toX(dg,xVals[j-yFrom])+", y="+toY(dg,yVals[j]));
					}
					ctx.stroke();
					if (bottomLines && (i+2) < bottomLines.length) {
						textOnWhite(ctx, bottomLines[i+2], dg.cWidth/2, dg.marginTop + dg.cheight + 30 + 15 * (i-1) );
					}
				}
			}
		}
		$("#"+canvasId).css('display','block');
	}
	
	function iDrawBraytonCycle( canvasId, hotCycle, coldCycle, cycleData ) 
	{
console.log("drawBraytonCycle..., maxPressure="+maxPressure);
		var canvas = document.getElementById(canvasId);
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		width = canvas.getAttribute("width");
		cWidth = width -2*marginX;
		height = canvas.getAttribute("height");
		cheight = height - 2*marginY;

//console.log("cWidth="+cWidth+", cheight="+cheight);
		var tDiff = maxTemp-minTemp; 
		var pDiff = maxPressure-minPressure;
		var showEnthalpyAndInternalEnergy=getBooleanParam("showEnthalpyAndInternalEnergy", false);
		
		minTemp = 0; // (minTemp - tDiff*0.05) > 0 ? Math.floor(minTemp - tDiff*0.05) : Math.floor(tTriplePoint+1);
		minPressure = 0; //(minPressure - pDiff*0.05) > 0 ? Math.floor((minPressure - pDiff*0.05)/1000) * 1000 : Math.floor(minPressure/1000) * 1000;
		//if (minPressure == 0) minPressure = 1000;

		var hMinTemp = minTemp;
		while (Math.floor(Module.PropsSI('H', 'T', hMinTemp, 'P', minPressure+1000, name) == 'Infinity')) {
			hMinTemp += 1;
			if (hMinTemp > 300) {
				console.log("out of scope: Module.PropsSI('H', 'T', "+hMinTemp+", 'P', "+(minPressure+1000)+", '"+name+"')=='Infinity'");
				return;
			}
		}
		minTemp = hMinTemp;
		maxPressure = Math.ceil((maxPressure + pDiff*0.05)/1000) * 1000;
console.log("maxPressure="+maxPressure+", ((maxPressure + "+pDiff+"*0.05)/1000="+((maxPressure + pDiff*0.05)/1000));
/*		
		var yPower = 1;
		Math.pow((maxPressure - p)/(maxPressure-minPressure), yLog)
		while (Math.pow((maxPressure - pCrit)/(maxPressure-minPressure), 1/yPower) > 2/3) {
			yPower -= 0.01;
		}
		yLog = 1/yPower;
if (!confirm("yPower="+yPower+" => yLog="+yLog)) return;
console.log("yPower="+yPower+" => yLog="+yLog);
*/
		maxTemp = Math.ceil(maxTemp + tDiff*0.05);
console.log("minPressure="+minPressure+", minTemp="+minTemp);
//console.log(JSON.stringify(turbinStages[turbinStages.length-1]));
//console.log(JSON.stringify(compressorStages[compressorStages.length-1].pOut));
		// TBD Available turbin work by background color, log-scale?????
//console.log("x="+tToX(minTemp)+", pToY("+minPressure+")="+pToY(minPressure)+", maxPressure="+maxPressure);
		// draw x - y coordinate lines
		ctx.beginPath();
		ctx.setLineDash([]);
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.moveTo( tToX(minTemp), pToY(minPressure));
		optimzedLineTo(ctx,tToX(maxTemp), pToY(minPressure));
		ctx.stroke();
		ctx.moveTo( tToX(minTemp), pToY(minPressure));
		optimzedLineTo(ctx, tToX(minTemp), pToY(maxPressure));
		ctx.stroke();

		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black'; 

		// draw temp and temp lines, 
		// some max-min temps values: 0.1 Hydrogen: 30, Nitrogen: 65, Methane: 120, CarbonDioxide: 200, Water: 340
		// some max-min pressure values: Hydrogen(0.3): 350 kPa, Nitrogen: 600 kPa,  Methane: 2000 kPa, CarbonDioxide: 4000 kPa, Water: 2000 kPa
		ctx.font = "8px Arial";
		var tStep = 1;	// 2, 4, 8
		var pStep = 1;  //1, 2, 4, 8, 16, 32, 64 kPa ...
		// OK, if less than 55 vertical lines  44 horisontal ones
		while (((maxTemp-minTemp)/tStep) > 40) {
			if (tStep == 1)  tStep = 2;
			else if (tStep == 2) tStep = 5;
			else if (tStep == 5) tStep = 10;
			else if (tStep == 10) tStep = 20;
			else if (tStep == 20) tStep = 50;
			else {
				console.log("too many tSteps="+((maxTemp-minTemp)/tStep)); 
				break;
			}
		}
		while ((((maxPressure-minPressure)/1000)/pStep) > 30) {
			if (pStep == 1) pStep = 2;
			else if (pStep == 2) pStep = 5;
			else if (pStep == 5) pStep = 10;
			else if (pStep == 10) pStep = 20;
			else if (pStep == 20) pStep = 50;
			else if (pStep == 50) pStep = 100;
			else if (pStep == 100) pStep = 200;
			else if (pStep == 200) pStep = 500;
			else if (pStep == 500) pStep = 1000;
			else {
				console.log("too many pSteps="+(((maxPressure-minPressure)/1000)/pStep)); 
				break;
			}
		}
console.log("Temp lines...");
		var t, p, h, x, y;
		const tInc = (maxTemp-minTemp)/cWidth * 5;
		ctx.strokeStyle = 'grey';
		for (t = minTemp; t < maxTemp; t++) {
			if ((t % tStep) == 0) {
				ctx.beginPath();
				ctx.moveTo( x = tToX(t), pToY(minPressure));
				optimzedLineTo(ctx, x, pToY(maxPressure));
				ctx.stroke();
				ctx.fillStyle = 'black';
				if (t < (maxTemp-50)) {
					textOnWhite(ctx,''+t, x, height);
				}
			}
		}
		textOnWhite(ctx,'T K', width-marginX, height);
console.log("Pressure- lines...");
		for (p = minPressure; p < maxPressure; p += 1000) {
			if (((p/1000) % pStep) == 0) {
				ctx.beginPath();
				ctx.moveTo( tToX(minTemp), y = pToY(p));
				optimzedLineTo(ctx,tToX(maxTemp), y);
				ctx.stroke();
				ctx.fillStyle = 'black'; 
				textOnWhite(ctx,''+Math.round(p/1000), 1, y+1);
			}
		}
		textOnWhite(ctx,'P kPa', 1, 10);

		ctx.lineWidth = 1;
		var hMin = Math.floor((Module.PropsSI('H', 'T', hMinTemp, 'P', maxPressure, name)+9999)/10000) * 10000;
		while (hMin == 'Infinity') {
			hMin = Math.floor((Module.PropsSI('H', 'T', ++hMinTemp, 'P', maxPressure, name)+9999)/10000) * 10000;
			if (hMinTemp > 300) {
	console.log("ERROR: Module.PropsSI('H', 'T', "+hMinTemp+", 'P', "+maxPressure+", "+name+")="+Module.PropsSI('H', 'T', hMinTemp, 'P', maxPressure, name));
				return;
			}
		}
		var hMax = Math.floor(Module.PropsSI('H', 'T', maxTemp, 'P', minPressure+1000, name)/10000) * 10000;
		while (hMax == 'Infinity') {
console.log("ERROR: Module.PropsSI('H', 'T', "+maxTemp+", 'P', "+(minPressure+1000)+", "+name+")="+Module.PropsSI('H', 'T', maxTemp, 'P', (minPressure+1000), name));
			return;
		}
		ctx.strokeStyle = 'green';
		const tSatInMinP = Module.PropsSI('T', 'P', minPressure+1000, 'Q', 0, name);
		var hNextBottom = 0, hNextSat = 0, hNextTop = 0;
		const pInc = Math.round((maxPressure - minPressure)/cheight)*10;	// 

		if (showEnthalpyAndInternalEnergy) {
			var hInc = 10000;
			while ((hMax-hMin)/hInc > 50) {
				if (hInc == 10000) hInc = 20000;
				else if (hInc == 20000) hInc = 50000;
				else if (hInc == 50000) hInc = 100000;
				else if (hInc == 100000) hInc = 200000;
				else if (hInc == 200000) hInc = 500000;
				else if (hInc == 500000) hInc = 1000000;
				else {
					console.log("Too many enthalpy steps: "+((hMax-hMin)/hInc)+" > 45");
					break;
				 }
			}
	console.log("Enthalpy- lines... hInc="+(hInc/1000)+", hMin="+(hMin/1000)+", hMax="+(hMax/1000)+", pInc="+pInc );
			for (h = hMin; h <= hMax; h += hInc) {
				var isFirst = true;
				ctx.beginPath();
				for (p = minPressure+1000; p <= maxPressure; p += pInc) {
					var tSat = Module.PropsSI('T', 'P', p, 'Q', 0, name);
					t = Module.PropsSI('T', 'P', p, 'H', h, name);
					if (t > maxTemp && t != 'Infinity') {
						break;
					}
					if (isFirst && tSat != 'Infinity' && Math.abs(t-tSat)<0.001) {
						;
					}
					else if (t != 'Infinity' && (x = tToX(t)) != 'Infinity' && t >= minTemp) {
						if (isFirst) {
							const hText = 'h='+ (h/1000)+ ' J/g';
							const textWidth = ctx.measureText(hText).width;
							if ((p == minPressure && x >= hNextBottom) || (p > minPressure && tSat != 'Infinity' && (x-textWidth) > hNextSat)) {
								if (p == minPressure) {
									if (t < maxTemp && h > hMin) {
										textOnWhite(ctx,hText, x+1, pToY(p));
										hNextBottom = x + textWidth;
									}
								}
								else {
	//console.log("h="+h+", hNextSat="+hNextSat+", hText="+hText+", x="+(x-textWidth)+", y="+(pToY(p))+", t="+t+", p="+p+", tSat="+tSat);
									if (h > hMin) {
										textOnWhite(ctx,hText, x-textWidth, pToY(p));
									}
									hNextSat = x;
								}
							}
							ctx.moveTo( x, pToY(p));
							isFirst = false;
						}
						else {
							optimzedLineTo(ctx, x, pToY(p));
						}
					}
					else if (!isFirst && (t == 'Infinity' ||  x == 'Infinity')) {
						break;
					}
				}
				ctx.stroke();
				x = tToX(t) ;
				{
					if (p < maxPressure) {
	//console.log("h="+h+", p="+p+", t="+t);
						textOnWhite(ctx,(h/1000)+' J/g', t != 'Infinity' && t >= (maxTemp) ? tToX(maxTemp) : tToX(t == 'Infinity' ? minTemp : t), pToY(p)+10);
					}
					else if (x != 'Infinity' && x >= hNextTop) {
						var hText = 'h='+ (h/1000)+ ' J/g';
						if (t < maxTemp && h > hMin) {
							textOnWhite(ctx,hText, x, pToY(maxPressure));
							hNextTop = x + ctx.measureText(hText).width;
						}
	//console.log("hNextTop: "+hNextTop+"="+x+" + "+ctx.measureText(hText).width+", t="+t);
					}
				}
			}
		}
		if (false) {
			ctx.beginPath();
			var d;
			ctx.lineWidth = 1;
			const dMin = Math.ceil(Module.PropsSI('D', 'T', maxTemp, 'P', minPressure, name)/10) * 10;
			const dMax = Math.floor(Module.PropsSI('D', 'T', minTemp, 'P', maxPressure, name)/10) * 10;
			ctx.strokeStyle = 'brown';
			var xNextBottom = 9999, xNextTop = 9999;
			for (d = dMin; d <= dMax; d += 10) {
				var isFirst = true;
				ctx.beginPath();
				ctx.setLineDash([5, 10]);
				for (p = minPressure+1000; p <= maxPressure-1000; p += pInc) {
					t = Module.PropsSI('T', 'P', p, 'D', d, name);
					if (t >= maxTemp) break;
					if (t != 'Infinity' && t > minTemp) {
						if (isFirst)
						{
							x = tToX(t);
							if (x <= xNextBottom) {
								var dText = d+' kg/m3';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x - ctx.measureText(dText).width;
							}
							ctx.moveTo( tToX(t), pToY(p));
							isFirst = false;
						}
						else {
							optimzedLineTo(ctx, tToX(t), pToY(p));
						}
					}
				}
				ctx.stroke();
				x = tToX(t);
				if (p < (maxPressure-1000)) {
					textOnWhite(ctx,d+' kg/m3', tToX(maxTemp)-10, pToY(p)+10);
				}
				else if (x < xNextTop) {
					var dText = d+' kg/m3';
					textOnWhite(ctx,dText, x, pToY(maxPressure)+20);
					xNextTop = x - ctx.measureText(dText).width;
				}
			}
			ctx.setLineDash([]);
		}
		var tFix = 0;
		var dMin = Math.ceil(Module.PropsSI('S', 'T', minTemp, 'P',maxPressure, name)/100)*100;
		while (dMin == 'Infinity') {
			tFix++;
			dMin = Math.ceil(Module.PropsSI('S', 'T', minTemp+tFix, 'P',maxPressure, name)/100)*100;
		}
		if (showEnthalpyAndInternalEnergy) {
			var d, sInc = 100;
			ctx.lineWidth = 1;
			const dMax = Math.floor(Module.PropsSI('S', 'T', maxTemp, 'P', minPressure+200000, name)/100)*100;
			while ((dMax-dMin)/sInc > 40) {
				if (sInc == 100) sInc = 200;
				else if (sInc == 200) sInc = 500;
				else if (sInc == 500) sInc = 1000;
				else if (sInc == 1000) sInc = 2000;
				else if (sInc == 2000) sInc = 5000;
				else if (sInc == 5000) sInc = 10000;
				else if (sInc == 10000) sInc = 20000;
				else if (sInc == 20000) sInc = 50000;
				else if (sInc == 50000) sInc = 100000;
				else {
					console.log("Too may entropy steps: "+((dMax-dMin)/sInc));
					break;
				 }
			}
console.log("sMin="+dMin+", sMax="+dMax+"(t="+maxTemp+", p="+(minPressure+200000)+"), sInc="+sInc);
			var xNextBottom = 0, xNextTop = 0;
			var minH = 100000000;
			hInc = hInc;
			var hLines = {};
			var sNum = 0;
			for (d = dMin; d <= dMax; d += sInc) {
				sNum++;
				var isFirst = true;
				ctx.beginPath();
				ctx.strokeStyle = 'purple';
				ctx.setLineDash([5, 10]);
				var prevH = -1, prevX, prevY;
				var pSat;
				for (t = minTemp+tFix; t <= maxTemp; t += tInc) {
					p = Module.PropsSI('P', 'T', t, 'S', d, name);
					if (p >= maxPressure && p != 'Infinity') break;
					if (p < 50000) continue;
					if (p != 'Infinity' && p > minPressure) {
						pSat = Module.PropsSI('P', 'T', t, 'Q', 0, name);
						if (pSat != 'Infinity' && Math.abs(p - pSat) < 0.00001) {
							//console.log("s="+d+" on sat. line: (p-pSat)="+(p - pSat));
						}
						else if (pSat != 'Infinity' && p > pSat) {
							//console.log("s="+d+", t="+t+", "+p+">"+pSat+"(pSat)");
							break;
						}
						else if (isFirst) {
							x = tToX(t);
							if (false && x >= xNextBottom) {
								var dText = (d == dMin ? 's=' : '') + (d/1000)+' J/g/K';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x + ctx.measureText(dText).width;
							}
							ctx.moveTo( prevX = tToX(t), prevY = pToY(p));
							isFirst = false;
						}
						else {
							var x = tToX(t), y = pToY(p);
							if (Math.abs((prevY-y)/(x - prevX)) > 2) {
//console.log("s="+d+", t="+t+", "+"Math.abs("+(prevY-y)+"/"+(x - prevX)+") > 2");
								break; // continue with pressure increments!
							}
							optimzedLineTo(ctx, x, y);
							const h1 = Module.PropsSI('H', 'P', p, 'S', d, name);
							const h2 = Module.PropsSI('H', 'P', p*1.001, 'S', d, name);
							const curH = Math.floor((h2-h1)*1000 / hInc);
							if (curH > prevH && (pSat === 'Infinity' || (p < pSat && (p*1.001)<pSat) || (p > pSat && (p*1.001) > pSat))) {
								if (minH > curH) minH = curH; 
								const hField = 'h'+curH;
								if (typeof hLines[hField] === 'undefined') {
									hLines[hField] = [];
								}
if (curH == 1) {
	//console.log((y-prevY)+"/"+(x - prevX)+",  (p-pSat)="+(p - pSat));
	//console.log(d+"=>"+hField+":tToX("+t+")="+x+", pToY("+p+")="+y+", (p*1.001)="+(p*1.001)+" < pSat="+pSat );
}
								hLines[hField].push(sNum+":"+Math.round(x)+';'+Math.round(y));
								prevH = curH;
							}
							prevX = x, prevY = y;
						}
					}
					else if (!isFirst && (p == 'Infinity' ||  tToY(p) == 'Infinity')) {
						console.log(p+" or "+tToY(p));
						break;
					}
				}
				if (pSat !== 'Infinity' && p > pSat) {
					p = pSat + 1;
				}
				// we must use presure steps when Internal energy line of S is going almost straight up!
//console.log("s="+d+", p="+p+", t="+t);
				for (; p <= maxPressure && p != 'Infinity'; p += pInc) {
					t = Module.PropsSI('T', 'P', p, 'S', d, name);
					if (t >= maxTemp && t != 'Infinity') break;
					if (t != 'Infinity' && t >= (minTemp+tFix)) {
						if (isFirst)
						{
							x = tToX(t);
							if (x >= xNextBottom) {
								var dText = (d == dMin ? 's=' : '') + (d/1000)+' J/g/K';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x + ctx.measureText(dText).width;
							}
							ctx.moveTo( tToX(t), pToY(p));
							isFirst = false;
						}
						else {
							var x, y;
							optimzedLineTo(ctx, x = tToX(t), y = pToY(p));
							const h1 = Module.PropsSI('H', 'P', p, 'S', d, name);
							const h2 = Module.PropsSI('H', 'P', p*1.001, 'S', d, name);
/*var pSat = Module.PropsSI('P', 'T', t, 'Q', 0, name);
if (pSat != 'Infinity' && (p-pSat) < 3*pInc)
{
	console.log(d+"/"+p+"/"+t+":"+((h2-h1)*1000 / hInc));
}*/
							const curH = Math.floor((h2-h1)*1000 / hInc);
							if (curH > prevH) {
								if (minH > curH) minH = curH; 
								const hField = 'h'+curH;
								if (typeof hLines[hField] === 'undefined') {
									hLines[hField] = [];
								}
if (curH == 1) {
	//console.log(d+"=>"+hField+":tToX("+t+")="+x+", pToY("+p+")="+y);
}
								hLines[hField].push(sNum+":"+Math.round(x)+';'+Math.round(y));
								prevH = curH;
							}
						}
					}
					else if (!isFirst && (t == 'Infinity' ||  tToX(t) == 'Infinity')) {
						console.log("t == 'Infinity'");
						break;
					}
				}
//console.log("s="+d+", p="+p+", t="+t);
				ctx.stroke();
				
				x = tToX(t);
//console.log("t="+t+", p="+p+", x="+x+", xNextTop="+xNextTop+", s="+(d/1000));
				if (p < (maxPressure-1000)) {
					textOnWhite(ctx,(d/1000)+' J/g/K', tToX(maxTemp)-30, pToY(p)+20);
				}
				else if (t != 'Infinity' && x > xNextTop) {
					var dText = (d/1000)+' J/g/K';
					textOnWhite(ctx,dText, x, pToY(maxPressure)+20);
					xNextTop = x + ctx.measureText(dText).width;
				}
			}
		}
console.log("Saturation curve ...");
		// Saturation curve + Critical Point!!
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.setLineDash([]);
		//ctx.setLineDash([10, 0]);
		var isFirst = true;
		for (t = minTemp+tFix; t <= tCrit; t += tInc) {
			p = Module.PropsSI('P', 'T', t, 'Q', 0, name);
			if (p == 'Infinity') continue;
			else break;
		}
		for (; p <= pCrit; p += pInc) {
			t = Module.PropsSI('T', 'P', p, 'Q', 0, name);
			if (t == 'Infinity') continue;
			if (p > maxPressure) {
				ctx.strokeStyle = 'black';
				ctx.stroke();
				break;
			}
			if (p >= minPressure+1000) {
				if (isFirst) {
					ctx.moveTo( tToX(t), pToY(p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(t), pToY(p));
				}
			}
		}
		if (p <= maxPressure) {
			optimzedLineTo(ctx, tToX(tCrit), pToY(pCrit));
			ctx.strokeStyle = 'black';
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite(ctx,'C.P: '+myRound(tCrit,1)+' K,'+Math.round(pCrit/1000)+' kPa', tToX(tCrit)-100, pToY(pCrit)); //  ()
		}
		if (false && minTemp <= tTriplePoint && minPressure <= pTriplePoint) {
			ctx.beginPath();
			ctx.moveTo( tToX(tToX(tTriplePoint)), pToY(pTriplePoint));
			ctx.lineWidth = 2;
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite(ctx,'T.P.', tToX(tTriplePoint), pToY(pTriplePoint)-14);
			//textOnWhite(ctx,'T.P. ('+tTriplePoint+' K, '+(pTriplePoint/1000)+' kPa)', tToX(tTriplePoint), pToY(pTriplePoint)-14);
		}

		// TBD Turbin/compressor curves + reheating/cooling lines
		//var allStages = turbinStages.concat(compressorStages);
		var i, j;
		ctx.lineWidth = 1;
		ctx.beginPath();
		if (hotCycle) {
			ctx.setLineDash([10, 0]);
			ctx.beginPath();
			hotCycle[0].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'red';
			ctx.stroke();
			drawDirectionArrow( ctx, hotCycle[0], hotCycle[0].pIn*0.50, 15, false, "Gas flow in discharge "+Math.round(hotCycle[0].massFlow*1000)+" kg/s" );
			//showPointData(ctx, hotCycle[0], FIRST_ITEM, -300, -30, hotCycle[1].massFlow, hotCycle[0].massFlow );
			showPointData(ctx, hotCycle[0], FIRST_ITEM, -350, 35, hotCycle[0].massFlow);
			showPointData(ctx, hotCycle[1], FIRST_ITEM, -350, -25, hotCycle[1].massFlow);
			showPointData(ctx, hotCycle[0], LAST_ITEM, 10, 10, hotCycle[0].massFlow );
			ctx.beginPath();
			hotCycle[1].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'green';
			ctx.stroke();
			drawDirectionArrow( ctx, hotCycle[1], hotCycle[1].pOut*0.45, 15, true, "Gas flow in charge "+Math.round(hotCycle[1].massFlow*1000)+" kg/s" );
			showPointData(ctx, hotCycle[1], LAST_ITEM, 16, -16, hotCycle[1].massFlow );

		}
		if (coldCycle) {
			ctx.beginPath();
			ctx.setLineDash([10, 0]);
			coldCycle[0].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'red';
			ctx.stroke();
			drawDirectionArrow( ctx, coldCycle[0], maxPressure*0.40, 15, false );
			showPointData(ctx, coldCycle[0], FIRST_ITEM, 25, 25, coldCycle[0].massFlow );
			//showPointData(ctx, coldCycle[0], LAST_ITEM, 20, -40,  );
			ctx.beginPath();
			coldCycle[1].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'green';
			ctx.stroke();
			showPointData(ctx, coldCycle[1], FIRST_ITEM, -15, -15, coldCycle[1].massFlow  );
			const item0 = coldCycle[0].items[0];
			showPointData(ctx, coldCycle[1], LAST_ITEM, 40, -40, coldCycle[1].massFlow, coldCycle[0].massFlow, item0.p, item0.t, item0.wetness );

			drawDirectionArrow( ctx, coldCycle[1], maxPressure*0.30, 15, coldCycle[1].isForward );
			
			if (cycleData.heatPumpNetWorkIn) {
//console.log("pTransformer="+JSON.stringify(pTransformer));
				const fillStyle = ctx.fillStyle;
				/*ctx.fillStyle = 'white';
				ctx.strokeStyle = 'white';
				ctx.rect( tToX(coldCycle[2].tOut)-10, pToY(coldCycle[0].pOut+400000)-10, tToX(coldCycle[3].tOut)+10, pToY(coldCycle[0].pOut+200000)+10);
				ctx.fill(); */
				pTransformer = {};
				pTransformer.highFrom = coldCycle[2].pIn;
				pTransformer.lowFrom = coldCycle[2].pOut;
//		maxPressure = pHigh * 18 / 12.5;
				pTransformer.lowTo = maxPressure / 18 * 15;
				pTransformer.highTo = maxPressure / 18 * 17;

				ctx.fillStyle = fillStyle;
				ctx.strokeStyle = 'green';
				isFirst = true;
				coldCycle[2].items.forEach( function(item) {
					if (isFirst) {
						ctx.moveTo( tToX(item.t), pToY(item.p));
						isFirst = false;
					}
					else {
						optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
					}
				});
				isFirst = true;
				ctx.stroke();
				drawDirectionArrow( ctx, coldCycle[2], (coldCycle[2].pIn+coldCycle[2].pOut)/2, 15, false );
				var i1, i2, i3, i4;
				i1 = showPointData(ctx, coldCycle[2], LAST_ITEM, -40, 20 );
				i2 = showPointData(ctx, coldCycle[2], FIRST_ITEM, 15, -15, coldCycle[3].massFlow );
				ctx.beginPath();
				coldCycle[3].items.forEach( function(item) {
					if (isFirst) {
						ctx.moveTo( tToX(item.t), pToY(item.p));
						isFirst = false;
					}
					else {
						optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
					}
				});
				ctx.stroke();
				drawDirectionArrow( ctx, coldCycle[3], (coldCycle[3].pIn+coldCycle[3].pOut)/2, 15, false );
				i3 = showPointData(ctx, coldCycle[3], FIRST_ITEM, 15, 5 );
				i4 = showPointData(ctx, coldCycle[3], LAST_ITEM, 15, 5 );

				ctx.setLineDash([10, 10]);
				ctx.beginPath();
				ctx.moveTo( tToX(i1.t), pToY(i1.p));
				ctx.lineTo( tToX(i4.t), pToY(i4.p));
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo( tToX(i2.t), pToY(i2.p));
				ctx.lineTo( tToX(i3.t), pToY(i3.p));
				ctx.stroke();
				pTransformer = {};
			}
		}
		if (hotCycle && coldCycle) {
			ctx.beginPath();
			ctx.lineWidth = 1;
			ctx.setLineDash([4, 4]);
			ctx.lineDashOffset = 0;

			var y, x1, x2;
			ctx.moveTo( tToX(coldCycle[0].tOut), pToY(coldCycle[0].pOut));
			drawPressureDropInPipe( ctx, coldCycle[0].pOut, hotCycle[1].pOut, coldCycle[0].tOut )
			drawPressureDropInPipe( ctx, coldCycle[0].pOut, hotCycle[1].pOut, coldCycle[0].tOut )
			ctx.lineTo( tToX(hotCycle[0].tIn), pToY(hotCycle[0].pIn));
			ctx.strokeStyle = 'red';
			ctx.stroke();

			ctx.beginPath();
			ctx.setLineDash([4, 4]);
			ctx.lineDashOffset = 5;
			ctx.moveTo( tToX(coldCycle[1].tIn), pToY(coldCycle[1].pIn) );
			drawPressureDropInPipe( ctx, coldCycle[1].pIn, hotCycle[0].pIn, coldCycle[1].tIn )
			ctx.lineTo( tToX(hotCycle[1].tOut), pToY(hotCycle[1].pOut));
			ctx.strokeStyle = 'green';
			ctx.stroke();
			
			ctx.beginPath();
			ctx.setLineDash([10, 10]);
			ctx.lineDashOffset = 0;
			ctx.moveTo( tToX(coldCycle[0].tIn), pToY(coldCycle[0].pIn));
			drawPressureDropInPipe( ctx, coldCycle[0].pIn, hotCycle[0].pOut, coldCycle[0].tIn )
			ctx.lineTo( tToX(hotCycle[0].tOut), y = pToY(hotCycle[0].pOut));
			ctx.strokeStyle = 'red';
			ctx.stroke();

			ctx.beginPath();
			ctx.setLineDash([10, 10]);
			ctx.lineDashOffset = 10;
			ctx.moveTo(tToX(coldCycle[1].tOut), pToY(coldCycle[1].pOut));
			drawPressureDropInPipe( ctx, coldCycle[1].pOut, hotCycle[1].pIn, coldCycle[1].tOut )
			ctx.lineTo( tToX(hotCycle[1].tIn), pToY(hotCycle[1].pIn));
			ctx.strokeStyle = 'green';
			ctx.stroke();

			const powerAndHeat = metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false );

			ctx.font = "15px serif";
			x = width/5-25;
			y = height/2.5;
			ctx.fillStyle = 'black'; 
			textOnWhite( ctx, "Energy storage charge/discharge power for "+name+" gas flow "+Math.round(hotCycle[1].massFlow*1000)+"/"+Math.round(hotCycle[0].massFlow*1000)+" kg/s and turbin/compressor stage efficiency "+getFloatParam('tEfficiency', 0.90)+"/"+getFloatParam('cEfficiency', 0.90), x, y );
			y += 20;
			var title = "Metrics of "+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million gravel ton "+Math.round(cycleData.storedEnergy_kWh/1000000)+" GWh energy storage";
			
			const ucGeneratorLoss=(hotCycle[0].workProduced-coldCycle[0].workConsumed)*(1-metrics.generatorEfficiency);

//District heating power "+Math.round(hotCycle[1].tIn)+" K - "+Math.round(hotCycle[0].tOut)+" K: 
 			const cryogenicCooling = true;// getBooleanParam('cryogenicCooling');
			const adjustedCompressorPlow = getBooleanParam('adjustedCompressorPlow');
			ctx.fillStyle = 'red'; 
			textOnWhite( ctx, "Discharge cycle: gross output "+Math.round(hotCycle[0].workProduced/1000)+" MW - cold gas compression "
				+Math.round(coldCycle[0].workConsumed/1000)+" MW"+
				" - generator loss "+Math.round(ucGeneratorLoss/1000)+" MW = "+Math.round(cycleData.netWorkOut/1000)+ " MW"+(powerAndHeat ? " and "
				+Math.round(cycleData.heatOutInDischarge/1000)+" MW heat ("+Math.round(hotCycle[0].tOut)+"=>"+Math.round(hotCycle[1].tIn)+" K)" : ""), x, y );
			y += 20;
			// For the case when the efficiency is >=1
			const hotWorkConsumed = hotCycle[1].workConsumed ? hotCycle[1].workConsumed : hotCycle[1].workProduced;
			const cGeneratorLoss= (hotWorkConsumed-coldCycle[1].workProduced)*(1/metrics.generatorEfficiency-1); // + (cryogenicCooling ? cycleData.heatPumpNetWorkIn : 0);
			/*const totalWork = 
				cycleData.heatPumpNetWorkIn ? 
					hotCycle[0].workProduced + hotWorkConsumed + coldCycle[1].workProduced + coldCycle[0].workConsumed + cycleData.heatPumpNetWorkIn
					: hotCycle[0].workProduced + hotWorkConsumed + coldCycle[1].workProduced + coldCycle[0].workConsumed;*/
			ctx.fillStyle = 'green'; 
			textOnWhite( ctx, "Charge cycle: Compressor work "+Math.round(hotWorkConsumed/1000)+" MW"+" - cold gas expander "+Math.round((coldCycle[1].workProduced)/1000)+" MW"+
						" - generator loss "+Math.round(cGeneratorLoss/1000)+" MW = "+Math.round(cycleData.netWorkIn/1000)+" MW"+(cycleData.heatPumpNetWorkIn ? " + heat pump work "+Math.round(cycleData.heatPumpNetWorkIn/1000)+" MW" : ""), x, y );
			y += 20;
			if (cycleData.heatPumpNetWorkIn) {
				textOnWhite( ctx, "Heat pump: Work consumed "+Math.round(cycleData.heatPumpNetWorkIn/1000)+
							" MW, Heat produced "+Math.round(cycleData.heatPumpHeating/1000)+" MW ("+Math.round(coldCycle[3].tOut)+"=>"+(Math.round(coldCycle[3].tIn+metrics.heatExchangeDeltaT))+" K), Cooling "+Math.round(cycleData.heatPumpCooling/1000)+" MW"+
							", Internal heat exchange "+Math.round(cycleData.heatPumpHeatExchange/1000)+" MW", x, y );
				y += 20;
			}
			ctx.fillStyle = 'black';
			const gearLoss = cycleData.gearLoss1000 * 100 / cycleData.workConsumed1000;
			const generatorLoss = cycleData.generatorLoss1000 * 100 / cycleData.workConsumed1000;
			if (powerAndHeat) {
				//const totalLoss = (cycleData.totalLoss1000 - cycleData.heatPumpHeating1000) * 100 / cycleData.workConsumed1000;
				const heatPumpLoss = (cycleData.heatPumpFrequencyConverterLoss1000) * 100 / cycleData.workConsumed1000;
				textOnWhite( ctx, "=> Electric power return efficiency "+myRound(100*cycleData.efficiency,1)+" % + district heat "+myRound(cycleData.distictHeatPercent,1)+" %."+
					" Lost in: heat pump cooling "+myRound(heatPumpLoss,2)+" %, "+
					"gears: "+myRound(gearLoss,1)+" %, generators: "+myRound(generatorLoss,1)+" %", x, y );
			}
			else {
				//const totalLoss = cycleData.totalLoss1000 * 100 / cycleData.workConsumed1000;
				//const heatPumpLoss = (cycleData.heatPumpHeating1000 + cycleData.heatPumpFrequencyConverterLoss1000) * 100 / cycleData.workConsumed1000;
				const heatPumpLoss = 100 - 100*cycleData.efficiency - gearLoss - generatorLoss;
				textOnWhite( ctx, "=> Electric power return efficiency "+myRound(100*cycleData.efficiency,1)+" %."+
							" Lost in: heat pump cooling "+myRound(heatPumpLoss,1)+" %, "+
							"gears: "+myRound(gearLoss,1)+" %, generators: "+myRound(generatorLoss,1)+" %", x, y );
			}
			if (false && Math.abs(netWorkOut - cycleData.totalWork)>100) {
				y += 20;
				textOnWhite( ctx, "Discharge power % of all motor/generator power: "
					+Math.round(100*netWorkOut/cycleData.totalWork)+" % ("+Math.round(netWorkOut/1000)+" MW/ "+Math.round(cycleData.totalWork/1000)+" MW)", x, y );
			}
			y += 20;
			textOnWhite( ctx, "Stored electricity "+Math.round(cycleData.storedElectricity_kWh/1000000)+" GWh"+(powerAndHeat ? " and stored district heat "+Math.round(cycleData.storedDistrictHeat_kWh/1000000)+" GWh" : "")+
						", power leak out: <"+Math.round(getTotalHeatLost()/1000000)+" MW", x, y );
			y += 20;
			textOnWhite( ctx, "Cost of storage "+myRound(cycleData.costOfStoragekWh,2)+" €/kWh and cost of electric power capasity "+Math.round(cycleData.costOfPowerKW)+" €/kW", x, y );
			y += 20;
			textOnWhite( ctx, "Total cost "+Math.round((cycleData.costOfStorage+cycleData.costOfPower+cycleData.costOfPlant)/1000000)+" million Eur (storage: "+Math.round(cycleData.costOfStorage/1000000)+", power plant and generators: "+Math.round(cycleData.costOfPlant/1000000)+", turbomachinery: "+Math.round(cycleData.costOfPower/1000000)+")", x, y );
			y += 20;
			textOnWhite( ctx, "Storage size "+myRound(metrics.totalMiningVolume*metrics.rockDensity/1000000,1)+" million ton gravel", x, y );
		}
	
		// draw temp and temp lines, 
		// some max-min temps values: 0.1 Hydrogen: 30, Nitrogen: 65, Methane: 120, CarbonDioxide: 200, Water: 340
		// some max-min pressure values: Hydrogen(0.3): 350 kPa, Nitrogen: 600 kPa,  Methane: 2000 kPa, CarbonDioxide: 4000 kPa, Water: 2000 kPa

		$("#"+canvasId).css('display','block');
		//$("#drawTurbin").css('display','block');
		$("#output").html("");
		ctx.setLineDash([]);

		$("#compressorDesignParams").css('display','block');
		const cUnits = getIntParam('cUnits2', metrics.cUnits);
		const hotCompressor = 
			getCompressorStages(hotCycle[1], LAST_ITEM, hotCycle[1].massFlow/metrics.cUnits, "Hot compressor", metrics.chargePDrops.diameterPipeToHotCompressor, 
							metrics.chargePDrops.diameterPipeFromHotCompressor, metrics.cEfficiency, (hotCycle[1].workConsumed*1000)/cUnits);
		const coldCompressor = 
			getCompressorStages(coldCycle[0], FIRST_ITEM, coldCycle[0].massFlow/metrics.cUnits, "Cold compressor", metrics.dischargePDrops.diameterPipeToColdCompressor, 
				metrics.dischargePDrops.diameterPipeFromColdCompressor, metrics.cLowEfficiency, (coldCycle[0].workConsumed*1000)/cUnits);//, true
		drawCompressor( "hotCompressorImage", hotCompressor, 125 );  // 1 m == 100 px
		drawCompressor( "coldCompressorImage", coldCompressor, 150 );  // 1 m == 150 px
		hotCycleG = hotCycle;
		coldCycleG = coldCycle;
		
//console.log(JSON.stringify(compressorStages[0].items));
console.log("drawBraytonCycle done");
	}
	var hotCycleG, coldCycleG;
	function redrawCompressors() {
		const cUnits = getIntParam('cUnits2', metrics.cUnits);
		var diameterPipeToHotCompressor = metrics.chargePDrops.diameterPipeToHotCompressor;
		var diameterPipeFromHotCompressor = metrics.chargePDrops.diameterPipeFromHotCompressor;
		var diameterPipeToColdCompressor = metrics.dischargePDrops.diameterPipeToColdCompressor;
		var diameterPipeFromColdCompressor = metrics.dischargePDrops.diameterPipeFromColdCompressor;
		
		// scale the pipes!
		if (cUnits != metrics.cUnits) {
			const rel = Math.sqrt(metrics.cUnits/cUnits);
			diameterPipeToHotCompressor = metrics.chargePDrops.diameterPipeToHotCompressor*rel;
			diameterPipeFromHotCompressor = metrics.chargePDrops.diameterPipeFromHotCompressor*rel;
			diameterPipeToColdCompressor = metrics.dischargePDrops.diameterPipeToColdCompressor*rel;
			diameterPipeFromColdCompressor = metrics.dischargePDrops.diameterPipeFromColdCompressor*rel;
		}
		const hotCompressor = getCompressorStages(hotCycleG[1], LAST_ITEM, hotCycleG[1].massFlow/cUnits, "Hot compressor", 
									diameterPipeToHotCompressor, diameterPipeFromHotCompressor, metrics.cEfficiency, (hotCycleG[1].workConsumed*1000)/cUnits);
		const coldCompressor = getCompressorStages(coldCycleG[0], FIRST_ITEM, coldCycleG[0].massFlow/cUnits, "Cold compressor", 
									diameterPipeToColdCompressor, diameterPipeFromColdCompressor, metrics.cLowEfficiency, (coldCycleG[0].workConsumed*1000)/cUnits);//, true
		const scale = getFloatParam('compressorScale', 0);
		drawCompressor( "hotCompressorImage", hotCompressor, scale ? scale : 125 );  // 1 m == 125 px
		drawCompressor( "coldCompressorImage", coldCompressor, scale ? scale : 150 );  // 1 m == 150 px
	}
	
	function drawPressureDropInPipe( ctx, pFrom, pTo, t )
	{
		var p = pFrom;
		if (pFrom == pTo) {
			ctx.lineTo( tToX(t), pToY(pTo));
		}
		else {
			var pStep = pFrom > pTo ? 0.96 : 1.04;
			const h = Module.PropsSI('H', 'P', pFrom, 'T', t, name);  // constant enthalpy inside pipe
			for (;;) {
				p = p * pStep;
				if (pFrom > pTo && p < pTo) p = pTo;
				else if (pFrom < pTo && p > pTo) p = pTo;

				t = Module.PropsSI('T', 'P', p, 'H', h, name);  // constant enthalpy inside pipe
				ctx.lineTo( tToX(t), pToY(p));
				if (p == pTo) break;
			}
		}
		var v = {};
		v.p = p;
		v.t = t;
		return v;
	}


	var prevX = -1;
	var prevY = -1;
	function optimzedLineTo( context, x, y ) {
		if (x != prevX || y != prevY) {
			context.lineTo( prevX = x, prevY = y);
		}
	}
	function textOnWhite( ctx, text, x, y )
	{
		const textMetrics = ctx.measureText(text);
		const height = parseFloat(ctx.font);
		//console.log("textMetrics.width="+textMetrics.width+", height="+height);
		ctx.clearRect( x, y-height, textMetrics.width, height);
		ctx.fillText(text, x, y );
	}
	function drawDirectionArrow( ctx, data, pTarget, lineLen, isForward, text ) {
		const items = data.items;
		if (items.length < 10) return;
		var i = Math.floor((items.length-1)/2);
		var iBottom = 0, iPrev = -1;
		var iTop = items.length-1;
//console.log("data.isForward="+data.isForward+",  isForward="+isForward);
//stage.pIn =
		var growingP = items[1].p > items[0].p;

		while (i != iPrev && iBottom < iTop) {
			if (growingP) {
				if (items[i].p < pTarget) {
					iBottom = i;
				}
				else if (items[i].p > pTarget) {
					iTop = i;
				}
				else {
					break;
				}
			}
			else {
				if (items[i].p > pTarget) {
					iBottom = i;
				}
				else if (items[i].p < pTarget) {
					iTop = i;
				}
				else {
					break;
				}
			}
			iPrev = i;
			i = Math.floor((iBottom + iTop)/2);
		}
		const item1 = items[i];
//console.log("selected i="+i+", iBottom="+iBottom+", iTop"+iTop+", items.length="+items.length+", pTarget="+pTarget+", item.p="+item1.p);
		const item2 = items[i+(isForward ? 1 : -1)];
//console.log("items.length="+items.length); console.log(", item1="+JSON.stringify(item1)); console.log(", item2="+JSON.stringify(item2));
		const x1 = tToX(item1.t), y1 = pToY(item1.p);
		const x2 = tToX(item2.t), y2 = pToY(item2.p);
		const x = x2 - x1, y = y2 - y1;
		const r = Math.sqrt(x*x + y*y);
		const toPixels = lineLen; 
//console.log("x="+x+", y="+y+"=>r="+r+"=>toPixels="+toPixels);
		// r*r = x * x + y * y;
		var radian;  // range from 0 to 2 * Math.PI;
		if (x > 0 && y >= 0) radian = Math.atan(y/x);
		else  if (x > 0 && y < 0) radian = Math.atan(y/x) + 2 * Math.PI;
		else  if (x < 0) radian = Math.atan(y/x) + Math.PI;
		else  if (x = 0 && y > 0) radian = Math.PI / 2;
		else  if (x = 0 && y < 0) radian = -Math.PI / 2;
		ctx.beginPath();
		// Math.PI/12 == 15 degrees
		ctx.moveTo( x1 + Math.cos(radian + Math.PI/12)*toPixels, y1 + Math.sin(radian + Math.PI/12)*toPixels);
		ctx.lineTo( x1, y1);
		ctx.lineTo( x1 + Math.cos(radian - Math.PI/12)*toPixels, y1 + Math.sin(radian - Math.PI/12)*toPixels);
		ctx.lineTo( x1 + Math.cos(radian + Math.PI/12)*toPixels, y1 + Math.sin(radian + Math.PI/12)*toPixels);
		ctx.closePath();
		const fillStyle = ctx.fillStyle;
		ctx.fillStyle = ctx.strokeStyle;
		ctx.fill();
		if (text) {
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite( ctx, text, x1+Math.abs(12*x/y), y1+6);
		}
		ctx.fillStyle = ctx.fillStyle;
	}
	function getGasFlow( type, data, isFirst, r1, r2 ) 
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		const item = isFirst ? data.items[data.items.length-1] : data.items[0];
			const flow = Math.round(data.massFlow * 1000/item.d)*(type == 'Hp' ? metrics.rockDensityHp/(metrics.rockDensityHp-metrics.gravelDensity) : metrics.rockDensityLp/(metrics.rockDensityLp-metrics.lpGravelDensity));

		if (typeof item.visc === 'undefined') item.visc = Module.PropsSI('V', 'P', item.p, 'H', item.h, name);
	
		var speed = Math.round(data.massFlow * 1000/item.d)/(r1*r1*Math.PI);
		var pDrop = Math.round(calcPressureDropInGravel(type, speed, item.visc, item.d, 1, item.p, item.t ));
		var pDropText = ",  \u0394P: "+pDrop;
		if (r2) {
			speed = Math.round(data.massFlow * 1000/item.d)/(r2*r2*Math.PI);
			var pDrop2 = Math.round(calcPressureDropInGravel(type, speed, item.visc, item.d, 1, item.p, item.t ));
			if (pDrop2 != pDrop) {
				pDropText = pDropText+" - "+pDrop2;
			}
		}
		pDropText += " Pa/m"
		var speed1 = myRound(flow/(r1*r1*Math.PI),2);
		var speed2 = r2 ? myRound(flow/(r2*r2*Math.PI),2) : speed1;
		return 'gas flow: '+speed1+(speed1 && speed1!=speed2 ? ' - '+speed2 : '')+' m/s'+pDropText;
	}
	function showPointData( ctx, data, isFirst, xDiff, yDiff, massFlow, massFlow2, p1, t1, wetness1) 
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		const item = isFirst ? data.items[data.items.length-1] : data.items[0];
		const x = tToX(item.t), y = pToY(item.p);
		const lineDash = ctx.getLineDash();
		const font = ctx.font;
		const strokeStyle = ctx.strokeStyle;
		var speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'H', item.h, name);
		if (speedOfSound == Infinity) {
			speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'T', item.t+0.1, name);
		}
		const v = Module.PropsSI('V', 'P', item.p, 'H', item.h, name); // viscosity
		const d = Module.PropsSI('D', 'P', item.p, 'H', item.h, name); // viscosity
		const d1 = p1 ? Module.PropsSI('D', 'P', p1, 'H', item.h, name) : d;
		const kVisc = v / d; // kinematic viscosy
		if (typeof massFlow === 'undefined') massFlow = data.massFlow;
		const text = myRound(item.t,1)+(t1 ? '/'+myRound(t1,1):'')+" K"+", "+Math.round(item.p/1000)+(p1 ? '/'+Math.round(p1/1000):'')+" kPa: enthalpy="+Math.round(item.h/1000)+" J/g, flow="+
					(massFlow2 ? Math.round(massFlow * 1000/item.d)+"/"+Math.round(massFlow2 * 1000/d1)+" m\u00B3/s, "+Math.round(massFlow*1000)+"/"+Math.round(massFlow2 * 1000)+" kg/s":
					 massFlow ? Math.round(massFlow * 1000/item.d)+" m3/s, "+Math.round(massFlow*1000)+" kg/s" : Math.round(1000/item.d)+" m\u00B3/s") 
						+", ν="+myRound(kVisc*1000000)+"μm\u00B2/s, mach:"+myRound(speedOfSound)+" m/s" // Mass specific entropy="+myRound((item.s/1000),2)+" J/g/K,
						+(item.wetness ? (', wetness='+myRound(item.wetness*100,2)+(typeof wetness1 !== 'undefined' ? '/'+myRound(wetness1*100,2):'')+'%') : ''); 
		ctx.strokeStyle = 'black';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo( x, y);
		const textMetrics = ctx.measureText(text);
		if (xDiff < -100) {
			ctx.lineTo( x+xDiff+textMetrics.width/2, y+yDiff+1);
		}
		else {
			ctx.lineTo( x+xDiff, y+yDiff+-5);
		}
		ctx.stroke();
		if (p1 && t1) {
			const x = tToX(t1), y = pToY(p1);
			ctx.beginPath();
			ctx.moveTo( x, y);
			if (xDiff < -100) {
				ctx.lineTo( x+xDiff+textMetrics.width/2+10, y+yDiff+1);
			}
			else {
				ctx.lineTo( x+xDiff+10, y+yDiff+-5);
			}
			ctx.stroke();
		}
		ctx.fillStyle = 'black'; 
		ctx.font = "12px serif";
		textOnWhite( ctx, text, x+xDiff+1, y+yDiff);
		
		ctx.setLineDash(lineDash);
		ctx.font = font;
		ctx.strokeStyle = strokeStyle;
		return item;
	}

// TBD: Check the blade stress in https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf
// But: ~10000 rmp is the upper limit of no problems area?? Only U matters!
// stress 1/2*(density)*U^2*K(1-b^2) where typical K=0.55-0.65 for blades, depens on b
// 
	function getCompressorStage(stageData, item, rpm ) {
			var stage = {};
			stage.flowM3 = stageData.massFlowInKg /item.d;
			if (item.v && item.speedOfSound) {
				stage.mach = item.speedOfSound;
			}
			else {
				var speedOfSound = item.speedOfSound ? item.speedOfSound : Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'H', item.h, name);
				if (speedOfSound == Infinity) {
					speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'T', item.t+0.1, name);
				}
				stage.mach = item.speedOfSound = speedOfSound;
			}
			if (stageData.constantDeltaH) {
				stage.U = stageData.U; // Math.sqrt(stageData.constantDeltaH / stageData.stageLoadingCoefficientMin);
				item.v = stage.v = stageData.v; // stageData.flowCoefficientMin * stage.U;
				stage.hubToTipRatio = stageData.getStageHubToTipRatio(item);
//console.log(stageData.constantDeltaH+"=>v="+stage.v);
			}
			else {
				item.v = stage.v = stageData.vMach*stage.mach;
				stage.hubToTipRatio = stageData.getStageHubToTipRatio(item);
			}
			const area =  stage.flowM3 / (stage.v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length] : stageData.horizontalVector));
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length]);

			stage.rTip = Math.sqrt(area/(Math.PI*(1-stage.hubToTipRatio*stage.hubToTipRatio)));
			stage.rHub = stage.rTip * stage.hubToTipRatio;

			if (!rpm) {
				// init inlet or outlet stage
				// A = PI*(rOut^2-rIn^2) ==  PI*rOut^2*(1-hubToTip^2)
				// => rOut = sqrt(A/(PI*(1-hubToTip^2))
				stage.U = stage.v/stageData.flowCoefficientMin;
				stageData.rpm = stage.rpm = 60*stage.U/(stage.rTip*2*Math.PI);
				stageData.rpmStages = 1;
				stageData.rpmCount++;
				stage.stageLoadingCoefficient = stageData.stageLoadingCoefficientMin;
				stageData.getDeltaH( stage, item );
			}
			else {

				if (stageData.constantDeltaH) {
					stageData.getDeltaH( stage, item );
					rpm = stage.U / ((stage.rTip*2*Math.PI) / 60);
					stageData.rpmStages = 1;
				}
				else {
					stage.U = item.v / stageData.flowCoefficientMin;
					stageData.getDeltaH( stage, item );
					rpm = stage.U / ((stage.rTip*2*Math.PI) / 60);
					stageData.rpmStages = 1;
				}
				stageData.rpmCount++;
				stage.rpm = rpm;

				// set new speed by mach limit and rpm, if we are outside optimal area 
				// but do NOT change speed for the last 2 stages 
//console.log(stageData.stages.length+": stageData.cStagesRemaining="+stageData.cStagesRemaining);
				if (stageData.constantDeltaH) {
					stage.stageLoadingCoefficient = stageData.constantDeltaH / (stage.U * stage.U);
				}
/*
				else if (stageData.maxStressExceeded) {
					stage.stageLoadingCoefficient = stageData.constantDeltaH / (stage.U * stage.U);
				}
				else if (stageData.cStagesRemaining > 2 && (stageData.rpmStages > stageData.maxRpmStages)) {	// stage.flowCoefficient > stageData.flowCoefficientMax || 
					const maxRpm = Math.sqrt(stageData.maxAN2EXP8/area);
					var stageLoadingCoefficientMin = stageData.stageLoadingCoefficientMin;
					stage.U = stage.v/stageData.flowCoefficientMin;
					const hubToTip = stage.rHub/stage.rTip;
					var rpm = 60*stage.U/(stage.rTip*2*Math.PI);
					
					if (stageData.maxAN2 && stageData.maxAN2 < (area*rpm*rpm)) {
						rpm = Math.sqrt(stageData.maxAN2/area);
						stage.rTip = 60*stage.U/(rmp*2*Math.PI);
						stage.rHub = Math.sqrt((stage.rTip*stage.rTip*Math.PI - area)/Math.PI);
					}
					stage.rpm = stageData.rpm = rpm;
					stageData.rpmStages = 1;
					stageData.rpmCount++;
					stage.deltaH = stage.U * stage.U * stageLoadingCoefficientMin;
					const hNow = item.h + 0.5*(stage.v*stage.v);

//if (stageData.rpmCount == 6) {
//	console.log("hCur>stageData.hEnd:"+hCur+">"+stageData.hEnd+"?, hCur="+item.h+"+"+(stageData.maxRpmStages * stage.deltaH)+" + "+(0.5*(stage.v*stage.v)));
//}
					if ((hNow+stageData.maxRpmStages*stage.deltaH) > stageData.hEnd && Math.trunc((stageData.hEnd - hNow)/stage.deltaH) >= 1) {
						const cRmpStages = Math.trunc((stageData.hEnd - hNow)/stage.deltaH) + 1;
						// adjust rpm to match the remaining enthalpy, we can split the remaining work even for both stages
						const oldDeltaH = stage.deltaH;
						stage.deltaH = (stageData.hEnd - hNow)/cRmpStages;	
						if (cRmpStages > 1) {
							stage.deltaH  = stage.deltaH*1.2;	// other wise too much i left to the last stage
							if (stage.deltaH > oldDeltaH) stage.deltaH = oldDeltaH;
						}
						stage.U = Math.sqrt(stage.deltaH/stageLoadingCoefficientMin);
console.log(stageData.rpmCount+": Adjusted rpm from "+stage.rpm+" to "+(60*stage.U/(stage.rTip*2*Math.PI))+", cRmpStages="+cRmpStages);
						stage.rpm = stageData.rpm = 60*stage.U/(stage.rTip*2*Math.PI);
						if (cRmpStages == 1) stage.isLast = true;
					}
					stage.stageLoadingCoefficient = stageLoadingCoefficientMin;
				}
				else {
					stage.stageLoadingCoefficient = stageData.stageLoadingCoefficientMin+(stage.flowCoefficient-stageData.flowCoefficientMin)*stageData.flowCoefficientToStageLoadingCoefficient;
				}
*/
			}
			stage.flowCoefficient = stage.v/stage.U;
			stage.deltaH = stage.U * stage.U * stage.stageLoadingCoefficient;
			if (typeof item.s === 'undefined') {
				item.s = Module.PropsSI('S', 'P', item.p, 'H', item.h, name);
			}
			const hCur = item.h + stage.deltaH*1.1 + 0.5*(stage.v*stage.v);
			if (!stage.isLast && hCur > stageData.hEnd) {
				// this the last stage, let's calc the work (new stage.deltaH) needed to reach the target pHigh,
				// end temperature does not matter, because we can adjust the start temperature, but the end pressure must be the configured pHigh!
				// We assume the pressure rise by speed decreasing is done by constant entropy (constant s)
				const hActualNow = item.h + 0.5*(item.v*item.v-stageData.speedOut*stageData.speedOut);
				const hTarget = Module.PropsSI('H','S', item.s, 'P', stageData.pHigh, name);
				var exit = {};
				if (false && stageData.constantDeltaH) {
					const deltaH = stage.deltaH;
					const hActualWork = deltaH * stageData.efficiency;
					const hHeating = deltaH * (1-stageData.efficiency);
					const s = Module.PropsSI('S','P', item.p, 'H', item.h, name);
					const p = Module.PropsSI('P','S', item.s, 'H', item.h+hActualWork, name);
					const h = item.h+hActualWork+ hHeating;
					exit.s = Module.PropsSI('S','P', p, 'H', h, name);
					exit.h = h + 0.5*(item.v*item.v-stageData.speedOut*stageData.speedOut);
					exit.p = Module.PropsSI('P','S', exit.s, 'H', exit.h, name);
					exit.t = Module.PropsSI('T','P', exit.p, 'S', exit.s, name);
					exit.v = stageData.speedOut;
				}
				else {
//console.log("item: "+JSON.stringify(item));
if (!item.p) {
	console.trace("item: "+JSON.stringify(item));
	var x = foo;
}
					ret = testResult( stageData.pHigh, 0, stage.deltaH*1.3, stageData.pHigh*0.002, function(deltaH) {
						stage.deltaH = deltaH;
						const hActualWork = deltaH * stageData.efficiency;
						const hHeating = deltaH * (1-stageData.efficiency);
						const s = Module.PropsSI('S','P', item.p, 'H', item.h, name);
						const p = Module.PropsSI('P','S', item.s, 'H', item.h+hActualWork, name);
						const h = item.h+hActualWork+ hHeating;
						stage.pOut = p;
						stage.hOut = h;
						exit.s = Module.PropsSI('S','P', p, 'H', h, name);
						exit.h = h + 0.5*(item.v*item.v-stageData.speedOut*stageData.speedOut);
						exit.p = Module.PropsSI('P','S', exit.s, 'H', exit.h, name);
						exit.t = Module.PropsSI('T','P', exit.p, 'S', exit.s, name);
						exit.v = stageData.speedOut;
if (exit.p === Infinity) {
	console.trace("deltaH="+deltaH+", exit="+JSON.stringify(exit)+", items: "+JSON.stringify(stageData.items));
	var x = foo;
}
			//console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(next.v*next.v - stage.v*stage.v)));
						return exit.p;
					});
				}
				stageData.exit = exit;
console.log("exit: "+JSON.stringify(exit));
				stage.isLast = true;
			}
			stage.stageLoadingCoefficient = stage.deltaH / (stage.U*stage.U);
			stage.UMach = stage.U/stage.mach;
			stage.vMach = stage.v/stage.mach;
			stage.p = item.p;
			stage.t = item.t;
			stage.h = item.h;
			stage.d = item.d;
//if (stageData.maxStressExceeded) console.log("Horizontal stage #"+stageData.stages.length+":"+JSON.stringify(stage));
			return stage;
	}
	function nextCompressorStage(stageData, prev, rpm, efficiency ) {
		stage = getCompressorStage(stageData, prev, rpm );
		
		if (stage == null) {
			console.log("stage == null");
			return null;
		}
		stageData.stages.push(stage);
		stageData.items.push(prev);
		//stageData.cStagesRemaining = (stageData.hEnd - prev.h - 0.5*stage.v*stage.v)/stage.deltaH;

		var next = {};
if (typeof stage.deltaH === 'undefined'  || !prev.v || !prev.p) {
	console.log("Bad stage:"+JSON.stringify(stage));
	console.log("Or bad item:"+JSON.stringify(prev));
	return null;
}
		const hActualWork = stage.deltaH * efficiency;
		const hHeating = stage.deltaH * (1-efficiency);
		const s = Module.PropsSI('S','P', prev.p, 'H', prev.h, name);	// use h for wet gas!
		const pMax = Module.PropsSI('P','S', s, 'H', hActualWork+prev.h, name);
//console.log("hActualWork="+hActualWork+", pMax="+pMax+", "+JSON.stringify(stage));
//console.log(JSON.stringify(prev));
		if (stageData.constantDeltaH) {
			if (stage.isLast && stage.pOut) {
				next.p = stage.pOut;
				next.h = stage.hOut;
			}
			else {
				next.p = Module.PropsSI('P', 'H', prev.h+hActualWork, 'S', s, name);
				next.h = prev.h+stage.deltaH; // hActualWork+hHeating;
			}
			next.t = Module.PropsSI('T','P', next.p, 'H', next.h, name);
			next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', next.p, 'H', next.h, name)
			next.v = stageData.v;
if (!s || !next.p || !next.h || !next.t || !next.v) {
	console.log("s="+s+"=>next="+JSON.stringify(next)+", prev="+JSON.stringify(prev));
}
		}
		else {
			if (!testResult( prev.h+hActualWork, prev.p+(pMax-prev.p)/3, pMax, hActualWork*0.01, function(p) {
				next.p = p;
				next.h = Module.PropsSI('H','P', p, 'S', s, name)+ hHeating;
				next.t = Module.PropsSI('T','P', p, 'H', next.h, name);
				next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'H', next.h, name)
				if (next.speedOfSound == Infinity) {
					next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'T', next.t+0.1, name);
					if (next.speedOfSound == Infinity) {
						console.log("Bad data: next="+JSON.stringify(next)+", prev="+JSON.stringify(prev)+"; stage="+JSON.stringify(stage));
						console.log(JSON.stringify(stageData));
						next.p = xyz; // break
					}
				}
				next.v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
if (!s || !p || !next.h || !stage.v || !next.t) {
	console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(next.v*next.v - stage.v*stage.v)));
	next.p = xyz; // break
}
				return next.h + 0.5*(next.v*next.v - stage.v*stage.v);
			})) {
	console.log("testResult == false: "+JSON.stringify(next));
				testResult( prev.h+hActualWork, prev.p+(pMax-prev.p)/2, pMax, hActualWork*0.01, function(p) {
					next.p = p;
					next.h = Module.PropsSI('H','P', p, 'S', s, name)+ hHeating;
					next.t = Module.PropsSI('T','P', p, 'H', next.h, name);
					next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'H', next.h, name)
					if (next.speedOfSound == Infinity) {
						next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'T', next.t+0.1, name);
						if (next.speedOfSound == Infinity) {
							console.log("Stuck inside the vaporization line?: "+JSON.stringify(next));
						}
					}
					next.v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(next.v*next.v - stage.v*stage.v)));
					return next.h + 0.5*(next.v*next.v - stage.v*stage.v);
				});
				return null;
			}
		}
		const hV = Module.PropsSI('H','P',next.p,'Q',1,name); 	// vapor
		if (next.h < hV) {
			const hL = Module.PropsSI('H','P',next.p,'Q',0,name); // liquid
			next.wetness = (hV-next.h) / (hV-hL);
			if (next.wetness > 0.15) {
				console.log("WARNING: next.wetness="+next.wetness+" > 0.15!!!!"); 
			}
		}
		next.s = Module.PropsSI('S','P', next.p, 'H', next.h, name);
		next.d = Module.PropsSI('D','P', next.p, 'H', next.h, name);
		if (next.d === Infinity) {
			next.d = Module.PropsSI('D','P', next.p, 'T', next.t+0.1, name);
		}
		next.hRemaining = stageData.hEnd - (prev.h + stage.v*stage.v*0.5);
//console.log("stage.wasLast="+stage.wasLast);
		if (stage.isLast) {
			const v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
			const flowM3 = stageData.massFlowInKg /next.d;
			const area =  flowM3 / (v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length-1] : stageData.horizontalVector));
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length-1]);
			if (stageData.maxStressExceeded) {
				// area = PI * ((midLine+x)^2 - (midLine-x)^2)
				// => area = PI * (midLine^2 + 2*x*midLine+x^2 - (midLine^2 - 2*x*midLine+x^2))
				// => area = PI * 4 *x*midLine
				// x = area / (midLine*PI*4);
				const x = area / (stageData.midLine*Math.PI*4);
				next.rTip = stageData.midLine + x;
				next.rHub = stageData.midLine - x;
				next.hubToTipRatio = stage.rHub / stage.rTip;
console.log("x="+x+", stage.rTip="+stage.rTip+", stage.rHub="+stage.rHub);
			}
			else {
				next.d = Module.PropsSI('D','P', next.p, 'T', next.t, name);
				next.flowM3 = stageData.massFlowInKg /next.d;
				next.hubToTipRatio = stageData.getStageHubToTipRatio(next);
				const area =  next.flowM3 / (next.v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length-1] : stageData.horizontalVector));
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length-1]);
				next.rTip = Math.sqrt(area/(Math.PI*(1-next.hubToTipRatio*next.hubToTipRatio)));
				next.rHub = next.rTip * next.hubToTipRatio;
			}
			stageData.hpExit = next;
console.log("stageData.hpExit="+JSON.stringify(stageData.hpExit));
			return null;
		}
if (!next.p || next.p == null) {
	console.log(JSON.stringify(next));
	var x = xyz;	// break
}
//console.log(JSON.stringify(next));
		return next;
	}

	// LP: hub/tip = starts from v=0.25Mach, v/w=0.3, hub/tip=0.5, keep: 
	// Calculated h defines new p, t and speed of sound 
	// If (h/w^2)/(v/w)=2/3 == (h/w^2)*(w/v)=2/3 == h = w*v*2/3
	function getCompressorStages( data, isFirst, massFlow, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, sideOfGeneratorShaft )
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		return getCompressorStagesI( true, data, isFirst, massFlow*1000, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, sideOfGeneratorShaft );
	}

	// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf
	// β1 angle  flowX component (=V) in blade inlet
	// β2 angle of flowX component (=V) in blade exit
	// α1 angle of absolute flow in blade inlet
	// α2 angle of flowX component (=V) in blade exit, THIS IS THE TOP STEED AND SETS THE UPPER LIMIT IF SPEED < 1 Mach
	// γ Stagger angle, actual angle status rotor to the flowX direction 
	// Ψ Stage loading factor  
	// Φ Flow coefficient
	// V = Vx = X component of abosulte flow speed == V
	// U = rotational speed
	// Vabs1 = absolute flow speed at rotor inlet
	// Vabs2 = absolute flow speed at rotor exit == TOP SPEED == eg. we can set it 0.95 MACH!
	// tan(β1)=(Reaction + Ψ/2)/Φ,  tan(β2)=(Reaction - Ψ/2)/Φ
	// Reaction=0.5 (for calculus, we will keep speeding up, but that is made by shorter stator length
	// => β1 = atan((1/2 + Ψ/2)/Φ), 
	//    β2 = atan((1/2 - Ψ/2)/Φ)
	// Vabs2^2 = (U-tan(β2)*V)^2 + V^2) == (V/Φ-tan(β2)*V)^2 + V^2 == V^2 * ((1/Φ-tan(β2))^2 + 1) 
	// => V = sqrt(Vabs2^2/((1/Φ-tan(β2))^2 + 1))
	// SET Vabs2 = Mach 0.9
	// 
	function setFlowSpeedForNewRpm(stageData, stage) {
		stage.v = stageData.v ? stageData.v : stageData.vMach*stage.mach;
		stage.U = stageData.U ? stageData.U : stage.v/stageData.flowCoefficientMin;
	}
	
	function calcCompressorStages( stageData, item )
	{
		stageData.stages = [];
		stageData.items = [];
		stageData.rpm = 0;
		stageData.rpmStages = 0;
		stageData.rpmCount = 0;

		var i;
		for (i = 0; i < 30; i++) {
			if (typeof item.s === 'undefined') {
				item.s = Module.PropsSI('S', 'P', item.p, 'H', item.h, name);
			}
if (!item.p) {
	console.trace(i+": item: "+JSON.stringify(item));
	var x = xyz;	// break;
}		
			item = nextCompressorStage(stageData, item, stageData.rpm, stageData.efficiency );
			if (item == null || !item.v || !item.p) {
				console.log(i+": item: "+JSON.stringify(item));
				break;
			}
			const lastStage = stageData.stages[stageData.stages.length-1];
			if (lastStage.isLast || item.hRemaining < lastStage.deltaH) {
				console.log("lastStage.isLast="+lastStage.isLast+" item.hRemaining < lastStage.deltaH == "+(item.hRemaining < lastStage.deltaH));
				break;
			}
		}
	}
	function toPoint(x,y) {
		var obj = {};
		obj.x = x;
		obj.y = y;
		return obj;
	}
// TBD: design by the type subsonic, transonic, supersonic => subsonic => stage 1 vMach<=0.9, transonic => stage 1 vMach <= 1.2, supersonic => stage 1 vMach <= 1.5
// Rule: each stage produces equal amout of power, chose the lowest number of stages matching with the selected type
// All other params are irrelevant before CFD optimization phase
	function getCompressorStagesI( isCompressor, data, isFirst, massFlowInKg, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, sideOfGeneratorShaft )
	{	
		function getSheetValues(title, name, data, decimalsOrDiv, decimals)
		{
			var i, ret = [];
			ret.push(title);
			for (i = 0; i < data.length; i++) {
				var val = data[i][name];
				if (typeof val  === 'undefined') ret.push(' ');
				else if (typeof val === 'string') {
					ret.push(val);
				}
				else if (decimalsOrDiv >= 1000) {
					ret.push(decimals ? myRound(val/decimalsOrDiv, decimals) : Math.round(val/decimalsOrDiv));
				}
				else {
					ret.push(decimalsOrDiv ? myRound(val, decimalsOrDiv) : Math.round(val));
				}
			}
			return ret;
		}
		//getMetrics();
		var i = isFirst ? data.items.length-1 : 0;
		var first = data.items[i];
		var last = data.items[i == 0 ? data.items.length-1 : 0];
		if ((isCompressor && first.p > last.p) || (!isCompressor && first.p < last.p)) {
			const tmp = first;
			first = last;
			last = tmp;
		}
		var stageData = {}
		// 6*4 design for both: 0.48, 0.33, 0.20, 1, 0.325:
		stageData.title = title;
		stageData.flowCoefficientMax = 0.60;	// flow coefficient max
		stageData.flowCoefficientMin = getFloatParam('flowCoefficient', 0.44); 	// 0.33 => β2=50, 0.4 => β2=45 degree (β2~tip stagger angle)
		stageData.stageLoadingCoefficientMin = getFloatParam('stageLoadingCoefficient', 0.20); // 0.19

		stageData.aspectRatio =  getFloatParam('aspectRatio', 1.25); //getFloatParam(first.t > 273 ? 'aspectRatio' : 'aspectRatioCyro', 1.2);	// 
		stageData.hubToTipRatio = getFloatParam('hubToTipRatio', 0.70); // 2/3; //  sideOfGeneratorShaft ? 0.5 : 
		stageData.hubToTipRatioMax = getFloatParam('hubToTipRatioMax', 0.9);
		//stageData.t2cInMiddleFlow = getFloatParam('t2cInMiddleFlow', 0.05);
		stageData.solidity = getFloatParam('solidity', 2);
		stageData.getStageHubToTipRatio = function(item) {
			if (item.t < 273 || stageData.hubToTipRatioMax == stageData.hubToTipRatio) return stageData.hubToTipRatio; // cryogenic => no problems with tensile stress
			const hNow = item.h + 0.5*item.v*item.v;
			const ret = stageData.hubToTipRatio  + (stageData.hubToTipRatioMax-stageData.hubToTipRatio)*(hNow - stageData.hIn) / (stageData.hOut-stageData.hIn);
//console.log(stageData.stages.length+": hNow="+hNow+" part="+(hNow - stageData.hIn)+" / "+(stageData.hOut-stageData.hIn)+" => ret="+ret); 
			return ret;
		}
		stageData.machMaxSpeed = getFloatParam('machMaxSpeed', 0.95);		// < 0.8 => subsonic, <= 1.2 => transonic, Relative MACH number in rotor tip, TOP SPEED OF GAS RELATIVE TO BLADE AND STAGE: Use Vrel1(β1) instead Vasb2!!!!
		if (maxAN2EXP8 = getFloatParam('maxAN2EXP8')) {
			stageData.maxAN2 = maxAN2EXP8*100000000;
		}
		stageData.cStressMaxMPa = getFloatParam(first.t < 373 ? 'cStressMaxMPaCold' : 'cStressMaxMPa', 568);
		stageData.tempStressMaxMPa = getFloatParam('tempStressMaxMPa', 923);
		//stageData.cStressMaxMPa2 = getFloatParam('cStressMaxMPa2', 568);
		//stageData.tempStressMaxMPa2 = getFloatParam('tempStressMaxMPa2', 923);
		//stageData.bladeCoolingK = getFloatParam('bladeCoolingK', 100);
		stageData.bladeOfStageWidth = getFloatParam('bladeOfStageWidth', 0.50);
		stageData.getDeltaH = function( stage, item ) {
			//	Cuts down the power if the max tensile stress would exceeded
			const hNow = item.h + 0.5*item.v*item.v;
			var stageLoadingCoefficient = stageData.stageLoadingCoefficientMin;
					
 			var deltaH = stage.U*stage.U*stageLoadingCoefficient;
			if (item.t > 273 && stageData.hubToTipRatioMax != stageData.hubToTipRatio) {
				stageLoadingCoefficient = (stageLoadingCoefficient + stageData.stages.length*0.0082) < 0.3 ? 
					(stageLoadingCoefficient + stageData.stages.length*0.0082) : 0.3;
//console.log("stageLoadingCoefficient="+stageLoadingCoefficient);
				stage.U = Math.sqrt(deltaH/stageLoadingCoefficient);
			}
			// no need to check max tensile stress below 500 Celsius
			const myStressCoefficient = 0.5*8000*(1-stage.hubToTipRatio*stage.hubToTipRatio)*0.55/1000000;
			if (item.t > 773) {
				var hRemaining = stageData.hOut - item.h + 0.5*stage.v*stage.v;
				if (hRemaining < deltaH) {
					stageLoadingCoefficient *= deltaH/hRemaining;	// => 1:1 increase of stageLoading and flow coefficients => best efficiency for Vx
					deltaH = hRemaining;
					stage.isLast = true;
				}
				// U^2 = deltaH/stageLoadingCoefficient;
				stage.tensileStressMPa = myStressCoefficient*deltaH / stageLoadingCoefficient;
				var hActualWork = deltaH * stageData.efficiency;
				const pOut = Module.PropsSI('P','H', item.h+hActualWork, 'S', item.s, name);	
				const tOut = Module.PropsSI('T','H', item.h+deltaH, 'P', pOut, name);
				const tUncooledBlade = item.t + (tOut-item.t)*stageData.bladeOfStageWidth;
				stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				if (tUncooledBlade > stageData.tempStressMaxMPa) {
					stage.bladeCoolingK = tUncooledBlade - stageData.tempStressMaxMPa;
				}
				else {
					stage.bladeCoolingK = 0;
				}
				stage.stageLoadingCoefficient = stageLoadingCoefficient;
/*
	Let's assume cooling down to the max strength area
				const tBladeMax = tUncooledBlade - stageData.bladeCoolingK;
				stage.maxTensileStressMPa = tBladeMax <= stageData.tempStressMaxMPa ? stageData.cStressMaxMPa :
					stageData.cStressMaxMPa2 + 	
					(stageData.cStressMaxMPa-stageData.cStressMaxMPa2)/(stageData.tempStressMaxMPa2-stageData.tempStressMaxMPa)
					* (stageData.tempStressMaxMPa2-tBladeMax);
				if (stage.maxTensileStressMPa > stageData.cStressMaxMPa) stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				if (tUncooledBlade > stageData.tempStressMaxMPa) {
					stage.bladeCoolingK = tUncooledBlade - stageData.tempStressMaxMPa;
				}
				if (stage.tensileStressMPa < stage.maxTensileStressMPa) {
					stage.stageLoadingCoefficient = stageLoadingCoefficient;
				}
				else {
					stage.tensileStressMPa = stage.maxTensileStressMPa;
					stage.stageLoadingCoefficient = myStressCoefficient*deltaH / stage.tensileStressMPa;
				}
*/
			}
			else {
				stage.stageLoadingCoefficient = stageLoadingCoefficient;
				stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				stage.tensileStressMPa = myStressCoefficient*deltaH / stageLoadingCoefficient;
				stage.bladeCoolingK = 0;
			}
			stage.tensileStressPercent = Math.round((stage.tensileStressMPa / stage.maxTensileStressMPa) * 100)+" %";
			stage.deltaH = deltaH;
			stage.U = Math.sqrt(deltaH / stage.stageLoadingCoefficient);
			stage.flowCoefficient =  stage.v / stage.U;
			
			// dynamic stage chord and aspect ratio calculion based on unused tensile stress
			const v2 = Math.sqrt(2 * stage.deltaH + stage.v*stage.v);
//console.log("v2="+v2+", v="+stage.v+", deltaH="+stage.deltaH+",  massFlowInKg="+ massFlowInKg);
			stage.F = (v2-stage.v) * massFlowInKg;	// the massflow is accelerated from v to v2 in a second 
			const hubToTip = stage.rHub / stage.rTip;
			testResult( stageData.K, 0.1, 0.4, stageData.K*0.01, function (d) {
				stage.tipToHubSectionArea = d;
				// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
				// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectinal area>/(hub sectinal area>, r=radius, t=thickness
				return stage.K = 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
			});
//OK: console.log("*****"+stageData.stages.length+": d="+stage.tipToHubSectionArea+", K="+stage.K+"; hubToTip="+hubToTip);
			// rTip*rTip - rMiddle*rMiddle = rMiddle*rMiddle - rHub*rHub;	// ever area in both sides =>
			// rMiddle = sqrt((rTip*rTip+rHub*rHub)/2)
			const rMiddle = Math.sqrt((stage.rTip*stage.rTip+stage.rHub*stage.rHub)/2);
			//const unusedTensileStress = (stage.maxTensileStressMPa - stage.tensileStressMPa)*1000000;
			const unusedTensileStress = stage.maxTensileStressMPa*1000000;	// we can ignore centrifugal force here
			// Calc first the min width %0.1 from <ero width tip with momentum. 
			// Hub width = almost tip width / 0.15
			// And finally check the momentum in hub.  Elastic section modulus in hub should be much higher than its momentum because of centrifugal force
			// See https://en.wikipedia.org/wiki/Section_modulus
			const rTip999 = 0.999*stage.rTip;
			const tip999MomentumPerM = (stage.F*(stage.rTip-stage.rHub)/2000*(stage.rTip*stage.rTip-rTip999*rTip999)/(stage.rTip*stage.rTip-stage.rHub*stage.rHub))
										/ (stageData.solidity*2*stage.rHub*Math.PI);   // assume that blade is a rectangle
			const r75 = Math.sqrt((stage.rTip*stage.rTip+rMiddle*rMiddle)/2);
			const r75MomentumPerM = (stage.F*(r75-rMiddle)*(stage.rTip*stage.rTip-rMiddle*rMiddle)/(stage.rTip*stage.rTip-stage.rHub*stage.rHub))
										/ (stageData.solidity*2*stage.rHub*Math.PI);   // assume that blade is a rectangle
			const hubMomentumPerM = stage.F*(rMiddle-stage.rHub) / (stageData.solidity*2*stage.rHub*Math.PI);
			stage.bladeThicknessInHub = Math.sqrt(6*hubMomentumPerM/unusedTensileStress);
			stage.bladeThicknessInTip = stage.bladeThicknessInHub*stage.tipToHubSectionArea;	// k=0.55 => tip cut area 16,5% of hub cut area
			stage.bladeThicknessInMiddle = stage.bladeThicknessInTip + (stage.bladeThicknessInHub-stage.bladeThicknessInTip)*(stage.rTip-rMiddle)/(stage.rTip-stage.rHub);
			
			// Momentum/m: (rMiddle/hubThickness * F) / (solidity(=2)*rHub*2*PI)  = (unusedTensileStress/2) * 1 m * hubThickness
			// => hubThickness = (rMiddle/hubThickness * F) / ((solidity(=2)*rHub*2*PI)*(unusedTensileStress/2))
			/*const bladeThicknessInHub = Math.sqrt(rMiddle*stage.F / (stageData.solidity*stage.rHub*Math.PI*unusedTensileStress));
			const bladeThicknessInTip = bladeThicknessInHub*0.15;*/
			// usedMomentumStress*b*h^2/6=r75MomentumPerM, where b=1 and h=bladeThicknessInMiddle =>
			const usedMomentumStressInMiddle = 6*r75MomentumPerM / (stage.bladeThicknessInMiddle*stage.bladeThicknessInMiddle*1);
			const usedMomentumStressInHub = 6*hubMomentumPerM / (stage.bladeThicknessInHub*stage.bladeThicknessInHub*1);
			stage.yieldMomentMidHubMPa = //Math.round(usedMomentumStressInMiddle/1000000)+'/'+
				Math.round(usedMomentumStressInHub/1000000);
//console.log("hubMomentumPerM="+hubMomentumPerM+", bladeThicknessInHub="+bladeThicknessInHub+",  usedMomentumStressInHub="+usedMomentumStressInHub);
			stage.totalTensileStressPercentMidHub = Math.round(((stage.tensileStressMPa + usedMomentumStressInMiddle/1000000) / stage.maxTensileStressMPa) * 100)+"/"
													+Math.round(((stage.tensileStressMPa + usedMomentumStressInHub/1000000) / stage.maxTensileStressMPa) * 100);

			// min chord is defined by max tensile stress
			//const minChord = (bladeThicknessInMiddle/stageData.t2cInMiddleFlow);
			//const defaultChord = (stage.rTip-stage.rHub) / stageData.aspectRatio;
			const bladeHeight = stage.rTip-stage.rHub;
			/* We cannot yet handle variable aspect ratio
			if (minChord > defaultChord) {
				stage.aspectRatio = ((stage.rTip-stage.rHub)) / minChord;
				stage.bladeThicknessInMiddle = (bladeThicknessInMiddle/minChord);
			}
			else */
			{
				stage.aspectRatio = stageData.aspectRatio;
				//stage.bladeThicknessInMiddle = (bladeThicknessInMiddle/defaultChord);
				// /0.75 scales the thickness of rectangle shape to the actual max thickness of a typical subsonic blade such as British C4 or C7 or NACA 65
				const middleMaxThickness = 100/0.75*stage.bladeThicknessInMiddle/bladeHeight
				stage.bladeMaxThicknessMid = //myRound(100/0.75*stage.bladeThicknessInTip/defaultChord,1)+'/'+
					myRound(middleMaxThickness,1);
				stage.bladeMaxThicknessHub = //myRound(100/0.75*stage.bladeThicknessInTip/defaultChord,1)+'/'+
					myRound(100/0.75*stage.bladeThicknessInHub/bladeHeight,1);
				// Re(h) exp(6) is between 3 and 5 (instead of 0.5) => Add 0.5 to the the calculated values of 
				// Figure 27 in  https://api.repository.cam.ac.uk/server/api/core/bitstreams/fbfb70fe-58b3-47fb-a338-859384279d7c/content
				const AR_at_1 = 2.25;
				const AR_at_5 = 1.7;
				stage.aspectRatio =  AR_at_1 - (middleMaxThickness-1)/(5-1)*(AR_at_1-AR_at_5);
/*
				var visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t, name);
				if (visc == Infinity) {
					visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t+0.1, name);	// use gas viscosity, ignore the obvious wetness here
				}
				if (visc != Infinity) {
					const hRe = stages[i].d * ((stages[i].rTip-stages[i].rHub)) * stages[i].v / visc;
				}
*/
			}
//console.log("*****"+stageData.stages.length+":rMiddle="+rMiddle+", bladeThicknessIn hub/Middl//e/tip="+stage.bladeThicknessInHub+"/"+stage.bladeThicknessInMiddle+"/"+stage.bladeThicknessInTip+", AR:"+stage.aspectRatio);
			stage.stageWidth2h = Math.cos(stageData.β2) / (0.35*stage.aspectRatio);		// e.g: rotor:gap:stator:gap 35:15:35:15 
			return deltaH;
		}

		stageData.maxStressExceeded = false;
		stageData.cStages = getIntParam('cStages', 0);
	    const hotCompressorTypeConstantH = $('#hotCompressorTypeConstantH').prop('checked');

console.log("cStages="+stageData.cStages+"grossPower="+grossPower+", hotCompressorTypeConstantH="+hotCompressorTypeConstantH); 
		if (hotCompressorTypeConstantH && stageData.cStages && grossPower) {
			stageData.constantDeltaH = (grossPower / stageData.cStages) / massFlowInKg;
			stageData.U = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMin);
			stageData.v = stageData.U*stageData.flowCoefficientMin;
			stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
console.log("stageData.constantDeltaH="+stageData.constantDeltaH); 
		}
		else {
			stageData.constantDeltaH = 0;
		}
		if (first.t < 273) 
		{
			if ($('#coldCompressorTypeConstantH').prop('checked')) {
				stageData.cStages = getIntParam('cColdStages', 0);
				stageData.constantDeltaH = (grossPower / stageData.cStages) / massFlowInKg;
				stageData.U = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMin);
				stageData.v = stageData.U*stageData.flowCoefficientMin;
				stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
console.log("Cold stageData.constantDeltaH="+stageData.constantDeltaH); 
			}
			else {
				stageData.constantDeltaH = 0;
				stageData.machMaxSpeed = getFloatParam('machMaxSpeedCold', 0.95);		// < 0.8 => subsonic, <= 1.2 => transonic, Relative MACH number in rotor tip, TOP SPEED OF GAS RELATIVE TO BLADE AND STAGE: Use Vrel1(β1) instead Vasb2!!!!
			}
		}
		stageData.maxStatorHubAbsSpeed = 0.7;	// ABSOLUTE MACH NUMBER IN STATOR HUB
		stageData.K = 0.55;			// defines <tip section area>/<hub section area>, typical range 0.55-0.65
		stageData.massFlowInKg = massFlowInKg;
		stageData.flowCoefficientToStageLoadingCoefficient = 1;
		stageData.maxRpmStages = 1;
		stageData.vGearMax = 180; // RENK Het Gear: max pitch line velocity 
		stageData.isCompressor = isCompressor;
		stageData.efficiency = stageEfficiency;
		stageData.tanβ1 = (1/2 + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
		stageData.tanβ2 = (1/2 - stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
		stageData.β1deg = 180 * Math.atan(stageData.tanβ1)/Math.PI;
		stageData.β2 = Math.atan(stageData.tanβ2);
		stageData.β2deg = 180 * stageData.β2/Math.PI;
		stageData.β1 = Math.atan(stageData.tanβ1);

		stageData.hubStageLoadingCoefficient = stageData.stageLoadingCoefficientMin/(stageData.hubToTipRatio*stageData.hubToTipRatio);
		stageData.hubFlowCoefficient = stageData.flowCoefficientMin / stageData.hubToTipRatio;
		stageData.hubβ1 = Math.atan((1/2 + stageData.hubStageLoadingCoefficient/2)/stageData.hubFlowCoefficient);
		stageData.hubβ1deg = 180 * stageData.hubβ1/Math.PI;

		// almost ordinary steel:
		stageData.shaftStrength = getFloatParam('shaftStrength',1000)*1000000 * 0.3;	// 0.4 OK for short term, max strength 1000 MPa * 0.3 => long term strength as shaft 300 MPa = 300000000 N/m2, short term 0.4
		stageData.shaftBearingSpace = getFloatParam('bearingSpace',2)/1000;	// 2 mm is probably enough for bearing, but is it enough for bearing oil pipe if used
		//stageData.shaftBearingSpace = 0.002;	// 5 mm is probably enough for bearing, but is it enough for bearing oil pipe if used
		stageData.rInnerShaftCoolingPipe = 0.010;	// 
		stageData.minShaftPipeWidth = getFloatParam('minShaftPipeWidth', 5)/1000;	//
		stageData.generatorRpm = 3000;	// 50 Hz power plant generator

		// https://en.wikipedia.org/wiki/Maraging_steel Grade 350
		//stageData.shaftStrength = 2413000000 * 0.35;	// 0.4 OK for short term, max strength 1000 MPa * 0.3 => long term strength as shaft 300 MPa = 300000000 N/m2, short term 0.4
		// We use β2 as the stagger angle, because β2 seems to be quite near to it in in picture. I did not find any easy way to calc the stagger angle
		//stageData.stageWidth2h = Math.cos(stageData.β2) / (0.35*stageData.aspectRatio);		// e.g: rotor:gap:stator:gap 35:15:35:15 
		stageData.getCompressorMetrics = function( stageData) {
			const frameTop = [];
			const frameBottom = [];
			const yInletPipe = inletPipeDiameter/2;
			const yExitPipe = exitPipeDiameter/2;
			const frameThickness = 0.050;
			const gearWidth = 0.250;
			const tipGap = 0.002;
			var stageData = this;
			function getInnerRadius(iStage) {
				iStage++;
				while (iStage < stageData.stages.length) {
					if (stageData.stages[iStage].rShaft) return stageData.stages[iStage].rShaft + stageData.shaftBearingSpace;
					iStage++;
				}
				return stageData.rInnerShaftCoolingPipe;
			}
			var xNextGear, nextBladeBasementFromX;
			var nextBladeBasement = [];
			var metrics = {};
			metrics.rotors = [];
			metrics.stators = [];
			metrics.shafts = [];
			metrics.bladeBasements = [];
			metrics.generatorShaft = [];
			metrics.whiteAreas = [];
			
			var x = 0;
			var nextHookP1 = 0, nextHookP2 = 0;
			var i, p, pb, pb2;
			for (i = 0; i < stageData.stages.length; i++) {
				const nextTip = i < stageData.stages.length-1 ? stageData.stages[i+1].rTip : stageData.hpExit.rTip;
				const nextHub = i < stageData.stages.length-1 ? stageData.stages[i+1].rHub : stageData.hpExit.rHub;
				const rInnerShaft = getInnerRadius(i);
				const stage = stageData.stages[i];

				var points = [];
				if (i == 0) {
					p=toPoint(-stage.width*(yInletPipe-stage.rTip)/(stage.rTip-nextTip), yInletPipe+tipGap);
					frameBottom.push(toPoint(p.x-0.1, p.y));
					frameBottom.push(p);
					frameTop.push(toPoint(p.x-0.1, p.y+frameThickness));
					frameTop.push(toPoint(p.x, p.y+frameThickness));
					frameBottom.push(p=toPoint(x, stage.rTip+tipGap));
					frameTop.push(toPoint(p.x, p.y+frameThickness));
					xNextGear = p.x-(inletPipeDiameter+frameThickness+gearWidth); // the gears box is immediately after the pipe turns up 90 degrees
					
					// IGV:
					var p2, p3;
					points.push(p = toPoint(x-stage.width*0.05, stage.rShaft+stageData.shaftBearingSpace)); // 
					points.push(toPoint(p.x, stage.rHub*0.94)); 
					points.push(toPoint(x-0.002, stage.rHub)); 
					points.push(toPoint(p.x, stage.rHub)); 
					points.push(toPoint(x-stage.width*0.05, stage.rTip+(stage.rTip-nextTip)*0.05+tipGap));
					points.push(toPoint(x-stage.width*0.40, stage.rTip+(stage.rTip-nextTip)*0.40+tipGap));
					points.push(toPoint(x-stage.width*0.40, stage.rShaft+stageData.shaftBearingSpace)); // 45 degrees down
					points.push(p);
					metrics.stators.push(points);

					// middle cone directing flow to compressor
					points = [];
					points.push(p3 = toPoint(x-stage.width*0.325, stage.rHub));
					points.push(p2=toPoint(p3.x-(p3.y-stage.rShaft+0.02), stage.rShaft+0.02)); // continues 45 degrees until top shaft
					points.push(toPoint(p2.x+stage.width/6, p2.y));
					points.push(toPoint(p3.x+stage.width/6, p3.y));
					points.push(p3);
					metrics.stators.push(points);

					// Shaft cover and insulation, perhaps about 70 mm
					points = [];
					points.push(p3 = toPoint(x-0.002, stage.rShaft+0.02)); // 45 degrees down
					points.push(p2 = toPoint(xNextGear+gearWidth, p2.y));
					points.push(toPoint(p2.x, p2.y+0.035));
					points.push(toPoint(p3.x, p3.y+0.035));
					metrics.stators.push(points);	
					points = [];
				}
				points.push(p = toPoint(x,stage.rTip));
				points.push(toPoint(x+stage.width*0.35, stage.rTip-(stage.rTip-nextTip)*0.35));
				points.push(pb2 = toPoint(x+stage.width*0.35, stage.rHub-(stage.rHub-nextHub)*0.35));
				points.push(pb = toPoint(x,stage.rHub));
				if (nextHookP1 && nextHookP2) {
					nextBladeBasement.push(nextHookP1);
					nextBladeBasement.push(nextHookP2);
				}
				nextBladeBasement.push(pb);
				nextBladeBasement.push(pb2);
				points.push(p);
				metrics.rotors.push(points);
				points = [];
				var p2;
				points.push(p = toPoint(x+stage.width*0.5, stage.rTip-(stage.rTip-nextTip)*0.5+tipGap));
				points.push(toPoint(x+stage.width*(i == stageData.stages.length-1 ? 1 : 0.85), stage.rTip-(stage.rTip-nextTip)*(i == stageData.stages.length-1 ? 1 : 0.85)+tipGap));
				points.push(p2 = toPoint(x+stage.width*(i == stageData.stages.length-1 ? 1 : 0.85), stage.rHub-(stage.rHub-nextHub)*(i == stageData.stages.length-1 ? 1 : 0.85)+tipGap));
				if (i == stageData.stages.length-1) {
					points.push(toPoint(x+stage.width + nextHub, 0));
					const xDistM = stage.width*0.15/Math.cos(Math.PI/4);
					points.push(toPoint(x+stage.width + nextHub-xDistM, 0));
					points.push(toPoint(p2.x-xDistM, p2.y));	// *0.97

//					points.push(toPoint(pb2.x+0.002, pb2.y-0.01));
//					points.push(toPoint(pb2.x+0.002, pb2.y));

					var points2 = [];
					points2.push(toPoint(x+stage.width-0.002, nextHub));
					points2.push(toPoint(x+stage.width+stage.width*0.35, stageData.stages[i].rShaft+0.002));
					points2.push(toPoint(x+stage.width+0.002, stageData.stages[i].rShaft+0.002));
					points2.push(toPoint(x+stage.width-stage.width*0.35, stage.rHub));
					//points2.push(toPoint(x+stage.width*0.50, stage.rHub-(stage.rHub-nextHub)*0.50)+tipGap);
					points2.push(toPoint(x+stage.width-0.002, nextHub));
					metrics.stators.push(points2);
				}
				points.push(p = toPoint(x+stage.width*0.5, stage.rHub-(stage.rHub-nextHub)*0.5+tipGap));
				points.push(p);
				metrics.stators.push(points);
				
				{
					var p1, p2, p3, stageShaft,k;
					for (k = i; k < stageData.stages.length; k++) {
						if (stageData.stages[k].rShaft) {
							stageShaft = stageData.stages[k].rShaft;
							break;
						}
					}
					if (i < stageData.stages.length-1)
					{
						const peek = stage.rHub-(stage.rHub-nextHub)*(stage.width-0.004)/stage.width;
						nextBladeBasement.push(toPoint(x+stage.width-0.004, peek));
						nextBladeBasement.push(toPoint(x+stage.width*0.85, nextHub ));
						nextHookP1 = toPoint(x+stage.width, nextHub*0.95 );
						nextHookP2 = toPoint(x+stage.width*0.95, nextHub-tipGap );
						nextBladeBasement.push(toPoint(x+stage.width*0.85, stageShaft));
						nextBladeBasement.push(toPoint(x+stage.width*0.80, stageShaft));
						nextBladeBasement.push(toPoint(x+stage.width*0.80, nextHub*0.99));

						var  whiteArea = [];
						p1 = toPoint(pb2.x, (stage.rHub > nextHub ? nextHub*0.95 : 2*stage.rHub - nextHub));
						whiteArea.push(p = toPoint(x+stage.width*0.35, stageShaft));
						whiteArea.push(toPoint(x+stage.width*0.80, stageShaft));
						whiteArea.push(toPoint(x+stage.width*0.80, yTemp = stageShaft+(p1.y-stageShaft)*(0.90-0.80)/(0.80-0.35)*0.90)-0.01);
						whiteArea.push(toPoint(x+stage.width*0.35, stageShaft+(p1.y-stageShaft)*0.90));
						whiteArea.push(p);
						metrics.whiteAreas.push(whiteArea);
					}
					else {
						// TBD
						const peek = stage.rHub-(stage.rHub-nextHub)*0.65 - 0.001;
						nextBladeBasement.push(toPoint(x+stage.width*0.65, peek));
						nextBladeBasement.push(toPoint(x+stage.width*0.60, peek-stage.width*0.05 ));
						nextHookP1 = toPoint(x+stage.width, nextHub*0.95 );
						nextHookP2 = toPoint(x+stage.width*0.61, nextHub-tipGap );
						nextBladeBasement.push(toPoint(x+stage.width*0.85, stageShaft));
						nextBladeBasement.push(toPoint(x+stage.width*0.80, stageShaft));
						nextBladeBasement.push(toPoint(x+stage.width*0.55, peek-stage.width*0.05));
/*
*/
						var  whiteArea = [];
						p1 = toPoint(pb2.x, (stage.rHub > nextHub ? nextHub*0.95 : 2*stage.rHub - nextHub));
						whiteArea.push(p = toPoint(x+stage.width*0.35, stageShaft));
						whiteArea.push(toPoint(x+stage.width*0.80, stageShaft));
						whiteArea.push(toPoint(x+stage.width*0.60, yTemp = stageShaft+(p1.y-stageShaft)*(0.90-0.80)/(0.80-0.35)*0.90)-0.01);
						whiteArea.push(toPoint(x+stage.width*0.35, stageShaft+(p1.y-stageShaft)*0.90));
						whiteArea.push(p);
						metrics.whiteAreas.push(whiteArea);
					}
					nextBladeBasement.push(p1 = toPoint(pb2.x, (stage.rHub > nextHub ? nextHub*0.95 : 2*stage.rHub - nextHub)));
					nextBladeBasement.push(p2 = toPoint(x+stage.width*0.96, stageShaft));
					nextBladeBasement.push(toPoint(nextBladeBasement[0].x, stageShaft));
					nextBladeBasement.push(nextBladeBasement[0]);
					metrics.bladeBasements.push(nextBladeBasement);
/*
					var  whiteArea = [];
					whiteArea.push(p = toPoint(x+stage.width*0.35, stageShaft));
					whiteArea.push(toPoint(x+stage.width*0.80, stageShaft));
					whiteArea.push(toPoint(x+stage.width*0.80, yTemp = stageShaft+(p1.y-stageShaft)*(0.90-0.80)/(0.80-0.35)*0.90)-0.01);
					whiteArea.push(toPoint(x+stage.width*0.35, stageShaft+(p1.y-stageShaft)*0.90));
					whiteArea.push(p);
					metrics.whiteAreas.push(whiteArea);
*/
					nextBladeBasement = [];
				}
				if (stage.rpmPower) 
				{
					points = [];
					points.push(p = toPoint(xNextGear, stage.rGear));
					points.push(toPoint(xNextGear+gearWidth/2, stage.rGear));
					points.push(toPoint(xNextGear+gearWidth/2, stage.rShaft));
					points.push(toPoint(x+stage.width*(i == stageData.stages.length-1 ? 1.4 : 0.96), stage.rShaft));
					points.push(toPoint(x+stage.width*(i == stageData.stages.length-1 ? 1.4 : 0.96), rInnerShaft));
					points.push(toPoint(xNextGear, rInnerShaft));
					points.push(p);
					metrics.shafts.push(points);

					points = [];
					const genShaftRadius = stageData.gearCenterDifference - stage.rGear < 0.075 ? stageData.gearCenterDifference - stage.rGear : 0.075;
					points.push(p = toPoint(xNextGear-gearWidth/2-0.01, stageData.gearCenterDifference + genShaftRadius));
					points.push(toPoint(xNextGear, stageData.gearCenterDifference + genShaftRadius));
					points.push(toPoint(xNextGear, 2*stageData.gearCenterDifference - stage.rGear));
					points.push(toPoint(xNextGear+gearWidth/2, 2*stageData.gearCenterDifference - stage.rGear));
					points.push(toPoint(xNextGear+gearWidth/2, stage.rGear));
					points.push(toPoint(xNextGear, stage.rGear));
					points.push(toPoint(xNextGear, stageData.gearCenterDifference - genShaftRadius));
					points.push(toPoint(xNextGear-gearWidth/2-0.01, stageData.gearCenterDifference - genShaftRadius));
					points.push(p);
					metrics.generatorShaft.push(points);

					xNextGear -= gearWidth;
				}
				x += stage.width;
				frameBottom.push(p=toPoint(x, nextTip+tipGap));
				frameTop.push(toPoint(p.x, p.y+frameThickness));
				if (i == stageData.stages.length-1) {
					frameBottom.push(p=toPoint(x+(yExitPipe-nextTip), yExitPipe));
					frameBottom.push(toPoint(p.x+0.1, p.y));
					frameTop.push(toPoint(p.x, p.y+frameThickness));
					frameTop.push(toPoint(p.x+0.1, p.y+frameThickness));
				}
			}
			metrics.minX = xNextGear + gearWidth - 0.1;
			metrics.maxX = frameBottom[frameBottom.length-1].x + 0.1;
			metrics.maxY = frameTop[0].y + 0.1;
			metrics.minY = -metrics.maxY;
			
			metrics.frame = frameTop.concat(frameBottom.reverse());
			metrics.frame.push(metrics.frame[0]);
			
			return metrics;
		}

		// Axial speed v has increased 2 times faster at rotor exit than mach in p, t 
		// Typical v and mach incerement per stage with the values above is between 1.04 and 1.05
		// => we will decrease v here by 1/1.02 to adjust it to the local mach number
		stageData.vvAbs2Mach = Math.sqrt(Math.pow(stageData.machMaxSpeed,2)/(Math.pow(1/stageData.flowCoefficientMin-stageData.tanβ2,2) + 1)) / 1.0225; 
		stageData.vMach = Math.cos(stageData.β1)*stageData.machMaxSpeed;
		stageData.machRelHub = stageData.vMach / Math.cos(stageData.hubβ1);

if (!first.p || !last.p) console.log("Bad cycledata:"+JSON.stringify(data.items));
		const speedIn = (massFlowInKg/first.d)/(Math.PI*inletPipeDiameter*inletPipeDiameter/4); 
		const speedOut = (massFlowInKg/last.d)/(Math.PI*exitPipeDiameter*exitPipeDiameter/4);
		stageData.speedOut = speedOut;
		last.v = speedOut;
		first.v = speedIn;
		stageData.pHigh = last.p;
		
		stageData.hIn = first.h + 0.5 * first.v * first.v;
		stageData.hOut = stageData.hEnd = last.h + 0.5* speedOut * speedOut;
console.log("speedOut="+speedOut+", exitPipeDiameter="+exitPipeDiameter+", hEnd="+stageData.hEnd);
		first.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', first.p, 'H', first.h, name);
		if (first.speedOfSound === Infinity) {
			first.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', first.p, 'T', first.t+0.1, name);
		}
		var inlet = {};
		{
			var vMachInlet = stageData.vMach
			var v = stageData.constantDeltaH ? stageData.v : stageData.vMach*first.speedOfSound;
			//v = stageData.vMachLimitForFirstStage*first.speedOfSound;
			first.s = Module.PropsSI('S','P', first.p, 'H', first.h, name);
			var hKinetic = 0.5* v*v;
			if (stageData.constantDeltaH) {
				inlet.v = stageData.v;
				inlet.h = first.h + 0.5*first.v*first.v-hKinetic;
				inlet.p = Module.PropsSI('P','S', first.s, 'H', inlet.h, name);
				inlet.t = Module.PropsSI('T','S', first.s, 'H', inlet.h, name);
				inlet.d = Module.PropsSI('D','S', first.s, 'H', inlet.h, name);
				if (inlet.d === Infinity) {
					inlet.d = Module.PropsSI('D','P', p, 'T', inlet.t+0.1, name);
				}
				inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
if (!inlet.p || !first.s) {
	console.trace("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
	var x = foo;	// break!!!
}
//else console.log("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));


			}
			else {
				var hMin = first.h - hKinetic*1.1;
				var pMin = Module.PropsSI('P','H', hMin, 'S', first.s, name);
				while (pMin == Infinity) {
					vMachInlet = vMachInlet*0.98;
					v = stageData.constantDeltaH ? stageData.v : vMachInlet*first.speedOfSound;
					hKinetic = 0.5* v*v;
					hMin = first.h - hKinetic*1.1;
					pMin = Module.PropsSI('P','H', hMin, 'S', first.s, name);
				}
//console.log("First item:"+JSON.stringify(first)+", pMin="+pMin+", hMin="+hMin+", stageData="+JSON.stringify(stageData));
				var ret = testResult(first.h, pMin, first.p, hKinetic*0.01, function(p) {
					inlet.p = p;
					inlet.h = Module.PropsSI('H','P', p, 'S', first.s, name);
					inlet.t = Module.PropsSI('T','P', p, 'S', first.s, name);
					inlet.d = Module.PropsSI('D','P', p, 'S', first.s, name);
					if (inlet.d === Infinity) {
						inlet.d = Module.PropsSI('D','P', p, 'T', inlet.t+0.1, name);
					}
					inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
					if (inlet.speedOfSound === Infinity) {
						inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'T', inlet.t+0.1, name);
					}
					//inlet.v = stageData.vMachLimitForFirstStage*inlet.speedOfSound;
					if (stageData.constantDeltaH) {
						inlet.v = stage.v;
					}
					else {
						inlet.v = vMachInlet*inlet.speedOfSound;
					}
					return inlet.h + 0.5*inlet.v*inlet.v;
				});
				console.log(title+" inlet:"+JSON.stringify(inlet));
				if (!ret || inlet.d === Infinity || !inlet.d || typeof inlet.d === 'undefined') {
					console.log("Bad inlet, first:"+JSON.stringify(first));
					return;
				}
			}
		}
		// let's first assume, that we can rotate around the middle line shaft
		var item = inlet;
		stageData.inlet = inlet;
		stageData.first = first;
		stageData.last = last;
		stageData.horizontalVector = 1;
//console.log("inlet="+JSON.stringify(inlet));
		calcCompressorStages( stageData, inlet ); 
		var stages = stageData.stages;
		var i;
		if (stageData.constantDeltaH) {
			var actualPower = 0;
			for (i = 0; i < stages.length; i++) {
				actualPower += stages[i].deltaH*stageData.massFlowInKg;
			}
			const constantDeltaH = (actualPower / stageData.cStages) / massFlowInKg;
//console.log("***grossPower="+grossPower+" => actualPower="+actualPower+", deltaH:"+stageData.constantDeltaH+"=>"+constantDeltaH);
			stageData.constantDeltaH = constantDeltaH;
			stageData.U = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMin);
			stageData.v = stageData.U*stageData.flowCoefficientMin;
			stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
			const hKinetic = 0.5* v*v;
			inlet.v = stageData.v;
			inlet.h = first.h + 0.5*first.v*first.v-hKinetic;
			inlet.p = Module.PropsSI('P','S', first.s, 'H', inlet.h, name);
			inlet.t = Module.PropsSI('T','S', first.s, 'H', inlet.h, name);
			inlet.d = Module.PropsSI('D','S', first.s, 'H', inlet.h, name);
			if (inlet.d === Infinity) {
				inlet.d = Module.PropsSI('D','P', p, 'T', inlet.t+0.1, name);
			}
if (!inlet.p || !first.s) {
	console.trace("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
	var x = foo;	// break!!!
}
//else console.log("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
			inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
			calcCompressorStages( stageData, inlet ); 
			if (stageData.constantDeltaH)
			{
				var actualPower = 0;
				stages = stageData.stages;
				for (i = 0; i < stages.length; i++) {
					actualPower += stages[i].deltaH*stageData.massFlowInKg;
				}
				const constantDeltaH = (actualPower / stageData.cStages) / massFlowInKg;
//console.log("***grossPower="+grossPower+" => actualPower="+actualPower+", deltaH:"+stageData.constantDeltaH+"=>"+constantDeltaH);
				if (stageData.constantDeltaH != constantDeltaH) {
					stageData.constantDeltaH = constantDeltaH;
					stageData.U = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMin);
					stageData.v = stageData.U*stageData.flowCoefficientMin;
					stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
					const hKinetic = 0.5* v*v;
					inlet.v = stageData.v;
					inlet.h = first.h + 0.5*first.v*first.v-hKinetic;
					inlet.p = Module.PropsSI('P','S', first.s, 'H', inlet.h, name);
					inlet.t = Module.PropsSI('T','S', first.s, 'H', inlet.h, name);
					inlet.d = Module.PropsSI('D','S', first.s, 'H', inlet.h, name);
					if (inlet.d === Infinity) {
						inlet.d = Module.PropsSI('D','P', p, 'T', inlet.t+0.1, name);
					}
					inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
if (!inlet.p || !first.s) {
	console.trace("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
	var x = foo;	// break!!!
}
else console.log("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
				}
			}
		}
		item = inlet;
		stageData.inlet = inlet;
		cosAll = 0;
		stages = stageData.stages;
		stageData.horizontalVectors = [];
		for (i = 0; i < stages.length; i++) {
//console.log(i+"/"+stages.length+":"+JSON.stringify(stages[i]));
			const cos = (stages[i].rTip-stages[i].rHub)*stages[i].stageWidth2h;
			const sin = (stages[i].rTip+stages[i].rHub)/2 - (i == (stages.length - 1) ? (stageData.hpExit.rTip + stageData.hpExit.rHub)/2 : (stages[i+1].rTip + stages[i+1].rHub)/2);
			const r = Math.sqrt(sin*sin + cos*cos);
			stageData.horizontalVectors.push(cos/r);
			cosAll += cos;
		}
		stageData.middleLineLength = cosAll;
		// Basic trigonometry: we know the approximate middle line length to turn rotors up
//console.log("stages:"+JSON.stringify(stages)+", stageData.horizontalVector="+stageData.horizontalVector);
//console.log("items:"+JSON.stringify(stageData.items));
		const sinAll = (stages[0].rTip+stages[0].rHub)/2 - (stages[stages.length-1].rTip + stages[stages.length-1].rHub)/2;
		const rAll = Math.sqrt(sinAll*sinAll + cosAll*cosAll);

		// now we turn the rotors up because of very strong centrifugal force 
		// The rotors must be in the vertical position straight up, because otherwise the centrifugical force will be pushing rotors to the same direction as the gas compression.
		// so we must turn the rotors up and calclulate everything again 
		stageData.horizontalVector = cosAll/rAll;
console.log("*****stageData.horizontalVector="+stageData.horizontalVector+", stageData.horizontalVectors="+JSON.stringify(stageData.horizontalVectors));
		//stageData.horizontalVectors = null;

		// calc again with rotor rotaing vertically
		calcCompressorStages( stageData, inlet ); 

		if (stageData.constantDeltaH)
		{
			stages = stageData.stages;
			var actualPower = 0;
			for (i = 0; i < stages.length; i++) {
				actualPower += stages[i].deltaH*stageData.massFlowInKg;
			}
			const constantDeltaH = (actualPower / stageData.cStages) / massFlowInKg;
console.log("***grossPower="+grossPower+" => actualPower="+actualPower+", deltaH:"+stageData.constantDeltaH+"=>"+constantDeltaH);
		}
		if (typeof stageData.exit === 'undefined') stageData.exit = last;
		item.s = Module.PropsSI('S','P', item.p, 'T', item.t, name);

		stageData.length = 0;
		stages = stageData.stages;
		var rpmPower = 0;
		var prevRmp = -1;
		var totalPower = 0;
		
		
		for (i = 0; i < stages.length; i++) {
			const tanβ2 = (1/2 - stages[i].stageLoadingCoefficient/2)/stages[i].flowCoefficient;
			const β2 = Math.atan(tanβ2);
			stages[i].β2deg = 180 * β2/Math.PI;
			const stageWidth2h = Math.cos(β2) / (0.35*stages[i].aspectRatio);		// e.g: rotor:gap:stator:gap 35:15:35:15 
			stages[i].width = (stages[i].rTip-stages[i].rHub)*stageWidth2h*(stageData.horizontalVectors ?  stageData.horizontalVectors[i] : stageData.horizontalVector);
if (!stages[i].width) console.log(i+"null width!!!, hv="+stageData.horizontalVectors[i])
			stages[i].diameterMm = (stages[i].rTip+0.002)*2*1000;
			stages[i].rTipMm = stages[i].rTip*1000;
			const hubToTip = (stages[i].rHub/stages[i].rTip);
			stages[i].hBladeMm = (stages[i].rTip - stages[i].rHub)*1000;
			stages[i].chordMm = stages[i].hBladeMm / stages[i].aspectRatio;
			stages[i].hubStageLoadingCoefficient = stages[i].stageLoadingCoefficient/(hubToTip*hubToTip);
			stages[i].hubFlowCoefficient = stages[i].flowCoefficient / hubToTip;
			stages[i].hubβ2deg = 180/Math.PI * Math.atan((1/2 - stages[i].hubStageLoadingCoefficient/2)/stages[i].hubFlowCoefficient);
			const deltaP = i == stages.length-1 ? stageData.hpExit.p : stages[i+1].p - stages[i].p;
			stages[i].pRiseCoeffcient = 2*deltaP/(stages[i].d*stages[i].U*stages[i].U);
			const tipTanβ1 = (1/2 + stages[i].stageLoadingCoefficient/2)/stages[i].flowCoefficient;
			const tipβ1 = Math.atan(tipTanβ1);
			stages[i].machRelTip = stages[i].v / (stages[i].mach * Math.cos(tipβ1));
			const hubTanβ1 = (1/2 + stages[i].hubStageLoadingCoefficient/2)/stages[i].hubFlowCoefficient;
			const hubβ1 = Math.atan(hubTanβ1);
			stages[i].machRelHub = stages[i].v / (stages[i].mach * Math.cos(hubβ1));
			// deltaH + 0.5*v^2 = 0.5*v2^2  => v2 = sqrt( 2*deltaH + v^2)

/*
	Centrifugal force cannot fix the 

			// let's assume that rotor is in 10 degree agle backward => 
			//stages[i].F = totalBladeMass * U^2 /rTip * sin(10)
			// =>totalBladeMass = stages[i].F/(U^2 /rTip * sin(10))
			const totalBladesMass = stages[i].F / (stages[i].U*stages[i].U*Math.sin(Math.PI/18) / stages[i].rTip);
console.log(totalBladesMass+" = "+stages[i].F+" / ("+(stages[i].U*stages[i].U)+"*"+Math.sin(Math.PI/18)+" / "+stages[i].rTip);
			// Next we calculate blade width from this know mass of all blades
			// <Blade tipArea> = 0.3 * <blade hubArea> 
			// => totalBladeMass = 0.65 * (rTip-rHub)*2*PI*rHub*hubWidth*(hubSolidity=2)
			// => bladeThicknessInHub = totalBladeMas/(0.65 * (rTip-rHub)*2*PI*rHub*2) * density(8);
			stages[i].bladeThicknessInHub = totalBladesMass/(0.65 * 8 * (stages[i].rTip-stages[i].rHub)*2*Math.PI*stages[i].rHub*2);
*/
/* Rotor tips are VERY VERY HOLLOW AND SLIM COMPARED TO THICKNESS IN HUB, d=0.15 => K=0.55

			if (i == 0) {
				var d;
				for (d = 0.1125; d < 0.5; d += 0.025) {
					const K = 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
					console.log("****** d="+d+" => K="+K);
				}
			}
			// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
			// => d=0.1625 => K=0.5516289551934646
			// => d=0.35 => K~0.65
*/
	
			stages[i].tensileStressMPa = 0.5*stages[i].U*stages[i].U*8000*(1-hubToTip*hubToTip)*stages[i].K/1000000; // Nimonics: 8000 kg/m3, austentic steel alloy density 7800kg/m3)
			if (i == stages.length-1) {
				stages[i].pRatio = stageData.hpExit.p / stages[i].p;
			}
			else {
				stages[i].pRatio = stages[i+1].p / stages[i].p;
			}
			var visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t, name);
			if (visc == Infinity) {
				visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t+0.1, name);	// use gas viscosity, ignore the obvious wetness here
			}
			if (visc != Infinity) {
				stages[i].cRe = stages[i].d * ((stages[i].rTip-stages[i].rHub)/stages[i].aspectRatio) * stages[i].v / visc;
				stages[i].cReText = stages[i].cRe/1000000;
			}
			const area = Math.PI*(stages[i].rTip*stages[i].rTip -  stages[i].rHub*stages[i].rHub);
			stages[i].AN2EXP8=stages[i].rpm*stages[i].rpm*area/100000000;
			stageData.length += stages[i].width;
			if (prevRmp != stages[i].rpm && rpmPower != 0) {
				stages[i-1].rpmPower = rpmPower;
				totalPower += rpmPower;
				rpmPower = 0;
			}
			stages[i].stagePower = stages[i].deltaH*stageData.massFlowInKg;
			rpmPower += stages[i].stagePower;
			prevRmp = stages[i].rpm;
		}
		totalPower += rpmPower;
		stages[i-1].rpmPower = rpmPower;
		var rPrev = 0, rPrevPrev = 0;
		// Md = 9500 * P / rpm;
		// Wvsall = Md / (max stength) * 0.4;
		// r = pow(2 * Wvsall/PI, 1/3);
		// Ja putkella: r^2*t = 2 * Wvsall/PI, jossa r on ulkohakaisija, ja renkaan paksuus
		// Kun sisähalkaisija tunnettu saadaan t = r-rIn
		var gearCenterDifferenceScale = 1;
		
		for (i = stages.length-1; i >= 0; i--) {
			if (stages[i].rpmPower) {
				// https://www.theseus.fi/bitstream/handle/10024/77283/Hartikainen_Matti.pdf?sequence=1
				const curPower =  stages[i].rpmPower * 1.2; // stages[i].deltaH //
				// stages[i].rpmPower, https://en.wikipedia.org/wiki/Torque: P = Mn*2*PI*rpm/60;
				const Md = 60 * curPower / (2 * Math.PI * stages[i].rpm);
				// Wx = 2*Wi/PI =>
				const Wx = 2 * (Md / stageData.shaftStrength) / Math.PI;
				if (rPrev == 0) {
					if (stageData.rInnerShaftCoolingPipe == 0) {
						stages[i].rShaft = Math.pow(Wx, 1/3);
					}
					else {
						testResult( Wx, stageData.rInnerShaftCoolingPipe, 0.20+stageData.rInnerShaftCoolingPipe, Wx*0.01, function (r) {
							stages[i].rShaft = r;
							return (Math.pow(r,4)-Math.pow(stageData.rInnerShaftCoolingPipe,4)) / r;
						});
						stages[i].shaftPipeWidth = stages[i].rShaft - stageData.rInnerShaftCoolingPipe;
					}
				}
				else {
					// http://rmseura.tkk.fi/opetusmonisteita/RLP_L.pdf: Ympyrärengaspoikkileikkauksen vääntö:
					// Wi = PI * (Dout^4 - Din^4) / (16*Dout) where Dout outer diameter of pipe and Din inner diameter
					// => Wi = PI*(Rout^4 - Rin^4) / (2*Rout); 
					testResult( Wx, rPrev, rPrev+(rPrev-rPrevPrev), Wx*0.01, function (r) {
						stages[i].rShaft = r;
						return (Math.pow(r,4)-Math.pow(rPrev,4)) / r;
					});
					stages[i].shaftPipeWidth = stages[i].rShaft - rPrev;
				}
				if (stages[i].shaftPipeWidth < stageData.minShaftPipeWidth) {
					if (stageData.gearCenterDifference) {
						const rGear  =  3000 * stageData.gearCenterDifference / (stages[i].rpm + 3000);
						const minShaft = stages[i].rShaft;
						stages[i].rShaft += (stageData.minShaftPipeWidth-stages[i].shaftPipeWidth);
						if (stages[i].rShaft > rGear) {
							stages[i].rShaft = rGear > minShaft ? rGear : minShaft;
						}
					}
					else {
						stages[i].rShaft += (stageData.minShaftPipeWidth-stages[i].shaftPipeWidth);	// never here???
					}
					stages[i].shaftPipeWidth = stageData.minShaftPipeWidth;
				}
				// This is now always the same as the actual power
				const torqueUpToPower = (stages[i].U/stages[i].rTip) * stageData.shaftStrength * Math.PI/2 * (Math.pow(stages[i].rShaft,4)-Math.pow(rPrev,4)) / stages[i].rShaft;
				stages[i].usedTorquePower = Math.round(100*stages[i].rpmPower/torqueUpToPower);
				// Next we calc the centrifugal tangential stress in pipe shft as % of max allowed
				// 3-15 Stresses in Rotating Rings Shigley's Mechanical Engineering Design, Eighth Edition. p.110
				// https://www.academia.edu/41460327/Shigleys_Mechanical_Engineering_Design_8th_Edition
				// 
				// σ = ρ * ω^2*(3 + ν)/8*(ri^2 + ro^2 + ri^2*ro^2/r^2 - (1 + 3 * ν) * r^2 / (3 + ν))
				// ρ = mass density, σ = tangential stress, ω = angular speed radians/s, 
				// ν = material's Poisson's ratio (0.3 for maranging steel), ri=inner radius, ro=outer radious,
				// r = inner radius (stress seems to be higher in the inner radius
				if (rPrev) {
					const ω = 2 * Math.PI * stages[i].rpm / 60;
					const ρ = 7700; // typical value for steel
					const ν = 0.3; // for maranging steel (steel 0.28 - 0.33
					const ro = stages[i].rShaft;
					const ri = rPrev;
					const r = ri;
	//if (i == 0) console.log("ω="+ω+", ρ="+ρ+", ν="+ν+", ro="+ro+", ri="+ri);
					stages[i].shaftTangentialStressOfMax =  ρ*ω*ω*(3 + ν)/8*(ri*ri + ro*ro + ri*ri*ro*ro/r*r - (1 + 3 * ν) * r*r / (3 + ν))
													 * 100 / stageData.shaftStrength;
				}
//console.log(i+":shaftTangentialStressOfMax %:"+stages[i].shaftTangentialStressOfMax);
				// Math.sqrt(stages[i].rpmPower/(stageData.shaftStrength*Math.PI) + rPrev*rPrev);
				rPrevPrev = rPrev;
				rPrev = stages[i].rShaft + stageData.shaftBearingSpace; // add 2 mm pipe thickness for bearings between pipes
				
				if (stageData.gearCenterDifference) {
					// rpm * rGear = 3000 * (diffShafts-rGear)
					// => rGear*(rpm + 3000) = 3000*diffShafts
					// => rGear = 3000*diffShafts / (rpm + 3000);
					stages[i].rGear  =  3000 * stageData.gearCenterDifference / (stages[i].rpm + 3000);
//console.log("*** stage "+i+": rGear="+stages[i].rGear+", rShaft="+stages[i].rShaft);
					if (stages[i].rGear < stages[i].rShaft) {
console.log("***** stage "+i+": Gear radius cannot be less than stage shaft:"+stages[i].rGear+" < "+stages[i].rShaft+" => use stronger steel for stage shafts");
						if (gearCenterDifferenceScale <  stages[i].rShaft/stages[i].rGear) {
console.log("***** New stageData.gearCenterDifference:"+stageData.gearCenterDifference+" => "+(stages[i].rShaft/stages[i].rGear));
							gearCenterDifferenceScale = stages[i].rShaft/stages[i].rGear;
				
						}
					}
				}
				else {
					if (sideOfGeneratorShaft) {
						stageData.height = 2 * stageData.stages[0].rTip + 0.052; // 50 mm for frame, 2 mm for tip gap
						stageData.gearCenterDifference = stageData.height / 2 + 0.10; // Generator shaft diameter 15 cm, 5 cm for margin
						stages[i].rGear  =  3000 * stageData.gearCenterDifference / (stages[i].rpm + 3000);
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) {
							stageData.gearCenterDifference *= stageData.vGearMax/vGear;
							stages[i].rGear *= stageData.vGearMax/vGear;
						}
					}
					else {
						stages[i].rGear = stages[i].rShaft*(stageData.constantDeltaH ? 2 : 1.5);	// add some space for sprockets
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) {
							stages[i].rGear *= stageData.vGearMax/vGear;	// scale down
						}
						stageData.gearCenterDifference = stages[i].rGear * (stages[i].rpm + 3000) / 3000;
//console.log("*** stage "+i+": rGear="+stages[i].rGear+", rShaft="+stages[i].rShaft+", stageData.gearCenterDifference="+stageData.gearCenterDifference);
					}
				}
				stages[i].vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
				stages[i].vShaft = stages[i].U * stages[i].rShaft / stages[i].rTip; // bearings contact velocity
				var k = i-1;
				while (k >= 0 && typeof stages[k].vGear === 'undefined') {
					stages[k].vGear = stages[k].U * stages[i].rGear / stages[k].rTip; // gear Pitch line velocity
					stages[k].vShaft = stages[k].U * stages[i].rShaft / stages[k].rTip; // bearings contact velocity
					k--;
				}
//console.log("rPrev="+rPrev+", stages["+i+"].rShaft="+stages[i].rShaft+". stages[i].rpmPower="+stages[i].rpmPower);
			}
			const nextPressure = i == stages.length-1 ? stageData.hpExit.p : stages[i+1].p;
			const pressureForce = Math.PI*(stages[i].rHub*stages[i].rHub - stages[i].rShaft*stages[i].rShaft)*(nextPressure-stages[i].p);
			stages[i].shaftPush = pressureForce + stages[i].F;
//console.log("nextPressure="+nextPressure+", p="+stages[i].p+", pressureForce="+pressureForce+", diff="+(nextPressure-stages[i].p)+"; stages[i].shaftPush="+stages[i].shaftPush+", stages[i].rShaft="+stages[i].rShaft);
		}
		for (i = stages.length-1; i >= 0; i--) {
			stages[i].rShaftMm = stages[i].rShaft*1000;
		}
		if (gearCenterDifferenceScale > 1) {
			stageData.gearCenterDifference = 0;
			for (i = stages.length-1; i >= 0; i--) {
				if (stages[i].rpmPower) {
					if (stageData.gearCenterDifference) {
						// rpm * rGear = 3000 * (diffShafts-rGear)
						// => rGear*(rpm + 3000) = 3000*diffShafts
						// => rGear = 3000*diffShafts / (rpm + 3000);
						stages[i].rGear  =  3000 * stageData.gearCenterDifference / (stages[i].rpm + 3000);
						if (stages[i].rGear < stages[i].rShaft) {
							console.log("stage "+i+": Gear radius cannot be less than stage shaft:"+stages[i].rGear+" < "+stages[i].rShaft+" => use stronger steel for stage shafts");
						}
					}
					else {
						stages[i].rGear = stages[i].rShaft*1.2;	// add some space for sprockets
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) stages[i].rGear *= stageData.vGearMax/vGear;	// scale down
						stageData.gearCenterDifference = (stages[i].rGear * (stages[i].rpm + 3000) / 3000)*gearCenterDifferenceScale;
					}
				}
			}
		}
		var stageProps = [];
		/*[{"flowM3":719.3554187114403,"mach":472.8455859277404,"v":216.47949592530023,"rTip":1.4709655790313987,"rHub":1.029675905321979,"U":655.9984725009098,
			"rpm":4258.647559707064,"stageLoadingCoefficient":0.2,"flowCoefficient":0.33,"deltaH":86066.79918470538,"UMach":1.3873418554046915,"vMach":0.45782281228354815,
			"p":83333.16541505809,"t":542.5115676655989,"h":565516.0364540833,"d":0.5173553713201356,"β2deg":50.47736872882888,"width":0.6409065284242838,
			"hubStageLoadingCoefficient":0.4081632653061225,"hubFlowCoefficient":0.4714285714285715,"hubβ2deg":32.11672348673144,"pRatio":1.547774080462195,
			"cRe":1492681.078958619,"AN2EXP8":0.18733186587945871,"rpmPower":32030825.663454242,"rShaft":0.11920533192181018,"shaftPipeWidth":0.01,"usedTorquePower":"0.30",
			"rGear":0.14156252472063413,"vGear":63.13186474510021},
		*/
		var titles = [];
		titles.push(title);
		titles.push('Pipe in');
		for (i = 0; i < stages.length; i++) {
			titles.push('Stage '+(i+1));
		}
		titles.push('Pipe out');
		stageProps.push(titles);
		first.diameter = inletPipeDiameter;
		first.diameterMm = inletPipeDiameter*1000;
		first.pRatio = stages[0].p / first.p;
		last.diameter = exitPipeDiameter;
		last.diameterMm = exitPipeDiameter*1000;
		last.pRatio = last.p / stageData.hpExit.p;
		//stages[stages.length-1].pRatio /= last.pRatio;
		var data = [];
		data.push( first );
		data = data.concat(stages);
		data.push( last );
		stageProps.push(getSheetValues('Temp K', 't', data ));
		stageProps.push(getSheetValues('P kPa', 'p', data, 1000 ));
		stageProps.push(getSheetValues('Vx m/s', 'v', data));
		stageProps.push(getSheetValues('D mm', 'diameterMm', data));
		stageProps.push(getSheetValues('h kJ/kg', 'h', data, 1000));
		stageProps.push(getSheetValues('P2/P1', 'pRatio', data, 2));
		stageProps.push(getSheetValues('Flow m3/s', 'flowM3', data));
		stageProps.push(getSheetValues('Power MW', 'stagePower', data, 1000000, 1));
		stageProps.push(getSheetValues('rpm', 'rpm', data));
		stageProps.push(getSheetValues('rTip mm', 'rTipMm', data));
		stageProps.push(getSheetValues('Hub/Tip', 'hubToTipRatio', data, 2));
		stageProps.push(getSheetValues('Blade h mm', 'hBladeMm', data));
		stageProps.push(getSheetValues('Chord mm', 'chordMm', data));
		stageProps.push(getSheetValues('Aspect ratio', 'aspectRatio', data, 2));
		stageProps.push(getSheetValues('Mid flow t/h %', 'bladeMaxThicknessMid', data));
		stageProps.push(getSheetValues('Hub t/h %', 'bladeMaxThicknessHub', data));
		if (stageData.constantDeltaH) 
		{
			//stageProps.push(getSheetValues('Aspect ratio', 'aspectRatio', data, 3));
			//stageProps.push(getSheetValues('Mach m/s', 'mach', data ));
			stageProps.push(getSheetValues('vRel tip inlet', 'machRelTip', data, 2));
			//stageProps.push(getSheetValues('vRel hub inlet', 'machRelHub', data, 2));
		}
		
		//stageProps.push(getSheetValues('P coeff.', 'pRiseCoeffcient', data, 3));
	
		stageProps.push(getSheetValues('Re(c) EXP06', 'cReText', data, 2 ));
		stageProps.push(getSheetValues('Shaft radius mm', 'rShaftMm', data));
		stageProps.push(getSheetValues('Shaft torque %', 'usedTorquePower', data));
		stageProps.push(getSheetValues('Shaft cent. stress %', 'shaftTangentialStressOfMax', data));
		stageProps.push(getSheetValues('uShaft m/s', 'vShaft', data, 1 ));
		stageProps.push(getSheetValues('uGear m/s', 'vGear', data, 1 ));
		stageProps.push(getSheetValues('Blades\' load kN', 'F', data, 1000));
		stageProps.push(getSheetValues('Shaft load kN', 'shaftPush', data, 1000));
		stageProps.push(getSheetValues('Max blade stress MPa', 'yieldMomentMidHubMPa', data));
		stageProps.push(getSheetValues('Centrifugal stress MPa', 'tensileStressMPa', data));
		//stageProps.push(getSheetValues('Centr. stress of max', 'tensileStressPercent', data));
		//stageProps.push(getSheetValues('Max stress mid/hub %', 'totalTensileStressPercentMidHub', data));
		if (stages[stages.length-1].bladeCoolingK) {
			stageProps.push(getSheetValues('Blade cooling K', 'bladeCoolingK', data));
		}
		stageProps.push(getSheetValues('Load coefficient', 'stageLoadingCoefficient', data, 2));
		stageProps.push(getSheetValues('Flow coefficient', 'flowCoefficient', data, 2));
		stageProps.push(getSheetValues('AN2 E08', 'AN2EXP8', data, 2));
		stageData.stageProps = stageProps;

		const hEff100 = Module.PropsSI('H', 'P', stageData.exit.p, 'S', first.s, name);
		stageData.adiabaticEfficiency = (hEff100-first.h)/(stageData.exit.h - first.h);
		/*
			"flowCoefficientMin":0.33,"stageLoadingCoefficientMin":0.2,"flowCoefficientToStageLoadingCoefficient":1,"massFlowInKg":411.25,"maxRpmStages":1,"aspectRatio":1.2,
			"hubToTipRatio":0.7,"machMaxSpeed":0.95,"maxStatorHubAbsSpeed":0.7,"vGearMax":180,"isCompressor":true,"efficiency":0.955,
			"tanβ1":1.8181818181818181,"tanβ2":1.2121212121212122,"β1deg":61.18920625702693,"β2":0.8809962820612887,
			"β2deg":50.47736872882888,"β1":1.0679531158670357,"shaftStrength":300000000,"shaftBearingSpace":0.002,"rInnerShaftCoolingPipe":0.01,
			"minShaftPipeWidth":0.01,"generatorRpm":3000,"stageWidth2h":1.515197511418009,"vvAbs2Mach":0.44774847167095166,"vMach":0.45782281228354815,
			"speedOut":8.807401930615992,"pHigh":2517078.5346587086,"hEnd":202141.21278021956}	*/
		stageData.titles = [
			Math.round(totalPower/1000000)+" MW Axial compressor with "+stageData.rpmCount+" pipe shafts and active tip gap control",
			"Adiabatic efficiency: "+myRound(stageData.adiabaticEfficiency,3), //", Average P2/P1 ratio: "+myRound(Math.log(last.p/first.p)/Math.log(stages.length),3), //+", Stage P2/P1 ratio: "+myRound(stageData.stages[0].pRatio,2),
			"P-out/P-in: "+myRound(last.p/first.p,2)+", Mass flow: "+Math.round(stageData.massFlowInKg)+" kg/s",
			stageData.rpmCount+" shafts, "+stageData.stages.length+" stages",
			"Tip: Min stage loading coefficient: "+ stageData.stageLoadingCoefficientMin + ", min flow coefficient: "+ stageData.flowCoefficientMin,
			"Hub: Max stage loading coefficient: "+myRound(stageData.stages[0].hubStageLoadingCoefficient,2)+ ", max flow coefficient: "+myRound(stageData.stages[0].hubFlowCoefficient,2),
			"Aspect ratio h/c: adaptive, Hub/Tip ratio"+(stageData.hubToTipRatioMax == stageData.hubToTipRatio ? ": "+stageData.hubToTipRatio : "s from "+stageData.hubToTipRatio+" to "+stageData.hubToTipRatioMax),
			//"Relative velocity on blade tip inlet surface: "+stageData.machMaxSpeed+" mach",
			//"Relative velocity on blade hub inlet surface: "+myRound(stageData.machRelHub,3)+" mach",
			"Max/min relative flow angle in blade tip/hub inlet β1: "+ myRound(stageData.β1deg, 1)+'/'+ myRound(stageData.hubβ1deg, 1)+'°'
		];
		if (!stageData.constantDeltaH)  stageData.titles.push("Axial velocity: "+myRound(stageData.vMach,3)+" mach");

		//if (!stageData.constantDeltaH) 
		stageData.height = 2 * (stageData.stages[0].rTip + 0.052); // 50 mm for frame, 2 mm for tip gap
		
		console.log("stages:"+JSON.stringify(stageData.stages));

		console.log(title+ " compressor stages: "+stageData.stages.length+", rpm speeds: "+stageData.rpmCount+
		", efficiency: "+myRound(stageData.adiabaticEfficiency,3)+", power: "+Math.round(totalPower/1000000)+" MW"+
		", compressor length, height, width: "+myRound(stageData.length,2)+", "+myRound(stageData.height,2)+", "+myRound(stageData.height,2)+" m");
		console.log("pHigh pipe diameter:"+exitPipeDiameter+", calculated gas properties:"+JSON.stringify(stageData.exit));
		//console.log("pHigh pipe expected, properties:"+JSON.stringify(last));
		console.log("pLow pipe diameter="+inletPipeDiameter+", gas properties:"+JSON.stringify(first));
		//console.log(JSON.stringify(stageData.stages, null, 2));

//calcStageProperties(stageData, stageData.massFlowInKg, first, last );
		
		return stageData;
	}
	function drawCompressorSide(ctx, metrics, stageData, xPx, yPx, mToPx, upSide ) {
		var side = upSide ? -1 : 1;
		function toX( xM ) { return xPx + xM*mToPx; }
		function toY( yM ) { return yPx + side*yM*mToPx; }
		function fillPoints(points, color, hasBorderLine) {
			const region = new Path2D();
			var i;
			for (i = 0; i < points.length; i++) {
				const p = points[i];
				if (i == 0) region.moveTo(toX(p.x),toY(p.y)); 
				else region.lineTo(toX(p.x),toY(p.y)); 
			}
			region.closePath();
			ctx.fillStyle = color;
			ctx.fill(region);
			if (hasBorderLine) {
				ctx.beginPath();
				for (i = 0; i < points.length; i++) {
					const p = points[i];
					if (i == 0) ctx.moveTo(toX(p.x),toY(p.y)); 
					else ctx.lineTo(toX(p.x),toY(p.y)); 
				}
				ctx.closePath();
				ctx.stroke();
			}
		}
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 1;
		const rpmColors = ['#FCB1AD', '#E5E7E7', '#FCA09C', '#D5D8D8', '#FC8782', '#C0C3C3', '#FB6A64', '#B2B6B6', '#FB4A43', '#A9ACAC', '#FB4A43', '#999C9C', '#FB4A43', '#8E9090', '#FB4A43', '#808181', '#FB4A43', '#747575'];
		const frameColor = '#393939';
		const generatorColor = '#FBCC43';
		
		var iRpm = 0;
		var rpmColor = rpmColors[0];
//console.log("metrics.bladeBasements:"+JSON.stringify(metrics.bladeBasements));
		var k;
		for (k = 0; k < metrics.rotors.length; k++) {
			fillPoints( metrics.rotors[k], rpmColor);
			fillPoints( metrics.stators[k], frameColor );
			fillPoints( metrics.bladeBasements[k], rpmColor);

			if (stageData.stages[k].rpmPower) {
				if (iRpm < metrics.shafts.length) {
					//fillPoints( metrics.bladeBasements[iRpm], rpmColor);
					fillPoints( metrics.shafts[iRpm], rpmColor );
//console.log(iRpm+": "+rpmColor+", points:"+JSON.stringify(metrics.shafts[iRpm]));
				}
				else {
//console.log("k="+k+", iRpm="+iRpm+" stage="+JSON.stringify(stageData.stages[i]));
				}
				iRpm++;
				rpmColor = rpmColors[iRpm % rpmColors.length];
			}
		}
		while (k < metrics.stators.length) {
			fillPoints( metrics.stators[k], frameColor );
			k++;
		}
		if (upSide) {
			for (k = 0; k < metrics.generatorShaft.length; k++) {
				fillPoints( metrics.generatorShaft[k], generatorColor );
			}
		}
		fillPoints( metrics.frame, frameColor );
		for (k = 0; k < metrics.whiteAreas.length; k++) {
			fillPoints( metrics.whiteAreas[k], 'white' );
		}
	}
	function drawXCoordinate( cm, x, xPx, height  ) {
		const text = x + ' m';
		const ctx = cm.ctx;
		ctx.fillText( text, xPx+2, 2*height/3);
		ctx.beginPath();
		ctx.moveTo(xPx, height/2);
		ctx.lineTo(xPx, 0 );
		ctx.stroke();
		
		ctx.fillText( text, xPx+2, cm.pxHeight-1);
		ctx.beginPath();
		ctx.moveTo(xPx, cm.pxHeight-height/2);
		ctx.lineTo(xPx, cm.pxHeight );
		ctx.stroke();
	}
	function drawYCoordinate( cm, y, yPx, height ) {
		const text = y + ' m';
		const ctx = cm.ctx;
		const width = ctx.measureText(text).width;

		ctx.fillText( text, 2, yPx-2);
		ctx.beginPath();
		ctx.moveTo(0, yPx);
		ctx.lineTo(height/2, yPx);
		ctx.stroke();
		
		ctx.fillText( text, cm.pxWidth-width-1, yPx-2);
		ctx.beginPath();
		ctx.moveTo(cm.pxWidth-height/2, yPx);
		ctx.lineTo(cm.pxWidth, yPx);
		ctx.stroke();
	}
	function getStageDataSheetArea(ctx, stageData, modelText, titleFont, cellFont, cellHeightPx, x, y ) 
	{
		const stageProps = stageData.stageProps;
		var points = [];
		ctx.font = titleFont;
		var cellWidthPx = ctx.measureText(modelText).width;
		const height = stageProps.length*cellHeightPx;
		const width = cellWidthPx*0.7+stageProps[0].length*cellWidthPx;
		points.push(toPoint(x, y));
		points.push(toPoint(x+height, y));
		points.push(toPoint(x+height, y+width));
		points.push(toPoint(x, y+width));
		return points;
	}

	function printStageDataSheet(ctx, stageData, modelText, titleFont, cellFont, cellHeightPx, x, y, tblId, drawOnPicture ) 
	{
		const stageProps = stageData.stageProps;
		var i, j, cellWidthPx = 0;
		var tbl = '';
		for (i = 0; i < stageProps.length; i++) {
			const row = stageProps[i];
			ctx.font = titleFont;
			if (drawOnPicture && cellWidthPx == 0) {
				cellWidthPx = ctx.measureText(modelText).width;
				const region = new Path2D();
				region.moveTo(x,y-cellHeightPx);
				region.lineTo(x+cellWidthPx*(0.7+row.length),y-cellHeightPx);
				region.lineTo(x+cellWidthPx*(0.7+row.length),y+cellHeightPx*(stageProps.length-1));
				region.lineTo(x,y+cellHeightPx*(stageProps.length-1));
				region.closePath();
				ctx.fillStyle = 'white';
				ctx.fill(region);
				ctx.fillStyle = 'black';
			}
			if (tblId) {
//console.log("row[1]="+row[1]+"#");
				if (row[1] && row[1]!=' ') {
					tbl += "<tr><th>"+row[0]+"</th>";
				}
				else {
					tbl += "<tr><th colspan=\"2\">"+row[0]+"</th>";
				}
			}
			if (drawOnPicture) ctx.fillText( row[0], x, y+i*cellHeightPx);
			
			ctx.font = i == 0 ? titleFont : cellFont;
			for (j = 1; j < row.length; j++) 
			{
				if (j != 1 || (row[j] && row[1]!=' ')) {
					if (tblId) {
						if (i == 0) {
							tbl += "<th>"+row[j]+"</th>";
						}
						else {
							tbl += "<td>"+row[j]+"</td>";
						}
					}
				}
				if (drawOnPicture) ctx.fillText( row[j], cellWidthPx*0.7+j*cellWidthPx, y+i*cellHeightPx);
			}
			if (tblId) {
				tbl += "</tr>";
			}
		}
		if (tblId) {
			$("#"+tblId).html(tbl);
		}
//console.log(tbl);
	}
	var gTotalPower = 0;
	function drawCompressor( canvasId, stageData, mToPx ) {
		const cm = stageData.getCompressorMetrics();
		const canvas = document.getElementById(canvasId);
		const xPx = -cm.minX*mToPx, yPx = cm.maxY*mToPx;
		function toX( xM ) { return xPx + xM*mToPx; }
		function toY( yM ) { return yPx + yM*mToPx; }

		if (canvas.width && canvas.height) {
			canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height); 
		}
		canvas.width = Math.round((cm.maxX - cm.minX)*mToPx);
		canvas.height = Math.round((cm.maxY - cm.minY)*mToPx);
//console.log("canvas.width="+canvas.width+", canvas.height="+canvas.height);
		const ctx = canvas.getContext("2d");
		cm.pxWidth = canvas.width;
		cm.pxHeight = canvas.height;
		cm.ctx = ctx;
		cm.mToPx = mToPx;
		// Upside:
		drawCompressorSide( ctx, cm, stageData, xPx,  yPx, mToPx, true );
		// clear the sheet data area on the lower half picture
		//cm.whiteAreas.push(getStageDataSheetArea(ctx, stageData, "12345678", "bold 11px Courier New", "bold 11px Courier New", 11, 20,  canvas.height/2+40 ));
		// Downside:
		drawCompressorSide( ctx, cm, stageData, -cm.minX*mToPx,  cm.maxY*mToPx, mToPx, false );
		var x; 
		ctx.lineWidth = 1;
		ctx.fillStyle = 'black'; 
		ctx.strokeStyle = 'black'; 
		ctx.font = "10px Courier New";
		for (x = Math.floor(cm.minX); x <= Math.floor(cm.maxX); x += 1) {
			drawXCoordinate( cm, x, toX(x), 10 );
		}
		for (x = Math.floor(cm.minY); x <= Math.floor(cm.maxY); x += 1) {
			drawYCoordinate( cm, x, toY(x), 10);
		}
		printStageDataSheet(ctx, stageData, "12345678", "bold 11px Courier New", "bold 11px Courier New", 11, 20,  canvas.height/2+40, canvasId.replace("Image", "Data"));
		var i;
		if (stageData.titles && stageData.titles.length > 0) {
			const x = 30; // 2*canvas.width/3
			var y = 20; // toY(stageData.stages[0].rShaft+0.37)+20; // 20;
			ctx.font = "bold 14px Courier New";
			//ctx.fillText( stageData.titles[0], canvas.width - ctx.measureText(stageData.titles[0]).width-30, y);
			ctx.fillText( stageData.titles[0], 30, y);
			y += 28;
			ctx.font = "bold 12px Courier New";
			for (i = 1; i < stageData.titles.length; i++) {
				textOnWhite( ctx, stageData.titles[i], x, y);
				y += 11;
			}
		}
		if (canvasId == 'hotCompressorImage' || canvasId == 'coldCompressorImage') {
			const image = new Image(); // Create new img element
			image.addEventListener("load", (e) => {
					console.log("Image loded");
					const imgagePosY = toY(stageData.stages[0].rShaft)+20;
console.log("***imagePosY:"+imgagePosY);
					ctx.drawImage(image, 0, imgagePosY);
					var stageLoading, flowCoefficient;
					var hubStageLoading, hubFlowCoefficient;
					var prevStageLoading = -1;
					var prevFlowCoefficient = -1;
					var i, iTo = -1, previ = -1;
					var iRpmTo = -1;
					const lastSeparated = stageData.stages[stageData.stages.length-1].stagePower <  stageData.stages[stageData.stages.length-2].stagePower;
					function showTipHubOnLine( i, xFrom,yFrom,xTo,yTo) {
//console.log(i+":(",xFrom+","+yFrom+"),(",xTo+","+yTo+")");
								const yDiff = Math.abs((yFrom-yTo)/20);
								const xDiff = Math.abs((xFrom-xTo)/20);
								ctx.beginPath();
								ctx.moveTo( xFrom-yDiff, yFrom-xDiff);
								ctx.lineTo( xFrom+yDiff, yFrom+xDiff);
								ctx.stroke();
								ctx.beginPath();
								ctx.moveTo( xTo-yDiff, yTo-xDiff);
								ctx.lineTo( xTo+yDiff, yTo+xDiff);
								ctx.stroke();
					}
					function getStageLoadingPosY( stageLoading ) {
						return imgagePosY + 5 + (204-5)*(0.6-stageLoading)/0.6;
					}
					function getFlowCoefficientPosX( flowCoefficient ) {
						return 42 + (463-42)*flowCoefficient/1;
					}
					var yTipPrev = 0, yHubPrev = 0;
					for (i = 0; i < stageData.stages.length; i++) {
						stageLoading = myRound(stageData.stages[i].stageLoadingCoefficient,3);
						flowCoefficient = myRound(stageData.stages[i].flowCoefficient,3);
						hubStageLoading = myRound(stageData.stages[i].hubStageLoadingCoefficient,3);
						hubFlowCoefficient = myRound(stageData.stages[i].hubFlowCoefficient,3);
						if (Math.abs(stageLoading-prevStageLoading) > 0.01 || Math.abs(prevFlowCoefficient-flowCoefficient)> 0.01 ||
							Math.abs(prevHubStageLoading-hubStageLoading)> 0.01  || Math.abs(prevHubFlowCoefficient-hubFlowCoefficient)> 0.01) 
						{
							var xFrom, xTo, yFrom, yTo;
							ctx.beginPath();
							ctx.moveTo( xFrom=getFlowCoefficientPosX(flowCoefficient), yFrom=getStageLoadingPosY(stageLoading));
							// TBD: Split the area to 10 equal areas  
							const rTip = stageData.stages[i].rTip;
							const areaDec = Math.PI*(rTip*rTip - stageData.stages[i].rHub*stageData.stages[i].rHub) / 10;
							var iArea;
							for (iArea = 1; iArea < 10; iArea++) {
								const rCur = Math.sqrt(rTip*rTip - iArea*areaDec/Math.PI);
								const ratio = rTip/rCur;
								const sl = stageLoading*ratio*ratio;
								const fc = flowCoefficient*ratio;
//console.log(iArea+": rTip="+rTip+", rCur="+rCur+"; ratio="+ratio+", sl="+sl+", fc="+fc);
								ctx.lineTo( getFlowCoefficientPosX(fc), getStageLoadingPosY(sl));
							}
							ctx.lineTo( xTo=getFlowCoefficientPosX(hubFlowCoefficient), yTo=getStageLoadingPosY(hubStageLoading));
							ctx.stroke();
							if (previ < 0) {
								// nop;
							}
							/* else if (i == stageData.stages.length-1 && lastSeparated) {
								ctx.fillText( "Tip#"+(i+1), xFrom, yFrom+6);
								ctx.fillText( "Hub#"+(i+1), xTo, yTo+6);
							}*/
							else if (i == (previ+1)) {
								if (!stageData.stages[i].rpmPower && i > iRpmTo) {
									const len = lastSeparated ? stageData.stages.length-1 : stageData.stages.length;
									for (iRpmTo = i; iRpmTo < len && !stageData.stages[iRpmTo].rpmPower; iRpmTo++);
									var tmpText = "Tips#"+i+'-'+iRpmTo;
									ctx.fillText( tmpText, xFrom-ctx.measureText(tmpText).width, yFrom);
									tmpText = "Hubs#"+i+'-'+iRpmTo;
									ctx.fillText( tmpText, xTo-ctx.measureText(tmpText).width, yTo);
									showTipHubOnLine( previ, getFlowCoefficientPosX(prevFlowCoefficient), getStageLoadingPosY(prevStageLoading),getFlowCoefficientPosX(prevHubFlowCoefficient), getStageLoadingPosY(prevHubStageLoading));
									iTo = iRpmTo;
								}
								else if (i > iTo) {
									showTipHubOnLine( previ, getFlowCoefficientPosX(prevFlowCoefficient), getStageLoadingPosY(prevStageLoading),getFlowCoefficientPosX(prevHubFlowCoefficient), getStageLoadingPosY(prevHubStageLoading));
									const yTip = getStageLoadingPosY(prevStageLoading);
									if (Math.abs(yTip-yTipPrev) > 10) {
										var tmpText = "Tip#"+i;
										ctx.fillText( tmpText, getFlowCoefficientPosX(prevFlowCoefficient)-ctx.measureText(tmpText).width-11, yTip);
										yTipPrev = yTip;
									}
									const yHub = getStageLoadingPosY(prevHubStageLoading);
									if (Math.abs(yHub-yHubPrev) > 10) {
										tmpText = "Hub#"+i;
										ctx.fillText( tmpText, getFlowCoefficientPosX(prevHubFlowCoefficient)-ctx.measureText(tmpText).width-8, yHub);
										yHubPrev = yHub;
									}
									iTo = i;
								}
								else {
									showTipHubOnLine(i, xFrom,yFrom,xTo,yTo);
								}
							}
							else if (i > iTo) {
								ctx.fillText( "Tips#"+(previ+1)+'-'+i, getFlowCoefficientPosX(prevFlowCoefficient), getStageLoadingPosY(prevStageLoading)+12);
								ctx.fillText( "Hubs#"+(previ+1)+'-'+i, getFlowCoefficientPosX(prevHubFlowCoefficient), getStageLoadingPosY(prevHubStageLoading)+12);
								iTo = i;
							}
							previ = i;
							prevStageLoading = stageLoading;
							prevFlowCoefficient = flowCoefficient;
							prevHubStageLoading = hubStageLoading;
							prevHubFlowCoefficient = hubFlowCoefficient;
						}
					}
					if (i == (previ+1)) {
						if (i > iTo) {
							ctx.fillText( "Tip#"+i, getFlowCoefficientPosX(flowCoefficient)+6, getStageLoadingPosY(stageLoading)+6);
							ctx.fillText( "Hub#"+i, getFlowCoefficientPosX(hubFlowCoefficient), getStageLoadingPosY(hubStageLoading)+12);
						}
					}
					else if (i > iTo) {
						ctx.fillText( "Tips#"+(previ+1)+'-'+i, getFlowCoefficientPosX(flowCoefficient), getStageLoadingPosY(stageLoading)+12);
						ctx.fillText( "Hubs#"+(previ+1)+'-'+i, getFlowCoefficientPosX(hubFlowCoefficient), getStageLoadingPosY(hubStageLoading)+12);
					}
			});
			image.src = 'BaseLineCompressor.JPG';
		}
		$("#"+canvasId).css('display','block');
	}
/*
		{
			const elem = document.getElementById("baseLineCompressor");
console.log("baseLineCompressor top="+elem.offsetTop+", left="+elem.offsetLeft+", width="+elem.naturalWidth+", height="+elem.naturalHeight);
		}
*/
	function stagesToHtmlTable( stageData )
	{
		//const tmp = {"flowM3":4173.533301242276,"speedOfSound":438.5292933044679,"v":142.52202032395206,"rTip":4.615800092373975,"rHub":3.4618500692804814,"w":431.884910072582,"rpm":893.4956052158383,"h":483243.00598183315,"t":464.66160353971225,"p":48895.79446968536,"d":0.35447548938912926,"flowCoefficient":0.33,"stageLoadingCoefficient":0.2,"deltaH":37304.91510968045,"wMach":0.9848484848484848};
	}
	//const test = getMetrics();
    </SCRIPT>
 </BODY></HTML>
