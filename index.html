<!DOCTYPE html><HTML lang="en"><HEAD> 
<!-- Copyright (c) 2024 Antti Saarenheimo

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

https://anttisaarenheimo.github.io/index.html
https://github.com/anttisaarenheimo/anttisaarenheimo.github.io
-->
<META charset="utf-8"> 
<META http-equiv="Cache-Control" content="no-store, no-cache, max-age=0, must-revalidate, proxy-revalidate">
<META http-equiv="pragma" content="nocache"> 
<TITLE>Pumped Thermal Energy Storage</TITLE> 
<!--link href="bootstrap.min.css" rel="stylesheet" type="text/css"/-->
<LINK href="index_files/jquery-ui.css" rel="stylesheet"> 
<SCRIPT src="index_files/jquery-1.11.0.min.js"></SCRIPT>
<SCRIPT src="index_files/jquery-migrate-1.2.1.min.js"></SCRIPT>
<SCRIPT src="index_files/jquery-ui.js"></SCRIPT>
<SCRIPT src="coolprop.js"></SCRIPT>
<SCRIPT src="Kacker-Okapuu_loss_model.js"></SCRIPT>
<!--SCRIPT type="javascript">
	console.log("typeof Module="+(typeof Module));
</SCRIPT-->
<style>
td {
	text-align:right; 
	font-family: Verdana;
	font-size: 60%;
	color: black;
}
th {
	font-family: Verdana;
	font-size: 60%;
	font-weight: bold;
	color: black;
	text-align:left;
}
.modal {
  display: none;
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0,0,0); /* Fallback color */
  background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
}

.modal-content {
  background-color: #fefefe;
  margin: 15% auto; 
  padding: 20px;
  border: 1px solid #888;
  width: 30%; 
}

</style>
</HEAD> 
<BODY onload="drawTpDiagram()">

<DIV><H3>Pumped Thermal Energy Storage Simulator - powered by Coolprop&nbsp;&nbsp;&nbsp; <a target="_blank" href="TeraPTES_en.pdf">Feasibility study</a>&nbsp;&nbsp;&nbsp; <a href="TeraPTES_fi.pdf">Feasibility study in finnish</a></H3></DIV>
<!--ul class="nav nav-tabs" id="myTab" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="home-tab" data-bs-toggle="tab" data-bs-target="#home" type="button" role="tab" aria-controls="home" aria-selected="true">Design parameters</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="storage-tab" data-bs-toggle="tab" data-bs-target="#storage" type="button" 
	onClick="drawOnlyStorage()" role="tab" aria-controls="storage" aria-selected="false">Storage</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="diagrams-tab" data-bs-toggle="tab" data-bs-target="#diagrams" type="button" 
		onClick="drawTpDiagram()" role="tab" aria-controls="diagrams" aria-selected="false">TP-diagram</button>
  </li>
</ul-->
<div class="tab-content" id="myTabContent">
  <div class="tab-pane show active" id="home" role="tabpanel" aria-labelledby="home-tab">
<DIV><LABEL>Fluid:</LABEL>
	<SELECT id="name" onchange="setGasMassFlowFor1200MW(this)"><OPTION>Argon</OPTION><!--OPTION>CarbonDioxide</OPTION--><OPTION>Helium</OPTION><OPTION>Hydrogen</OPTION><OPTION>Methane</OPTION><OPTION selected>Nitrogen</OPTION><!--OPTION>CarbonDioxide</OPTION--><!--OPTION>R134a</OPTION><OPTION>Water</OPTION-->
	</SELECT><BUTTON onClick="drawTpDiagram()">Draw storage, T-P diagram and compressors</BUTTON>
	<!--BUTTON onClick="calcDiagrams()">Draw the selected diagrams</BUTTON--> 
	<!--<INPUT id="noDistrictHeat" checked type="checkbox" value="true"><LABEL>Use stored liqued nitrogen to maximize electric output</LABEL>-->
	<!--BUTTON 
	onClick="zoomToTpDiagram(10)">Zoom to T-P diagram</BUTTON> <INPUT id="zoom" type="float" value="10"-->
</DIV>
<DIV>
	<DIV>
		<LABEL>Mass flow of main turbins (kg/s): </LABEL><INPUT size="4" id="dischargeMassFlow" type="float" value="1951" onchange="metricsChanged()">
		<LABEL>Number of power units: </LABEL><INPUT id="numberOfUnits" type="text" value="2" size="2" maxlength="2" onchange="metricsChanged()">
		<INPUT id="powerOnly" type="checkbox" checked value="1"><LABEL>Optimize for power only</LABEL>
		<INPUT id="externalIceStorage" type="checkbox" checked onchange="$('#hpStorageUtilization').val(this.checked ? '59', '42')" value="1">
		<LABEL>External cryogenic ice storage, its size </LABEL><INPUT id="iceStorageSize" type="text" value="55" size="2" maxlength="2"><LABEL>% of the low pressure storage size</LABEL>
		<!--<INPUT id="dischargeMassFlowRange" type="checkbox"><LABEL>Draw diagram for Gross turbin work MW: </LABEL><INPUT size="4" id="dischargeMassFlowFrom" type="float" value="400"> - <INPUT size="4" id="dischargeMassFlowTo" type="float" value="4000">-->
	</DIV>
<!--	<LABEL>Gross turbin work MW: </LABEL><INPUT size="4" id="grossWorkOut" type="float" value="1400" onchange="metricsChanged()">
	<INPUT id="grossWorkOutRange" type="checkbox"><LABEL>Draw diagram for Gross turbin work MW: </LABEL><INPUT size="4" id="grossWorkOutFrom" type="float" value="600"> - <INPUT size="4" id="grossWorkOutTo" type="float" value="8000">
-->
</DIV>
<DIV>
	<LABEL>Storage size Mt (curshed stone): </LABEL><INPUT size="4" id="storageSizeMTon" type="float" value="25" onchange="metricsChanged()">
	<LABEL>High pressure storage heat capasity utilization %</LABEL><INPUT size="2" id="hpStorageUtilization" type="float" value="59" onchange="metricsChanged()">
	<LABEL>Top fill used as </LABEL>
	<INPUT TYPE="radio" name="topFillUsedFor" id="topFillUsedAsStorage" checked value="storage"><LABEL>Storage</LABEL>
	<INPUT TYPE="radio" name="topFillUsedFor" id="topFillUsedAsWeight" value="weight"><LABEL>Weight</LABEL>
	<INPUT TYPE="radio" name="topFillUsedFor" id="topFillUsedAsColdStorage" value="cold" title="Waste heat is heat exchanged to the bottom and waste cold to the top"><LABEL>Cold storage</LABEL>
	<INPUT TYPE="radio" name="topFillUsedFor" id="topFillWithIceWithStorage" value="ice" title="Waste heat is heat exchanged to the bottom and waste cold to a external ice storage"><LABEL>Ice storage</LABEL>
	<!--INPUT id="hpStorageSize" type="checkbox"><LABEL>Draw diagram for Plow</LABEL><INPUT style="width:2em" size="2" VALUE="48" id="pLowStorageSize"/><LABEL>kPa and range:</LABEL><INPUT size="4" id="hpStorageSizeFrom" type="float" value="10"> - <INPUT size="4" id="hpStorageSizeTo" type="float" value="60"-->
</DIV>
<DIV>
	<LABEL>P high/low: </LABEL><INPUT size="4" id="highToLowPressureRatio" type="float" value="20" onchange="metricsChanged()">
	<LABEL>P low kPa: </LABEL><INPUT size="4" id="targetPLow" type="float" value="96" onchange="metricsChanged()"> 
	<!--LABEL>P high/low (in discharge): </LABEL><INPUT size="4" id="highToLowPressureRatio" type="float" value="25" onchange="metricsChanged()">
	<LABEL>P low kPa (in discharge): </LABEL><INPUT size="4" id="targetPLow" type="float" value="95" onchange="metricsChanged()"--> 
	<!--INPUT id="pRatioRange" type="checkbox" checked><LABEL>Draw diagram for P low </LABEL><INPUT style="width:2em" size="2" VALUE="48" id="pLowPressureRatio"/><LABEL> kPa in P1/P2 range:</LABEL><INPUT size="4" id="pRatioFrom" type="float" value="10"> - <INPUT size="4" id="pRatioTo" type="float" value="50"-->
<!--/DIV>
<DIV-->
	<LABEL>T high (K): </LABEL><INPUT size="4" id="tHigh" type="float" value="1173"> 
	<!--INPUT id="tHighRange" type="checkbox"><LABEL>Draw diagram for T high (K) range:</LABEL>
	<INPUT size="4" id="tHighFrom" type="float" value="800"> - <INPUT size="4" id="tHighTo" type="float" value="1500"-->
</DIV>
<DIV>
	<LABEL>Average hot compressor stage efficiency: </LABEL>
	<INPUT size="4" id="cEfficiency" type="float" value="0.969" title="The efficiency resulted from the default hot compressor design parameters">
	<LABEL>Average cryogenic turbin stage efficiency: </LABEL>
	<INPUT size="4" id="tLowEfficiency" type="float" value="0.969" title="The default cryogenic turbin efficiency of is scaled from cryogenic compressor efficiency">
	<LABEL>Efficiency of inlet and outlet diffusers: </LABEL>
	<INPUT size="4" id="diffuserEfficiency" type="float" value="0.98" title="97 % is a typical efficiency for an industrial diffuser with a high area ratio">
</DIV>
<DIV>
	<LABEL>Average hot turbin stage efficiency: </LABEL>
	<INPUT size="4" id="tEfficiency" type="float" value="0.973" title="The default hot turbin efficiency of is scaled from cryogenic compressor efficiency" >
	<LABEL>Average cryogenic compressor stage efficiency: </LABEL>
	<INPUT size="4" id="cLowEfficiency" type="float" value="0.975" title="The efficiency resulted from the default cryogenic compressor design parameters" > 
	<LABEL>Heat exchanger temp difference (K): </LABEL><INPUT size="4" id="heatExchangeDeltaT" type="float" value="2">
</DIV>
<DIV>
	<LABEL>Heat pump compressor stage efficiency: </LABEL> <INPUT size="4" id="cHeatPumpEfficiency" type="float" value="0.978">
	<LABEL>Heat pump turbin stage efficiency: </LABEL> <INPUT size="4" id="tHeatPumpEfficiency" type="float" value="0.980">
	<LABEL>Relative pressure loss in each heat exchanger: </LABEL> <INPUT size="4" id="heatExchangePressureLoss" type="float" value="0.005">
	<!--INPUT id="tEffRange" type="checkbox"><LABEL>Draw diagram for turbin and compressor stage efficiencies </LABEL><INPUT size="4" id="tEfficiencyFrom" type="float" value="0.90"> - <INPUT size="4" id="tEfficiencyTo" type="float" value="0.98"-->
</Div>
<DIV>
	<INPUT id="updateCompressorEfficiencies" type="checkbox" checked title="Update compressor efficiencies from the calculated efficiency of the compressor designs">
	<LABEL>Update compressor efficiencies from the design</LABEL>
	<INPUT id="updateTurbinEfficiencies" type="checkbox" checked  title="Scale the turbin efficiencies from the calculated efficiencies of respective compressor designs">
	<LABEL>Update turbin efficiencies from the design</LABEL>
	<LABEL>Minumum chord lengt (mm)</LABEL><INPUT size="4" id="minChordLengthMm" type="float" value="30">
</DIV>
<DIV>
	<!-- powerOnly option produces worse power back % than the combined power ????-->
	<LABEL>Efficiency of the synchronous motor-generator: </LABEL><INPUT size="4" id="generatorEfficiency" type="float" value="0.99"> 
	<LABEL>Frequency converter efficiency: </LABEL><INPUT size="4" id="frequencyConverterEfficiency" title="For the heat pump and cold compressor startup" type="float" value="0.97"> 
	<a target="_blank" href="https://www.renk.com/en/products/turbo-high-speed/vacuum-gearbox-systems/het">Vacuum gear efficiency: </a><INPUT size="4" id="gearEfficiency" type="float" value="0.993"> 
	<!--INPUT size="4" id="cEfficiencyFrom" type="float" value="0.87"><INPUT size="4" id="cEfficiencyTo" type="float" value="0.93"-->
</Div>
<DIV>
	<LABEL>HP storage density tn/m3:</LABEL><INPUT size="3" id="rockDensityHp" type="float" value="3.0" onchange="metricsChanged()">, Cp J/g:<INPUT size="3" id="hpCp" type="float" value="0.80" onchange="metricsChanged()">
	<LABEL>LP storage density tn/m3:</LABEL><INPUT size="3" id="rockDensityHp" type="float" value="2.8" onchange="metricsChanged()">, Cp J/g:<INPUT size="3" id="lpCp" type="float" value="0.80" onchange="metricsChanged()">
	<!--LABEL>Gravel density in the storage (tn/m3): </LABEL><INPUT size="4" id="gravelDensity" type="float" value="2.1" onchange="metricsChanged()"-->
	<LABEL>The porosity of crushed stone in the insulation : </LABEL><INPUT size="4" id="insGravelPorosity" type="float" value="0.5" onchange="metricsChanged()">
</DIV>
<DIV>
	<LABEL>Open pit angle: </LABEL><INPUT size="2" id="maxOpenPitAngle" type="float" value="73" onchange="metricsChanged()">
	<LABEL>Max top fill angle: </LABEL><INPUT size="2" id="maxTopFillAngle" type="float" value="70" onchange="metricsChanged()">
	<LABEL>Ramp width (m): </LABEL><INPUT size="2" id="rampWidth" type="float" value="8" onchange="metricsChanged()">
	<LABEL>Ramp slope 1:n </LABEL><INPUT size="2" id="rampSlope" type="float" value="9" onchange="metricsChanged()">
</DIV>
<DIV>
	<LABEL>Max relative pressure drop in pipes: </LABEL><INPUT size="4" id="maxPressureDrop" type="float" value="0.01" onchange="metricsChanged()">
	<!--LABEL>Average cost of insulation, gas isolation and borders €/m2: </LABEL><INPUT size="4" id="costOfSurfaceM2" type="float" value="1200" onchange="metricsChanged()"-->
	<LABEL>Max heat leak out W/m&#xB2;: </LABEL><INPUT size="3" style="width:3em" id="maxHeatFlowOut" type="float" value="20" onchange="metricsChanged()">
	<LABEL>U value of stone wool+crushed stone mix W/mK: </LABEL><INPUT size="4" style="width:4em" id="uOfGravelrockwoolMix" type="float" value="0.1" onchange="metricsChanged()">
	<LABEL>Max hot rock strength (MPa): </LABEL><INPUT size="2" id="maxHotRockPressureMPa" type="float" value="100" onchange="metricsChanged()">
</DIV>
<!--DIV>  You cannot remelt vulcanized rubber and max temp on vulcanaized rubber is about 200 Celsius 
	<LABEL>Gas enclosed inside: </Label>
	<INPUT type="radio" id="isolatedWithRecycledRubber" value="rubber" checked onclick="document.getElementById('isolatedWithSteel').checked=false"><label>Melted recycled tire rubber+crushed stone, the temperature range 223 K - </label><Input type="float" id="maxRubberTemp" size="3" value="673"><span> K<span>
	<INPUT type="radio" id="isolatedWithSteel" value="steel" onclick="document.getElementById('isolatedWithRecycledRubber').checked=false"><label>Steel</label>
</DIV-->
<DIV>
	<!--LABEL>Average cost of construction work, insulation and gas isolation €/m2: </LABEL><INPUT size="4" id="costOfSurfaceM2" type="float" value="1200" onchange="metricsChanged()"-->
	<LABEL>Cost of injected and shotcreted rock €/m2: </LABEL><INPUT size="4" id="costOfRockSurfaceM2" type="float" value="250" onchange="metricsChanged()">
	<LABEL>Cost of 5 mm welded steel cover €/m2: </LABEL><INPUT size="4" id="costOfSteelSurfaceM2" type="float" value="250" onchange="metricsChanged()">
	<LABEL>Cost of gas flow channels in crushed stone €/m2: </LABEL><INPUT size="4" id="costOfChannelsM2" type="float" value="25" onchange="metricsChanged()" title="Cost is for ">
</DIV>
<DIV>
	<LABEL>Cost of crushed stone+stone wool insulation €/m3: </LABEL><INPUT size="4" id="costOfInsulationM3" type="float" value="25" onchange="metricsChanged()">
	<LABEL>Cost of open pit mining €/m3: </LABEL><INPUT size="4" id="costOfMiningM3" type="float" value="12" onchange="metricsChanged()">
	<!--LABEL>Cost of stainless steel sheet €/ton: </LABEL><INPUT size="4" id="costOfStainlessSteelPerTon" type="float" value="1500" onchange="metricsChanged()">
	<LABEL>Cost of he plate processing €/m2: </LABEL><INPUT size="4" id="costOfSteelPlateProcessingPerM2" type="float" value="5" onchange="metricsChanged()"-->
	<LABEL>Cost of crushed stone storage roof and walls €/m2: </LABEL><INPUT size="4" id="costOfWallAndRoofAboveM2" type="float" value="300" onchange="metricsChanged()">
</DIV>
<DIV>
	<LABEL>Cost of ice storage roof and walls €/m2: </LABEL><INPUT size="4" id="costOfIceStorageWallAndRoofIceM2" type="float" value="100" onchange="metricsChanged()">
	<LABEL>Cost of turbomachinery power €/kW: </LABEL><INPUT size="4" id="tcCostOfKW" type="float" value="40" onchange="metricsChanged()">
	<LABEL>Costs of power plant and generator €/kW: </LABEL><INPUT size="4" id="otherCostOfKW" type="float" value="200" onchange="metricsChanged()">
	<!--LABEL>Cost of generator €/kW: </LABEL><INPUT size="4" id="generatorCostOfKW" type="float" value="50" onchange="metricsChanged()"-->
	<LABEL>Cost of heat exchage €/kW: </LABEL><INPUT size="4" id="heCostOfKW" type="float" value="40" onchange="metricsChanged()">
</DIV>
<!--DIV>
	<INPUT id="cryogenicCooling" checked title="pLow gas cooled to saturation temperature with heat pump" type="checkbox" value="true">
	<LABEL>Set T low equal to Saturation temperature in P low with heat pump</LABEL>
	<INPUT id="motorGenerator" checked title="Compressors and turbins share the same axle and motor-generator" type="checkbox" value="true">
	<LABEL>Compressors and turbins share the same axle and motor-generator</LABEL>
	<INPUT id="showEnthalpyAndInternalEnergy" title="" type="checkbox" value="true">
	<LABEL>Show the mass specific enthalpy (J/g) and entropy (J/g/K) lines</LABEL>
</DIV-->
<DIV>
	<LABEL>Crushed stone of low-pressure storage min/max:</LABEL><INPUT id="gravelMinLp" type="float" value="40" size="3" maxlength="3"onchange="metricsChanged()">/
	<INPUT id="gravelMaxLp" type="float" value="120" size="3" maxlength="3"onchange="metricsChanged()">
	<LABEL>Porosity:</LABEL><INPUT id="gravelPorosityLp" onfocus="porositySet=true" type="float" size="4" maxlength="4" onchange="metricsChanged()">
	<BUTTON onClick="metricsChanged(); calcPressureDropInGravel('Lp')">Update pressure drop</BUTTON><LABEL id="expectedPDropLp"></LABEL>
</DIV>
<DIV>
	<LABEL>Crushed stone of high-pressure storage min/max:</LABEL><INPUT id="gravelMinHp" type="float" value="10" size="3" maxlength="3" onchange="metricsChanged()">/
	<INPUT id="gravelMaxHp" type="float" value="70" size="3" maxlength="3" onchange="metricsChanged()">
	<LABEL>Porosity:</LABEL><INPUT id="gravelPorosityHp" type="float" onfocus="porositySet=true" size="4" maxlength="4" onchange="metricsChanged()">
	<BUTTON onClick="metricsChanged(); calcPressureDropInGravel('Hp')">Update pressure drop</BUTTON><LABEL id="expectedPDropHp"></LABEL>
</DIV>

<DIV>
	<BUTTON onClick="simulateStorageHeatExchange()">Simulate heat exchange (take </BUTTON> 
	<LABEL>Height resolution (m):</LABEL> <INPUT id="heSimulationStepLen" type="float" size="3" value="0.1">
	<LABEL>Time resolution (s):</LABEL><INPUT id="heSimulationTimeResolution" type="text" size="4" value="900"> <Input id="calcHeatExchangeCoeffcient" type="checkbox" 
			title="Use heat exchange coefficient to calculate gas temperature (takes more time, but the result is the same)">
	<LABEL>Iterations:</LABEL><INPUT id="heSimulations" type="text" size="4" value="2">
</DIV>
<DIV>
	<LABEL>Max temp difference in low/high-pressure storage bottom:</LABEL><INPUT id="lpMaxLowDiff" type="text" size="4" value="10"><INPUT id="hpMaxLowDiff" type="text" size="4" value="25">
	<LABEL>and top:</LABEL><INPUT id="maxHighDiff" type="text" size="4" value="250">
	<!--span id="liquidCoolStorages" style="display:none"> 
		<LABEL>Liquid methane coolant capasity (GWh):</LABEL><INPUT id="lpLiquidStorageSizeGWh" type="text" size="4" value="95">
		<LABEL>Cooling water capasity (GWh):</LABEL><INPUT id="hpLiquidStorageSizeGWh" type="text" size="4" value="115">
	</span-->
</DIV>

<!-- these hidden old values are set based on the values of hpStorageSizeRockM3, highToLowPressureRatio, rockDensity, gravelDensity, insGravelDensity -->
<!--INPUT size="6" id="radius" type="hidden" value="150">
<INPUT size="6" id="pHigh_kPa" type="hidden" value="2500"> 
<INPUT size="6" id="pLow_kPa" type="hidden" value="100"-->
<!-- onclick="$('#heatPumpValues').css('display', this.checked ? 'block' : 'none')"  -->
<!--DIV id="heatPumpValues" style="display:none"><LABEL>Heat pump Turbin Tin (K)</LABEL><INPUT size="6" type="float" id="heatPumpTurbinTin" value="313">
<LABEL>Heat pump Compressor Tin (K)</LABEL> <INPUT size="6" type="float" id="heatPumpCompressorTin" value="300"></DIV-->
<!--DIV><INPUT size="6" id="adjustedCompressorPlow" title="Adjust compressor low tempreature" type="checkbox" value="true"><LABEL
>Adjust hot compressor's P low to set its Tin the same as turbin Tout</LABEL></DIV-->
	</div>
	<div class="tab-pane fade" id="storage" role="tabpanel" aria-labelledby="storage-tab">
		<canvas id="myPicture" width="1000" height="800" style="border:1px solid #000000;display:none"></canvas>
	</div>
	<!--div class="tab-pane fade" id="diagrams" role="tabpanel" aria-labelledby="diagrams-tab"-->
		<div>
			<INPUT id="showEnthalpyAndInternalEnergy" title="" type="checkbox" value="true" onClick="if (this.checked) drawTpDiagram()">
			<LABEL>Show the mass specific enthalpy (J/g) and entropy (J/g/K) lines</LABEL>
		</div>
		<canvas id="myCanvas" width="1000" height="800" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="lpHeatExchangeDiagram" width="500" height="400" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="hpHeatExchangeDiagram" width="500" height="400" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="usedHeatCapasitiesAndEnthalpies" width="500" height="400" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram0" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram1" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram2" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram3" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<canvas id="diagram4" width="500" height="600" style="border:1px solid #000000;display:none"></canvas>
		<DIV id="compressorDesignParams" style="display:none">
			<H3>Hot compressor design parameters</H3>
			<DIV><!-- 0.216, 0.44-->
				<LABEL>Mean load coefficient: </LABEL><INPUT size="5" type="float" id="hotLoadCoefficient" value="0.45"/>
				<LABEL>Mean flow coefficient: </LABEL><INPUT size="5" type="float" id="hotFlowCoefficient" value="0.74"/>
				<LABEL>Hot compressors:</LABEL><INPUT size="2" id="cHotUnits2" value="2"/>
				<LABEL>Stages:</Label><INPUT size="5" type="float" id="cStagesHot" value="21"/>
				<LABEL>Generator rpm:</LABEL><INPUT size="5" type="radio" name="hotRpm" id="hotRpm3000" value="3000"/><Span>3000</span> <INPUT size="5" type="radio" name="hotRpm" id="hotRpm3600" value="3600"/><Span>3600</span><INPUT size="5" type="radio" name="hotRpm" id="hotRpm1500" checked value="1500"/><Span>1500</span> <INPUT size="5" type="radio" name="hotRpm" id="hotRpm1800" value="1800"/><Span>1800</span>
			</DIV>
			<!--DIV>
				<Label>Hot compressor  type:</Label>
				<input id="hotCompressorTypeConstantRpm" name="hotCompressorType" type="radio" checked value="constantRpm"><LABEL>Synchronized with generator rpm</LABEL>
				<input id="hotCompressorTypeConstantH" name="hotCompressorType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power</label>
				<input id="hotCompressorTypeConstantVrel" name="hotCompressorType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeed" value="0.771"/>
			</DIV-->
			<DIV>
				<Label>Hot compressor diameter:</LABEL>
				<input id="hotCOD" name="hotCompressorDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="hotCMD" name="hotCompressorDiameter" type="radio" value="CMD"><LABEL>Constant mean diameter</LABEL>
				<input id="hotCID" name="hotCompressorDiameter" type="radio" checked value="CID"><LABEL>Constant inner diameter</LABEL>
				<input id="hotHasIGV" type="checkbox" checked value="true"><LABEL>Has IGV</LABEL> 
				<LABEL>, IGV AR:</LABEL><INPUT type="float"  size="4" id="hotIGV_AR" value="4">
			</DIV>
			<DIV>
				<!--LABEL>Min Hub/Tip ratio</LABEL><INPUT type="float" size="4" id="hubToTipRatioHot" value="0.50"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMaxHot" value="0.90"/-->
				<LABEL>Solidity c/s: </LABEL><INPUT type="float"  size="4" id="solidityHot" value="2" title="Chord spacing of front rotor: chord length/distance between chords"/>
				<!--LABEL>to </LABEL><INPUT type="float"  size="4" id="lastSolidityHot" value="2.5" title="Chord spacing of stators and rear stages"/-->
				<LABEL>Min tip gap:</LABEL><INPUT type="float"  size="4" id="tipGapMmHot" value="0.25" title="tip gap mm"/><SPAN> mm </SPAN><INPUT type="float"  size="4" id="tipGapPercentHot" value="0.5" title="tip gap/h %"/><SPAN> % (α/h)</SPAN>
				<LABEL>Rotor blade max thickess in tip mm</LABEL><INPUT size="4" type="float" id="maxTipThicknessHot" value="2"/>
			</DIV>
			<DIV>
				<LABEL>Reaction:</LABEL><INPUT type="float" size="3" id="hotReaction" value="0.50"/>
				<!--LABEL>Max reaction in bladed root:</LABEL><INPUT size="4" type="float" id="maxReactionInRootHot" value="0.8"/-->
				<LABEL>Min/max hub/tip ratio: </LABEL><INPUT size="4" type="float" id="minHubToTipHot" value="0.55"/> <INPUT size="4" type="float" id="maxHubToTipHot" value="0.99"/> 
				<!--LABEL>Divide optimal AR by:</LABEL><INPUT size="4" type="float" id="divOptARHot" value="1"/-->
				<!--LABEL>Cascaded stages loss factor: </LABEL><INPUT size="4" type="float" id="cascadeStageLossHot" value="1"/-->
				<!--LABEL>Blockage factor (depends on AR): </LABEL><INPUT size="4" type="float" id="blockageFactorHot" value="0.86"/>
				<LABEL>Reference AR for blockage: </LABEL><INPUT size="4" type="float" id="referenceARHot" value="1.7"/-->
				<LABEL>Stage power distribution first/last: </LABEL><INPUT size="4" type="float" id="firstToLastDeltaH_Hot" value="1"/>
				<!--LABEL>Min Reynolds number of rotor tip:</LABEL><INPUT size="4" type="float" id="minTipReHot" value="800000"/-->
			</DIV>
			<DIV>
				<LABEL>Max allowed hot compressor/turbin blade stress MPa (eg. 50% of stress to give plastic 0.2% strain in 3000h)</LABEL><INPUT size="4" type="float" id="cStressMaxMPa" value="228"/>
				<LABEL>Gap between rotor and stator (% of rotor chord length):</LABEL> <INPUT type="float"  size="4" id="rotorStatorGap" value="20" title=""/><SPAN> %</SPAN>
			</DIV>
			<DIV>
				<LABEL>Max uncooled blade temperature K</Label><INPUT size="4" type="float" id="tempStressMaxMPa" value="1200"/>
				<LABEL>Strength decreased by</LABEL><INPUT size="4" type="float" id="tempMaxStressMPaDecrValue" value="1"/><LABEL> MPa/K above</Label><INPUT size="4" type="float" id="tempMaxStressMPaDecr" value="1023"/>
					<!-- blade is 
					<!--INPUT size="4" type="float" id="cStressMaxMPa2" value="134"/><Span>MPa in</span>
					<INPUT size="4" type="float" id="tempStressMaxMPa2" value="1088"/><Span>K, see: </span-->
					<a target="_blank" href="https://www.specialmetals.com/documents/technical-bulletins/nimonic-alloy-105.pdf">Nimonic 105</a>
					<a target="_blank" href="https://upcommons.upc.edu/bitstream/handle/2117/350237/ANEXO%203-%20Materiales.pdf?sequence=2">MAR-M 200</a>
					<a target="_blank" href="https://www.specialmetals.com/documents/technical-bulletins/nimonic/">Nimonic alloys</a>
					<!-- assume unlimited cooling-->
					<!--LABEL>Blade cooling up to K: </LABEL><INPUT size="3" type="float" id="bladeCoolingK" value="400"/-->
			</DIV>
			<DIV id="shaftData"> <!--style="display:none">-->
				<LABEL>Shaft bearing space mm:</LABEL><INPUT size="2" type="float" id="bearingsSpace" type="float" value="2"/>
				<!-- https://en.wikipedia.org/wiki/Maraging_steel, https://en.wikipedia.org/wiki/Aermet, https://en.wikipedia.org/wiki/Ultimate_tensile_strength -->
				<LABEL>Shaft steel ultimate tensile strength MPa (650-2400): </LABEL><INPUT size="4" type="float" id="shaftStrength" type="float" value="2400"
					title="The shaft is cooled, so all ultimate strength steels are available, e.g. Maraging steel"/>
				<LABEL>Min shaft pipe wall mm</LABEL><INPUT size="2" type="float" id="minShaftPipeWidth" type="float" value="4"/>
				<BUTTON onClick="redrawHotCompressor()">Redraw hot compressor</BUTTON>
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScaleHot"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
			</DIV>
			<canvas id="hotCompressorImage" style="border:1px solid #000000;display:none;"></canvas>
			<table id="hotCompressorData"> </table> 
			<br/>
			<H3>Hot turbin design parameters</H3>
			<DIV><!-- 0.216, 0.44-->
				<LABEL>Mean load coefficient: </LABEL><INPUT size="5" type="float" id="hotTurbinLoadCoefficient" value="0.40"/>
				<LABEL>Mean flow coefficient: </LABEL><INPUT size="5" type="float" id="hotTurbinFlowCoefficient" value="0.57"/>
				<LABEL>Hot turbins:</LABEL><INPUT size="2" id="cHotTurbinUnits2" value="2"/>
				<LABEL>Stages:</Label><INPUT size="5" type="float" id="cStagesHotTurbin" value="21"/>
				<LABEL>Generator rpm:</LABEL><INPUT size="5" type="radio" name="hotTurbinRpm" id="hotTurbinRpm3000" value="3000"/><Span>3000</span> <INPUT size="5" type="radio" name="hotTurbinRpm" id="hotTurbinRpm3600" value="3600"/><Span>3600</span><INPUT size="5" type="radio" name="hotTurbinRpm" id="hotTurbinRpm1500" checked value="1500"/><Span>1500</span> <INPUT size="5" type="radio" name="hotTurbinRpm" id="hotTurbinRpm1800" value="1800"/><Span>1800</span>
			</DIV>
			<!--DIV>
				<Label>Hot turbin  type:</Label>
				<input id="hotTurbinTypeConstantRpm" name="hotTurbinType" type="radio" checked value="constantRpm"><LABEL>Synchronized with generator rpm</LABEL>
				<input id="hotTurbinTypeConstantH" name="hotTurbinType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power</label>
				<input id="hotTurbinTypeConstantVrel" name="hotTurbinType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeed" value="0.771"/>
				<LABEL>Subsonic &lt; 0.9 &lt;= Transonic &lt;= 1.2 &lt; Supersonic</LABEL>
			</DIV-->
			<DIV>
				<Label>Hot turbin diameter:</LABEL>
				<input id="hotTurbinCOD" name="hotTurbinDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="hotTurbinCMD" name="hotTurbinDiameter" type="radio" checked value="CMD"><LABEL>Constant mean diameter</LABEL>
				<input id="hotTurbinCID" name="hotTurbinDiameter" type="radio" value="CID"><LABEL>Constant inner diameter</LABEL>
				<!--input id="hotTurbinHasIGV" type="checkbox" checked value="true"><LABEL>Has OGV</LABEL> 
				<LABEL>, OGV AR:</LABEL><INPUT type="float"  size="4" id="hotTurbinIGV_AR" value="4"-->
			</DIV>
			<DIV>
				<!--LABEL>Min Hub/Tip ratio</LABEL><INPUT type="float" size="4" id="hubToTipRatioHot" value="0.50"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMaxHot" value="0.90"/-->
				<LABEL>Solidity c/s: </LABEL><INPUT type="float"  size="4" id="solidityHotTurbin" value="1.0" title="Chord spacing of front rotor: chord length/distance between chords"/>
				<!--LABEL>to </LABEL><INPUT type="float"  size="4" id="lastSolidityHotTurbin" value="2.5" title="Chord spacing of stators and rear stages"/-->
				<LABEL>Min tip gap:</LABEL><INPUT type="float"  size="4" id="tipGapMmHotTurbin" value="0.25" title="tip gap mm"/><SPAN> mm </SPAN><INPUT type="float"  size="4" id="tipGapPercentHotTurbin" value="0.5" title="tip gap/h %"/><SPAN> % (α/h)</SPAN>
				<LABEL>Rotor blade max thickess in tip mm</LABEL><INPUT size="4" type="float" id="maxTipThicknessHotTurbin" value="3"/>
				<LABEL>Gap between rotor and stator (% of rotor chord length):</LABEL> <INPUT type="float"  size="4" id="rotorStatorGapTurbin" value="40" title=""/><SPAN> %</SPAN>
			</DIV>
			<DIV>
				<LABEL>Reaction:</LABEL><INPUT type="float" size="3" id="hotTurbinReaction" value="0.45"/>
				<!--LABEL>Max reaction in bladed root:</LABEL><INPUT size="4" type="float" id="maxReactionInRootHotTurbin" value="0.8"/-->
				<!--LABEL>Divide optimal AR by:</LABEL><INPUT size="4" type="float" id="divOptARHotTurbin" value="1"/-->
				<LABEL>Max mean line tMax/c:</LABEL><INPUT size="4" type="float" id="tMaxToChordHotTurbin" value="0.20"/>
				<LABEL>Max aspect ratio:</LABEL><INPUT size="4" type="float" id="maxAspectRatioHotTurbin" value="7"/>
				<LABEL>Min/max hub/tip ratio: </LABEL><INPUT size="4" type="float" id="minHubToTipHotTurbin" value="0.45"/> <INPUT size="4" type="float" id="maxHubToTipHotTurbin" value="0.99"/> 
				<!--LABEL>Cascaded stages loss factor: </LABEL><INPUT size="4" type="float" id="cascadeStageLossHotTurbin" value="1"/-->
				<!--LABEL>Blockage factor (depends on AR): </LABEL><INPUT size="4" type="float" id="blockageFactorHotTurbin" value="0.86"/>
				<LABEL>Reference AR for blockage: </LABEL><INPUT size="4" type="float" id="referenceARHotTurbin" value="1.7"/-->
				<LABEL>Stage power distribution first/last: </LABEL><INPUT size="4" type="float" id="firstToLastDeltaH_HotTurbin" value="1.0"/>
				<!--LABEL>Min Reynolds number of rotor tip:</LABEL><INPUT size="4" type="float" id="minTipReHotTurbin" value="800000"/-->
			</DIV>
			<DIV>
				<BUTTON onClick="redrawHotTurbin()">Redraw hot turbin</BUTTON>
				<LABEL>Scale:</LABEL>
				<SELECT id="compressorScaleHotTurbin"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
					<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
				</SELECT>
			<DIV>
			<canvas id="hotTurbinImage" style="border:1px solid #000000;display:none;"></canvas>
			<table id="hotTurbinData"> </table> 
			<br/>
			<H3>Cryogenic compressor design parameters</H3>
			<DIV>
				<LABEL>Mean load coefficient: </LABEL><INPUT size="5" type="float" id="coldLoadCoefficient" value="0.32"/>
				<LABEL>Mean flow coefficient: </LABEL><INPUT size="5" type="float" id="coldFlowCoefficient" value="0.62"/>
				<LABEL>Cryogenic compressors:</LABEL><INPUT size="2" id="cColdUnits2" value="2"/>
				<LABEL>Stages:</Label><INPUT size="5" type="float" id="cStagesCold" value="16"/>
				<LABEL>Generator rpm:</LABEL><INPUT size="5" type="radio" name="coldRpm" id="coldRpm3000" value="3000"/><Span>3000</span> <INPUT size="5" type="radio" name="coldRpm" id="coldRpm3600" value="3600"/><Span>3600</span><INPUT size="5" type="radio" name="coldRpm" id="coldRpm1500" checked value="1500"/><Span>1500</span> <INPUT size="5" type="radio" name="coldRpm" id="coldRpm1800" value="1800"/><Span>1800</span>
			</DIV>
			<!--DIV>
				<Label>Cryo compressor type:</Label>
				<input id="coldCompressorTypeConstantRpm" name="coldCompressorType" type="radio" checked value="constantRpm"><LABEL>Synchronized with generator rpm</LABEL>
				<input id="coldCompressorTypeConstantH" name="coldCompressorType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power:</label>
				<input id="coldCompressorTypeConstantVrel" name="coldCompressorType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeedCold" value="0.752"/>
			</DIV-->
			<DIV>
				<Label>Cryo compressor diameter:</LABEL>
				<input id="coldCOD" name="coldCompressorDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="coldCMD" name="coldCompressorDiameter" type="radio" value="CMD"><LABEL>Constant mean flow diameter</LABEL>
				<input id="coldCID" name="coldCompressorDiameter" type="radio" checked value="CID"><LABEL>Constant inner diameter</LABEL>
				<input id="coldHasIGV" type="checkbox" checked value="true"><LABEL>Has IGV</LABEL>
				<LABEL>, OGV AR:</LABEL><INPUT type="float"  size="4" id="coldIGV_AR" value="4">
			</DIV>
			<DIV>
				<!--LABEL>Hub/Tip ratio from:</LABEL><INPUT type="float" size="4" id="hubToTipRatioCold" value="0.50"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMaxCold" value="0.90"/-->
				<LABEL>Solidity c/s </LABEL><INPUT type="float"  size="4" id="solidityCold" value="2" title="Chord spacing: chord length/distance between chords"/>
				<!--LABEL>to </LABEL><INPUT type="float"  size="4" id="lastSolidityCold" value="2.5" title="Chord spacing of stators and rear stages"/-->
				<LABEL>Min tip gap:</LABEL><INPUT type="float"  size="4" id="tipGapMmCold" value="0.25" title="tip gap mm"/>
				<SPAN> mm </SPAN><INPUT type="float"  size="4" id="tipGapPercentCold" value="0.5" title="tip gap/h %"/><SPAN> % (α/h)</SPAN>
				<LABEL>Rotor blade max thickess in tip mm</LABEL><INPUT size="4" type="float" id="maxTipThicknessCold" value="3"/>
			</DIV>
			<DIV>
				<LABEL>Reaction: </LABEL><INPUT type="float" size="3" id="coldReaction" value="0.50"/>
				<LABEL>Min/max hub/tip ratio: </LABEL><INPUT size="4" type="float" id="minHubToTipCold" value="0.40"/> <INPUT size="4" type="float" id="maxHubToTipCold" value="0.99"/> 
				<!--LABEL>Divide optimal AR by: </LABEL><INPUT size="4" type="float" id="divOptARCold" value="1"/-->
				<!--LABEL>Cascaded stages loss %: </LABEL><INPUT size="4" type="float" id="cascadeStageLossCold" value="1"/-->
				<!--LABEL>Blockage factor: </LABEL><INPUT size="4" type="float" id="blockageFactorCold" value="0.86"/>
				<LABEL>Reference AR for blockage: </LABEL><INPUT size="4" type="float" id="referenceARCold" value="1.7"/-->
				<LABEL>Stage power distribution first/last: </LABEL><INPUT size="4" type="float" id="firstToLastDeltaH_Cold" value="1.0"/>
				<!--LABEL>Min Reynolds number of rotor tip:</LABEL><INPUT size="4" type="float" id="minTipReCold" value="500000"/-->
				<!--LABEL>Max reaction in bladed root:</LABEL><INPUT size="4" type="float" id="maxReactionInRootCold" value="0.8"/-->
			</DIV>
			<DIV>
				<LABEL>50% of max allowed steady stress of cryo compressor/turbin blades MPa</LABEL><INPUT size="4" type="float" id="cStressMaxMPaCold" value="175"/>
					<a target="_blank" href="https://nickelinstitute.org/media/1723/materialsforcryogenicservice_engineeringpropertiesofausteniticstainlesssteel_4368_.pdf">Cryogenic austenitic steels</a>
				<BUTTON onClick="redrawColdCompressor()">Redraw cryo compressor</BUTTON>
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScaleCold"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
			</DIV>
			<canvas id="coldCompressorImage" style="border:1px solid #000000;display:none"></canvas>
			<table id="coldCompressorData"> </table> 
			<br/>
			<H3>Cryogenic turbin design parameters</H3>
			<DIV>
				<LABEL>Mean load coefficient: </LABEL><INPUT size="5" type="float" id="coldTurbinLoadCoefficient" value="0.30"/>
				<LABEL>Mean flow coefficient: </LABEL><INPUT size="5" type="float" id="coldTurbinFlowCoefficient" value="0.45"/>
				<LABEL>Cryogenic turbins:</LABEL><INPUT size="4" id="cColdTurbinUnits2" value="2"/>
				<LABEL>Stages:</Label><INPUT size="5" type="float" id="cStagesColdTurbin" value="15"/>
				<LABEL>Generator rpm:</LABEL><INPUT size="5" type="radio" name="coldRpm" id="coldTurbinRpm3000" value="3000"/><Span>3000</span> <INPUT size="5" type="radio" name="coldTurbinRpm" id="coldTurbinRpm3600" value="3600"/><Span>3600</span><INPUT size="5" type="radio" name="coldTurbinRpm" id="coldTurbinRpm1500" checked value="1500"/><Span>1500</span> <INPUT size="5" type="radio" name="coldTurbinRpm" id="coldTurbinRpm1800" value="1800"/><Span>1800</span>
			</DIV>
			<!--DIV>
				<Label>Cryo turbin type:</Label>
				<input id="coldTurbinTypeConstantRpm" name="coldTurbinType" type="radio" checked value="constantRpm"><LABEL>Synchronized with generator rpm</LABEL>
				<input id="coldTurbinTypeConstantH" name="coldTurbinType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power:</label>
				<input id="coldTurbinTypeConstantVrel" name="coldTurbinType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeedColdTurbin" value="0.752"/>
			</DIV-->
			<DIV>
				<Label>Cryo turbin diameter:</LABEL>
				<input id="coldTurbinCOD" name="coldTurbinDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="coldTurbinCMD" name="coldTurbinDiameter" type="radio" checked value="CMD"><LABEL>Constant mean flow diameter</LABEL>
				<input id="coldTurbinCID" name="coldTurbinDiameter" type="radio" value="CID"><LABEL>Constant inner diameter</LABEL>
				<!--input id="coldTurbinHasIGV" type="checkbox" checked value="true"><LABEL>Has OGV</LABEL>
				<LABEL>, IGV AR:</LABEL><INPUT type="float"  size="4" id="coldTurbinIGV_AR" value="4"-->
			</DIV>
			<DIV>
				<!--LABEL>Hub/Tip ratio from:</LABEL><INPUT type="float" size="4" id="hubToTipRatioColdTurbin" value="0.50"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMaxColdTurbin" value="0.90"/-->
				<LABEL>Solidity c/s </LABEL><INPUT type="float"  size="4" id="solidityColdTurbin" value="1.05" title="Chord spacing: chord length/distance between chords"/>
				<!--LABEL>to </LABEL><INPUT type="float"  size="4" id="lastSolidityColdTurbin" value="2.5" title="Chord spacing of stators and rear stages"/-->
				<LABEL>Min tip gap:</LABEL><INPUT type="float"  size="4" id="tipGapMmColdTurbin" value="0.25" title="tip gap mm"/>
				<SPAN> mm </SPAN><INPUT type="float"  size="4" id="tipGapPercentColdTurbin" value="0.25" title="tip gap/h %"/><SPAN> % (α/h)</SPAN>
				<LABEL>Rotor blade max thickess in tip mm</LABEL><INPUT size="4" type="float" id="maxTipThicknessColdTurbin" value="1"/>
			</DIV>
			<DIV>
				<LABEL>Reaction: </LABEL><INPUT type="float" size="3" id="coldTurbinReaction" value="0.45"/>
				<LABEL>Max mean line tMax/c:</LABEL><INPUT size="4" type="float" id="tMaxToChordColdTurbin" value="0.20"/>
				<LABEL>Max aspect ratio:</LABEL><INPUT size="4" type="float" id="maxAspectRatioColdTurbin" value="7"/>
				<LABEL>Min/max hub/tip ratio: </LABEL><INPUT size="4" type="float" id="minHubToTipColdTurbin" value="0.45"/> <INPUT size="4" type="float" id="maxHubToTipColdTurbin" value="0.99"/> 
				<!--LABEL>Divide optimal AR by: </LABEL><INPUT size="4" type="float" id="divOptARColdTurbin" value="1"/-->
				<!--LABEL>Cascaded stages loss %: </LABEL><INPUT size="4" type="float" id="cascadeStageLossColdTurbin" value="1"/-->
				<!--LABEL>Blockage factor: </LABEL><INPUT size="4" type="float" id="blockageFactorColdTurbin" value="0.86"/>
				<LABEL>Reference AR for blockage: </LABEL><INPUT size="4" type="float" id="referenceARColdTurbin" value="1.7"/-->
				<LABEL>Stage power distribution first/last: </LABEL><INPUT size="4" type="float" id="firstToLastDeltaH_ColdTurbin" value="1.0"/>
				<!--LABEL>Min Reynolds number of rotor tip:</LABEL><INPUT size="4" type="float" id="minTipReColdTurbin" value="500000"/-->
				<!--LABEL>Max reaction in bladed root:</LABEL><INPUT size="4" type="float" id="maxReactionInRootColdTurbin" value="0.8"/-->
			</DIV>
			<DIV>
				<BUTTON onClick="redrawColdTurbin()">Redraw cryo turbin</BUTTON>
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScaleColdTurbin"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
			</DIV>
			<canvas id="coldTurbinImage" style="border:1px solid #000000;display:none"></canvas>
			<table id="coldTurbinData"> </table> 
			<br/>
<!-- TBD heat pump compressors stage + cooling + stage-->
			<H3>Heat pump compressor design parameters</H3>
			<DIV>
				<LABEL>Heat Pump fluid:</LABEL>
				<SELECT id="hpFluid"><OPTION selected>Argon</OPTION><OPTION>Helium</OPTION><OPTION>Hydrogen</OPTION><OPTION>Methane</OPTION><OPTION>Nitrogen</OPTION>
				</SELECT>
				<LABEL>Heat pump compressors: </LABEL><INPUT size="2" id="cHpUnits2" value="2"/>
				<LABEL>Mean load coefficient: </LABEL><INPUT size="5" type="float" id="hpLoadCoefficient" value="0.32"/>
				<LABEL>Mean flow coefficient: </LABEL><INPUT size="5" type="float" id="hpFlowCoefficient" value="0.605"/>
				<LABEL>Compressor stages:</Label><INPUT size="5" type="float" id="cStagesHp" value="6"/>
				<LABEL>Generator rpm:</LABEL><INPUT size="5" type="radio" name="hpRpm" id="hpRpm3000" value="3000"/><Span>3000</span> <INPUT size="5" type="radio" name="hpRpm" id="hpRpm3600" value="3600"/><Span>3600</span><INPUT size="5" type="radio" name="hpRpm" id="hpRpm1500" checked value="1500"/><Span>1500</span> <INPUT size="5" type="radio" name="hpRpm" id="hpRpm1800" value="1800"/><Span>1800</span>
			<DIV>
			<DIV>
				<LABEL>Internal pressure: </LABEL>
					<!--INPUT size="5" type="radio" name="hpPressure" id="hpPressureAdjusted" value="adjusted"/>
					<Label>Adjusted for hub/tip ratio: </Label> <INPUT size="5" type="float" id="hpHubToTipRatio" value="0.65"/-->
					<INPUT size="5" type="hidden" checked name="hpPressure" id="hpPressureAbsolute" value="absolute"/>
					<Label>Absolute high pressure (kPa): </Label><INPUT size="5" type="float" id="hpHighPressureKPa" value="4117"/>
					<!--div style="display:hidden">
						<Label>Show compressor 1/2:</LABEL>
						<input id="hpCompressorOne" name="hpCompressor" type="radio" value="one" checked><LABEL>First</LABEL>
						<input id="hpCompressorTwo" name="hpCompressor" type="radio" value="two"><LABEL>Second</LABEL>
					</div-->
			</DIV>
			<!--DIV>
				<Label>Heat pump type:</Label>
				<input id="hpCompressorTypeConstantRpm" name="hpCompressorType" type="radio" checked value="constantRpm"><LABEL>Synchronized with generator rpm</LABEL>
				<input id="hpCompressorTypeConstantH" name="hpCompressorType" type="radio" value="constantH"><Label>Constant number of stages and shafts with equal power:</label>
				<input id="hpCompressorTypeConstantVrel" name="hpCompressorType" type="radio" value="constantVrel"><LABEL>Constant relative speed in mach:</LABEL><INPUT size="5" type="float" id="machMaxSpeedHp" value="0.752"/>
			</DIV-->
			<DIV>
				<Label>Heat pump compressor diameter:</LABEL>
				<input id="hpCOD" name="hpCompressorDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="hpCMD" name="hpCompressorDiameter" type="radio" checked value="CMD"><LABEL>Constant mean flow diameter</LABEL>
				<input id="hpCID" name="hpCompressorDiameter" type="radio" value="CID"><LABEL>Constant inner diameter</LABEL>
				<input id="hpHasIGV" type="checkbox" checked value="true"><LABEL>Has IGV</LABEL>
				<LABEL>, IGV AR:</LABEL><INPUT type="float"  size="4" id="hpIGV_AR" value="4">
			</DIV>
			<DIV>
				<!--LABEL>Hub/Tip ratio from:</LABEL><INPUT type="float" size="4" id="hubToTipRatioHp" value="0.50"/>
				<SPAN> to </SPAN><INPUT type="float" size="4" id="hubToTipRatioMaxHp" value="0.90"/-->
				<LABEL>Compressor reaction: </LABEL><INPUT type="float" size="3" id="hpReaction" value="0.55"/>
				<LABEL>Compressor solidity c/s </LABEL><INPUT type="float"  size="4" id="solidityHp" value="2" title="Chord spacing: chord length/distance between chords"/>
				<LABEL>Min tip gap:</LABEL><INPUT type="float"  size="4" id="tipGapMmHp" value="0.1" title="tip gap mm"/>
				<SPAN> mm </SPAN><INPUT type="float"  size="4" id="tipGapPercentHp" value="0.1" title="tip gap/h %"/><SPAN> % (α/h)</SPAN>
				<LABEL>Rotor blade max thickess in tip mm</LABEL><INPUT size="4" type="float" id="maxTipThicknessHp" value="0.5"/>
			</DIV>
			<DIV>
				<LABEL>Max mean line tMax/c:</LABEL><INPUT size="4" type="float" id="tMaxToChordHpTurbin" value="0.20"/>
				<LABEL>Max aspect ratio:</LABEL><INPUT size="4" type="float" id="maxAspectRatioHpTurbin" value="7"/>
				<LABEL>Min/max hub/tip ratio: </LABEL><INPUT size="4" type="float" id="minHubToTipHp" value="0.45"/> 
											  <INPUT size="4" type="float" id="maxHubToTipHp" value="0.99"/> 
				<!--LABEL>Divide optimal AR by: </LABEL><INPUT size="4" type="float" id="divOptARHp" value="1"/-->
				<!--LABEL>Blockage factor: </LABEL><INPUT size="4" type="float" id="blockageFactorHp" value="0.86"/>
				<LABEL>Reference AR for blockage: </LABEL><INPUT size="4" type="float" id="referenceARHp" value="1.7"/-->
				<!--LABEL>Stage power distribution first/last: </LABEL><INPUT size="4" type="float" id="firstToLastDeltaH_Hp" value="1.02"/-->
			</DIV>
			<DIV>
				<!--LABEL>Max allowed heat pump compressor/turbin blade stress MPa (eg. 50% of stress to give plastic 0.2% strain in 3000h)</LABEL><INPUT size="4" type="float" id="cStressMaxMPaHp" value="228"/-->
				<BUTTON onClick="redrawHpCompressor()">Redraw heat pump compressor</BUTTON>
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScaleHp"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
			</DIV>

		<canvas id="hpCompressorImage1" style="border:1px solid #000000;display:none"></canvas>
		<table id="hpCompressorData1"> </table>
		<canvas id="hpCompressorImage2" style="border:1px solid #000000;display:none"></canvas>
		<table id="hpCompressorData2"> </table>
			<H3>Heat pump turbin design parameters</H3>
			</DIV>
				<LABEL>Load coefficient of turbin: </LABEL><INPUT size="5" type="float" id="hpTurbinLoadCoefficient" value="0.21"/>
				<LABEL>Flow coefficient of turbin: </LABEL><INPUT size="5" type="float" id="hpTurbinFlowCoefficient" value="0.61"/>
				<LABEL>Heat pump turbines: </LABEL><INPUT size="2" id="cHpTurbinUnits2" value="2"/>
				<LABEL>Turbin stages:</Label><INPUT size="5" type="float" id="cStagesHpTurbin" value="11"/>
			</DIV>
			<DIV>
				<Label>Heat pump turbin diameter:</LABEL>
				<input id="hpTurbinCOD" name="hpTurbinDiameter" type="radio" value="COD"><LABEL>Constant outer diameter</LABEL>
				<input id="hpTurbinCMD" name="hpTurbinDiameter" type="radio" checked value="CMD"><LABEL>Constant mean flow diameter</LABEL>
				<input id="hpTurbinCID" name="hpTurbinDiameter" type="radio" value="CID"><LABEL>Constant inner diameter</LABEL>
			</DIV>
			<DIV>
				<LABEL>Turbin reaction: </LABEL><INPUT type="float" size="3" id="hpTurbinReaction" value="0.52"/>
				<LABEL>Turbin solidity c/s </LABEL><INPUT type="float"  size="4" id="solidityHpTurbin" value="1.05" title="Chord spacing: chord length/distance between chords"/>
				<LABEL>Max mean line tMax/c:</LABEL><INPUT size="4" type="float" id="tMaxToChordHpTurbin" value="0.20"/>
				<LABEL>Max aspect ratio:</LABEL><INPUT size="4" type="float" id="maxAspectRatioHpTurbin" value="7"/>
			</DIV>
			<DIV>
				<!--LABEL>Max allowed heat pump compressor/turbin blade stress MPa (eg. 50% of stress to give plastic 0.2% strain in 3000h)</LABEL><INPUT size="4" type="float" id="cStressMaxMPaHp" value="228"/-->
				<BUTTON onClick="redrawHpTurbin()">Redraw heat pump turbin</BUTTON>
				<LABEL>Scale:</LABEL>
					<SELECT id="compressorScaleHpTurbin"><OPTION value="0">Default</OPTION><OPTION value="75">1 m == 75px</OPTION><OPTION value="100">1 m == 100px</OPTION><OPTION value="125">1 m == 125px</OPTION><OPTION value="150">1 m == 150px</OPTION>
						<OPTION value="200">1 m == 200px</OPTION><OPTION value="225">1 m == 225px</OPTION><OPTION value="250">1 m == 250px</OPTION><OPTION value="500">1 m == 500px</OPTION><OPTION value="1000">1 m == 1000px</OPTION>
					</SELECT>
			</DIV>
		<canvas id="hpTurbinImage" style="border:1px solid #000000;display:none"></canvas>
		<table id="hpTurbinData"> </table>
		</DIV>
		<canvas id="smithsChart" style="border:1px solid #000000;display:none"></canvas>
	</div>
<div id="myModal" class="modal">
  <div class="modal-content">
    <h4 id="modalTitle"></h4>
    <p id="modalContent"></p>
    <p id="modGasWeight"></p>
	<div id="modalStartButton">
		<Button onclick="fnSimulateChargeDischarge()">Start simulation</button>
		<Button onclick="document.getElementById('myModal').style.display='none'">Cancel</button>
	</div>
	<div id="modalStopButton">
		<Button onclick="stopChargeDischargeSimulation = true;">Stop simulation</button>
	</div>
  </div>
</div>


<SCRIPT>
var fnSimulateChargeDischarge;
var stopChargeDischargeSimulation = false;
function calcTurbin()
{
// experimental code to analyze Mitsubishi M701JAC (2018), input values are customized to match with known facts
	var props =  {};
	var methaneHeatValue =  55.5*1000000;  // heat value of CH4 +butane and ethane traces J/kg
	var flowOut = props.flowOut=getFloatParam('outFlowTurbin');
	var netPower = props.netPower=getFloatParam('netPowerMWTurbin')*1000000;
	var efficiency = props.efficiency=getFloatParam('totalEfficiency')/100;
	var grossPower = props.grossPower = netPower / efficiency;
	var tOut = props.tOut=getFloatParam('tOutTurbin')+273;
	//var naturalGasFlowIn = props.naturalGasFlowIn=getFloatParam('naturalGasIn');
	var tIn = props.tIn=getFloatParam('tInCompressor',15)+273;
	//var tHigh = props.tHigh=getFloatParam('tHighTurbin',1600)+273;
	//var internalCooling = props.internalCooling=getFloatParam('internalCooling')/100;
	var pRatio = props.pRatio=getFloatParam('pRatioTurbin');
	var pDrop = 1; // props.pDrop=1-getFloatParam('pDropTurbin')/100;
	var otherLoss = props.otherLoss=getFloatParam('otherLossTurbin')/100;
	var compressorStageEfficiency = props.otherLoss=getFloatParam('compressorStageEfficiency')/100;
	
	var heatRate = props.heatRate = getFloatParam('heatRateTurbin');
	var naturalGasFlowIn = props.naturalGasFlowIn = (netPower*heatRate/3600)/(methaneHeatValue*0.977);
	var methaneIn = 0.977*naturalGasFlowIn;  
	var nitrogenIn = 0.016*naturalGasFlowIn;
	var co2In = 0.007*naturalGasFlowIn;
	var naturalGasMix = [['Methane', 'Nitrogen', 'CarbonDioxide'], [0.977, 0.016, 0.007], [16, 28, 44], [0,0,0] ];
	const naturalGasMixName = getMixName(naturalGasMix); // 'Methane[0.977000]&CarbonDioxide[0.007000]&Nitrogen[0.016000]';
	//const naturalGasMixName = 'Methane[0.977000]&Nitrogen[0.016000]&CarbonDioxide[0.007000]'; // getMixName(naturalGasMix);
	const pLowIn = 101325*pDrop;
	const pHighOut = pLowIn*pRatio;
	const pHighIn = pHighOut*pDrop;
	const pLowOut = 101325/pDrop;
	const vaporPercent = props.vaporPercent = Module.HAPropsSI('W','T	',tIn,'P',pLowIn,'R',0.5);
	var airMixIn = [['Nitrogen', 'Oxygen', 'Argon', 'Water'], [0.781, 0.209, 0.009, vaporPercent],[28,32,40,18],[0,0,0,0]]; // typical humidity?
	fixSum(airMixIn);

	var dryAirMixIn = [['Nitrogen', 'Oxygen', 'Argon'], [0.782, 0.209, 0.009], [28, 32, 40], [0,0,0]] ; // typical humidity?
	var airFlowIn = props.airFlowIn = flowOut - naturalGasFlowIn;
	var heatProduced = props.heatProduced = methaneIn * methaneHeatValue;
	var tHigh = 1650 + 273;
	const dryAirMixName = getMixName(dryAirMixIn);

	if (!otherLoss) otherLoss = 0;
	
	//CH4(16) + 2*O2(32) => CO2(44) + 2*H2O(18)  (80 == 80)
	const oxygenUsed = methaneIn * 2 * 32/16;	
	const co2Mol = 44; // 12+2*16 // Module.PropsSI('M', null, null, null, null, 'CarbonDioxide');
	const waterMol = 18; // Module.PropsSI('M', null, null, null, null, 'Water');
	const co2Produced = (oxygenUsed + methaneIn)*co2Mol/(co2Mol + 2 * waterMol)+ co2In;
	const vaporProduced = (oxygenUsed + methaneIn) * 2 * waterMol/(co2Mol + 2 * waterMol);
	var mixOut = [['CarbonDioxide','Nitrogen', 'Water', 'Oxygen', 'Argon'], [0, 0, 0, 0, 0], [44, 28, 18, 32, 40], [0, 0, 0, 0, 0]];
	mixOut[1][0] = (co2In + co2Produced)/flowOut;				// co2 content
	mixOut[1][1] = (airMixIn[1][0]*airFlowIn+nitrogenIn)/flowOut;	// Nitrogen content
	mixOut[1][2] = (airMixIn[1][3]*airFlowIn+vaporProduced)/flowOut;	// wapor content
	mixOut[1][3] = (airMixIn[1][1]*airFlowIn-oxygenUsed)/flowOut;	// unused oxygen 
	mixOut[1][4] = airMixIn[1][2]*airFlowIn/flowOut;		// Argon
	fixSum(mixOut);
	
	props.hOut = mixPropWithTP('H', 'T', tOut, 'P', pLowOut, mixOut );
	//props.hTotalOut = props.hOut*flowOut;
	//props.heatOut = (props.hOut*flowOut-heatIn);
	//props.kineticOut = 1 - props.heatOut - efficiency - otherLoss;
	//props.speedOut = Math.sqrt(2 * props.kineticOut*grossPower/(flowOut*10));
	props.hNGasLow = mixPropWithTP('H', 'T', tIn, 'P', pLowIn, naturalGasMix );
	props.hNGasHigh = getMixH100WithS('T', tIn, 'P', pLowIn, pHighOut, naturalGasMix )/ 0.80;
	props.naturalGasCompressionWork = (props.hNGasHigh-props.hNGasLow)*naturalGasFlowIn;

	// returns the enthalpy of water vapor
	//props.hAirInHA = Module.HAPropsSI('H', 'T', tIn, 'P', pLowIn, 'R',0.5);
	//props.hDryAirInDelta100 = Module.PropsSI('H', 'T', tIn+100, 'P', pLowIn, 'Air') - Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air');
	//props.hMyDryAirInDelta100 = Module.PropsSI('H', 'T', tIn+100, 'P', pLowIn, dryAirMixName) - Module.PropsSI('H', 'T', tIn, 'P', pLowIn, dryAirMixName);
	//props.hAirInDelta100 = mixPropWithTP( 'H', 'T', tIn+100, 'P', pLowIn, airMixIn ) - mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, airMixIn );
	props.hAirIn = Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air');
	props.hAirInOWN = mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, airMixIn );
	props.hTotalIn = props.hNGasLow*naturalGasFlowIn + props.hAirIn*airFlowIn;
	props.hTotalHigh = props.hTotalIn + heatProduced;
	
	
	if (!tHigh) {
		props.hHigh = props.hTotalHigh/flowOut;
		props.tHigh = mixPropWithTP('T', 'H', props.hHigh, 'P', pHigh, mixOut ); 
		tHigh = props.tHigh;
	}
	else 
	{
		props.hHigh = mixPropWithTP('H', 'T', tHigh, 'P', pHighIn, mixOut );
		console.log("calulated tHigh="+props.tHigh+", given tHigh:"+tHigh );
	}
	//var tInHubTip = props.tInHubTip = getHubTip('tInHubTip', mixPropWithTP('D','T', tHigh, 'P', pHighIn, mixOut), flowOut);
	var tOutHubTip; // = props.tOutHubTip = getHubTip('tOutHubTip', mixPropWithTP('D','T', tOut, 'P', pLowOut, mixOut), flowOut);
	props.hOut_tIn = mixPropWithTP( 'H', 'T', tIn, 'P', pLowIn, mixOut );
	// approximation, we assme the in and out gas mixes to have the same enthalpy in the same tIn (probably not true)
	props.heatOut = (props.hOut-props.hOut_tIn)*flowOut;
	props.tInHeatExchange = props.tOut;
	//props.kineticOut = tOutHubTip.kineticEnergyW;
	//props.cooling = grossPower - netPower - props.heatOut - props.kineticOut - otherLoss*grossPower;
	{
//console.log(tOut+" K: cooling"+grossPower+" - "+netPower+" - "+props.heatOut+" - "+props.kineticOut+" - "+(otherLoss*grossPower)+"="+props.cooling);
		// impossible, we have a wrong exit temperature value => fix it
		var cooling = 0;
//console.log("testResult( "+cooling+", "+(tOut/2)+", +"+tOut);
		testResult( 0, tOut, tOut/2, grossPower*0.002, function(t) {
			tOut = t;
			tOutHubTip = props.tOutHubTip = getHubTip('tOutHubTip', mixPropWithTP('D','T', t, 'P', pLowOut, mixOut), flowOut);
			props.kineticOut = tOutHubTip.kineticEnergyW;
			props.hOut = mixPropWithTP('H', 'T', t, 'P', pLowOut, mixOut);
			props.heatOut = (props.hOut-props.hOut_tIn)*flowOut + props.kineticOut;
			props.cooling = grossPower - netPower - props.heatOut - otherLoss*grossPower;
//console.log(t+" K: cooling: "+props.cooling+"="+grossPower+" - "+netPower+" - "+props.heatOut+" - "+props.kineticOut+" - "+(otherLoss*grossPower));
			return props.cooling;
		});
		console.log("Fixed tOut from "+props.tOut+" to "+tOut+" K");
		props.tOut = tOut;
		props.cooling = 0;
	}
	
	// We know the stage efficiency of best high end compressors to be 0.95, calclulate the adiabatic efficiency
	var compressorEfficiency = props.compressorEfficiency = doAdiabaticProcessWithS('Nitrogen',pLowIn, pHighOut, tIn, compressorStageEfficiency, null).efficiency;
	props.hCompressedAir100OWN = getMixH100WithS('T', tIn, 'P', pLowIn, pHighOut, airMixIn );
	props.sDryAirIn = Module.PropsSI('S', 'T', tIn, 'P', pLowIn, 'Air' );
	props.hCompressedAir100 = Module.PropsSI('H', 'S', props.sDryAirIn, 'P', pHighOut, 'Air' );	// ignore vaport content
	props.compressorWork = (props.hCompressedAir100OWN-props.hAirInOWN)*airFlowIn/compressorEfficiency;
	props.hCompressedAirOWN = (props.hCompressedAir100OWN-props.hAirInOWN)/compressorEfficiency + props.hAirInOWN;

	// Actual tHigh is 
	var hHighActual = props.hHighActual = props.hOut_tIn+(grossPower+props.compressorWork+props.naturalGasCompressionWork)/flowOut;
	var tHighActual = props.tHighActual = getMixTempAtHP( hHighActual, pHighIn, tHigh/2, tHigh, mixOut );

	var hOut100 = props.hOut100 = getMixH100WithS('T', tHighActual, 'P', pHighIn, pLowOut, mixOut );

	props.entalpyAt1650C = (props.hHigh - props.hOut)*flowOut;
	props.turbinEthalpyUsed = (hHighActual - props.hOut)*flowOut;
	props.turbinWorkProduced = netPower + grossPower*otherLoss + props.compressorWork + props.naturalGasCompressionWork;
	props.turbinEfficiency = props.turbinWorkProduced/props.turbinEthalpyUsed;
	props.turbinEfficiencyWithKineticLoss = props.turbinWorkProduced/(props.turbinEthalpyUsed+props.kineticOut);

	//props.sAirIn = Module.HAPropsSI('S', 'T', tIn, 'P', pLowIn, 'R',0.5 );
	//props.sDryAirIn = Module.PropsSI('S', 'T', tIn, 'P', pLowIn, 'Air' );
	//props.sAirVaporIn = Module.HAPropsSI('S', 'T', tIn, 'P', pLowIn, 'R', 0.5);
	//props.hAirIn = Module.PropsSI('H', 'T', tIn, 'P', pLowIn, 'Air' );
		//getMixH100WithS( 'T', tIn, 'P', pLowIn, pHighOut, airMixIn );
/*https://www.mhi.co.jp/technology/review/pdf/e503/e503001.pdf 
	props.compressorWork = props.turbinWorkProduced - netPower - otherLoss*grossPower - props.naturalGasCompressionWork;
console.log((props.compressorWork/1000000)+" = "+(props.turbinWorkProduced/1000000)+" - "+(netPower/1000000)+" - "+(otherLoss*grossPower/1000000)+" - "+(props.naturalGasCompressionWork/1000000));
	props.hCompressedAir = (props.compressorWork/airFlowIn) + props.hAirIn;
	props.tCompressedAir = Module.PropsSI('T', 'H', props.hCompressedAir, 'P', pHighOut, 'Air' );
	props.tCompressedAirOWN = getMixTempAtHP(props.hCompressedAir, pHighOut, 500, 1200, airMixIn );
	// null == props.tCompressedAir = Module.HAPropsSI('T', 'H', props.hCompressedAir, 'P', pHigh, 'W', vaporPercent );
	//props.tCompressedDryAir = Module.PropsSI('T', 'H', props.hCompressedAir, 'P', pHighOut, 'Air' );
*/
	//props.tCompressedAirOWN = getMixTempAtHP(props.hCompressedAirOWN, pHighOut, 500, 1200, airMixIn );
	//var cInHubTip = props.cInHubTip = getHubTip('cInHubTip',mixPropWithTP('D', 'T', props.tCompressedAirOWN, 'P', pLowIn, airMixIn), airFlowIn);
	//var cOutHubTip = props.cOutHubTip = getHubTip('cOutHubTip', mixPropWithTP('D','T', props.tCompressedAir, 'P', pHighOut, airMixIn), airFlowIn);

	//props.compressorEfficiency = (props.hCompressedAir100-props.hAirIn)/((props.hCompressedAir - props.hAirIn) - cOutHubTip.kineticEnergyW/airFlowIn);

	//props.mixOut = mixOut;
	console.log(JSON.stringify(props, null, 2 ));
}

function getHubTip(id,density,massFlow) {
	var hubTip = {};
	const val = document.getElementById(id).value;
	var slash = val.indexOf('/');
	hubTip.hub = parseFloat(val.substring(0,slash));
	hubTip.tip = parseFloat(val.substring(slash+1));
	hubTip.area = (hubTip.tip*hubTip.tip-hubTip.hub*hubTip.hub)*Math.PI;
	if (density && massFlow) {
		hubTip.volume = massFlow / density;
		hubTip.speed = hubTip.volume/hubTip.area;
		hubTip.kineticEnergyW = 0.5*massFlow*10*hubTip.speed*hubTip.speed;
	}
	return hubTip;
}
function fixSum(mix) {
	var sum = 0, moleSum = 0;
	for (i = 0; i < mix[0].length; i++) {
		sum += mix[1][i];
		moleSum += mix[2][i];
	}
	for (i = 0; i < mix[0].length; i++) {
		mix[1][i] = mix[1][i] / sum;		// by weight
		mix[3][i] = mix[1][i]*mix[2][i]/moleSum; // by volume
	}
	return sum;
}


function getMixName(mix ) {
	var s = '', error='';
	var i;
	var sum = fixSum(mix);
	if (sum != 1) error = " Scaled to sum="+sum;
	for (i = 0; i < mix[0].length; i++) {
		var fraction = ''+mix[1][i];
		if (fraction.length > 8) fraction = fraction.substring(0,8);
		else while (fraction.length<8) fraction = fraction + '0';
		s = s + (i > 0 ? '&' : '') + mix[0][i]+'['+fraction+']';
	}
//console.log(s+error);
	return s;
}

/**
	An extension of Dalton's law of additive pressures to include the statement that the internal energy, enthalpy, 
	and entropy of a mixture of gases are equal to the sum of the internal energies, enthalpies, and entropies the 
	individual constituents would have if each existed alone at the same temperature and volume. 
=> Use T and P to get D(|gas), use D(|gas) and T to get H, S  etc.
*/
function mixPropWithTP( outProp, tName, t, pName, p, mix ) {
	var i, outVal = 0;
	for (i = 0; i < mix[0].length; i++) {
		if (mix[0][i] == 'Water' && tName=='T' && t<380) {
			if (outProp == 'D') {
				var d = Module.PropsSI( 'D', 'T', tName=='T' ? t : p, 'Q', 1, 'Water' )/2;  // R=0.5
				outVal += d;
			}
			else if (outProp == 'H') {
				var x = Module.PropsSI( outProp+'|gas', tName, t, pName, p*mix[3][i], mix[0][i] )*mix[1][i];
				if (x == Infinity) {
					console.log("Module.PropsSI( "+outProp+'|gas'+", "+tName+", "+t+", "+pName+", "+p*mix[3][i]+", "+mix[0][i]+" )*"+mix[1][i]+"="+x);
					x = Module.PropsSI( outProp+'|gas', tName, t, pName, p*mix[3][i], mix[0][i] )*mix[1][i];
				}
				if (x == Infinity) {
					console.log( "Module.PropsSI("+outProp+", "+tName+", "+t+", "+pName+", "+p+", "+mix[0][i]+")="+x);
				}
				if (x < 2256471) {	// not yet vapor!
					// its liquid => vaporize it
					x += 2256471.5924066794;
				}
				if (x != Infinity) {
					outVal += x*mix[1][i];
				}
			}
		}
		else {
//console.log("Module.PropsSI( '"+outProp+"', '"+tName+"', "+t+", '"+pName+"', "+p+", '"+mix[0][i]+"' ) * "+mix[1][i]);
			if (outProp == 'H') {
				outVal += Module.PropsSI( outProp, tName, t, pName, p*mix[3][i], mix[0][i])* mix[1][i];
			}
			else {
				outVal += Module.PropsSI( outProp, tName, t, pName, p, mix[0][i])* mix[1][i];
			}
		}
	}
//console.log("outVal="+outVal);
	return outVal;
}

function getMixTempAtHP( h, p, tMin, tMax, mix ) {
	return testResult( h, tMin, tMax, h*0.01, function(t) {
		const h = mixPropWithTP('H', 'T', t, 'P', p, mix);
//console.log("h(t="+t+",p="+p+")="+h);
		return h;
	});
}

function getMixH100WithS( inProp1, inValLow1, inProp2, inValLow2, inValHigh2, mix ) {
	var i, outVal = 0;
	var all = '';
	for (i = 0; i < mix[0].length; i++) {
		const s = (mix[0][i] == 'Water' && inProp1=='T' && inValLow1<380) ? 
			Module.HAPropsSI( 'S', inProp1, inValLow1, inProp2, inValLow2, 'W', mix[1][i])
			: Module.PropsSI( 'S', inProp1, inValLow1*(inProp1 == 'P' ? mix[3][i]:1), inProp2, inValLow2*(inProp2 == 'P' ? mix[3][i]:1), mix[0][i] );
if (!s || s == Infinity) {
	console.log("Module.HAPropsSI('S'"+inProp1+", "+inValLow1+", "+inProp2+", "+inValLow2+", "+'W'+", "+mix[1][i]+"="+s);
}
else {
		outVal += Module.PropsSI( 'H', 'S', s, inProp2, inValHigh2*(inProp2 == 'P' ? mix[3][i]:1), mix[0][i])*mix[1][i];
/*		if (mix[0][i] == 'Water') {
			console.log("Water h(s="+s+", "+inProp2+"="+inValLow2+")="+Module.PropsSI( 'H', 'S', s, inProp2, inValLow2, mix[0][i])+"=>"+
					Module.PropsSI( 'H', 'S', s, inProp2, inValHigh2, mix[0][i]));
		}*/
}
//		all += mix[0][i]+"*"+mix[1][i]+'_';
	}
//console.log("Module.PropsSI( '"+inProp1+"', "+inValLow1+", '"+inProp2+"', "+inValLow2+", '"+inValHigh2+"', '"+all+"')="+outVal);
	return outVal;
}

	// See http://www.coolprop.org/coolprop/HighLevelAPI.html
	const FIRST_ITEM = true;
	const LAST_ITEM = false;
	var LOST_AS_HEAT = 0.05;

	const isCylinder = false; // getBooleanParam( 'shapeCylinder', true );
	const isCone = true; // getBooleanParam( 'shapeCylinder', true );

	//var extraCompressionHeat = 0.09;
	var name="Nitrogen";
	var generatorLocation = 'GROUND';		// TOP, GROUND, MIDDLE, BOTTOM
	var coldExpanderLocation = 'SAME';	// or BOTTOM
	var chargeLevel = 0.5; // 0 - 1
	var pLowParam = null;
	var dischargeMassFlowValue = null;
	
	//var turbinStages;
	//var compressorStages;
	//var zoomedTurbinStages;
	//var cZoomedTurbinStages = 2;
	//var maxSteamWetness = 0;
	//var impulseTurbineefficiency = 0.90;
	var pTransformer = {};

	//drawOnlyStorage();

	function setGasMassFlowFor1200MW(select) {
console.log("setGasMassFlowFor1200MW");
		const gas = $(select).val();
		var massFlow = 1645;
		//$("#tHigh").val('1173');		// default mass flow
		//$("#cStressMaxMPa").val('456');	// default Nimonic 105 3000h 0.2 proof tensile strength when cooled to 923 K
		//$("#tempStressMaxMPa").val("923");
		if (gas == 'Nitrogen') {
			massFlow = 1845;
			$("#tHigh").val('1173');
			$("#cEfficiency").val("0.943");
			$("#tEfficiency").val("0.966");
			$("#cLowEfficiency").val("0.954");
			$("#tLowEfficiency").val("0.972");
			$("#tHigh").val('1173');
			$("#hotLoadCoefficient").val('0.29');
			$("#hotFlowCoefficient").val('0.60');
			$("#cHotUnits2").val('4');
			$("#cStagesHot").val('14');
			$("#solidityHot").val('1.5');
			$("#divOptARCold").val('1.02');
			$("#firstToLastDeltaH_Hot").val('1.03');
			$("#hotRpm3000").prop('checked', true);
			$("#divOptARHot").val('1.03');

			$("#coldLoadCoefficient").val('0.194');
			$("#coldFlowCoefficient").val('0.483');
			$("#cColdUnits2").val('8');
			$("#cStagesCold").val('16');
			$("#solidityCold").val('1.3');
			$("#divOptARCold").val('1');
			$("#firstToLastDeltaH_Cold").val('1.02');
			$("#coldRpm3000").prop('checked', true);
		}
		else if (gas == 'Argon') {		
			massFlow = 3509;
			$("#numberOfUnits").val("3");
			$("#cEfficiency").val("0.970");
			$("#tLowEfficiency").val("0.968");
			$("#tEfficiency").val("0.973");
			$("#cLowEfficiency").val("0.97");
			$("#tHigh").val('1173');
			// 0.977, 0.978
			$("#cHeatPumpEfficiency").val("0.977");
			$("#tHeatPumpEfficiency").val("0.978");

			$("#hotLoadCoefficient").val('0.41');
			$("#hotFlowCoefficient").val('0.775');
			$("#cHotUnits2").val('3');
			$("#cStagesHot").val('19');
			$("#solidityHot").val('2');
			$("#firstToLastDeltaH_Hot").val('1.');
			$("#hotRpm1500").prop('checked', true);

			$("#hotTurbinLoadCoefficient").val('0.30');
			$("#hotTurbinFlowCoefficient").val('0.50');
			$("#cHotTurbinUnits2").val('3');
			$("#cStagesHotTurbin").val('17');
			$("#divOptARHotTurbin").val('1.0');
			$("#solidityHotTurbin").val('1');
			$("#hotTurbinRpm1500").prop('checked', true);

			$("#coldLoadCoefficient").val('0.315');
			$("#coldFlowCoefficient").val('0.65');
			$("#cColdUnits2").val('3');
			$("#cStagesCold").val('13');
			$("#solidityCold").val('2');
			//$("#divOptARCold").val('1.06');
			$("#firstToLastDeltaH_Cold").val('1');
			$("#coldRpm1500").prop('checked', true);
			//$("#topFillUsedAsStorage").prop("checked", true );

			$("#coldTurbinLoadCoefficient").val('0.32');
			$("#coldTurbinFlowCoefficient").val('0.48');
			$("#cColdTurbinUnits2").val('3');
			$("#cStagesColdTurbin").val('12');
			$("#solidityColdTurbin").val('1');
			$("#firstToLastDeltaH_ColdTurbin").val('1');
			$("#coldTurbinRpm1500").prop('checked', true);


			$("#hpLoadCoefficient").val('0.33');
			$("#hpFlowCoefficient").val('0.63');
			$("#cHpUnits2").val('9');
			$("#cHpUnits2Turbin").val('3');
			$("#cStagesHp").val('9');
			$("#solidityHp").val('1.6');

			$("#hpTurbinLoadCoefficient").val('0.23');
			$("#hpTurbinFlowCoefficient").val('0.67');
			$("#cHpUnits2Turbin").val('3');
			$("#cStagesHpTurbin").val('14');
			$("#solidityHpTurbin").val('1.05');
			/*
			$("#hpLoadCoefficient").val('0.50');
			$("#hpFlowCoefficient").val('0.95');
			$("#cHpUnits2").val('3');
			$("#cHpUnits2Turbin").val('3');
			$("#cStagesHp").val('9');
			$("#solidityHp").val('1.6');

			$("#hpTurbinLoadCoefficient").val('0.35');
			$("#hpTurbinFlowCoefficient").val('0.65');
			$("#cStagesHpTurbin").val('13');
			$("#solidityHpTurbin").val('1');
*/
		}
		else if (gas == 'Hydrogen') {
			massFlow = 200;
			if (parseInt($("#tHigh").val()) > 700) {
				//$("#tempStressMaxMPa").val("700"); // ~max temp for maraging 2400 steel
				$("#tHigh").val('700');
				//$("#cStressMaxMPa").val('1800');
			}
			$("#cHotUnits2").val('4');
			$("#cStagesHot").val('29');
			$("#hotLoadCoefficient").val('0.56');
			$("#hotFlowCoefficient").val('0.90');
			$("#hotRpm3000").prop('checked', true);
			$("#divOptARHot").val('1.5');

			$("#coldLoadCoefficient").val('0.5');
			$("#coldFlowCoefficient").val('0.8');
			$("#firstToLastDeltaH_Cold").val('1.02');
			$("#cColdUnits2").val('4');
			$("#cStagesCold").val('29');
			$("#coldRpm3000").prop('checked', true);
		}
		else if (gas == 'Helium') {
			massFlow = 250;
			$("#tHigh").val('1173');
			$("#cHotUnits2").val('4');
			$("#cStagesHot").val('29');
			$("#hotLoadCoefficient").val('0.50');
			$("#hotFlowCoefficient").val('0.90');
			$("#hotRpm3000").prop('checked', true);
			$("#divOptARHot").val('2');

			$("#coldLoadCoefficient").val('0.35');
			$("#coldFlowCoefficient").val('0.7');
			$("#firstToLastDeltaH_Cold").val('0.95');
			$("#cColdUnits2").val('4');
			$("#cStagesCold").val('30');
			$("#coldRpm3000").prop('checked', true);
		}
		else if (gas == 'Methane') {
			if (parseInt($("#tHigh").val()) > 623) {
				$("#tHigh").val('623');
				//$("#cStressMaxMPa").val('1800');
			}
			$("#hotLoadCoefficient").val('0.28');
			$("#hotFlowCoefficient").val('0.62');
			$("#cHotUnits2").val('4');
			$("#cStagesHot").val('14');
			$("#hotRpm3000").prop('checked', true);
			$("#divOptARHot").val('1.03');

			$("#coldLoadCoefficient").val('0.24');
			$("#coldFlowCoefficient").val('0.56');
			$("#firstToLastDeltaH_Cold").val('1.04');
			$("#cColdUnits2").val('8');
			$("#cStagesCold").val('16');
			$("#coldRpm3000").prop('checked', true);
			massFlow = 2152;
		}
		//$("#liquidCoolStorages").css("display", gas == 'Argon' ? 'block' : 'none');
		//$("#flowCoefficient").val(gas == 'Helium' ? 0.65 : 0.5); 
		//$("#stageLoadingCoefficient").val(gas == 'Helium' ? 0.8 : 0.25);
		$("#highToLowPressureRatio").val(gas == 'Argon' || gas == 'Helium' ? 11 : 20 );	// tLowHP=0 C => water cooling possible
		$("#targetPLow").val(gas == 'Argon'  || gas == 'Helium' ? 102 : 96 );
		$('#dischargeMassFlow').val(massFlow);
		metricsChanged();
	}
	var porositySet = false;
	function calcPressureDropInGravel(type, speed, visc, density, length, p, t ) {
		var porosity = 0;
		var gravelDensity;
		// topFillWithIceWithStorage system lp gravel used just for weigh => set min partice size 1 mm
		const min = type == 'Lp' && metrics.topFillWithIceWithStorage ? 1 : getFloatParam( "gravelMin"+type, 0 );
		const max = getFloatParam( "gravelMax"+type, 0 );
		if (metrics) metrics["gravelMin"+type] = min;
		if (metrics) metrics["gravelMax"+type] = max;
		const minPorosity = (2.65-2.2)/2.65;
		const maxPorosity = 0.55;
		porosity = getFloatParam( "gravelPorosity"+type, 0 );
		if (porosity>0) {
			if (porosity>maxPorosity || porosity < minPorosity) {
				alert("Porosity must be in typical range for compacted gravel:"+minPorosity+"-"+maxPorosity);
				porosity = 0;
			}
			porositySet = false;
		}
		if (porosity == 0) {
			gravelDensity = 1.5 + (2.1-1.5)*(1-min/max);
			porosity = (2.65-gravelDensity)/2.65;
		}
		else {
			gravelDensity = 2.65*(1 - porosity);
		}
		if (metrics){
			if (type == 'Hp') {
				metrics.gravelDensity = gravelDensity;
				metrics.hpGravelPorosity = porosity;
			}
			else if (type == 'Lp') {
				metrics.lpGravelDensity = gravelDensity;
				metrics.lpGravelPorosity = porosity;
			}
		}
		// sort: 6/12, n=0.51 => (9.7±6.3)·10-8 m2
		// sort: 20/40, n=0.40 => (9±6)·10-8 m2
		// y=x*visc/k + x^2*c*visc/k = (1638±289)x²+(200±124)x   => 200 = 0.000018/0.00000009, c ~= 8.2
		// sort 6/12: y=(2976±366)x²+(185±120)x => 187 = 0.000018/0.000000097, c = 2976/185 ~= 16.1
		// Calclulated for 6/12, n=0.51: y=2141*x²+715*x, turbulent part quite near, but Laminar part 4*actual!
		// => Calcluates too high pressure drops for small particle sizes and low speed
		// deltaP/L = x*a + x^2*b
		var a = 200;	// laminar flow part
		var b = 1630;	// turbulent flow part
if (min==0) min=0.0001; // 0.1mm
//console.log("min="+min+", max="+max+", porosity="+porosity+", gravelDensity="+gravelDensity);
		// When v=inlet speed in free space (m/2), L=distance (m), Dp=smallest particle diameter (m), n=porosity, density=fluid density kg/m3
		// wiki Ergun_equation:  deltaP=v*(150*visc*L/Dp^2)*(1-n)^2/n^3+v^2*(1.75*L*density/Dp)*(1-n)/n^3
		// Darcy-Forchheimer
		// Darcy–Forchheimer equation is best for gravels, but its values k and c must be measured for each case.
		// So we use Ergun equation extension for turbulent flows to scale the known values 
		// https://www.researchgate.net/publication/322140487_Behaviour_study_of_airflow_through_gravels_based_on_laboratory_experimentation_and_contrast_with_FEM_models
		// gravel sort: 20/40, n=0.40:  (1638±289)x²+(200±124)x
		// Test: 
		const dE = 0.03; // (0.02+0.04) / 2
		const dEfective = (min + max)/2000;	// https://publications.vtt.fi/julkaisut/muut/2013/VTT-R-00257-13.pdf: 0.25-10mm => efective particle size: 0.65mmm
		a = a *(Math.pow(dE,2)/Math.pow(dEfective,2))*(Math.pow(0.4,3)/Math.pow(porosity,3))*(Math.pow(1-porosity,2)/Math.pow(1-0.4,2));
		b = b *(dE/dEfective)*(Math.pow(0.4,3)/Math.pow(porosity,3))*((1-porosity)/(1-0.4));
		if (visc) {
			a = a*visc/0.000018;
			b = b*visc/0.000018;
		}
		if (density) {
			b = b*density/1.8;// air density 1.8 kg/m3
		}
		if (typeof speed === 'undefined') {
			$("#expectedPDrop"+type).text("Pressure drop (Pa)="+Math.round(b)+"*velocity²+"+Math.round(a)+"*velocity, (porosity of compacted crushed stone: "+myRound(porosity,2)+")");
		}
		else if (speed) {
			var ret = speed*a + speed*speed*b;	// pressure drop/L: Pa/m
			if (length) ret = ret * length;
			return ret;
/*
//console.log(type+" pressure drop="+ret+", (v:"+speed+",visc:"+visc+",d:"+density+",L:"+length+")=>a:"+a+", b:"+b+", effective diameter:"+dEfective);
			// All preceeding formulas assumes ambient temperature (~300 K).  Pressure drop transform enhalpy to kinetic energy that keeps the gas flowing. 
			// What is the enthaply needed to keep the flow at contant speed at 300 K?
			const s300K = Module.PropsSI('S', 'P', p, 'T', 300, name); 
			const hDrop = Module.PropsSI('H', 'P', p, 'T', 300, name) - Module.PropsSI('H', 'P', p-ret, 'S', s300K, name);
			// The same enthalpy is needed also in the catual temperature
			const s = Module.PropsSI('S', 'P', p, 'T', t, name); 
			const h = Module.PropsSI('H', 'P', p, 'T', t, name); 
			const p2 = Module.PropsSI('P', 'H', h-hDrop, 'S', s, name); 
console.log(Math.round(t)+": pressure drop at ambient temp:"+ret+", actual pressure drop: "+(p-p2));
			return Number.isFinite(p2) ? p-p2 : ret;
*/
		}
	}
	
	// Steam saturation is not an adibatic process.  Instead the wetness and released enthalpy is calculated using constant entropy.
	// It probably needs much higher pressure drop than abiabatic expansion with high cp/cv
	// https://www.e3s-conferences.org/articles/e3sconf/pdf/2021/28/e3sconf_pgsge2021_03055.pdf
	function logSatValues( pStart, name )
	{
		var hV = Module.PropsSI('H','P',pStart,'Q',1,name); 
		var hL = Module.PropsSI('H','P',pStart,'Q',0,name); 
		var sV = Module.PropsSI('S','P',pStart,'Q',1,name); 
		var sL = Module.PropsSI('S','P',pStart,'Q',0,name); 
		var cp = Module.PropsSI('C','P',pStart,'Q',1,name); 
		var cv = Module.PropsSI('CVMASS','P',pStart,'Q',1,name); 
		var cpL = Module.PropsSI('C','P',pStart,'Q',0,name); 
		var cvL = Module.PropsSI('CVMASS','P',pStart,'Q',0,name); 
		var t = Module.PropsSI('T','P',pStart,'Q',1,name); 
		console.log(name+" staturation values in "+pStart+" Pa: t="+t+" K, hSat="+((hV-hL)/1000)+", cpV/cvV="+(cp/cv)+", cpL/cvL="+(cpL/cvL)+", sV="+sV+", sL="+sL
			+", valuesOf("+(t+0.001)+")="+JSON.stringify(getValuesMin(name,t+0.001,pStart)));
	}

	function printRow( isTurbin, v, vSum ) 
	{
	 	if (typeof v === 'undefined') {
			return '<tr><th title="Turbin Inlet/Outlet temperature">T(in-out) K</th><th title="Inlet/Outlet pressure">P(in-out) kPa</th>'+
			(isTurbin ? '<th title="Work done by generator">Work done kJ/kg</th><th title="Reheating of fluid by PCHE before next stage">Reheating kJ/kg</th><th title="Inlet pressure devided by outlet pressure">Pin/POut</th>'+
			'<th title="1 - (Compressor work)/(Turbin work) in this pressure range">Stage efficiency</th>' : '<th>Work consumed kJ/kg</th><th>Cooling kJ/kg</th><th>POut/Pin</th>')+
			'<th title="Inlet-outlet density of fluid ">D(in-out) kg/m3</th><th>Speed of sound (in-out) m/s</th>'+
			'<th>Entropy In - Out J/g/K</th><th  title="Min/max specific heat ratio">cp/cv (min-max)</th><th title="Specific heat in constant presure in temp range">cp ave kJ/K</th>'+
			'<th  title="Viscosity">Visc(in-out) μPa/s</th><th>Conductivity(out) mW/m-K</th></tr>';
		}
		else {
			if (vSum) {
				if (v.workProduced) vSum.workProduced = (vSum.workProduced ? vSum.workProduced : 0) + v.workProduced;
				if (v.workConsumed) vSum.workConsumed = (vSum.workConsumed ? vSum.workConsumed : 0) + v.workConsumed;
				if (v.heating) vSum.heating = (vSum.heating ? vSum.heating : 0) + v.heating;
				if (v.cooling) vSum.cooling = (vSum.cooling ? vSum.cooling : 0) + v.cooling;
/*
				if (typeof v.items === 'undefined') {
					console.trace("Step data missing:"+JSON.stringify(v));
					return '';
				}
*/
			}
			return "<tr>"+printCell( 3, v.tIn, v.tOut )+printCell( 1, v.pIn/1000, v.pOut/1000 )+
				(isTurbin ? printCell( 1, v.workProduced/1000)+printCell( 1, v.heating/1000)+printCell( 3, v.pIn/v.pOut)+printCell(2, v.stageEfficiency)
					: printCell( 1, v.workConsumed/1000)+printCell( 1, v.cooling/1000)+printCell( 3, v.pOut/v.pIn))+
				printCell( 1, v.dIn, v.dOut )+printCell( 1, v.sosIn, v.sosOut )+printCell( 3, v.sIn/1000, v.sOut/1000)+
				γRange( v.items ) + cpAve( v.items ) + printCell( 1, v.vIn*1000000, v.vOut*1000000)+printCell( 1, v.tcOut*1000)+"</tr>";
		}
	}
	function getInputParam( id, defValue ) {
		var ret = $('#'+id).val();
//console.log("$('#"+id+"').val()="+ret+", default="+defValue+"=> ret="+(ret ? ret : defValue));
		return ret ? ret : defValue;
	}

	function getFloatParam( id, defValue ) {
		var ret = $('#'+id).val();
//console.log("$('#"+id+"').val()="+ret+", default="+defValue+"=> ret="+(ret ? ret : defValue));
		return ret ? parseFloat(ret) : defValue;
	}
	function getIntParam( id, defValue ) {
		var ret = $('#'+id).val();
		return ret ? parseInt(ret) : defValue;
	}

	function getBooleanParam( id, defValue ) {
		if (document.getElementById(id)) {
			return $('#'+id).prop('checked');
		}
		else {
			return defValue;
		}
	}



	function printCell( roundTo, f1, f2 )
	{
		if (Number.isNaN(f1)) return '<td></td>';
		if (typeof f2 == 'undefined') {
			return '<td>'+myRound( f1, roundTo )+'</td>';
		}
		else if (f2 == 'bold') {
			'<td><span style="font-weight: bold;">'+myRound( f1, roundTo )+'</span></td>';
		}
		else {
			return '<td>'+myRound( f1, roundTo )+' - '+myRound( f2, roundTo )+'</td>';
		}
	}
	
	// 
	//	Use equal internal energies S to get enthalpy of 100% efficience, recalc S with the actual enthalpy
	//
	function doAdiabaticProcessWithS( name, pFrom, pTo, tFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		var hFrom = Module.PropsSI('H', 'P', pFrom, 'T', tFrom, name);
//console.log(name+": t="+tFrom+", p="+pFrom+" => h="+hFrom);
		return doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone );
	}

	// P1 and P2 have the same enthalpy and P1 is wet, but P2 may or may not be wet
	function getWetnessOfP2( name, P1, P2, wetnessOfP1 )
	{
		const hLiqC = Module.PropsSI('H', 'P', P1, 'Q', 0, name);
		const hGasC = Module.PropsSI('H', 'P', P1, 'Q', 1, name);
		const hLiqE = Module.PropsSI('H', 'P', P2, 'Q', 0, name);
		const hGasE = Module.PropsSI('H', 'P', P2, 'Q', 1, name);
		const h = hGasC*(1-wetnessOfP1) + hLiqC*wetnessOfP1;
				
		// h = hGasE*(1-wetnessE) + hLiqE*wetnessE  = hGasE + (hLiqE-hGasE)*wetnessE
		// => wetnessE = (h-hGasE) / (hGasE-hLiqE)
		const wetnessOfP2 = (h - hGasC) / (hGasE-hLiqE);		// wetnessE
console.log("P1="+P1+", P2="+P2+", wetnessOfP1="+wetnessOfP1+", h="+h+", wetnessOfP2="+wetnessOfP2);
		return wetnessOfP2<0 ? 0 : wetnessOfP2;
	}

	// The max wetness of turbin/compressor (15%) seems to create more problems than it solves
	function doWetAdiabaticProcessWithS( name, pFrom, pTo, wetness, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		const hLiq = Module.PropsSI('H', 'P', pFrom, 'Q', 0, name);
		const hGas = Module.PropsSI('H', 'P', pFrom, 'Q', 1, name);
//console.log(name+": hLiq="+hLiq+", hGas="+hGas+", wetness="+wetness);
		var hFrom = hGas - (hGas-hLiq)*wetness;
		var stage = doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone );
		stage.massFlow = 1/(1-wetness);
		//if (stage.workConsumed) stage.workConsumed *= stage.massFlow;		// always stage.massFlow==1
		//if (stage.workProduced)  stage.workProduced *= stage.massFlow;		// always stage.massFlow==1
		return stage;
	}

	function doAdiabaticProcess( name, pFrom, pTo, hFrom, efficiency, dbgTitle, tMax, tMin, pfAreWeDone )
	{
		var curP = pFrom;
		const pRel = pFrom > pTo ? pFrom/pTo : pTo/pFrom;
		const steps = pRel > 2 ? 15 : 8;		// approximate number of stages in the default design
		var pStep = Math.pow( pFrom > pTo ? 1/pRel : pRel, 1/steps);
		//var pStep = pFrom > pTo ? 0.96 : 1.04;
		var isCompression = pFrom < pTo; 
		const sFrom = Module.PropsSI('S', 'P', pFrom, 'H', hFrom, name);
		var tFrom = Module.PropsSI('T', 'P', pFrom, 'H', hFrom, name);
		var sCur = sFrom;
		var hPrev = hFrom;
		var curT = tFrom;
		var items = [];
		var hCooled = 0;
//if (tMin) console.log("tMin="+tMin);
		var v = {};
		v.p = pFrom;
		v.t = tFrom;
		v.s = sCur;
		v.h = hPrev;
//console.log("doAdiabaticProcessWithS "+pFrom+"=>"+pTo+", vIn="+JSON.stringify(v)+"; efficiency="+efficiency);
		items.push(v);
		var loops = 1;
		var exitNow = false;
		
		while (!exitNow) 
		{
			curP = curP * pStep;
			if (isCompression && curP >= pTo) {
				curP = pTo;	
				exitNow = true;
			}
			else if (!isCompression && curP <= pTo) {
				curP = pTo;
				exitNow = true;
			}
			v = {};
			var hCur = Module.PropsSI('H', 'P', curP, 'S', sCur, name);

			if (tMax)
			{
				const tIdeal = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
				if (tIdeal >= tMax) {
					exitNow = true;
					hCur = Module.PropsSI('H', 'T', tMax, 'S', sCur, name);
					curP = Module.PropsSI('P', 'T', tMax, 'S', sCur, name);
				}
			}
			if (tMin) {
				const tIdeal = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
				if (tIdeal <= tMin) {
//console.log(tIdeal+" <= "+tMin);
					exitNow = true;
					//v.tIdeal = tMin;
					var testH = Module.PropsSI('H', 'T', tMin, 'S', sCur, name);
					if (testH != 'Infinity') {
						hCur = testH;
						curP = Module.PropsSI('P', 'T', tMin, 'S', sCur, name);
					}
				}
			}
			//v.hIdeal = hCur;
			if (hCur) {
				if (isCompression) {
					hCur = (hCur-hPrev)*(1-efficiency) + hCur;
				}
				else {
					hCur = (hPrev-hCur)*(1-efficiency) + hCur;
				}
			}
			curT = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
			hPrev = hCur;
			sCur = Module.PropsSI('S', 'P', curP, 'H', hCur, name);  // adjusted by efficiency
			v.p = curP;
			v.t = curT;
			v.s = sCur;
			v.h = hCur;
			if (v.p && v.t && v.s && v.h) {
				items.push(v);
			}
			else {
				console.log(name+":Unexpected values: v="+JSON.stringify(v)+", items:"+JSON.stringify(items));
				console.trace(dbgTitle+": pFrom="+pFrom+", pTo="+pTo+", hFrom="+hFrom+", efficiency="+efficiency);
				//console.log("all items: "+JSON.stringify(items));
				break;
			}
			if (typeof pfAreWeDone === 'function') {
				if (pfAreWeDone( v, items )) {
					exitNow = true;
				}
			}
			if (items.length > 1000) {
				//console.log("Too many steps, v="+JSON.stringify(v));
				break;
			}
		}
		return newCycleDataI( name, items, efficiency, 1, hCooled, dbgTitle );
	}
	var tSatAir = 0;
	function doAdiabaticProcessWithLiquidAirCooling( name, pFrom, pTo, efficiency, massFlow, dbgTitle, tSat, pRatio, pfAreWeDone )
	{
		if (!tSat) {
			tSatAir = tSat = Module.PropsSI('T', 'P', 101325, 'Q', 0, 'Air');
		}
		var curP = pFrom;
		var pStep = pFrom > pTo ? 1/pRatio : pRatio;
		pRatio = pStep;
		var steps = -1;
		// calc nearest stage number to pRatio
		for ( steps = 1; steps < 50; steps++) {
			// steps = Math.log(pTo/pFrom) / Math.log(pStep);
			// => Math.log(pStep) = Math.log(pTo/pFrom) / steps
			// => pStep = Math.pow( e, Math.log(pTo/pFrom) / steps);
			pStep = Math.pow(Math.E, Math.log(pTo/pFrom) / steps);
//console.log(dbgTitle+", stages:"+steps+", pTo="+pTo+"pStep="+pStep+"=>pTo2="+pFrom*Math.pow(pStep, steps));
			if ((pRatio > 1 && pStep < pRatio) || (pRatio < 1 && pStep > pRatio)) {
console.log(dbgTitle+", *****pRatio: "+pRatio+"->"+pStep+", stages:"+steps+", pTo="+pTo+"=="+pFrom*Math.pow(pStep, steps));
				break;
			}
		}
		var isCompression = pFrom < pTo; 
		tSat += isCompression ? 0.5 : -0.5; // min heat exchange difference
		const hFrom = Module.PropsSI('H', 'P', pFrom, 'T', tSat, name);
		const sFrom = Module.PropsSI('S', 'P', pFrom, 'H', hFrom, name);
		var tFrom = Module.PropsSI('T', 'P', pFrom, 'H', hFrom, name);
		var sCur = sFrom;
		var hPrev = hFrom;
		var curT = tFrom;
		var items = [];
		var hCooled = 0;
//if (tMin) console.log("tMin="+tMin);
		var v = {};
		v.p = pFrom;
		v.t = tFrom;
		v.s = sCur;
		v.h = hPrev;
console.log("doAdiabaticProcessWithS "+pFrom+"=>"+pTo+", vIn="+JSON.stringify(v)+"; efficiency="+efficiency);
		items.push(v);
		var loops = 1;
		var exitNow = false;
		
		for (i = 0; i < steps; i++)
		{
			curP = curP * pStep;
			v = {};
			var hCur = Module.PropsSI('H', 'P', curP, 'S', sCur, name);

			//v.hIdeal = hCur;
			if (hCur) {
				if (isCompression) {
					hCur = (hCur-hPrev)*(1-efficiency) + hCur;
				}
				else {
					hCur = (hPrev-hCur)*(1-efficiency) + hCur;
				}
			}
			curT = Module.PropsSI('T', 'P', curP, 'H', hCur, name);
			hPrev = hCur;
			sCur = Module.PropsSI('S', 'P', curP, 'H', hCur, name);  // adjusted by efficiency
			v.p = curP;
			v.t = curT;
			v.s = sCur;
			v.h = hCur;
			if (v.p && v.t && v.s && v.h) {
				items.push(v);
			}
			else {
				console.log(name+":Unexpected values: v="+JSON.stringify(v)+", items:"+JSON.stringify(items));
				console.trace(dbgTitle+": pFrom="+pFrom+", pTo="+pTo+", hFrom="+hFrom+", efficiency="+efficiency);
				//console.log("all items: "+JSON.stringify(items));
				break;
			}
//console.log(dbgTitle+": i="+i+", v="+JSON.stringify(v));
			v = {};
			curT = tSat;
			const hTmp = Module.PropsSI('H', 'P', curP, 'T', curT, name);
			hCooled += hCur - hTmp;
			hCur = hTmp;
			sCur = Module.PropsSI('S', 'P', curP, 'H', hCur, name);  // adjusted by efficiency
			v.p = curP;
			v.t = curT;
			v.s = sCur;
			v.h = hCur;
			if (v.p && v.t && v.s && v.h) {
				items.push(v);
			}
			else {
				console.log(name+":Unexpected values: v="+JSON.stringify(v)+", items:"+JSON.stringify(items));
				console.trace(dbgTitle+": pFrom="+pFrom+", pTo="+pTo+", hFrom="+hFrom+", efficiency="+efficiency);
				//console.log("all items: "+JSON.stringify(items));
				break;
			}
			if (items.length > 1000) {
				//console.log("Too many steps, v="+JSON.stringify(v));
				break;
			}
		}
		cycleData = newCycleDataI( name, items, efficiency, massFlow, hCooled, dbgTitle );
		cycleData.efficiency = efficiency;
		return cycleData;
	}

	function newCycleData( name, stage, massFlow )
	{
		return newCycleDataI( name, stage.items, stage.stageEfficiency, massFlow, stage.hCooled, stage.dbgTitle );
	}
	var baseMachinerySizeIndex = 7000;	// used to scale the cost of calculated turbins and compressors to 1/25 bar, stage efficiency 0.92

	function addCycleDataI( hpFluid, stage1, stage2, dbgTitle )
	{
		var stage = Object.assign({}, stage1);
		stage.pOut = stage2.pOut;
		stage.tOut = stage2.tOut;
		stage.hOut = stage2.hOut;
		stage.sOut = stage2.sOut;
		stage.dOut = stage2.dOut;
		stage.flowOut = stage2.flowOut;
		stage.viscOut = stage2.viscOut;
//console.log(dbgTitle+": items1: "+JSON.stringify(stage1.items)); 
//console.log(dbgTitle+": items2: "+JSON.stringify(stage2.items)); 
		stage.workConsumed	= stage1.workConsumed + stage2.workConsumed;
		stage.efficiency = (stage1.workConsumed*stage1.efficiency + stage2.workConsumed*stage2.efficiency) / stage.workConsumed;
//console.log("merged stage="+JSON.stringify(stage));
//if (stage.efficiency > 2) throw new Error("Bad efficiency="+stage.efficiency);
		const items = stage.items;
		if (dbgTitle) {
			stage.items = null;
			console.log(dbgTitle+": "+JSON.stringify(stage)); //+", last="+JSON.stringify(last));
		}
		stage.items = items.concat(stage2.items);
		return stage;
	}

	function newCycleDataI( name, items, stageEfficiency, massFlow, hCooled, dbgTitle )
	{
		var stage = {};
		if (dbgTitle) stage.dbgTitle = dbgTitle;
		const last = items[items.length-1];
		const first = items[0];
		const pFrom = first.p;
		const pTo = last.p;
		last.d = Module.PropsSI('D', 'P', last.p, 'H', last.h, name);
		first.d = Module.PropsSI('D', 'P', first.p, 'H', first.h, name);
		stage.stageEfficiency = stageEfficiency;
		stage.pIn = stageEfficiency > 1 ? last.p : first.p;
		stage.pOut = stageEfficiency > 1 ? first.p : last.p;
		stage.tIn = stageEfficiency > 1 ? last.t : first.t;
		stage.tOut = stageEfficiency > 1 ? first.t : last.t;
		stage.hIn = stageEfficiency > 1 ? last.h : first.h;
		stage.hOut = stageEfficiency > 1 ? first.h : last.h;
		stage.hCooled = hCooled;
		stage.sIn = stageEfficiency > 1 ? last.s : first.s;
		stage.sOut = stageEfficiency > 1 ? first.s : last.s;
		stage.isForward = (stageEfficiency <= 0 && pFrom > pTo) || (stageEfficiency > 0 && pFrom < pTo);
		stage.massFlow = massFlow;		// 1 == 1000 kg
		const idealWork = Math.abs(Module.PropsSI('H', 'P', stage.pOut, 'S', stage.sIn, name) - stage.hIn) + stage.hCooled;
		if (stage.hOut > stage.hIn) {
			stage.workConsumed = ((stage.hOut+stage.hCooled) - stage.hIn);
			stage.efficiency = idealWork / stage.workConsumed; 
		}
		else {
			stage.workProduced = (stage.hIn - stage.hOut - stage.hCooled);
			stage.efficiency = stage.workProduced / (idealWork);
		}
		stage.dIn = Module.PropsSI('D', 'P', stage.pIn, 'H', stage.hIn, name); 
		stage.dOut = Module.PropsSI('D', 'P', stage.pOut, 'H', stage.hOut, name);
		stage.flowIn = 1000 / stage.dIn ;
		stage.flowOut = 1000 / stage.dOut;
		stage.viscIn = Module.PropsSI('V', 'P', stage.pIn, 'H', stage.hIn, name); 
		stage.viscOut = Module.PropsSI('V', 'P', stage.pOut, 'H', stage.hOut, name);
		if (dbgTitle) {
			//console.log(dbgTitle+": "+JSON.stringify(stage)); //+", last="+JSON.stringify(last));
		}
//if (tMin) console.log(JSON.stringify(last));
		stage.items = items;
		stage.getRelativeSize = function() {
			return 1;
		}
		return stage;
	}
	function getStageStep(stageEfficiency) {
		if (stageEfficiency >= 0.94) return 1.04;
		if (stageEfficiency >= 0.93) return 1.045;
		if (stageEfficiency >= 0.92) return 1.05;
		if (stageEfficiency >= 0.915) return 1.06;
		if (stageEfficiency >= 0.91) return 1.07;
		if (stageEfficiency >= 0.905) return 1.08;
		if (stageEfficiency >= 0.90) return 1.09;
		if (stageEfficiency >= 0.89) return 1.10;
		if (stageEfficiency >= 0.88) return 1.12;
		return 1.13;
	}

	function myRoundAsExponent( num, c ) {
		var exp = 0;
		while (num > 10) {
			num = num / 10;
			exp++;
		}
		return myRound(num, c)+' EXP'+(exp < 10 ? '0'+exp : ''+exp);
	}
	
	function myRound( num, c) {
		if (typeof num === 'undefined') return '';
		if (!num) return num;
		var ret = '';
		if (typeof c === 'undefined') {
			if (num < 1) c = 3;
			else if (num < 10) c = 2;
			else if (num < 100) c = 1;
			else c = 0;
		}
		if (c == 0) return Math.round(num)+'';
		else if (c == 1) ret += Math.round( ( num + Number.EPSILON ) * 10 ) / 10;
		else if (c == 2) ret += Math.round( ( num + Number.EPSILON ) * 100 ) / 100;
		else if (c == 3) ret += Math.round( ( num + Number.EPSILON ) * 1000 ) / 1000;
		else if (c == 4) ret += Math.round( ( num + Number.EPSILON ) * 10000 ) / 10000;
		else if (c == 5) ret += Math.round( ( num + Number.EPSILON ) * 100000 ) / 100000;
		else ret += Math.round( ( num + Number.EPSILON ) * 1000000 ) / 1000000;
		const iDot = ret.lastIndexOf('.');
		var cZeros;
		if (iDot == -1) {
			ret += '.';
			cZeros = c;
		}
		else {
			cZeros = c - ((ret.length-1)-iDot);
		}
		while (cZeros > 0) {
			ret += '0';
			cZeros--;
		}
		return ret;
	}
	function getValuesMin( name, curT, curP )
	{
			var v = {};
			v.p = curP;
			v.t = curT;
			v.h = Module.PropsSI('H', 'P', v.p, 'T', v.t, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'T', v.t, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'T', v.t, name)
			v.γ = v.cp/v.cv; 
			//const k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', curP, 'T', curT, name );
			// v.γ = 1+1/k;   // wrong value!
			return v;
	}
	function getSatValuesMin( name, curP, curS )
	{
			var v = {};
			v.p = curP;
			v.s = curS;
			v.t = Module.PropsSI('T', 'P', curP, 'Q', 1, name)
			v.h = Module.PropsSI('H', 'P', curP, 'S', curS, name)
			v.hGas = Module.PropsSI('H', 'P', curP, 'Q', 1, name)
			v.hLiq = Module.PropsSI('H', 'P', curP, 'Q', 0, name)
        	v.cp = Module.PropsSI('C', 'P', curP, 'Q', 1, name)
			v.cv = Module.PropsSI('CVMASS', 'P', curP, 'Q', 1, name)
			v.γ = v.cp/v.cv; 
			return v;
	}

	function getValues( name, curT, curP )
	{
			var v = {};
			v.p = curP;
			v.t = curT;
			v.h = Module.PropsSI('H', 'P', v.p, 'T', v.t, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'T', v.t, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'T', v.t, name)
			v.cpAve = v.cp / 1000;
			v.cvAve = v.cv / 1000;
			v.deltaH = 0;
			v.rho = Module.PropsSI('D', 'P', v.p, 'T', v.t, name)
			v.tc = Module.PropsSI('CONDUCTIVITY', 'P', v.p, 'T', v.t, name)
			v.sos = Module.PropsSI('SPEED_OF_SOUND', 'P', v.p, 'T', v.t, name)
			v.z = Module.PropsSI('Z', 'P', v.p, 'T', v.t, name)
			v.v = Module.PropsSI('VISCOSITY', 'P', v.p, 'T', v.t, name)
			v.pip=Module.PropsSI('PIP', 'P', v.p, 'T', v.t, name)
			v.Prandtl=Module.PropsSI('Prandtl', 'P', v.p, 'T', v.t, name)
			//v.tSat=Module.PropsSI('T', 'P', v.p, 'Q', 0, name) 
			v.k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', v.p, 'T', v.t, name)
			v.γ = v.cp/v.cv; //1+1/v.k;
			return v;
	}
	function getValuesPH( name, curP, curH )
	{
			var v = {};
			v.p = curP;
			v.h = curH;
			v.t = Module.PropsSI('T', 'P', v.p, 'H', curH, name)
        	v.cp = Module.PropsSI('C', 'P', v.p, 'H', curH, name)
			v.cv = Module.PropsSI('CVMASS', 'P', v.p, 'H', curH, name)
			v.cpAve = v.cp / 1000;
			v.cvAve = v.cv / 1000;
			v.deltaH = 0;
			v.rho = Module.PropsSI('D', 'P', v.p, 'H', curH, name)
			v.tc = Module.PropsSI('CONDUCTIVITY', 'P', v.p, 'H', curH, name)
			v.sos = Module.PropsSI('SPEED_OF_SOUND', 'P', v.p, 'H', curH, name)
			v.z = Module.PropsSI('Z', 'P', v.p, 'H', curH, name)
			v.v = Module.PropsSI('VISCOSITY', 'P', v.p, 'H', curH, name)
			v.pip=Module.PropsSI('PIP', 'P', v.p, 'H', curH, name)
			v.Prandtl=Module.PropsSI('Prandtl', 'P', v.p, 'H', curH, name)
			v.k = Module.PropsSI('ISENTROPIC_EXPANSION_COEFFICIENT', 'P', v.p, 'H', curH, name)
			v.γ = v.cp/v.cv; //1+1/v.k;
			//v.γ = 1+1/v.k;
			return v;
	}
	const marginX = 22;
	const marginY = 10;
	var cWidth, cheight, height, width;
	var minTemp, maxTemp, minPressure, maxPressure;
	var yLog = 1;
	
	function tToX( t ) {
		return Math.abs(marginX + (cWidth)*(t - minTemp)/(maxTemp-minTemp));
	}
	function pToY( p ) {
		//return Math.abs(marginY + (cheight)*Math.pow((maxPressure - p)/(maxPressure-minPressure), yLog));
		if (pTransformer.lowFrom) {
			p = pTransformer.lowTo + (p - pTransformer.lowFrom) / (pTransformer.highFrom - pTransformer.lowFrom) * (pTransformer.highTo - pTransformer.lowTo);
		}
		return Math.abs(marginY + (cheight)*(maxPressure - p)/(maxPressure-minPressure));
	}

	function logMoveTo( ctx, x, y ) {
		console.log("x="+x+", y="+y);
		ctx.moveTo( x, y );
	}

	var pTriplePoint, tTriplePoint;
	const motorGenerator = getBooleanParam('motorGenerator', true);
	
	function drawTpDiagram() {
		isRedraw = false;
		if (typeof Module.PropsSI === 'undefined') {
console.log("Waiting coolprop to init ...");
			//$("#name").val('Helium');
			//$("#name").trigger('change');
			setTimeout( drawTpDiagram, 300 );
		}
		else {
			//$("#name").val("Argon");
			//setGasMassFlowFor1200MW("#name");
			metrics = {};
			pLowParam = null;
			dischargeMassFlowValue = null;
//Could liquidmethane and nitrogen to be used as secondary storage for cool 
// Liquid to 
			//console.log("Methan triplePoint: t="+tTriplePoint+", p="+pTriplePoint);
/**/
/*
		tTriplePoint = Module.PropsSI('T_TRIPLE', '', 0, '', 0, name);
		pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, name);

XXX
			iceCPTest();
Coolprop support vaport only to -10 C			
			var t, h, dVals = [];
			for (t = 283; t>0; t--) {
				d = Module.PropsSI('D', 'P', 1, 'T', t, "Water");
				if (!d || d == null || d === 'Infinity' || d == 'null') break;
				dVals.push(d);
			}
			console.log("p=1, vapor min temp="+(t+1)+" K, dVals="+JSON.stringify(dVals));
			dVals = [];
			for (t = 283;t>0; t--) {
				d = Module.PropsSI('D', 'P', 0.001, 'T', t, "Water");
				if (!d || d == null  || d === 'Infinity' || d == 'null') break;
				dVals.push(d);
			}
			console.log("p=0.001 Pa: vapor  min temp:"+(t+1)+" K, dVals="+JSON.stringify(dVals));
*/
			drawIt(true, true, true);
		}
	}
	function getLiquidHeatStorage( storageGas, inConstantVolume, pFrom, workingGasName, pWorkingGas, tLowWorkingGas, maxCapasityGWh )
	{
		const tTriplePoint = Module.PropsSI('T_TRIPLE', '', 0, '', 0, storageGas);
		const pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, storageGas);
		const tFrom = Module.PropsSI('T', 'P', pFrom, 'Q', 0, storageGas);
		const hFrom = Module.PropsSI('H', 'P', pFrom, 'Q', 0, storageGas);
		const d = Module.PropsSI('D', 'P', pFrom, 'Q', 0, storageGas);
		var coolStorage = {
			density : d,
			maxLevel : 0,
			minLevel : 0,
			curLevel : -1,
			maxCapasity : maxCapasityGWh ? maxCapasityGWh*3600*1000000000 : 0,
			workingGasName : workingGasName,
			storageGasName : storageGas,
			pWorkingGas : pWorkingGas,
			tLowWorkingGas : tLowWorkingGas,
			tOut : tLowWorkingGas,
			inConstantVolume : inConstantVolume,
			tHigh : tFrom,
			hHigh : hFrom,
			hHighWorkingGas :  Module.PropsSI('H', 'P', pWorkingGas, 'T', tFrom-metrics.heatExchangeDeltaT, workingGasName),
			hLowWorkingGas : Module.PropsSI('H', 'P', pWorkingGas, 'T', tLowWorkingGas, workingGasName),
			secondsInUse : 0,
			useStorage : function (massFlowInKg, hIn, tIn, timeInSeconds, chargeCool, pLowActual, tLowActual) {
				const totalMass = massFlowInKg * timeInSeconds;
				var deltaH;
				this.secondsInUse += timeInSeconds;
				if (chargeCool) {
					if (this.curLevel == -1 && this.maxCapasity>0) {
						this.curLevel = 0;
						this.maxCapasity = -this.maxCapasity;
					}
					/*
					deltaH = this.hLowWorkingGas - hIn;
					// charging cool
					if (this.curLevel == 0 || deltaH > 0) {
						this.hOut = this.hLowWorkingGas;
						this.tOut = tIn;
					}
					else if ((deltaH*totalMass + this.curLevel) < 0) {
						this.hOut = this.hLowWorkingGas + this.curLevel/totalMass;
						this.tOut = Module.PropsSI('T', 'P', this.pWorkingGas, 'H', this.hOut, this.workingGasName) - metrics.heatExchangeDeltaT;	// tOut of this batch
						this.curLevel = 0;
					}
					else*/
					deltaH = this.hLowWorkingGas - this.hHighWorkingGas;
					if (this.maxCapasity && (this.curLevel+deltaH) < this.maxCapasity) {
						this.hOut = hIn;
						this.tOut = tIn;
					}
					else
					{
						this.hOut = this.hHighWorkingGas;
						this.tOut = this.tHigh-metrics.heatExchangeDeltaT;
						this.curLevel += deltaH*totalMass;
						if (this.curLevel < this.minLevel) {
							this.minLevel = this.curLevel;
						}
//console.log(Math.round(this.secondsInUse/3600)+":"+this.storageGasName+": "+massFlowInKg+"*"+timeInSeconds+"*"+deltaH+"="+(deltaH*totalMass)+" => curLevel="+this.curLevel);
					}
				}
				else {
					if (this.curLevel == -1 && this.maxCapasity>0) {
						this.maxCapasity = this.minLevel = this.curLevel = -this.maxCapasity;
					}
					if (!this.hLowWorkingGasInDischarge) 
					{
						this.hLowWorkingGasInDischarge = Module.PropsSI('H', 'P', pLowActual ? pLowActual : this.pWorkingGas, 'T', this.tLowWorkingGas + metrics.heatExchangeDeltaT, this.workingGasName);
					}
					deltaH = hIn - this.hLowWorkingGasInDischarge;
					if (tIn < this.tLow || (this.maxCapasity && (this.curLevel+deltaH) > 0)) {
//console.log("tIn > this.tLow="+tIn+" > "+this.tLow);
						this.hOut = hIn;
						this.tOut = tIn;
					}
					else {
						this.curLevel += deltaH*totalMass;
						if (this.curLevel > this.maxLevel) {
							this.maxLevel = this.curLevel;
						}
//console.log(Math.round(this.secondsInUse/3600)+":"+this.storageGasName+": "+massFlowInKg+"*"+timeInSeconds+"*"+deltaH+"="+(deltaH*totalMass)+" => curLevel="+this.curLevel);
						this.hOut = this.hLowWorkingGasInDischarge;
						this.tOut = this.tLowWorkingGas + metrics.heatExchangeDeltaT;
					}
				}
			},
			capasityInGWh :  function () { return Math.round((this.maxLevel-this.minLevel)/(3600*1000000000));},
			sizeInM3 : function () {return Math.round((this.maxLevel-this.minLevel)/(this.hHigh - this.hLow)/this.density);}
		};
		var h;

		if (inConstantVolume) {
			const dGas = Module.PropsSI('D', 'P', pFrom, 'Q', 1, storageGas);
			const hGas = Module.PropsSI('H', 'P', pFrom, 'Q', 1, storageGas);
			var hTo, tTo = tFrom;

			while (tTo > tTriplePoint && tTo > tLowWorkingGas) {
				if ((tTo-1)< tTriplePoint) tTo = tTriplePoint+1;
				else if ((tTo-1)< tLowWorkingGas) tTo = tLowWorkingGas+1;
				h = Module.PropsSI('H', 'T', tTo-1, 'D', d, storageGas);
				if (h == Infinity || tTo < 76) break;	// returns 
				tTo--;
				hTo = h;
				//console.log("T="+tTo+", p="+p+", h="+h+" (hQ0:"+hQ0+", hQ1="+hQ1+", dQ0="+dQ0+", dQ1="+dQ1);
			}
			coolStorage.tLow = tTo+metrics.heatExchangeDeltaT;
			coolStorage.hLow = Module.PropsSI('H', 'T', coolStorage.tLow, 'D', d, storageGas);
			coolStorage.hLowWorkingGas =  Module.PropsSI('H', 'P', pWorkingGas, 'T', coolStorage.tLow, workingGasName);
			console.log("Liquid "+storageGas+": d="+d+", t:"+tFrom+"-"+tTo+", hFrom="+hFrom+", ave Cv="+d*((hFrom-hTo)/(tFrom-tTo)/1000)+" kJ/K/m3, dGas="+dGas+", hSat="+(hGas-hFrom));
		}
		else {
			var tCp = tFrom, hCp;
			var diff = 1;
			while (tCp >  tTriplePoint && tCp >= tLowWorkingGas) {
				h = Module.PropsSI('H', 'T', tCp-diff, 'P', pFrom, storageGas);
				if (h == Infinity && diff == 1) {
					diff = 0.1;
					continue;
				}
				if (h == Infinity) break;	// returns 
				tCp -= diff;
				hCp = h;
			}
			coolStorage.tLow = tCp;
			coolStorage.hLow = hCp;
			coolStorage.hLowWorkingGas =  Module.PropsSI('H', 'P', pWorkingGas, 'T', coolStorage.tLow, workingGasName);
			coolStorage.dMin = Module.PropsSI('D', 'T', tCp, 'P', pFrom, storageGas);
			console.log("Liquid "+storageGas+" in Cp in "+pFrom+": dMin="+coolStorage.dMin+", tCp:"+tFrom+"-"+tCp+", hFrom="+hFrom+", ave Cp="+d*((hFrom-hCp)/(tFrom-tCp)/1000)+" kJ/K/kg");
		}
		return coolStorage;
	}
	function drawOnlyStorage() {
		if (typeof Module.PropsSI === 'undefined') {
console.log("Waiting coolprop to init ...");		
			setTimeout( drawOnlyStorage, 300 );
		}
		else {
			metrics = {};
			pLowParam = null;
			dischargeMassFlowValue = null;
			drawIt(false, true, false);
		}
	}
	var lastCycleData;
	function drawIt(drawTpDiagram, drawStorageFlag, drawCompressors) {
		name = getInputParam('name', 'Nitrogen' );
		pCrit = Module.PropsSI('PCRIT', '', 0, '', 0, name)
		tCrit = Module.PropsSI('TCRIT', '', 0, '', 0, name);
		tTriplePoint = Module.PropsSI('T_TRIPLE', '', 0, '', 0, name);
		pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, name);
		minTemp = tTriplePoint - 0.5;
		minPressure =  000000; //pTriplePoint * 0.98;

		const cryogenicCooling = true; //getBooleanParam('cryogenicCooling', true);
		const adjustedCompressorPlow = false; //getBooleanParam('adjustedCompressorPlow');
		var tHigh = getFloatParam('tHigh', 1033);
/*		if (name == 'Methane' && tHigh > 625) {
			tHigh = 625;
			$("#tHigh").val('625');
		}*/
		var tLow = getFloatParam('tLow', 273);
		var tEfficiency = getFloatParam('tEfficiency', 0.90);
		var cEfficiency = getFloatParam('cEfficiency', tEfficiency);
		var tLowEfficiency = getFloatParam('tLowEfficiency', tEfficiency);
		var cLowEfficiency = getFloatParam('cLowEfficiency', cEfficiency);
		var hotCycle = []
		var coldCycle = []
		metricsChanged();
		if (getMetrics() == null) return;
		var pHigh = metrics.pHigh; // getFloatParam('pHigh_kPa', 5000) *  1000;
		var pLow = metrics.pLow; // getFloatParam('pLow_kPa', 25) * 1000;
		maxPressure = pHigh * 18 / 14;
		maxTemp = tHigh+100; //1100; // tCrit < 200 ? 400 : tCrit + 200;

		const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, true );
if (cycleData == null) return;
		lastCycleData = cycleData;
/*		
		var tSatInMinP = Module.PropsSI('T', 'P', pLow, 'Q', 0, name);
		console.log("Liquid storage, tSat:"+tSatInMinP+", K, D="+Module.PropsSI('D', 'P', pLow, 'T', tSatInMinP-0.01, name)+" kg/m3, h="+
			Module.PropsSI('H', 'P', pHigh, 'T', tSatInMinP-0.01, name));
*/
/*
		const pTest = 20000;
		const tSatIn20kPa = Module.PropsSI('T', 'P', pTest, 'Q', 0, name);
		const hLiquid = Module.PropsSI('H', 'P', pTest, 'T', tSatIn20kPa-0.01, name);
		const hGas = Module.PropsSI('H', 'P', pTest, 'T', tSatIn20kPa+0.01, name);
		const hSaturation=hGas-hLiquid;
		const pTop = pTest*243;
		var tTopP, hTopP=hLiquid;
		while ((tTopP = Module.PropsSI('T', 'P', pTop, 'H', hTopP, name)) == 'Infinity') hTopP += 1000;
		var tTopOut = Module.PropsSI('T', 'P', pTop, 'H', hTopP+hSaturation, name)	// 0.8 because of extra heat by heatpump compressor and expander with 0.92 efficiency
		
		console.log("Liquid storage, p=20 kPa, tSat:"+tSatIn20kPa+", K,  D_liq="+Module.PropsSI('D', 'P', pTest, 'T', tSatIn20kPa-0.01, name)+" kg/m3, "+
			"D_gas="+Module.PropsSI('D', 'P', pTest, 'T', tSatIn20kPa+0.1, name)+" kg/m3, h_Liq="+(hLiquid/1000)+" J/g"
			+", hSaturation="+(hSaturation/1000)+" J/g, P="+pTop/1000+" kPa =>  "+tTopP+" K => "+tTopOut+" K, D: "
			+ Module.PropsSI('D', 'P', pTop, 'T', tTopP, name )+" kg/m3 => "+Module.PropsSI('D', 'P', pTop, 'T', tTopOut, name )+" kg/m3, deltaH="+(hTopP-hLiquid)/1000+" J/g") ;
*/
/*
		const pHeHigh = 20000000;  // is 200 bar OK?
		const tColdHeOut = tSatIn20kPa-5;		// 5 K diff to limit PCHE size
		const hColdHeOut = Module.PropsSI('H', 'P', pHeLow, 'T', tColdHeOut, 'Hydrogen');
		const tColdHeIn = Module.PropsSI('T', 'P', pHeLow, 'H', hColdHeOut-hSaturation, 'Hydrogen');
		const sColdHeOut = Module.PropsSI('S', 'P', pHeLow, 'T', tColdHeOut, 'Hydrogen');
		const sColdHeIn = Module.PropsSI('S', 'P', pHeLow, 'T', tColdHeIn, 'Hydrogen');

		console.log("Hydrogen heat pump pLow="+(pHeLow/1000)+" kPa;"+tColdHeIn+" K => "+tColdHeOut+" K"+
					 ", D: "+Module.PropsSI('D', 'P', pHeLow, 'H', hColdHeOut-hSaturation, 'Hydrogen')+" kg/m3 => "+Module.PropsSI('D', 'P', pHeLow, 'H', hColdHeOut, 'Hydrogen')+" kg/m3");
		const orgName = name;
*/	
//: TBD: Triple point ja jäätymispiste tulee ottaa huomioon typen nesteytyksessä

		if (drawTpDiagram) {
			iDrawBraytonCycle( "myCanvas", hotCycle, coldCycle, cycleData, drawCompressors );
		}
		cycleData.hotCycle = hotCycle;
		cycleData.coldCycle = coldCycle;
		if (drawStorageFlag) {
			drawStorage( 'myPicture', getMetrics(), cycleData );
		}
	}
/*
Obsolate function, we now calclulate dimensions from the known volumes

function iterateBelowGroundLPheight( metrics)
{
	const maxDiff = 2000;
	const r = metrics.r;
	// V=V3 * 3 * 4 / PI + 4*r*r*r
	// JA kartion kulma 30 astetta, saadaan:
	// r=leikattava sisäkartion säde, koska kolmiolla s*s=r*r+h*h ja koska komion kulma on 30 niin 2*r=s, saadaan h = sqrt(3*r*r);
	// => Poisleikattavan sisäkartion tilavuus Vs=r*r*PI*sqrt(3*r*r)/3;
	const Vcut = r*r*Math.PI*Math.sqrt(3*r*r)/3;
	var x = r/3, loop = 0, testV, h2, r2;

console.log("Cut height: "+Math.sqrt(3*r*r)+", Vcut="+Vcut+", V3="+metrics.V3);	
	
	while (loop<100) {
		r2 = r+x;
		h2 = Math.sqrt(3*r2*r2);
		testV = (r2*r2*Math.PI*h2)/3 - Vcut;
		const diff = testV - metrics.V3;
		if (Math.abs(diff) <= maxDiff) break;
		if (testV > metrics.V3) {
			if (Math.abs(diff)<50000) {
				x -= 0.01
			}
			else if (Math.abs(diff)<500000) {
				x -= 0.1
			}
			else {
				x -= 1;
			}
		}
		else {
			if (Math.abs(diff)<50000) {
				x += 0.01
			}
			else if (Math.abs(diff)<500000) {
				x += 0.1
			}
			else {
				x += 1;
			}
		}
//console.log(loop+":r="+r2+", h="+h2+", diff="+(testV - metrics.V3)+", testV="+testV);
		loop++;
	}
	var ret = {};
	ret.loop = loop;
	ret.r = r2;
	ret.h = h2 - Math.sqrt(3*r*r); // leikatun osan korkeus
	ret.V3 = (r2*r2*Math.PI*h2/3)-Vcut;
	return ret;
}
*/
var metrics = {};

function metricsChanged() {
console.log("metricsChanged()..");	
	metrics = {};
/*	lpTemps = [];
	hpTemps = [];
	lpHeCCache = {};
	lpHeCache = {};
	hpHeCache = {};*/
	//getMetrics();
}

function getCone( V )//, concreteMaxStrengthMPa, weightMPa )
{
	var ret = {};
	// configurable angle, it may be up to 75 (or 80)
	ret.maxAngle = getFloatParam('maxOpenPitAngle', 60 );
	/*
		V = h*PI/3*(rTop*rTop + rTop*rBottom + rBottom*rBottom);
		
		If rBottom=rTop/2 and h=rTop/2*tan(maxAngle) =>
		 h = Math.tan(Math.PI*dome.maxAngle/180)*(rTop/4)
	*/
	//maxHotRockPressureMPa
	
	if (metrics.pHighActual && (metrics.pHigh < metrics.pHighActual || metrics.dome.prevAdjustment)) {
		// rBottom = rTop*(1/(1 + pHigh/pHighActual));
		// =>  1 + pHigh/pHighActual = rTop / rBottom;
		// => pHigh/pHighActual = rTop / rBottom - 1;
		// => pHighActual = pHigh/(rTop / rBottom - 1);
		const totalDepth = metrics.hBelow + metrics.dome.hBottom;
		const maxAngleTan = Math.tan(Math.PI*ret.maxAngle/180);
		var pHigh = metrics.pHigh;
		const pHighOptimal = (metrics.topFillUsedAsWeight ? 20 : 17.5)*96000*(metrics.storageSizeTons/25000000);
		if (pHigh < pHighOptimal) {
			pHigh = pHighOptimal;
		}
		metrics.pHighAdjusted = pHigh;
		var pHighActual = metrics.pHighActual;
		if (metrics.dome.prevAdjustment) {	
			pHighActual = pHighActual / metrics.dome.prevAdjustment; // hBottomUnAdjusted / metrics.dome.hBottom; // adjuste it to 'unadjusted' value
		}
/*
console.log("check pHighActual: "+pHighActual+", pHighActual/pLow:"+(pHighActual/metrics.pLow)+"=("+pHighActual+"/"+metrics.pLow+")");
		if (pHighActual > metrics.pHigh && (pHighActual/metrics.pLow) < 17.5) {
			pHighActual = metrics.pLow * 17.5;		// 
console.log("Set pHighActual: "+pHighActual);
		}
*/
		/*	hBottom = pHigh/pHighActual * maxAngleTan*(rTop/2);
			rBottom = rTop*(1/(1 + pHigh/pHighActual)) 
			V = hBottom * PI / 3 (rTop*rTop + rTop*rBottom + rBottom*rBottom);
			V = pHigh/pHighActual * maxAngleTan*(rTop/2) * PI / 3 * (rTop*rTop + rTop*rTop*(1/(1 + pHigh/pHighActual))  + rTop*(1/(1 + pHigh/pHighActual))*rTop*(1/(1 + pHigh/pHighActual))) 
			V = pHigh/pHighActual * maxAngleTan*(1/2) * PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual))) * rTop^3
			rTop = pow( V / (pHigh/pHighActual * maxAngleTan*(1/2) * PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual))), 1/3)
		*/
//  metrics.maxHotRockPressureMPa
		ret.vCave = V;
		ret.rTop = Math.pow(V/(pHigh/pHighActual * maxAngleTan*(1/2) * Math.PI / 3 * (1 + (1/(1 + pHigh/pHighActual))  + (1/(1 + pHigh/pHighActual))*(1/(1 + pHigh/pHighActual)))), 1/3);
		//ret.rTopTEST = Math.pow(V/((Math.tan(Math.PI*ret.maxAngle/180)/2)*Math.PI/3*(1 + 1/2 + 1/4)), 1/3);
		testResult( V, ret.rTop, ret.rTop/2, V*0.001, function (rBottom) {
			ret.hBottom = (ret.rTop-rBottom)*maxAngleTan;
			ret.rBottom = rBottom;
			return ret.hBottom*Math.PI/3*(ret.rTop*ret.rTop + ret.rTop*rBottom + rBottom*rBottom);
		});
		ret.prevAdjustment = pHigh/pHighActual;
//console.log("Prev HP storage:"+JSON.stringify(metrics.dome));
console.log("HP height adjusted by ratio: "+(pHigh/pHighActual)+" ("+pHigh+"/"+pHighActual+"), => ret:"+JSON.stringify(ret));
	}
	else {
		ret.rTop = Math.pow(V/((Math.tan(Math.PI*ret.maxAngle/180)/2)*Math.PI/3*(1 + 1/2 + 1/4)), 1/3);
		ret.rBottom = ret.rTop/2; //1.5;
console.log("Set first time rTop="+ret.rTop);
	}
	ret.s = ret.rTop*2;
	ret.topArea = Math.PI*ret.rTop*ret.rTop;
	ret.vCaveTop = 0;
	ret.side = (ret.rTop - ret.rBottom) / Math.cos(Math.PI*ret.maxAngle/180);
	if (typeof ret.hBottom === 'undefined') ret.hBottom = Math.sqrt(ret.side*ret.side - ret.rBottom*ret.rBottom);		// leikatun kartion korkeus kärkeen
	ret.sideArea = Math.PI*ret.side*(ret.rTop + ret.rBottom);
	ret.vCave = V;
	return ret;
}

function getAverageRockHeatCapasitykJinKg(tLow, tHigh )
{
	const tLowOrg = tLow;
	const tHighOrg = tHigh;
	const deltaT = tHigh-tLow;
	var ret = 0;
	if (tHigh < 273 && metrics.iceStorage) {
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tHigh))/2000 * (tHigh-tLow);
		tLow = tHigh;
	}
	if (tLow < 200) {
		const tLowHigh = tHigh < 200 ? tHigh : 200;
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tLowHigh))/2000 * (tLowHigh-tLow);
		tLow = tLowHigh;
	}
	if (tLow < 293) {
		const tLowHigh = tHigh < 293 ? tHigh : 293;
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tLowHigh))/2000 * (tLowHigh-tLow);
		tLow = tLowHigh;
	}	
	if (tLow < 473) {
		const tLowHigh = tHigh < 473 ? tHigh : 473;
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tLowHigh))/2000 * (tLowHigh-tLow);
		tLow = tLowHigh;
	}	
	if (tLow < 773) {
		const tLowHigh = tHigh < 773 ? tHigh : 773;
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tLowHigh))/2000 * (tLowHigh-tLow);
		tLow = tLowHigh;
	}	
	if (tLow < 1023) {
		const tLowHigh = tHigh < 1023 ? tHigh : 1023;
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tLowHigh))/2000 * (tLowHigh-tLow);
		tLow = tLowHigh;
	}	
	if (tLow < tHigh) {
		ret += (getRockHeatCapasityJinKgK(tLow) + getRockHeatCapasityJinKgK(tHigh))/2000 * (tHigh-tLow);
	}
	ret = ret / deltaT;
console.log("***getAverageRockHeatCapasitykJinKg("+tLowOrg+","+tHighOrg+")="+ret);
	return ret;
}
function getRockHeatCapasityJinKgK(t, type)
{
	//return metrics.hpCp*1000;	// for testing

	// https://rruff.geo.arizona.edu/doclib/am/vol67/AM67_470.pdf, 0-300 K of cp cobolt olivine
	// Debye temperatur of Silicate minerals: 480-900 välillä https://pubs.usgs.gov/of/1988/0663/report.pdf 
	
	// 455-Article%20Text-929-1-10-20170428.pdf, pages 73 and 74,  
	// "and Cp and Cv reduce to 14.24 and 14.1 J mol-1 K-1 for gabbro and 16.71 and 16.54 J mol-1 K -1 for harzburgite respectively"
	// (at room temperature of 293.15 K) => average cp for mafic and ultramafic rocks ~15.5 1 J mol-1 K-1 at 293.15 K 
	// Debus temp: gabbro and harzburgite are found to be 548 K and 693K
	// For mafic gabbro:
	//  WRONG: 
	// Use Olivine Cobalt as reference, or should we ask also debyes temp 
	//const relCp = [{t:0.1*293/0.3, cp:4/16}, {t:0.1*293/0.3, cp:10/16}, {t:293, cp:16/16}];
	// 658 K Debye below 20 C, normalized specific heat capasity of non porous rocks above it =>
	// Ref
	
	// Measured specific heat capacities for nonporous rock samples seems to decrease linearily between 293-773 K and to be constant above it
	// we assume the the decrease continue in same rate below 293 K°C
	if (t >= 773) {
		return (metrics.rockHeatCapasityAt773K + (t - 773)/(1023-773)*(metrics.rockHeatCapasityAt1023K - metrics.rockHeatCapasityAt773K)) * 1000;
	}
	else if (t >= 473) {
		return (metrics.rockHeatCapasityAt473K + (t - 473)/(773-473)*(metrics.rockHeatCapasityAt773K - metrics.rockHeatCapasityAt473K)) * 1000;
	}
	else if (t >= 293) {
		return (metrics.hpCp + (t-293)/(473-293)*(metrics.rockHeatCapasityAt473K-metrics.hpCp)) * 1000;
	}
	else if (t < 273 && ((metrics.topFillWithIceWithStorage && typeof type === 'undefined') || type=='ice')) {
		// ice heat capasity decrease by temp is almost linear
		// https://www.aanda.org/articles/aa/pdf/2004/10/aa3290.pdf:
		const cp2cv = metrics.crushedIceDensity;  // cp/m3
		const cpAtT = getIceHeatCapasityKJinKgK(t)
		return cpAtT*cp2cv/metrics.lpGravelDensity * 1000;		
	}
	else if (t >= 200) {
		return (metrics.rockHeatCapasityAt200K + (t - 200)/(293-200)*(metrics.hpCp-metrics.rockHeatCapasityAt200K)) * 1000;
	}
	else {
		// https://en.wikipedia.org/wiki/Debye_model for Gabbro: https://journals.squ.edu.om/index.php/squjs/article/viewFile/455/464:
		// For gabbro the heat capasity at 82K is about 20% of that at Debyes temp 548 K
		// and with a linear decrease its heat capasity would be zero at 27 K =>  
		// This is a very raw estimation,  
		return (metrics.rockHeatCapasityAt75K + (t - 75)/(200-75)*(metrics.rockHeatCapasityAt200K-metrics.rockHeatCapasityAt75K)) * 1000;;
	}
}
function getIceHeatCapasityKJinKgK(t)
{
		// ice heat capasity decrease by temp is almost linear
		// https://www.aanda.org/articles/aa/pdf/2004/10/aa3290.pdf:
		const iceCpAt79_98K =  0.7146;
		const iceCpAt99_57K = 0.8878;
		const iceCpAt175_36K = 1.398;
		const iceCpAt267_77K = 2.074;
		var cpAtT;
		if (t < 99.57) {
			cpAtT = iceCpAt79_98K + (t - 79.98)/(99.57-79.98)*(iceCpAt99_57K-iceCpAt79_98K);
		}
		else if (t < 175.36)
			cpAtT = iceCpAt99_57K + (t - 99.57)/(175.36-99.57)*(iceCpAt175_36K-iceCpAt99_57K);
		else {
			cpAtT = iceCpAt175_36K + (t - 175.36)/(267.77 - 175.36)*(iceCpAt267_77K-iceCpAt175_36K);
		}
		return cpAtT;  // to CV kJ/kg to J/kg
}

function logHeatCapasities() {
	var iceEnthalpy = 0, prevHtc = 0;
	for (t = 73; t <= 273; t += 5) {
		const htcIce = getRockHeatCapasityJinKgK(t,'ice')*metrics.lpGravelDensity/1000/metrics.crushedIceDensity;
		if (t > 78) {
			iceEnthalpy = iceEnthalpy + ((htcIce+prevHtc)/2)*5;
//console.log("(("+htcIce+"+"+prevHtc+")/2)*5="+(((htcIce+prevHtc)/2)*5)+"=>iceEnthalpy="+iceEnthalpy);
		}
/*
		console.log("Heat capasity MJ/M3 at "+t+": ice="+myRound(htcIce,2)+ 
			", enthalpyFrom78="+Math.round(iceEnthalpy)+
			", crushed ice="+myRound(getRockHeatCapasityJinKgK(t,'ice')*metrics.lpGravelDensity/1000,2)+
			", lp gravel="+myRound(getRockHeatCapasityJinKgK(t,'lp')*metrics.lpGravelDensity/1000,2)+
			", hp gravel="+myRound(getRockHeatCapasityJinKgK(t,'lp')*metrics.gravelDensity/1000,2));*/
		prevHtc = htcIce;
	}
}
	
// https://www.aanda.org/articles/aa/pdf/2004/10/aa3290.pdf  Cp of water ice:
// Ice mix below 200 K
function iceCP( T ) {
	const e = Math.E;
	const iceCp = 0.00773 * T * (1-Math.pow(e,-0.001263 * T * T)) * (1+Math.pow(e,-3 * Math.sqrt(T))* 0.00847 * Math.pow(T,6)+0.00000020825 * Math.pow(T,4) * Math.pow(e,-0.0497 * T));
	return iceCp;
}

function iceCPTest() {
	test = [];
	h = 0;
	for (T = 50; T < 273; T++) {
		cp = iceCP( T );
		h += cp;
		test.push( T+": Cp="+cp+", h="+h );
	}
	console.log("Ice Cp and h by temp:"+JSON.stringify(test));
}

function getTotalHeatLost()
{
	// the actual power is stored into hp storage, the low pressure storage losses are 
	return metrics.maxHeatFlowOut * metrics.highPressureStorageSurfaceArea; 
	// + metrics.lowPressureStorageSurfaceArea);
}

function getMetrics(pRatio, storageSize) {
	if (metrics && metrics.rGround && typeof pRatio === 'undefined' && typeof hpStorageSizeRockMm3 === 'undefined') return metrics;
	const tHigh = getFloatParam('tHigh', 1033);
	metrics.tHigh = tHigh;

	var storageMetrics = {
		iceStorage : true,
		heatPumpCompressorTin : 313, // getFloatParam("heatPumpCompressorTin", 313);	// 40 Celsius
		coolingWaterTemp : 283, // getFloatParam("heatPumpCompressorTin", 313);	// 40 Celsius
		cUnits : getIntParam('numberOfUnits', 4 ), 
		heatExchangeDeltaT : getFloatParam('heatExchangeDeltaT', 2),  // // 2 K difference in heat exchange
		//heatPumpHighP : 5000000, // 5MPa==50 bar == 20MPa==200 bar
		heatPumpHighP : getFloatParam('hpHighPressureKPa', 2117)*1000, // 3MPa=30bar, 5MPa==50 bar == 20MPa==200 bar$
		<!-- these hidden old values are set based on the values of hpStorageSizeRockM3, highToLowPressureRatio, rockDensity, gravelDensity, insGravelDensity -->
		storageSizeTons : (storageSize ? storageSize : getFloatParam('storageSizeMTon', 20 )) * 1000000,	
		ins : getFloatParam('highPressureInsulationM', 10 ), // in meters
		maxHpGravelExpansion : getFloatParam('maxHpGravelExpansion', 0.05 ), 
		lpGravelExpansionIn100K :  getFloatParam('lpGravelExpansionIn100K', 0.001 ),
		costOfSurfaceM2 : getFloatParam('costOfSurfaceM2', 1200 ),
		costOfMiningM3 : getFloatParam('costOfMiningM3', 12 ),
		generatorCostOfKW : getFloatParam('generatorCostOfKW', 0),
		tcCostOfKW : getFloatParam('tcCostOfKW', 50),		// cost of tubin or compressor power
		heCostOfKW : getFloatParam('heCostOfKW', 50),		// cost of heat exchangers  
		otherCostOfKW: getFloatParam('otherCostOfKW', 50),	// all other power plant cost
		rockDensityHp : getFloatParam('rockDensityHp', 3.0 ), 
		rockDensityLp : getFloatParam('rockDensityLp', 2.8 ), 
		highToLowPressureRatio : (pRatio ? pRatio : getFloatParam('highToLowPressureRatio', 25 )),	
		pRatioTolerance : getFloatParam('pRatioTolerance_kPa', 100)*1000,	// by default about 1 bar tolerance before the deck starts to rise by pressure
		//gravelDensity : getFloatParam('gravelDensity', 2.1 ),	// high density because it makes storage more compact and aboslute pressure drop does not matter in a high pressure
		//lpGravelDensity : getFloatParam('lpGravelDensity', 2.1 ),	// high density because it makes storage more compact and aboslute pressure drop does not matter in a high pressure
		crushedIceDensity : getFloatParam('crushedIceDensity', 0.93*2.2/2.65),	// compacted gravel 2.1/2.65, ice is probably more packed
		crushedIcePorosity : getFloatParam('crushedIcePorosity', 1 - 2.2/2.65),	// compacted gravel 2.1/2.65, ice is probably more packed
		hpCp : getFloatParam('hpCp', 0.8),
		lpCp : getFloatParam('lpCp', 0.8),
		//rockHeatCapasityAt293K : getFloatParam('rockHeatCapasityAt293K', 0.8)*1000, // kJ/kg/K  at 293K !!!
		//rockHeatCapasityAt773K : getFloatParam('rockHeatCapasityAt773K', 1.3 )*1000, // kJ/kg/K  (Cp increases from 20C to 500C and then stabilize 
		maxPartLiquid : 0.01,   // spefic value is calculated later
		maxTopFillAngle : getFloatParam('maxTopFillAngle', 50),
		maxHotRockPressureMPa: getFloatParam('maxHotRockPressureMPa', 200),
		maxHeatFlowOut : getFloatParam('maxHeatFlowOut', 20),	// W/m^2
		powerAndHeat : !getBooleanParam('powerOnly', false ),
		externalIceStorage : getBooleanParam('externalIceStorage', true ),
		gearEfficiency : getFloatParam('gearEfficiency', 0.993 ), 
		frequencyConverterEfficiency : getFloatParam('frequencyConverterEfficiency', 0.97 ), 
		generatorEfficiency : getFloatParam('generatorEfficiency', 0.99 ),
		topFillUsedAsWeight: document.getElementById("topFillUsedAsWeight").checked,
		topFillWithIceWithStorage: document.getElementById("topFillWithIceWithStorage").checked,
		topFillUsedAsColdStorage: document.getElementById("topFillUsedAsColdStorage").checked,
		rampWidth : getFloatParam('rampWidth', 8),
		rampSlope : getFloatParam('rampSlope', 7 ),
		uOfGravelrockwoolMix : getFloatParam('uOfGravelrockwoolMix', 0.1),	// W/(T * m)	// heat flows in gravel is mainly by radiation => bichar blocks it
		heatExchangePressureLoss  : getFloatParam('heatExchangePressureLoss', 0.0025)	// relative pressure loss in heat exchange??

		//concreteMaxStrengthMPa : 80	// for a very high quality rock-filled concrete could have >90 MPa
	};
	metrics = storageMetrics;
	metrics.rockHeatCapasityAt1023K = metrics.hpCp * 1.3/0.8;
	metrics.rockHeatCapasityAt773K = metrics.hpCp * 1.2/0.8;
	metrics.rockHeatCapasityAt473K = metrics.hpCp * 1.0/0.8;
	metrics.rockHeatCapasityAt200K = metrics.hpCp*0.78;		// gabbro heat capasity would zero at 27 K, if heat capasity decrease would we linear to very end
	metrics.rockHeatCapasityAt75K = metrics.hpCp*0.225;		// gabbro heat capasity would zero at 27 K, if heat capasity decrease would we linear to very end
	metrics.rockHeatCapasityDecreaseBelow163 = metrics.rockHeatCapasityAt200K/(163 - 27);		// gabbro heat capasity would zero at 27 K, if heat capasity decrease would we linear to very end
	
	metrics.tEfficiency = getFloatParam('tEfficiency', 0.97);
	metrics.cEfficiency = getFloatParam('cEfficiency', metrics.tEfficiency);
	metrics.tLowEfficiency = getFloatParam('tLowEfficiency', metrics.tEfficiency);
	metrics.cLowEfficiency = getFloatParam('cLowEfficiency', metrics.cEfficiency);
	//metrics.cHeatPumpEfficiency = getFloatParam('cHeatPumpEfficiency', metrics.cLowEfficiency);
	//metrics.tHeatPumpEfficiency = getFloatParam('tHeatPumpEfficiency', metrics.tLowEfficiency);
	metrics.insGravelDensity = getFloatParam('insGravelPorosity', 0.5) * metrics.rockDensityHp;	// low density to minimize the pressure drop in low pressure
	calcPressureDropInGravel('Lp');
	calcPressureDropInGravel('Hp');

	metrics.pLow = getFloatParam( pLowParam ? pLowParam : 'targetPLow', 102 ) * 1000;
	metrics.pHigh = metrics.pLow * metrics.highToLowPressureRatio;

	const tExternal = 273;

	//maxHeatFlowOut = deltaT * uOfGravelrockwoolMix/ins =>
	metrics.ins = (tHigh-tExternal)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;

	metrics.externalEclosure = true; // document.getElementById('isolatedWithRecycledRubber').checked;
	metrics.maxTempOfEnclosure = tHigh; 	// assume max temp for steel 
	//metrics.externalEclosure ? getFloatParam('maxRubberTemp', 673) : tHigh; 	// assume max temp for steel
	
	//if (metrics.ins == 10) metrics.ins = metrics.ins*tHigh/1030; // scale the Insulation layer to the default, THIS IGNORES TE
	
	// Let's fix the dome rock temperature to approximately 300 or 750K, we assume insulation k value of cave top is 10 times of 10m gravel Insulation in the bottom lp storage
	//const	hpInsulationBoundaryTemp = isCone ? tHigh : 300;
	const tSat = Module.PropsSI('T', 'P', metrics.pLow, 'Q', 0, name);
	const cEfficiency= getFloatParam('cEfficiency', 0.92);
	const ccEfficiency= getFloatParam('ccEfficiency', 0.92);
	const mainCompressor = doAdiabaticProcessWithS( name, metrics.pHigh, metrics.pLow, tHigh, 1/cEfficiency,null );
	const coldCompressor = doAdiabaticProcessWithS( name, metrics.pLow, metrics.pHigh, tSat+0.01, ccEfficiency, null );

	const tc = getEnergyLevelChangeOf1000KgGasFlow( mainCompressor, coldCompressor );
	if (metrics.topFillWithIceWithStorage) {
		metrics.lpGravelPart = 0.4;		// just an initial guess to have weight on top
		metrics.hpGravelPart = 0.6;
	}
	else {
		metrics.lpGravelPart = tc.lpGravelWeight / (tc.lpGravelWeight + tc.hpGravelWeight);
		metrics.hpGravelPart = tc.hpGravelWeight / (tc.lpGravelWeight + tc.hpGravelWeight);
	}
console.log("metrics.lpGravelPart="+metrics.lpGravelPart+"; metrics.hpGravelPart="+metrics.hpGravelPart);
	metrics.caveTopInsulation = 0;
	metrics.insCaveBottom = (metrics.topFillWithIceWithStorage ? (mainCompressor.tIn - 280) : (280-coldCompressor.tIn))*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	
	// scale the low pressure insulation layer for its lower temps but check also the tLow temp diff between 70K and 300K
	// in the middle we lose energy from both directions == multiply by 2
	metrics.lpInsForLowTBottom = (metrics.topFillWithIceWithStorage ? (tHigh-300) : (1.5*(tHigh-tSat))) *metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	const lpInsForLowTBottom = metrics.lpInsForLowTBottom;
	const lpInsForHighT = (mainCompressor.tIn-280)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	const lpInsForLowT = (280-tSat)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
	metrics.insLpSides = lpInsForHighT > lpInsForLowT ? lpInsForHighT : lpInsForLowT;

	var h, loop = 0;
	var scaledToVolume = 0;
	var sizeMultiplier = 1;
	
	// The low and high pressure storages have the same weight.  The weight of low pressure storage must contain the high pressure.
	// So the high pressure defines the depth and volume of the high pressure storage.  
	// V1 = the high pressure cylider rock volume needed to contains pHigh pressure == 

	// this estimation was based on radius=150 and insulation layer=10, 
	//Loop again: expected density=2 <> calclulated density=1.8343575910031746 or 1.973478029020575<>2.0375
	metrics.hpExpectedAverageDensity = (metrics.gravelDensity * 3 + metrics.insGravelDensity) / 4;	// very near to the actual value when high pressure insulation layer is 10 m
	var lpExpectedV3AverageGravelDensity = (metrics.gravelDensity * 6 + metrics.insGravelDensity) / 7;	// This applies below ground!
	
	metrics.hpGravelPartActual = metrics.hpGravelPart;
	for (;;) {
		// the mined volume 
		metrics.actualV1 =  metrics.storageSizeTons * metrics.hpGravelPartActual / metrics.hpExpectedAverageDensity;
		// hp storage size as rock m3
		metrics.V1 = metrics.storageSizeTons * metrics.hpGravelPartActual/metrics.rockDensityHp;
		// V1 is the dense base rock volume needed above to contain the pressure, 
		// V2 = the rock volume to contain the expansion of gravel in the high pressure cylinder,
		// 		== the volume exceeding the high pressure storage because of gravel fill
		metrics.V2 = metrics.actualV1 - metrics.V1;
		// the mined volume above the high pressure cylinder
		metrics.V3 = metrics.storageSizeTons * (1-metrics.hpGravelPartActual)/(metrics.topFillUsedAsWeight ? lpExpectedV3AverageGravelDensity : metrics.rockDensityLp) 
			- (metrics.topFillUsedAsWeight ? 0 : metrics.V2);
		metrics.totalMiningVolume = metrics.actualV1 + metrics.V3;
		metrics.rockDensity = (metrics.V1*metrics.rockDensityHp + (metrics.V3+metrics.V2)*metrics.rockDensityLp)/metrics.totalMiningVolume;

		if (metrics.V2 < 0 || metrics.V3<0) {
			console.log("Bad values:\r\n"+JSON.stringify(metrics, null, 2)); 
			return null;
		}
		
		// volume above ground

		metrics.isCylinder = isCylinder;
		
		{
			var dome = getCone(metrics.actualV1);
			metrics.domeThickness = 0; // dome.thickness2;
			metrics.rCylinder = dome.rTop; 
//console.log("Actual dome width="+caveS+": "+caveVolume+"=> scaleLength="+dome.scaleLength+", dome="+JSON.stringify(dome));
			
			// next we calclulate 1. insulation layer in the side and bottom. 2 the volume extension reserve in the top of cave 3. the actual storage volume 
			// 1. Kartion halkaisija pienenee 2*10/sin(60)
			const xWidthHpInsulation = metrics.ins/Math.sin(Math.PI*dome.maxAngle/180) 
			dome.rTopI = dome.rTop - xWidthHpInsulation;
			//  dome.rBottomI = dome.rBottom - (dome.rTop-dome.rTopI);	// equal insulation everywhere
			dome.hBottomI = dome.hBottom - metrics.insCaveBottom;
			metrics.pHighStorageHeight = dome.hBottomI;
			// dome.rBottomI = dome.rBottom - xWidthHpInsulation; 
			dome.rBottomI = dome.rBottom * dome.rTopI / dome.rTop;	// better insulation in the top?
			metrics.dome = dome;
			// Rock temperature about 300K,  bottom temp 200K => 100K diff, in the side the difference is tHigh-300 => bottom insulation should be ins*100/(tHigh-300)
			// when h is the same => V1/V2=r1*r1/r2*r2 => V2 = V1*r2*r2/r1*r1
			//const r1 = dome.s/2, r2=dome.sActual/2;
			//metrics.insHp = metrics.ins*100/(tHigh-300);
			metrics.highPressureInsulationMVolume = dome.vCave * (1 - dome.rTopI*dome.rTopI/(dome.rTop*dome.rTop)) + Math.PI * dome.rBottomI*dome.rBottomI*metrics.insCaveBottom;
			metrics.topInsulationVolume = 0; //isCone ? dome.rTopI*dome.rTopI*Math.PI*metrics.caveTopInsulation :
			//dome.vCaveTop * (1- Math.pow(dome.r-(1+metrics.caveTopInsulation),3)/Math.pow(dome.r,3));	// min 1 m free space!
			metrics.highPressureStorageVolume = (dome.vCave - metrics.highPressureInsulationMVolume);
			metrics.rCaveBottom = dome.rBottom;

			// for simplicity we assume the percentage of insulation of the total volume to be the same in high and low pressures storages
			metrics.hpAverageGravelDensity = // total high pressure height 
				(metrics.highPressureStorageVolume * metrics.gravelDensity +  metrics.highPressureInsulationMVolume*metrics.insGravelDensity) / dome.vCave;
/*
			metrics.actualV1 = dome.vCave;
			metrics.totalMiningVolume = metrics.actualV1 + metrics.V3;

			// V2 = the rock volume to contain the expansion of gravel in the high pressure cylinder,
			// 		== the volume exceeding the high pressure storage because of gravel fill
			metrics.V2 = metrics.actualV1 - metrics.V1;

			// the mined volume above the high pressure cave
			metrics.V3 = metrics.V1 - metrics.V2;
			if (metrics.V2 < 0 || metrics.V3<0) {
				console.log("Bad values:\r\n"+JSON.stringify(metrics, null, 2)); 
				return null;
			}
*/
			// the volume above ground has no insulation layer, so its density that of the compacted gravel density
			metrics.lpExpectedV3AverageGravelDensity = lpExpectedV3AverageGravelDensity;
//			metrics.V4 = ((metrics.V1-metrics.V3)  + metrics.V3 * (1 - lpExpectedV3AverageGravelDensity/metrics.rockDensity))
//						* metrics.rockDensity / metrics.lpGravelDensity;
			metrics.V4 = ((metrics.V3) * (1 - lpExpectedV3AverageGravelDensity/metrics.rockDensityLp))+
							+ metrics.actualV1 * (1 - metrics.hpExpectedAverageDensity/metrics.rockDensityHp) * metrics.rockDensityLp/metrics.lpGravelDensity;
		
/*console.log(metrics.V4+" = ("+metrics.V1+" * "+(1 - metrics.hpAverageGravelDensity/metrics.rockDensity)+" + "+metrics.V3+" * "+(1 - lpExpectedV3AverageGravelDensity/metrics.rockDensity)+")"+
						"* "+(metrics.rockDensity / metrics.lpGravelDensity));*/

			// hMin = hBelow + hAbove;
			// V3 = PI*rGround*rGround*hBelow/3 - ;
			//metrics.extDome = getExternalDome45( dome, metrics.dome.thickness2 );
			//metrics.extDomeIns = getExternalDome45( dome, metrics.dome.thickness2+metrics.ins );
			metrics.rOpenBottom = metrics.dome.rTop; 
			metrics.rTop = metrics.dome.rTopI;

			// V3 + extDome.volume = PI/3*rGround*rGround*hBelow*rGround/(rGround-rTop) - PI/3*rTop*rTop*hBelow*rGround/rTop;
			// V3 + extDome.volume = (PI/3*rGround*rGround*rGround/(rGround-rTop) - PI/3*rTop*rTop*rGround/rTop)*hBelow;
			// hBelow = (V3 + extDome.volume) / (PI/3*(rGround*rGround*rGround/(rGround-rTop) - rTop*rTop*rGround/rTop));
			var V3 = metrics.V3; // + metrics.extDome.volume;
			testResult( V3, metrics.rTop, dome.rTop*2, 0.005*V3,
					function (h) { 
						metrics.rGroundBelow = h;
						metrics.hBelow = Math.tan(Math.PI*dome.maxAngle/180)*(metrics.rGroundBelow-dome.rTop);
//console.log("metrics.rGroundBelow="+metrics.rGroundBelow+", metrics.hBelow="+metrics.hBelow);
						return Math.PI/3*metrics.hBelow*(Math.pow(metrics.rGroundBelow,2)+metrics.rGroundBelow*dome.rTop+Math.pow(dome.rTop,2));
					});
			
			// Check first if side angle is less or equal to maxTopFillAngle
			// because of 45 angle:  rGround = ;
			// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * hTop / 3;
			// when hTop = hGround*rTop/rGround =>
			// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * (hGround*rTop/rGround) / 3;
			// => hGround = 3 * (V4 - extDome.volume) / (PI * rGround * rGround - PI * rTop * rTop * rTop/rGround)
			var rGround = metrics.rGroundBelow;
			var hGround = 3 * (metrics.V4)/(Math.PI * rGround * rGround - Math.PI * metrics.rTop * metrics.rTop * metrics.rTop/rGround);
			var actualAngleRad = Math.atan2(hGround,rGround); // atan2(y,x)
console.log("rGround="+rGround+", hGround="+hGround+", "+actualAngleRad+"<="+(Math.PI*metrics.maxTopFillAngle/180)+"?");
			if (actualAngleRad <= (Math.PI*metrics.maxTopFillAngle/180)) {
				metrics.rGround = rGround;
				metrics.hAbove = hGround * (rGround-metrics.rTop)/rGround;
				metrics.topFillAngleRad = actualAngleRad;
				metrics.topFillTan = Math.tan(actualAngleRad);
			}
			else {
				// We first check if metrics.rGroundBelow==metrics.rGround
				metrics.topFillAngleRad = Math.PI*metrics.maxTopFillAngle/180;
				metrics.topFillTan = Math.tan(metrics.topFillAngleRad);
				// V4 = extDome.volume + PI * rGround * rGround * hGround / 3 - PI * rTop * rTop * hTop / 3;
				// and hGround = rGround * topFillTan, hTop = rTop * topFillTan;
				// V4 = extDome.volume + PI * rGround * rGround * rGround * topFillTan / 3 - PI * rTop * rTop * rTop * topFillTan / 3;
				// => rGround = pow( 3 * (V4 - extDome.volume)/(PI* topFillTan) + rTop * rTop * rTop, 1/3);
				metrics.rGround = Math.pow( 3 * (metrics.V4)/(Math.PI*metrics.topFillTan) + metrics.rTop * metrics.rTop * metrics.rTop, 1/3);
				metrics.hAbove = (metrics.rGround - metrics.rTop)*metrics.topFillTan;
			}
metrics.checkedV4=metrics.hAbove*Math.PI/3*(metrics.rGround*metrics.rGround+metrics.rGround*metrics.rTop+metrics.rTop*metrics.rTop);
			metrics.toSideX = function (deltaY) { return deltaY/ this.topFillTan;}
			metrics.toSideY = function (deltaX) { return deltaX * this.topFillTan;}

			var x = metrics.rGround - metrics.rTop; 
			metrics.sideAbove =  Math.sqrt( metrics.hAbove * metrics.hAbove + x * x );
			metrics.gasEnclosureFromHpTop = lpInsForLowTBottom - lpInsForLowTBottom * (metrics.maxTempOfEnclosure - tSat)/(tHigh - tSat);
			metrics.pHighActual = (metrics.lpGravelDensity*10000)*(metrics.hAbove+metrics.hBelow - lpInsForLowTBottom)+(metrics.insGravelDensity*10000)*
				(lpInsForLowTBottom - metrics.gasEnclosureFromHpTop);
//OK: rubber use case adapts the storage size a little bi smaller => higher pHigh
//console.log("pHighActual:"+metrics.pHighActual+" = "+(metrics.lpGravelDensity*10000)+"*"+(metrics.hAbove+metrics.hBelow - lpInsForLowTBottom)+"+"+(metrics.insGravelDensity*10000)+"*"+(lpInsForLowTBottom - metrics.gasEnclosureFromHpTop));

/*
			if (metrics.pHighActual < metrics.pHigh && scaledToVolume) {
				const hBelow  = (metrics.pHigh-(metrics.insGravelDensity*10000)*(metrics.caveTopInsulation+lpInsForLowTBottom))/(metrics.lpGravelDensity*10000)+lpInsForLowTBottom-metrics.hAbove;
				const rGroundBelow = metrics.dome.rTop + (hBelow/Math.tan(Math.PI*dome.maxAngle/180));
				// V3 + extDome.volume = PI/3*rGround*rGround*hBelow*rGround/(rGround-rTop) - PI/3*rTop*rTop*hBelow*rGround/rTop
				const V3 = hBelow * Math.PI/3*(rGroundBelow*rGroundBelow + rGroundBelow*metrics.rTop + metrics.rTop*metrics.rTop);
console.log("Adjusted V3:"+metrics.V3+"=>"+V3+", hBelow:"+metrics.hBelow+"=>"+hBelow+", rGroundBelow:"+metrics.rGroundBelow+"=>"+rGroundBelow);
				metrics.V3 = V3;
				metrics.hBelow = hBelow;
				metrics.rGroundBelow = rGroundBelow;
			}
*/
/*
			metrics.topDome = getMetricsOfDome45(metrics.V4);
			metrics.sideAbove = metrics.topDome.r*Math.PI / 4;	// path from 45 to 90
			metrics.hAbove = metrics.topDome.h;
			metrics.rGround = metrics.topDome.s / 2;
			// h = height of V3, hTot = distance to virtual end of cone
			// V3 = PI*rGround*rGround*hTot/3 - PI*rOpenBottom*rOpenBottom*(hTot-h)/3
			// hTot = h * rGround / (rGround-rOpenBottom);
			// => V3 = PI*rGround*rGround*h * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(h * rGround * (rGround-rOpenBottom)-h)/3
			// => V3/h = PI*rGround*rGround * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(rGround * (rGround-rOpenBottom)-1)/3
			// => h = V3/(PI*rGround*rGround * rGround / (rGround-rOpenBottom)/3 - PI*rOpenBottom*rOpenBottom*(rGround * (rGround-rOpenBottom)-1)/3);
			metrics.hBelow = 3 * metrics.V3/(Math.PI*metrics.rGround*metrics.rGround * metrics.rGround / (metrics.rGround-metrics.rOpenBottom)  
						- Math.PI*metrics.rOpenBottom*metrics.rOpenBottom*(metrics.rGround / (metrics.rGround-metrics.rOpenBottom)-1));
			metrics.rTop = 0;
console.log("Vtest="+(Math.PI*metrics.rGround*metrics.rGround*metrics.hBelow));
*/
			metrics.hCylinder = dome.hBottom;

			x = metrics.rGroundBelow - metrics.rOpenBottom; 
			metrics.sideBelow = Math.sqrt( metrics.hBelow * metrics.hBelow + x * x );
			var sinX = metrics.hBelow / metrics.sideBelow;
			var sinXRad = Math.asin(sinX);

			// 
			if (isCone) {
				//metrics.extDomeIns.hActual = 0;
				metrics.hBelowActual = metrics.hBelow - lpInsForLowTBottom;
				//metrics.extDomeIns.rTopActual = metrics.extDomeIns.rTop;
			}
			/*
			else {
				const outside = (metrics.extDomeIns.r-dome.r)*Math.sin(sinXRad-Math.PI/4);
				const rads = Math.asin(outside/metrics.extDomeIns.r);
				metrics.extDomeIns.rads = Math.PI/4+2*rads; 	// why???, it is double otherwise
				metrics.extDomeIns.hActual = metrics.extDomeIns.r * (1-Math.sin(metrics.extDomeIns.rads));
	// this is shit:
	//metrics.hBelow + dome.r*Math.sin(Math.PI/4) - metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads);
	//console.log("diff="+(dome.r*Math.sin(Math.PI/4))+"-"+(metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads))+"="+(dome.r*Math.sin(Math.PI/4) - metrics.extDomeIns.r * Math.sin(metrics.extDomeIns.rads)));
				metrics.extDomeIns.rTopActual =
					metrics.rOpenBottomActual = metrics.extDomeIns.r * Math.cos(metrics.extDomeIns.rads);
				metrics.hBelowActual = metrics.hCylinder + metrics.hBelow -
					(metrics.dome.hBottom+metrics.dome.hTop-metrics.dome.r+metrics.extDomeIns.r-metrics.extDomeIns.hActual);
			}*/
			
			// V3 = hBelow * rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - hBelow * (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3;
			// => V3 = hBelow * (rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3);
			// => hBelow = V3 / (rGround / (rGround-rOpenBottom) * rGround * rGround * PI / 3 - (rGround / (rGround-rOpenBottom) - 1)*rOpenBottom*rOpenBottom*PI/3);
			//metrics.hBelow = metrics.V3 / (metrics.rGroundBelow / (metrics.rGroundBelow-metrics.rOpenBottom) * metrics.rGroundBelow * metrics.rGroundBelow * Math.PI / 3 - 
			//				(metrics.rGroundBelow / (metrics.rGroundBelow-metrics.rOpenBottom) - 1)*metrics.rOpenBottom*metrics.rOpenBottom*Math.PI/3);
			x = (metrics.rGroundBelow-metrics.insLpSides/sinX);
//console.log(x+"=("+metrics.rGroundBelow+"-"+sinX+"*"+metrics.insLpSides);
			// V1/V2==pow(r1,3)/pow(r2,3) => V2 = V1*pow(r2,3)/pow(r1,3)
			metrics.caveSide = dome.side  + metrics.domeThickness;
			metrics.rGroundBelowActual = x;
			metrics.rOpenBottomActual = metrics.rGroundBelowActual - (metrics.hBelowActual/Math.tan(Math.PI*metrics.dome.maxAngle/180));
			if (isCone) {
				metrics.sideBelowActual = metrics.sideBelow*(1-(metrics.rOpenBottomActual-metrics.rOpenBottom)/(metrics.rGroundBelow-metrics.rOpenBottom));
				if (metrics.topFillWithIceWithStorage) {
					metrics.vLpInsulation = //Math.PI*metrics.sideBelowActual*(metrics.rGroundBelow+metrics.rOpenBottomActual)*metrics.insLpSides +
											Math.PI*lpInsForLowTBottom*metrics.rOpenBottomActual*metrics.rOpenBottomActual;
											//+(metrics.topFillUsedAsWeight ? Math.PI*metrics.rGroundBelow * metrics.rGroundBelow*metrics.insLpSides : 0);
				}
				else {
					metrics.vLpInsulation = Math.PI*metrics.sideBelowActual*(metrics.rGroundBelow+metrics.rOpenBottomActual)*metrics.insLpSides
											+ Math.PI*lpInsForLowTBottom*metrics.rOpenBottomActual*metrics.rOpenBottomActual +
											(metrics.topFillUsedAsWeight ? Math.PI*metrics.rGroundBelow * metrics.rGroundBelow*metrics.insLpSides : 0);
				}
			}
			/*else {
				metrics.vLpInsulation = metrics.V3 - metrics.V3*Math.pow(x,3)/Math.pow(metrics.rGroundBelow,3) 
					+ metrics.extDome.area*metrics.ins; // approximation, but good enough for us
			}*/
			metrics.lpV3AverageGravelDensity = (metrics.lpGravelDensity *(metrics.V3-metrics.vLpInsulation) + metrics.vLpInsulation*metrics.insGravelDensity) / metrics.V3;
			metrics.highPressureStorageSurfaceArea = dome.topArea + Math.PI*dome.rBottomI*dome.rBottomI*Math.PI + dome.sideArea;
			metrics.lowPressureStorageSurfaceArea = //metrics.extDome.area + // area of top dome
													(metrics.topFillUsedAsWeight ? 
													Math.PI*metrics.rGroundBelow * metrics.rGroundBelow :
													Math.PI*metrics.rTop*metrics.rTop+
													Math.PI*metrics.sideAbove*(metrics.rGround+metrics.rTop)) + // side above ground
													Math.PI*metrics.sideBelow*(metrics.rGroundBelow+metrics.rOpenBottom)+ // side below ground
													Math.PI*metrics.rOpenBottom*metrics.rOpenBottom;
			metrics.maxHpGravelExpansionUpM = (metrics.highPressureStorageVolume*metrics.maxHpGravelExpansion)
				/(Math.PI*metrics.dome.rTopI*metrics.dome.rTopI);
			// we assume lp gravel to shrink 
			// it's simpler not to expand cone inside ball segment => cone height won't change
			// 15 MPa*25 =>
		}

/*
//console.log("metrics.testV3 = "+(metrics.rGroundBelow*metrics.rGroundBelow*Math.PI*h/3)+" - "+(metrics.rCylinder*metrics.rCylinder*(h*metrics.rCylinder/metrics.rGroundBelow)*Math.PI/3)+", h="+h);
metrics.testV3 = metrics.rGroundBelow*metrics.rGroundBelow*Math.PI*h/3 - metrics.rCylinder*metrics.rCylinder*(h*metrics.rCylinder/metrics.rGroundBelow)*Math.PI/3;
console.log("V3-testV3="+(metrics.V3-metrics.testV3));
if (Math.abs(metrics.V3-metrics.testV3)>10) {
	console.log("Test failed:"+JSON.stringify(storageMetrics)); 
	return;
}*/
		metrics.lowPressureStorageVolume = metrics.V3 - metrics.vLpInsulation + (metrics.topFillUsedAsWeight ? 0 : metrics.V4);
//console.log(metrics.lowPressureStorageVolume+" = "+metrics.V4+" + "+metrics.V3+" - "+metrics.vLpInsulation);
		var hpGravelPartNow = metrics.highPressureStorageVolume*metrics.gravelDensity
				/(metrics.highPressureStorageVolume*metrics.gravelDensity + metrics.lowPressureStorageVolume*metrics.lpGravelDensity);
//console.log("Math.abs("+hpGravelPartNow+"-"+metrics.hpGravelPart+")="+Math.abs(hpGravelPartNow-metrics.hpGravelPart)+", metrics.hpGravelPartActual="+metrics.hpGravelPartActual);
		var hpGravelPartAdjusted = false;
		if (Math.abs(hpGravelPartNow-metrics.hpGravelPart)>0.005) {
			hpGravelPartAdjusted = true;
			var old = metrics.hpGravelPartActual;
			if (hpGravelPartNow > metrics.hpGravelPart) {
//console.log(metrics.hpGravelPartActual+"*("+(1-(hpGravelPartNow-metrics.hpGravelPart))+"="+(metrics.hpGravelPartActual*(1-(hpGravelPartNow-metrics.hpGravelPart))));;
				metrics.hpGravelPartActual = metrics.hpGravelPartActual*(1-(hpGravelPartNow-metrics.hpGravelPart));
			}
			else {
//console.log(metrics.hpGravelPartActual+"*("+(1+(metrics.hpGravelPart+hpGravelPartNow))+"="+(metrics.hpGravelPartActual*(1+(metrics.hpGravelPart-hpGravelPartNow))));;
				metrics.hpGravelPartActual = metrics.hpGravelPartActual*(1+(metrics.hpGravelPart-hpGravelPartNow));
			}
console.log("hpGravelPartNow="+hpGravelPartNow+"=> adjusted hpGravelPartActual: "+old+"=>"+metrics.hpGravelPartActual);
		}
		
		if (!metrics.hpAverageGravelDensity || !metrics.hpExpectedAverageDensity || !metrics.lpV3AverageGravelDensity) {
if (!metrics.hpAverageGravelDensity) console.log("metrics.hpAverageGravelDensity="+metrics.hpAverageGravelDensity);
else if (!metrics.hpExpectedAverageDensity) console.log("metrics.hpExpectedAverageDensity="+metrics.hpExpectedAverageDensity);
else if (!metrics.lpV3AverageGravelDensity) console.log("metrics.lpV3AverageGravelDensity="+metrics.lpV3AverageGravelDensity);
console.log("Bad values:"+JSON.stringify(storageMetrics, null, 2)); 
alert("Internal error");
return null;
		}
		else if (Math.abs(metrics.hpAverageGravelDensity-metrics.hpExpectedAverageDensity)<0.01 && Math.abs(metrics.lpV3AverageGravelDensity-lpExpectedV3AverageGravelDensity)) {
//console.log("metrics.pHighActual="+metrics.pHighActual+"="+(metrics.lpGravelDensity*10000)+"*("+metrics.hAbove+"+"+metrics.hBelow+"-"+lpInsForLowTBottom+")+"+(metrics.insGravelDensity*10000)+"*("+metrics.caveTopInsulation+"+"+lpInsForLowTBottom);

//console.log(metrics.pHigh+" < "+metrics.pHighActual+"?");
			// readjust depth and height if more that 2% too much weight 
			if (loop < 10 && metrics.pHighAdjusted < metrics.pHighActual && (metrics.pHighActual-metrics.pHighAdjusted) > metrics.pHighAdjusted*0.02) {
				loop++;
console.log(loop+": Adjust LP storage weight to match high pressure, hpGravelPartAdjusted="+hpGravelPartAdjusted);
				continue;
			}
			else if (metrics.pHighActual < metrics.pHigh && (metrics.pHighActual - metrics.pHigh) > metrics.pRatioTolerance*0.05) {  // exceeds by more than 5% the set safe margin
			{
					storageSizeTons = metrics.storageSizeTons;
					metrics.storageSizeTons = metrics.storageSizeTons * sizeMultiplier * Math.pow(metrics.pHigh/metrics.pHighActual, 3);
console.log("Scaled size from "+storageSizeTons+" to "+metrics.storageSizeTons+", sizeMultiplier="+sizeMultiplier);
					scaledToVolume++;
					metrics.pHighActual = 0; 	// no adjustement when we increase the size
					sizeMultiplier *= 1.02;		// increase the min size by small steps...
			if (loop++ > 10) {
console.log(JSON.stringify(storageMetrics)); 
				alert("Cannot resolve expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity);
				return null;
			}
console.log(loop+": Increase storage size");
					continue;	// retry the loop
				}
			}
			else if (hpGravelPartAdjusted) {
				if (loop++ > 10) {
console.log(JSON.stringify(storageMetrics)); 
					console.error("Too many adjustments of metrics.hpGravelPartActual="+metrics.hpGravelPart+"=>"+metrics.hpGravelPartActual);
					return null;
				}
			}
			if (metrics.topFillUsedAsWeight) {
				metrics.lpAverageGravelDensity = 
					(metrics.lpGravelDensity *(metrics.V3-metrics.vLpInsulation) + metrics.vLpInsulation*metrics.insGravelDensity) / metrics.V3;
			} else {
				metrics.lpAverageGravelDensity = 
					(metrics.V4 * metrics.lpGravelDensity + metrics.lpGravelDensity *(metrics.V3-metrics.vLpInsulation) + metrics.vLpInsulation*metrics.insGravelDensity) / (metrics.V4 + metrics.V3);
			}
			break;
		}
		else {

console.log("Loop again: expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity+" or "+metrics.lpV3AverageGravelDensity+"<>"+lpExpectedV3AverageGravelDensity);
			if (loop++ > 20) {
console.log(JSON.stringify(storageMetrics, null, 2)); 
				alert("Cannot resolve expected density="+metrics.hpExpectedAverageDensity+" <> calclulated density="+metrics.hpAverageGravelDensity);
				return null;
			}
			metrics.hpExpectedAverageDensity = metrics.hpAverageGravelDensity;
			lpExpectedV3AverageGravelDensity = metrics.lpV3AverageGravelDensity;
console.log(loop+": Adjusting average densities");
		}
	}
	if (metrics.pHigh > metrics.pHighActual) {
		metrics.pLow = metrics.pLow*metrics.pHighActual / metrics.pHigh;
		metrics.pHigh = metrics.pHighActual;
	}
	/*
	metrics.testV4 = metrics.rGroundBelow*metrics.rGround*metrics.rGround*Math.PI/3 - metrics.rTop*metrics.rTop*metrics.rTop*Math.PI/3;
	console.log("V4-testV4="+(metrics.V4-metrics.testV4));
	if (Math.abs(metrics.V4-metrics.testV4)>10) {
		console.log("Test failed:"+JSON.stringify(storageMetrics)); 
		return;
	}*/

//console.log("pHighStorageHeight="+Math.round(metrics.pHighStorageHeight)+", highPressureStorageVolume Mm3="+Math.round(metrics.highPressureStorageVolume/1000000)+
//		", hpAverageGravelDensity="+myRound(metrics.hpAverageGravelDensity,2));
		// Above ground expansion of gravel V4:

	// TBD: chargeLevel = 0 - 1		// charge level of hot storage
	// Hight<0 == below => decrease the in/out pressure, height>0 == above => increments in/out pressure
	if (generatorLocation == 'TOP') {
		metrics.pipeFromColdCompressor = metrics.rCylinder + metrics.hCylinder + metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;
		metrics.heightOfColdCompressorOut = -(chargeLevel * metrics.hCylinder + metrics.hBelow + metrics.hAbove);
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = -(1-chargeLevel) * (metrics.hBelow+metrics.hAbove-20+5);	// 20 m insulation in the bottom and 5 m in the top
		metrics.heightAboveColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove-20+5);
		metrics.pipeToColdCompressor = (metrics.hBelow+metrics.hAbove-20+5) + 20; // height and some extra

		metrics.heightOfMainTurbinIn = -(metrics.hBelow+metrics.hAbove+15);	// 10 m insulation, 5 m for machinery
		metrics.pipeToMainTurbin = (metrics.hBelow+metrics.hAbove+15)+50;	// some extra
		metrics.heightOfMainTurbinOut = -10;	// 5 m insulation and some extra 
		metrics.pipeFromMainTurbin = 20;	// height and some extra 
	}	
	else if (generatorLocation == 'GROUND') {
		metrics.pipeFromColdCompressor = metrics.sideBelow + metrics.caveSide + 50;
		metrics.heightOfColdCompressorOut = -chargeLevel * metrics.hCylinder+metrics.domeThickness+metrics.hBelow;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder+metrics.domeThickness+metrics.hBelow;
		metrics.heightOfColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove) - metrics.hAbove;
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove) + metrics.hAbove;
		metrics.pipeToColdCompressor = metrics.sideBelow + 50;
		metrics.heightOfMainTurbinIn = metrics.hBelow + metrics.domeThickness;	// 
		metrics.pipeToMainTurbin = metrics.sideBelow + metrics.domeThickness + metrics.rOpenBottom + 20;	// some extra
		metrics.heightOfMainTurbinOut = 20;
		metrics.pipeFromMainTurbin =  20;	// height and some extra 
	}
	else if (generatorLocation == 'MIDDLE') {
		metrics.pipeFromColdCompressor = metrics.caveSide + 50;
		metrics.heightOfColdCompressorOut = -chargeLevel * metrics.hCylinder;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = chargeLevel * (metrics.hBelow+metrics.hAbove);		// insulation
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeToColdCompressor = metrics.rOpenBottom + 20;

		metrics.heightOfMainTurbinIn = -10;	// 
		metrics.pipeToMainTurbin = metrics.rCylinder + 20;	// some extra
		metrics.heightOfMainTurbinOut = metrics.hBelow + metrics.hAbove;
		metrics.pipeFromMainTurbin = metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;	// height and some extra 
	}
	else if (generatorLocation == 'BOTTOM') {
		metrics.pipeFromColdCompressor = metrics.rCylinder + 20;
		metrics.heightOfColdCompressorOut = (1-chargeLevel) * metrics.hCylinder;
		metrics.heightAboveColdCompressorOut = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdCompressorIn = metrics.hCylinder + chargeLevel * (metrics.hBelow+metrics.hAbove);
		metrics.heightAboveColdCompressorIn = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeToColdCompressor = metrics.rCylinder + metrics.hCylinder + 20;

		metrics.heightOfMainTurbinIn = metrics.hCylinder;
		metrics.pipeToMainTurbin = metrics.caveSide + metrics.rCylinder + 20;	// some extra
		metrics.heightOfMainTurbinOut = metrics.hCylinder + metrics.hBelow + metrics.hAbove;
		metrics.pipeFromMainTurbin = metrics.caveSide +  metrics.sideAbove + metrics.sideBelow + metrics.rTop + 20;	// height and some extra 
	}
	
	if (coldExpanderLocation == 'BOTTOM') {
		metrics.pipeToColdExpander = metrics.rCylinder + 20;
		metrics.heightOfColdExpanderIn = (1-chargeLevel) * metrics.hCylinder;
		metrics.heightAboveColdExpanderIn = chargeLevel * metrics.hCylinder;
		metrics.heightOfColdExpanderOut = metrics.hCylinder + chargeLevel * (metrics.hBelow+metrics.hAbove);
		metrics.heightAboveColdExpanderOut = (1-chargeLevel) * (metrics.hBelow+metrics.hAbove);
		metrics.pipeFromColdExpander = metrics.rCylinder + metrics.hCylinder + 20;
	}
	else {
		metrics.pipeToColdExpander = metrics.pipeFromColdCompressor; 
		metrics.heightOfColdExpanderIn = metrics.heightOfColdCompressorOut;
		metrics.heightAboveColdExpanderIn = metrics.heightAboveColdCompressorOut;
		metrics.heightOfColdExpanderOut = metrics.heightOfColdCompressorIn; 
		metrics.heightAboveColdExpanderOut = metrics.heightAboveColdCompressorIn; 
		metrics.pipeFromColdExpander = metrics.pipeToColdCompressor;
	}
	metrics.heightOfMainCompressorOut = metrics.heightOfMainTurbinIn;
	metrics.pipeToMainCompressor = metrics.pipeFromMainTurbin;
	metrics.heightOfMainCompressorIn = metrics.heightOfMainTurbinOut;
	metrics.pipeFromMainCompressor = metrics.pipeToMainTurbin;

	// Kartion vaipan pinta-ala = PI * r * s, jossa s = sqrt(r*r + h*h), 
	// Leikatun kartion vaipan apinta.ala = PI * r * s - PI * r2 * s2, jossa r2 ja s2 ovat leikatun kartion säde ja sivun pituus
console.log(JSON.stringify(storageMetrics, null, 2)); 
/*
	if (typeof pRatio === 'undefined' && typeof hpStorageSizeRockMm3 === 'undefined') {
		document.getElementById('pHigh_kPa').value = metrics.pHigh/1000;
		document.getElementById('pLow_kPa').value = metrics.pLow/1000;
		document.getElementById('radius').value = metrics.rCylinder;
		document.getElementById("storageDimensions").text = 
"pHigh: "+Math.round(metrics.pHigh/1000)+" kPa, pLow: "+Math.round(metrics.pLow/1000)+" kPa. Low pressure storage above ground height: "+Math.round(metrics.hAbove)+" m and top radius: "+Math.round(metrics.rTop)
+".<br>Its ground level radius: "+Math.round(metrics.rGround)+" and below ground depth: "+Math.round(metrics.hAbove)
+" m.<br>High pressure storage (cylinder) radius: "+Math.round(metrics.rCylinder)+" m, height: "+Math.round(metrics.hCylinder)+"m and its average density: "+myRound(metrics.hpAverageGravelDensity,2);
console.log("heightBelow="+Math.round(metrics.hBelow));
console.log("heightAbove ground="+Math.round(metrics.hAbove)+" m");
console.log("lowPressure storage height="+Math.round(metrics.hBelow+metrics.hAbove)+" m" );
console.log("highPressureStorageSurfaceArea="+Math.round(metrics.highPressureStorageSurfaceArea));
console.log("lowPressureStorageSurfaceArea="+Math.round(metrics.lowPressureStorageSurfaceArea));
	}
*/
	return metrics;
}	

	function getColdStoragePressureDrop(partOfTotalLength, visc, gasDensity, flow, rActual, p, t) {
		const r = rActual ? rActual : metrics.rCylinder;
		const x1 = flow / (r * r * Math.PI);
		const L1 = (metrics.hBelowActual+(metrics.topFillUsedAsWeight ? 0 : metrics.hAbove))*partOfTotalLength;
		return calcPressureDropInGravel('Lp', x1, visc, gasDensity, L1, p, t );
/*
		const porosity = 1 - metrics.hpAverageGravelDensity/metrics.rockDensity;	// free space in gravel between 0-1
		const Re = gasDensity * x1 * 0.015 / (visc*porosity);
//console.log("Reynold's number in low pressure storage:"+Re);
		// Darcy's law: deltaP = L*Q*visc/(-k*A);	
		return L1 * visc/0.000018*(1927*x1*x1+324*x1)*gasDensity/1.2;	// scale air deinity 1.2 kg/m3 to the actual density
*/
	}
	function getHotStoragePressureDrop(partOfTotalLength, visc, gasDensity, flow, rActual, p, t) {
		const r = rActual ? rActual : (partOfTotalLength > 0.5 ? (metrics.dome.rTopI+2*metrics.dome.rBottomI)/3 : (metrics.dome.rTopI*2+metrics.dome.rBottomI)/3);  // worst case
		const L1 = metrics.dome.hBottomI*partOfTotalLength;
		const x1 = flow / (r * r * Math.PI);
		return calcPressureDropInGravel('Hp', x1, visc, gasDensity, L1, p, t );
/*
		const porosity = 1 - metrics.gravelDensity/metrics.rockDensity;	// free space in gravel between 0-1
		const Re = gasDensity * x1 * 0.003 / (visc*porosity);
console.log("Reynold's number in high pressure storage:"+Re);
		// Darcy's law: deltaP = L*Q*visc/(-k*A);	
		return L1 * visc/0.000018*(3342*x1*x1+305*x1)*gasDensity/1.2;	// scale air density 1.2 kg/m3 to the actual density
*/
	}
	function getPipePressureDrop(visc, density, flow, diameter, length, height, heightAbove, densityAbove ) {
			const epsilon = getFloatParam("epsilon", 0.025); 	// for 0.0025 == drawn tube
		
			flow = flow / metrics.cUnits;
			const speed = flow / (Math.PI*diameter*diameter/4);
			// Renolds number: 
			const Re = density*speed*diameter / visc;	// Reinolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
			// Darcy–Weisbach friction factor by Tkachenko, Mileikovskyi 2020 for 2320 <= Re <= 1000000000
			const A0 = -0.79638*Math.log(epsilon/(diameter*8.208) + 7.3357/Re);
			const A1 = Re*(epsilon/diameter) + 9.3120665*A0;
			const f = Math.pow((8.128943+A1)/(8.128943*A0-0.86859209*A1*Math.log(A1/(3.7099535*Re))), 2);
	if (height) console.log( "9.81*"+density+"*"+height+"="+ (9.81*density*height));
	if (densityAbove) console.log("9.81*"+densityAbove+"*"+heightAbove+"="+(9.81*densityAbove*heightAbove));

			// Pressure drop with Darcy–Weisbach friction factor f:  
			return f*length/diameter*density*Math.pow(speed,2)/2  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
				   + (height ? 9.81*density*height : 0) 		//	Head-loss form: deltaP=g*density*height 
				   - (densityAbove ? 9.81*densityAbove*heightAbove : 0);
	}
	function getHeadLossPT( p, t, height ) {
		const density = Module.PropsSI('D', 'P', p, 'T', t, name);
		return 9.81*density*height;
	}
	function getHeadLoss( density, height ) {
		return 9.81*density*height;
	}
	function getExternalIceStorage(tMin) {
		var ret = {};
		ret.solidPart = metrics.crushedIceDensity;
		ret.height = getFloatParam('iceStorageHeight', 50); // (metrics.hAbove+metrics.hBelowActual);
		ret.totalMassInTons = metrics.lowPressureStorageVolume * metrics.lpGravelDensity * getFloatParam("iceStorageSize", 66) / 100;
		ret.sizeM3 = ret.totalMassInTons/(0.93 * ret.solidPart); 	// assume crushed ice to have same density as low pressure gravel
		const rTest = Math.pow(ret.sizeM3/(ret.height*Math.PI), 1/2); 
		testResult( ret.sizeM3, rTest, rTest*2, 0.01*ret.sizeM3, 
			function(r) {
				ret.rBottom = r;
				ret.rTop = ret.rBottom - ret.height/metrics.topFillTan;
				return Math.PI/3*ret.height*(ret.rBottom*ret.rBottom + ret.rBottom*ret.rTop + ret.rTop*ret.rTop);
			});
		ret.side = Math.sqrt(ret.height*ret.height + (ret.rBottom-ret.rTop)*(ret.rBottom-ret.rTop));
		ret.sideArea = Math.PI*ret.side*(ret.rBottom+ret.rTop);
		ret.topArea =  Math.PI*ret.rTop*ret.rTop;
		ret.sideWidth = 15;
		const rExtBottom = ret.rBottom+ret.sideWidth;
		const rExtTop = ret.rTop+ret.sideWidth;
		ret.sideVolume = Math.PI/3*ret.height*(rExtBottom*rExtBottom + rExtBottom*rExtTop + rExtTop*rExtTop) - ret.sizeM3;
		ret.earthWorkVolume = (ret.sideVolume*2.1/2.65);
		ret.depth = ret.earthWorkVolume / (Math.PI*rExtBottom*rExtBottom);

		const uValueInCold = 0.030; // u-value decrease in very cold
		const insluationCostPerM3 = 30; 

		// XPS min temperature is -50 => gravel+biochar/rock wool must be used inner parts!!!
		ret.insForTop = (280-tMin)*uValueInCold/metrics.maxHeatFlowOut;	// about 25% can be done with XPS having at least three times better U-value/euro
		ret.insForBottom = (280-tMin)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;
		ret.insForSide = (280-tMin)*uValueInCold/metrics.maxHeatFlowOut; // + 10 m frozen gravel earth mix
		const costOfColdChannelsM2 = getFloatParam('costOfColdChannelsM2', getFloatParam('costOfChannelsM2', 25)/ 4);	// 25 % of hot channel cost 
		ret.getArea = function( h ) {
			const r = this.rTop + (this.rBottom-this.rTop)* (this.height-h) / this.height;
			return r*r*Math.PI;
		};
		// ice is produced with 1.3m * 
		console.log("walls:"+ (metrics.costOfMiningM3*ret.earthWorkVolume) +
				   "\n\rchannels:"+ (0.25 * costOfColdChannelsM2*(ret.getArea(0) + ret.getArea(ret.height))) + 
				   "\n\rIce storage insulation:"+getFloatParam('costOfInsulationM3', 25)*(ret.getArea(0)*ret.insForBottom) + insluationCostPerM3*(ret.insForTop*ret.getArea(ret.height)+ret.sideArea*ret.insForSide)+
				   "\n\rIce storage wall and roof:"+ getFloatParam('costOfIceStorageWallAndRoofIceM2', 100)*(ret.getArea(ret.height)+ret.sideArea)+
				   "\n\rIce work cost:" + (ret.totalMassInTons * getFloatParam("iceWorkCostPerTon", 3))); // 
		ret.cost = metrics.costOfMiningM3*ret.earthWorkVolume + 	// earth walls and cover of ice
				   0.25 * costOfColdChannelsM2*(ret.getArea(0) + ret.getArea(ret.height)) + // Frozen earth can be used instead of concrete, and channel network simpler too, estimate cost 25% of hot channels
				   getFloatParam('costOfInsulationM3', 25)*(ret.getArea(0)*ret.insForBottom) + insluationCostPerM3*(ret.insForTop*ret.getArea(ret.height)+ret.sideArea*ret.insForSide)	// insulation cost
				   + getFloatParam('costOfIceStorageWallAndRoofIceM2', 100)*(ret.getArea(ret.height)+ret.sideArea)
				   + ret.totalMassInTons * getFloatParam("iceWorkCostPerTon", 4); // depends on distance of the ice 
console.log("External ice storage:"+JSON.stringify(ret, null, 2));
		return ret;
	}

	function calcIceStorage( massFlowKg, hours, tMin, tMax, pLow, params ) {
		params = params ? params : {};
		var ret = {};
		ret.tMax = tMax;
		ret.tMin = tMin;
		//ret.flowChannels = params.flowChannels ? params.flowChannels : 0.04;	// lets assume, that 4% of volume  is used for flow channels
		//ret.channelWidth = params.channelWidth ? oarams.channelWidth : 0.005;	// 
		ret.solidPart = metrics.crushedIceDensity;
		ret.height = params.height ? params.height : 50;
		ret.heAreaPerM3 = 2 * ret.flowChannels/ret.channelWidth;  // 2 sides!
		ret.averageCp=(getIceHeatCapasityKJinKgK(tMin)+getIceHeatCapasityKJinKgK(tMax)) / 2;	// kJ/L
		ret.hcJPerTon = (tMax-tMin)*ret.averageCp*1000*1000;	// KJ => J, kg => ton
		ret.massFlowKg = massFlowKg;
		ret.pLow = pLow;
		const tSat = Module.PropsSI('T', 'P', pLow, 'Q', 1, name);
		if (tMin <= tSat) {
			tMin = tSat + 0.1;
console.log("tMin changed, tSat="+tSat);
		}
		ret.gasDeltaH = (Module.PropsSI('H', 'P', pLow, 'T', tMax, name)-Module.PropsSI('H', 'P', pLow, 'T', tMin, name));
		ret.hePower = massFlowKg*ret.gasDeltaH;
		ret.hours = hours;
		ret.capasityInJoules = ret.hePower*hours*3600;
		ret.totalMassInTons = 1.1 * ret.capasityInJoules/ret.hcJPerTon;	// 1.1 to compensate small cp in tSat (See Debye's model)
		ret.sizeM3 = ret.totalMassInTons/(0.93 * ret.solidPart); 	// assume crushed ice to have same density as low pressure gravel
		ret.areaM2 = ret.sizeM3 / ret.height;
		const flowArea = ret.areaM2 * (1 - ret.solidPart);
		const densityMin = Module.PropsSI('D', 'P', pLow, 'T', tMin, name);
		const densityMax = Module.PropsSI('D', 'P', pLow, 'T', tMax, name);
		ret.speedMin = massFlowKg / densityMin / flowArea;
		ret.speedMax = massFlowKg / densityMax / flowArea;
		ret.pDropMin = calcPressureDropInGravel("Hp", ret.speedMin, Module.PropsSI('V', 'P', pLow, 'T', tMin, name), densityMin, 1, pLow, tMin );
		ret.pDropMax = calcPressureDropInGravel("Hp", ret.speedMax, Module.PropsSI('V', 'P', pLow, 'T', tMin, name), densityMax, 1, pLow, tMin );
		ret.pDrop = ret.pDropMin*ret.height/2 + ret.pDropMax*ret.height/2;
		
		/*
		const tMid = (tMin+tMax) / 2;
		const density = Module.PropsSI('D', 'P', pLow, 'T', tMid, name);
		const prantdl = Module.PropsSI('PRANDTL', 'P', pLow, 'T', tMid, name);
		const conductivity = Module.PropsSI('conductivity', 'P', pLow, 'T', tMid, name);
		const visc = Module.PropsSI('V', 'P', pLow, 'T', tMid, name);
		ret.hD = 4 * ret.flowChannels*ret.channelWidth / (ret.flowChannels * (ret.flowChannels/ret.channelWidth)); // == ret.channelWidth;
		ret.ReD = density*ret.speed*ret.hD/visc;
		ret.NuD = 8.23; 	// approximation, it would be 8.23 fully developed laminar flow, 
		ret.NuCalc = 0.664*Math.pow(ret.ReD,1/2)*Math.pow(prantdl,1/3);
		ret.htCoefficient = ret.NuD*conductivity/ret.hD;
		ret.heatFlowPerKinMeter = ret.heAreaPerM3*ret.areaM2*ret.htCoefficient;
		const f = ret.ReD/90;	// about, aspect ratio 40
		ret.pressureDrop = f * ret.height / ret.hD * (density*ret.speed*ret.speed/2);
		*/
		//  Design: depth 30% of height
		// earthwork volume: the storage is a square
		ret.side = Math.sqrt(ret.areaM2);			// 
		// XPS min temperature is -50 => gravel+biochar/rock wool must be used inner parts!!!
		ret.insForTop = (280-tMax)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut*0.75;	// about 50% can be done with XPS having at least three times better U-value/euro
		ret.insForBottom = (280-tMin)*metrics.uOfGravelrockwoolMix/metrics.maxHeatFlowOut;

		testResult( 0, 0, ret.height, 0.01*ret.sizeM3, 
				function(depth) {
					// 4 m earth on the top
					ret.earthWorkHeight = ret.height - depth + ret.insForBottom + 1 + 4;	// 1 m for bottom channels, 4 m for top cover and channels
					ret.earthWorkVolume = 4 * ret.side * ret.earthWorkHeight*ret.earthWorkHeight / 2;	// the slope has >45 degree angle
					ret.depth = depth;
					return ret.areaM2*depth*(2.6/2) - ret.earthWorkVolume;
				});
		//ret.freezingFrameAreaM2 = 0.05 * ret.areaM2; // freezing going on 5% of top area
		const costOfColdChannelsM2 = getFloatParam('costOfColdChannelsM2', getFloatParam('costOfChannelsM2', 25)/ 4);	// 25 % of hot channel cost 
		// ice is produced with 1.3m * 
		console.log("earth walls:"+ (getFloatParam("costOfEarthWorkM3",metrics.costOfMiningM3/2) *ret.earthWorkVolume) +
				   "\n\rchannels:"+ (2 * costOfColdChannelsM2*ret.areaM2) + 
				   "\n\rIce storage cover and insulation:"+(getFloatParam('costOfInsulationM3', 25)*ret.areaM2*(ret.insForTop+ret.insForBottom)) +
				   "\n\rwork cost:" + (ret.totalMassInTons * getFloatParam("iceWorkCostPerTon", 3))); // 
		ret.cost = metrics.costOfMiningM3*ret.depth*ret.areaM2 + 	// earth walls and cover of ice
				   0.25 * 2 * costOfColdChannelsM2*ret.areaM2 + // Frozen earth can be used instead of concrete, and channel network simpler too, estimate cost 25% of hot channels
				   getFloatParam('costOfInsulationM3', 25)*ret.areaM2*(ret.insForTop+ret.insForBottom)+	// insulation cost
				   + ret.totalMassInTons * getFloatParam("iceWorkCostPerTon", 4); // 
console.log("Ice storage:"+JSON.stringify(ret, null, 2));
		return ret;
	}

	// {sheetThickness : 0.0002, diameter : 0.0004, sheetDistance :0.0006)
	function calcHeatExchanger( pLowFluidMassFlowKg, tHot, tCold, pHigh, pLow, maxPressurDropPercent, params, title ) {
		// heat exchanger is built from 2m*1m*1m units. Both sides as 0.25m2 cross flow area and in/out pipes 
		// hot gas up side and cold down side 
		const pLowFluid = params && params.pLowFluid  ? params.pLowFluid : name;
		const pHighFluid = params && params.pHighFluid  ? params.pHighFluid : pLowFluid;
		const heatExchangeDeltaT = params && params.heatExchangeDeltaT ? params.heatExchangeDeltaT : metrics.heatExchangeDeltaT;
		const tHotHigh = params && params.tHotHigh ? params.tHotHigh : tHot - heatExchangeDeltaT;
		const tColdHigh = params && params.tColdHigh ? params.tColdHigh : tCold - heatExchangeDeltaT;
		const sheetThickness = params && params.sheetThickness ? params.sheetThickness : 0.00005;	// 0.5 mm
		//const heatTransferPerM2 = 25*metrics.heatExchangeDeltaT; // W/m2/K, air heat exgange coefficient at 2 m/s, 
		//const epsilon = getFloatParam("epsilonHE", 0.0025); 	// for 0.0025 drawn tube, OK for aluminum or steel sheets
		const sheetDistance = params && params.sheetDistance ? params.sheetDistance :0.0005;  //
		const hpCrossArea = params && params.hpCrossArea ? params.hpCrossArea : 0.25;
		const panelsPerM2 = 2 / sheetDistance;
		//const htLength = 2;	// counter flow area
		//const length = 2+Math.sqrt(1);	// add cross length
		const pLowDeltaH = Module.PropsSI('H', 'P', pLow, 'T', tHot, pLowFluid)-Module.PropsSI('H', 'P', pLow, 'T', tCold, pLowFluid);
		const pHighFluidMassFlowKg = pLowFluid == pHighFluid ? pLowFluidMassFlowKg :
			pLowFluidMassFlowKg * pLowDeltaH / (Module.PropsSI('H', 'P', pHigh, 'T', tHotHigh, pHighFluid)-Module.PropsSI('H', 'P', pHigh, 'T', tColdHigh, pHighFluid));
		const pHigh_hIn = Module.PropsSI('H', 'P', pHigh, 'T', tHotHigh, pHighFluid);
		const deltaH = pHigh_hIn - Module.PropsSI('H', 'P', pHigh, 'T', tColdHigh, pHighFluid);
		const heatExchangePower = deltaH * pLowFluidMassFlowKg;
		const viscColdLowP = Module.PropsSI('V', 'P', pLow, 'T', tCold, pLowFluid);
		const viscHotLowP = Module.PropsSI('V', 'P', pLow, 'T', tHot, pLowFluid);
		const viscColdHighP= Module.PropsSI('V', 'P', pHigh, 'T', tCold, pHighFluid);
		const viscHotHighP= Module.PropsSI('V', 'P', pHigh, 'T', tHot, pHighFluid);

		const dColdLowP = Module.PropsSI('D', 'P', pLow, 'T', tCold, pLowFluid);
		const dHotLowP = Module.PropsSI('D', 'P', pLow, 'T', tHot, pLowFluid);
		const dColdHighP= Module.PropsSI('D', 'P', pHigh, 'T', tCold, pHighFluid);
		const dHotHighP= Module.PropsSI('D', 'P', pHigh, 'T', tHot, pHighFluid);

		const prantdlColdLowP = Module.PropsSI('PRANDTL', 'P', pLow, 'T', tCold, pLowFluid);
		const prantdlHotLowP =  Module.PropsSI('PRANDTL', 'P', pLow, 'T', tHot, pLowFluid);
		const prantdlColdHighP= Module.PropsSI('PRANDTL', 'P', pHigh, 'T', tCold, pHighFluid);
		const prantdlHotHighP=  Module.PropsSI('PRANDTL', 'P', pHigh, 'T', tHot, pHighFluid);

		const conductivityColdLowP = Module.PropsSI('conductivity', 'P', pLow, 'T', tCold, pLowFluid);
		const conductivityHotLowP =  Module.PropsSI('conductivity', 'P', pLow, 'T', tHot, pLowFluid);
		const conductivityColdHighP= Module.PropsSI('conductivity', 'P', pHigh, 'T', tCold, pHighFluid);
		const conductivityHotHighP=  Module.PropsSI('conductivity', 'P', pHigh, 'T', tHot, pHighFluid);
		const metalHeatCoefficient = params && params.metalHeatCoefficient ? params.metalHeatCoefficient : 80.5; // steel at 20 C

		const tMid = (tCold+tHot) / 2;
		const dMidLowP = Module.PropsSI('D', 'P', pLow, 'T', tMid, pLowFluid);
		const dMidHighP= Module.PropsSI('D', 'P', pHigh, 'T', tMid, pHighFluid);
		const prantdlMidLowP = Module.PropsSI('PRANDTL', 'P', pLow, 'T', tMid, pLowFluid);
		const prantdlMidHighP= Module.PropsSI('PRANDTL', 'P', pHigh, 'T', tMid, pHighFluid);
		const conductivityMidLowP = Module.PropsSI('conductivity', 'P', pLow, 'T', tMid, pLowFluid);
		const conductivityMidHighP= Module.PropsSI('conductivity', 'P', pHigh, 'T', tMid, pHighFluid);
		const viscMidLowP = Module.PropsSI('V', 'P', pLow, 'T', tMid, pLowFluid);
		const viscMidHighP= Module.PropsSI('V', 'P', pHigh, 'T', tMid, pHighFluid);
 
		// we calc pipe diameter by dHotLowP/dHotHighP relation, pipe distance is dimeter*Math.PI/2 
		// and pipe thickess is  2*sheetThickness/Math.PI (original volume
		// Rectagle sheetDistance*sheetDistance has 
		// Total inner area A = sheetDistance*(sheetDistance - 2*sheetThickness)
		const totA = sheetDistance*(sheetDistance - 2*sheetThickness);
		// totA = pipeA + pipeA*dHotHighP/dHotLowP =>
		const pipeA = totA*hpCrossArea; // 3*totA/(1+dHotHighP/dHotLowP);
		// pipeA = n * r*r*PI, sheetDistance = n*r*PI => pipeA = r*sheetDistance => r = pipeA/sheetDistance
		const diameter = 2 * pipeA/sheetDistance;
		const pipesPerSheetDistance = pipeA*4 / (diameter*diameter*Math.PI);
		var totalFlowAreaPart = sheetDistance*(sheetDistance - 2*sheetThickness) / (sheetDistance*sheetDistance);
		var innerPipeAreaPerM2 = pipeA / (sheetDistance*sheetDistance);
		var innerPipePerimeterM2 = pipesPerSheetDistance * diameter * Math.PI / (sheetDistance*sheetDistance);
		var outerFlowAreaPart = totalFlowAreaPart - innerPipeAreaPerM2;
		// outer perimeter elongation:  (2*r*PI - 2*r) / (r*PI) = 2 - 2/PI
		const outerPerimeterElongation = 2 - 2/Math.PI;

console.debug("totA="+totA+", pipeA="+pipeA+", diameter="+diameter+", totalFlowAreaPart="+totalFlowAreaPart+", innerPipeAreaPerM2="+innerPipeAreaPerM2+", outerFlowAreaPart="+outerFlowAreaPart+" outerPerimeterElongation="+outerPerimeterElongation);
		//const innerPipeAreaPerM2 = Math.pow(diameter/2,2)*Math.PI*panelsPerM2/(Math.PI*diameter/2);
		//console.log("innerPipeAreaPerM2="+innerPipeAreaPerM2);

//console.log("heatExchangePower="+heatExchangePower+", massFlowKg="+massFlowKg);
		const flowF = function (diameter, getInnerHtCoefficient, visc, density, prantdl, conductivity, massFlowKg ) {
			var ret = {};
			ret.sheetThickness = sheetThickness;
			ret.sheetDistance = sheetDistance;
			ret.massFlowKg = massFlowKg;
			ret.flow = massFlowKg / density;
			ret.prantdl = prantdl;
			ret.innerPipePerimeterM2 = innerPipePerimeterM2;
			ret.innerPipeAreaPerM2 = innerPipeAreaPerM2;
			ret.deltaH = deltaH;
			ret.pHigh = pHigh;
			const r = diameter/2 + sheetThickness;
			const width = r*Math.PI;	// width of single double half-pipe and metal sheet in both sides
			const extraArea = sheetThickness*(width-2*r); // cross area of metal sheet between the pipes
			// calc the length from 
			const maxPressureDrop = pLow*maxPressurDropPercent;
			ret.maxPressureDrop = maxPressureDrop;

			testResult( maxPressureDrop, 0, 10, 0.01*maxPressureDrop, 
				function(speed) {
					ret.speed = speed;
					const lpFlowArea = ret.flow / speed;
					ret.externalAreaPerM2 = outerFlowAreaPart; // (width*sheetDistance / (sheetDistance*width - extraArea - r*r*Math.PI));
					ret.totalCrossAreaM2 = lpFlowArea / ret.externalAreaPerM2;
					ret.wettedPermeterM2 = 2 * outerPerimeterElongation / sheetDistance;
					ret.wettedPermeter = ret.wettedPermeterM2 * ret.totalCrossAreaM2;
					ret.hD = 4*lpFlowArea / ret.wettedPermeter;
					ret.ReLow = density*speed*ret.hD/visc;
					// hydraulic diameter < 1 mm
					// https://en.wikipedia.org/wiki/Micro_heat_exchanger
					// Let's assume constant heat flux and NuD outside pipes is the same as inside the pipe (it is probably bigger) 
					//ret.NuDCalcLow = 0.664*Math.pow(ret.ReLow,1/2)*Math.pow(prantdl,1/3);
					// see Fundamentals of Heat and Mass Transfer, 6e. Table 8.1 page 
					ret.NuD = 7.5; 	// approximation, it would be 8.23 fully developed laminar flow, 

					// https://calcdevice.com/forced-convection-of-inner-pipe-surface-id130.html
					// laminar/turbulent flow
						//ret.ReD > 2900 ? 	// fully turbulent flow in pipe (and other small enclosures) 
						//(0.021*Math.pow(ret.prantdl,0.43)*Math.pow(ret.ReD,0.8)) :	// for turbulent flow
						//(0.15*Math.pow(ret.prantdl,0.43)*Math.pow(ret.ReD,1/3));	// for laminar flow
						// For forced laminar flow over isothermal plate, 
						// Fundamentals of Heat and Mass Transfer, 7.30, ed 6, page 410, Pr >= 0.60
						// 0.664*Math.pow(ret.ReD,1/2)*Math.pow(ret.prantdl,1/3)
					ret.innerHtCoefficient = getInnerHtCoefficient(ret.totalCrossAreaM2);
					ret.externalHtCoefficient = ret.NuD*conductivity/ret.hD;
					//ret.htCoefficient = 1 / (1/ret.innerHtCoefficient + 1/ret.externalHtCoefficient);
					// Ignore 1 mm metal between, its htCoefficient > 50000 W/K/m, only the gas matters
					// 1/heatExchangePower = 1/(ret.totalCrossAreaM2*ret.wettedPermeterM2*length*ret.externalHtCoefficient*heatExchangeDeltaT/2) 
					// 						 +1/(ret.totalCrossAreaM2*innerPipePerimeterM2*length*ret.innerHtCoefficient*heatExchangeDeltaT/2)
					// => length = heatExchangePower/(ret.totalCrossAreaM2*ret.wettedPermeterM2*ret.externalHtCoefficient*heatExchangeDeltaT) 
					// 				+ heatExchangePower/(ret.totalCrossAreaM2*innerPipePerimeterM2*ret.innerHtCoefficient*heatExchangeDeltaT)
					ret.innerHeatFlowPerKinM3 = innerPipePerimeterM2*ret.innerHtCoefficient;
					ret.outerHeatFlowPerKinM3 = ret.wettedPermeterM2*ret.externalHtCoefficient;
					ret.actualHtLength = heatExchangePower/(ret.totalCrossAreaM2*ret.wettedPermeterM2*ret.externalHtCoefficient*heatExchangeDeltaT/2) 
										+ heatExchangePower/(ret.totalCrossAreaM2*innerPipePerimeterM2*ret.innerHtCoefficient*heatExchangeDeltaT/2);
					//ret.actualHtLength *= 1.5; // increase the length because of cross flow of the micro tube plate shell
					ret.length = ret.actualHtLength * Math.sqrt(0.5*0.5 + 1);	// add the cross flow length
					// https://pipingtechs.com/heat-exchanger-pressure-drop/
					const f = 90/ret.ReLow;	// k=64 for fully developed  laminar flow in pipe
					ret.pDropLow = f * ret.length / ret.hD * (density*ret.speed*ret.speed/2);
					return ret.pDropLow;
				}, 15);
			ret.volumeM3 = ret.totalCrossAreaM2*ret.length;
			return ret;
		}
/*
		const flowTP = function (massFlowKg, t, p ) {
			innerHtCoefficient = function (crossAreaM2) {
				const visc= Module.PropsSI('V', 'P', p, 'T', t, name);
				const d= Module.PropsSI('D', 'P', p, 'T', t, name);
				//const prantdl=  Module.PropsSI('PRANDTL', 'P', p, 'T', t, name);
				const conductivity=  Module.PropsSI('conductivity', 'P', p, 'T', t, name);
				const flow = massFlowKg / d;
				const speed = flow / (crossAreaM2 * innerPipeAreaPerM2);
				const ReD = d*speed*diameter/visc;
				const NuD = 4.36;	// fully developed laminar flow
							//ret.ReD > 2900 ? 	// fully turbulent flow in pipe (and other small enclosures) 
							//(0.021*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,0.8)) :
							//(0.15*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,1/3));
				return NuD*conductivity/diameter;
			}
//console.log("ReD="+ReD+", NuD="+NuD+"="+(0.021*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,0.8))+", conductivityMidHighP="+conductivityMidHighP+", prantdlMidHighP="+prantdlMidHighP+", diameter="+diameter+"=>innerHtCoefficient="+innerHtCoefficient);
			return flowF(diameter, innerHtCoefficient, visc, d, prantdl, conductivity, massFlowKg);
		}
		const flowMidF = function () {
			innerHtCoefficient = function (crossAreaM2) {
				const flow = massFlowKg / dMidHighP;
				const speed = flow / (crossAreaM2 * innerPipeAreaPerM2);
				const ReD = dMidHighP*speed*diameter/viscMidHighP;
				const NuD = 4.36;	// fully developed laminar flow
							//ret.ReD > 2900 ? 	// fully turbulent flow in pipe (and other small enclosures) 
							//(0.021*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,0.8)) :
							//(0.15*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,1/3));
				return NuD*conductivityMidHighP/diameter;
			}
//console.log("ReD="+ReD+", NuD="+NuD+"="+(0.021*Math.pow(prantdlMidHighP,0.43)*Math.pow(ReD,0.8))+", conductivityMidHighP="+conductivityMidHighP+", prantdlMidHighP="+prantdlMidHighP+", diameter="+diameter+"=>innerHtCoefficient="+innerHtCoefficient);
			return flowF(diameter, innerHtCoefficient, viscMidLowP, dMidLowP, prantdlMidLowP, conductivityMidLowP, massFlowKg);
		}
*/
		const flowColdF = function () {
			innerHtCoefficient = function (crossAreaM2) {
				const flow = pHighFluidMassFlowKg / dColdHighP;
				const speed = flow / (crossAreaM2 * innerPipeAreaPerM2);
				const ReD = dColdHighP*speed*diameter/viscColdHighP;
				const NuD = 4.36;	// fully developed laminar flow
							//ret.ReD > 2900 ? 	// fully turbulent flow in pipe (and other small enclosures) 
							//(0.021*Math.pow(prantdlColdHighP,0.43)*Math.pow(ReD,0.8)) :
							//(0.15*Math.pow(prantdlColdHighP,0.43)*Math.pow(ReD,1/3));
				return NuD*conductivityColdHighP/diameter;
			}
//console.log("ReD="+ReD+", NuD="+NuD+"="+(0.021*Math.pow(prantdlColdHighP,0.43)*Math.pow(ReD,0.8))+", conductivityColdHighP="+conductivityColdHighP+", prantdlColdHighP="+prantdlColdHighP+", diameter="+diameter+"=>innerHtCoefficient="+innerHtCoefficient);
			return flowF(diameter, innerHtCoefficient, viscColdLowP, dColdLowP, prantdlColdLowP, conductivityColdLowP, pLowFluidMassFlowKg);
		}
/*
		const flowHotF = function (massFlowKg) {
			innerHtCoefficient = function (crossAreaM2) {
				const flow = massFlowKg / dHotHighP;
				const speed = flow / (crossAreaM2 * innerPipeAreaPerM2);
				const ReD = dHotHighP*speed*diameter/viscHotHighP;
				const NuD = 4.36;
					//ret.ReD > 2900 ? 	// fully turbulent flow in pipe (and other small enclosures) 
					//(0.021*Math.pow(prantdlHotHighP,0.43)*Math.pow(ReD,0.8)) :	// turbulent flow
					//(0.15*Math.pow(prantdlHotHighP,0.43)*Math.pow(ReD,1/3));	// for laminar flow
				return NuD*conductivityHotHighP/diameter;
			}
//console.log("ReD="+ReD+", NuD="+NuD+", conductivityHotHighP="+conductivityHotHighP+", diameter="+diameter+"=>innerHtCoefficient="+innerHtCoefficient);
			return flowF(diameter,innerHtCoefficient,viscHotLowP, dHotLowP, prantdlHotLowP, massFlowKg);
		}
*/
		const getHeatExhangerData = function( flowF, visc, density, conductivity, prantdl, massFlowKg )
		{
			var ret = flowF(massFlowKg);

			ret.tHot=tHot, ret.tCold=tCold, ret.pHigh=pHigh, ret.pLow=pLow;
			const flow = massFlowKg / density;
			ret.speedHighP = flow / (ret.totalCrossAreaM2 * innerPipeAreaPerM2);
			const Re = density*ret.speedHighP*diameter / visc;	// Reinolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
			ret.ReHighP = Re;
			ret.diameter = diameter;
			const f = 64/Re; // friction factor of fully developed laminar flow in pipe
			// Pressure drop with Darcy–Weisbach friction factor f: 
			ret.pDropHigh=f*ret.length/diameter*density*Math.pow(ret.speedHighP,2)/2;  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
			ret.heatLeakLossW = ret.totalCrossAreaM2*metalHeatCoefficient*(2*sheetThickness/sheetDistance/outerPerimeterElongation)*
					(tHot-tCold)/(outerPerimeterElongation*ret.length);
			ret.heatLeakLossPercent = 100*ret.heatLeakLossW / heatExchangePower;
			ret.totalWeightTons = ret.volumeM3*(sheetThickness*2/sheetDistance)*8;	// steel ¨8000 kg/m3
			ret.totalSheetAreaM2 = ret.volumeM3/sheetDistance;
			ret.heatExchangeDeltaT = heatExchangeDeltaT;
			//ret.costDescription = "totalWeightTons*4000+totalCrossAreaM2*4000+totalSheetAreaM2*40 Eur"
			console.log( "Material costs:"+(ret.totalWeightTons * getFloatParam("costOfStainlessSteelPerTon", 1600))+ 
				   "\r\nManufacturing cost of sheets: "+(ret.totalSheetAreaM2 * getFloatParam("costOfSteelPlateProcessingPerM2", 5)) + // manufacturing cost m2: 5 e/m2 
				   "\r\nFrame and installation cost:"+ (ret.totalCrossAreaM2 * getFloatParam("heatExchangerFrameAndPipesCostPerM2", 4000)));	// installation cost 
			ret.cost = ret.totalWeightTons * getFloatParam("costOfStainlessSteelPerTon", 1600)+ 
				   ret.totalSheetAreaM2 * getFloatParam("costOfSteelPlateProcessingPerM2", 5) + // manufacturing cost m2: 5 e/m2 
				   ret.totalCrossAreaM2 * getFloatParam("heatExchangerFrameAndPipesCostPerM2", 4000);	// installation cost 
			//ret.NuDCalcHigh = 0.664*Math.pow(Re,1/2)*Math.pow(prantdl,1/3); // OK
			console.log(ret.pDropHigh+"="+f+"*"+ret.length+"/"+diameter+"*"+density+"*"+(Math.pow(ret.speedHighP,2)/2));
			return ret;
		}
		var midHE = getHeatExhangerData( flowColdF, viscColdHighP, dColdHighP, conductivityColdLowP, prantdlColdHighP, pLowFluidMassFlowKg );
		midHE.pDropActual = getHeatExchangerPressureDrop( midHE, pLowFluidMassFlowKg, false, pLowFluid );
		midHE.deltaT_Hot = getHeatExchangeDeltaT( midHE, pLowFluidMassFlowKg, tHot, pLowFluid, pHighFluid );
		midHE.deltaT_Cold = getHeatExchangeDeltaT( midHE, pLowFluidMassFlowKg, tCold, pLowFluid, pHighFluid );
		if (pLowFluid != pHighFluid) {
			midHE.pHighFluidMassFlowKg = pHighFluidMassFlowKg;
			midHE.pLowFluidMassFlowKg = pLowFluidMassFlowKg;
		}
		midHE.pLowFluid = pLowFluid;
		midHE.pHighFluid = pHighFluid;
		midHE.tHotHigh = tHotHigh;
		midHE.tColdHigh = tColdHigh;
		midHE.tHot = tHot;
		midHE.tCold = tCold;
		midHE.pHigh = pHigh;
		midHE.pLow = pLow;

		if (title) midHE.title = title;
console.log((title ? title : 'Heat exchanger')+":"+JSON.stringify(midHE, null, 2));
		return midHE;
/*
		const coldSide = getHeatExhangerData( flowColdF, viscColdHighP, dColdHighP, conductivityColdLowP, prantdlColdHighP  );
console.log("Heat exchanger cold side:"+JSON.stringify(coldSide, null, 2));
		const hotSide = getHeatExhangerData( flowHotF, viscHotHighP, dHotHighP, conductivityHotLowP, prantdlHotHighP );
console.log("Heat exchanger hot side:"+JSON.stringify(hotSide, null, 2));
*/
// TBD: Cals the values in the middle and then actual pressure drop integral in steps 
	}

	function getHeatExchangeDeltaT( heatExhanger, massFlowKg, t, pLowFluid, pHighFluid )
	{
		// temp difference depends on load (power) and gas conductivity in given temperature and pressure 
		// Heat exhanger is sclated to preferred temp diff in the worst case (cold side+turbin massflow), temo difference is less elsewhere
		const ret = heatExhanger;
		//const visc= Module.PropsSI('V', 'P', p, 'T', t, name);
		//const density = Module.PropsSI('D', 'P', p, 'T', t, name);
		//const prantdl=  Module.PropsSI('PRANDTL', 'P', p, 'T', t, name);
		const conductivityLowP =  Module.PropsSI('conductivity', 'P', ret.pLow, 'T', t, pLowFluid);
		const conductivityHighP =  Module.PropsSI('conductivity', 'P', ret.pHigh, 'T', t, pHighFluid);
		//const flow = massFlowKg / density;
		//const speed = flow / (crossAreaM2 * innerPipeAreaPerM2);
		//const ReD = density*speed*ret.diameter/visc;
		const NuD = 4.36;	// fully developed laminar flow in pipe
		const innerHtCoefficient = NuD*conductivityHighP/ret.diameter;
		const externalHtCoefficient = ret.NuD*conductivityLowP/ret.hD;
		const heatExchangePower = ret.deltaH * massFlowKg;
		const heatExchangeDeltaT = heatExchangePower/(ret.totalCrossAreaM2*ret.wettedPermeterM2*externalHtCoefficient*ret.actualHtLength/2) 
								+ heatExchangePower/(ret.totalCrossAreaM2*ret.innerPipePerimeterM2*innerHtCoefficient*ret.actualHtLength/2);
		return heatExchangeDeltaT;
	}

	function getHeatExchangerPressureDrop( heatExhanger, massFlowKg, isHighPressure, name )
	{
		const ret = heatExhanger;
		const p = isHighPressure ? ret.pHigh : ret.pLow;
		const diameter = isHighPressure ? ret.diameter : ret.hD;
		const length = ret.length / 10;
		const tStep = (ret.tHot-ret.tCold) / 10;
		var pDrop = 0;
		for (t = ret.tCold + tStep/2; t < ret.tHot; t += tStep) {
			const visc= Module.PropsSI('V', 'P', p, 'T', t, name);
			const density = Module.PropsSI('D', 'P', p, 'T', t, name);
			const speed = massFlowKg / (density * ret.totalCrossAreaM2 * (isHighPressure ? ret.innerPipeAreaPerM2 : ret.externalAreaPerM2));
			const Re = density*speed*diameter/visc;
			const f = (isHighPressure ? 64 : 90)/Re;
			const deltaP = f*length/diameter*density*Math.pow(speed,2)/2;
//console.log("Pressure drop at "+t+" K, deltaP="+deltaP+", Re="+Re+", speed="+speed+", massFlowKg="+massFlowKg);
			pDrop += deltaP;  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
		}
		return pDrop;
	}

	function getPipeDiameterAndPressureDrop(visc, flow, density, length, maxPressureDrop, pipeDiameter, maxSpeed)  { // height, heightAbove, densityAbove, )
		flow = flow / metrics.cUnits;
		const epsilon = getFloatParam("epsilon", 0.025); 	// for steel, structural or forged (0.0025 drawn tube, but pipe diameter is too big for that
		var diameter = pipeDiameter ? pipeDiameter : 4;	// start with 2m
		return getPipeDiameterAndPressureDropX(visc, flow, density, length, maxPressureDrop, epsilon, diameter, maxSpeed, pipeDiameter );
	}

	function getPipeDiameterAndPressureDropX(visc, flowF, density, length, maxPressureDrop, epsilon, diameter, maxSpeed, pipeDiameter)  { // height, heightAbove, densityAbove, )
		var deltaP;
		// Heuristic search of pipe diameter and pressure drop for a turbulent flow in a steel pipe having the diameter a few meters
		if (maxSpeed) {
			diameter = Math.pow(flowF*4/(Math.PI * maxSpeed), 0.5);
		}
//console.log("typeof flowF="+(typeof flowF)+", maxSpeed="+maxSpeed+", diameter="+diameter+", pipeDiameter="+pipeDiameter);
		var ret = {};
		ret.speed = 2;		// start with something
		var loop;
		for (loop = 1; loop < 20; loop++) {
			var flow;
			if (typeof flowF === 'function') {
				ret.exterior = flowF(diameter, ret.speed);
				length = ret.exterior.length;
				// flow of a single pipe
				flow = (ret.exterior.massFlowKg/density)
						/ (ret.exterior.crossAreaM2*ret.exterior.panelsPerM2*(1/(diameter*Math.PI/2)));
if (!length || isNaN(lenght)) {
	console.log("exterior="+JSON.stringfy(ret.exterior));
	throw new Error();
}
			}
			else {
				flow = flowF;
			}
			ret.flow = flow;
			ret.speed = flow / (Math.PI*diameter*diameter/4);
			// Renolds number: 
			const Re = density*ret.speed*diameter / visc;	// Reynolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
			// Darcy–Weisbach friction factor by Tkachenko, Mileikovskyi 2020 for 2320 <= Re <= 1000000000
			// https://en.wikipedia.org/wiki/Darcy_friction_factor_formulae
			const A0 = -0.79638*Math.log(epsilon/(diameter*8.208) + 7.3357/Re);
			const A1 = Re*(epsilon/diameter) + 9.3120665*A0;
			const f = Math.pow((8.128943+A1)/(8.128943*A0-0.86859209*A1*Math.log(A1/(3.7099535*Re))), 2);
			// Pressure drop with Darcy–Weisbach friction factor f: 
			deltaP=f*length/diameter*density*Math.pow(ret.speed,2)/2;  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
			if (pipeDiameter) break; // the diameter is already set by the charge loop
//console.log(loop+":diameter="+diameter+", length="+length+"=> deltaP="+deltaP+". flow="+flow);
			if (maxPressureDrop == 0) {
				maxPressureDrop = deltaP;
			}
			else if (Math.round(deltaP) == maxPressureDrop) break;
			else if (deltaP < maxPressureDrop) {
				if (maxSpeed) break;
				if ((maxPressureDrop-deltaP)/maxPressureDrop < 0.2) {
					break;
				}
			}
			diameter = diameter * Math.pow(deltaP/ maxPressureDrop,1/4);	// 
		}
//if (height) console.log( "9.81*"+density+"*"+height+"="+ (9.81*density*height));
//if (densityAbove) console.log("9.81*"+densityAbove+"*"+heightAbove+"="+(9.81*densityAbove*heightAbove));
		ret.maxPressureDrop = maxPressureDrop;
		ret.pressureDrop = deltaP;
					   //+ (height ? 9.81*density*height : 0) 		//	Head-loss form: deltaP=g*density*height 
					   //- (densityAbove ? 9.81*densityAbove*heightAbove : 0)
					   ;
		ret.diameter = diameter;
		ret.flow = flow;
//console.log(loop+": ret="+JSON.stringify(ret));
		return ret;
	}

	function getEndwallPressureDrop(visc, flow, density, innerLength, innerDiameter, outerLength, outerDiameter)  { 
		const epsilon = getFloatParam("epsilon", 0.0025); 	// 0.0025 drawn tube, and finished surface?
		const A = (outerDiameter*outerDiameter - innerDiameter*innerDiameter);
		const speed = flow / (Math.PI*A/4);
		const fnGetPressureDrop = function(diameter, length) {
			// Renolds number: 
			const Re = density*speed*diameter / visc;	// Reynolds number https://en.wikipedia.org/wiki/Reynolds_number#Flow_around_airfoils
			// Darcy–Weisbach friction factor by Tkachenko, Mileikovskyi 2020 for 2320 <= Re <= 1000000000
			// https://en.wikipedia.org/wiki/Darcy_friction_factor_formulae
			const A0 = -0.79638*Math.log(epsilon/(diameter*8.208) + 7.3357/Re);
			const A1 = Re*(epsilon/diameter) + 9.3120665*A0;
			const f = Math.pow((8.128943+A1)/(8.128943*A0-0.86859209*A1*Math.log(A1/(3.7099535*Re))), 2);
			// Pressure drop with Darcy–Weisbach friction factor f: 
			return f*length/diameter*density*Math.pow(speed,2)/2;  // https://en.wikipedia.org/wiki/Darcy%E2%80%93Weisbach_equation
		}
		// scale pressure loss to the actual flow
		return fnGetPressureDrop(innerDiameter, innerLength)*(innerDiameter*innerDiameter)/A + fnGetPressureDrop(outerDiameter, outerLength)*(outerDiameter*outerDiameter)/A;
	}
	//
	//	Estimates the pressure drop in acceleration or decleretion
	//
	function getCompressorInletOrExitPressureDrop( massFlow, pipeOuterDiameter, pipeInnerDiameter, pipe, rTip, rHub, inlet, length ) {
		var step = (rTip-rHub)/10;	
		const inletOuterDiameter = 2*rTip;
		const inletInnerDiameter = 2*rHub;
		const toInnerLength = Math.sqrt(length*length + (inletInnerDiameter-pipeInnerDiameter)*(inletInnerDiameter-pipeInnerDiameter))/length;
		const toOuterLength = Math.sqrt(length*length + (inletOuterDiameter-pipeOuterDiameter)*(inletOuterDiameter-pipeOuterDiameter))/length;
		const vector = inlet.c2 ? inlet.c2/inlet.v : 1;		// actual fluid velocity known and different from axial velocity?
		var pressureDrop = 0;
		var x;
		if (!inlet.visc || typeof inlet.visc === 'undefined') {
			inlet.visc = Module.PropsSI('VISCOSITY', 'T', inlet.t, 'P', inlet.p, name);
			if (typeof inlet.visc === 'undefined') {
				inlet.visc = Module.PropsSI('VISCOSITY', 'T', inlet.t+1, 'P', inlet.p, name);
			}
		}
		if (pipe.visc == null || typeof pipe.visc === 'undefined') {
			var t = pipe.t+1;
			for (;;) {
				pipe.visc = Module.PropsSI('VISCOSITY', 'T', t, 'P', pipe.p, name);
				if (pipe.visc != null && typeof pipe.visc !== 'undefined') {
					console.log( name+" viscosity found at t="+t+", p="+pipe.p+", pipe t="+pipe.t);
					break;
				}
				t++;
			}
		}
		console.log("pipe="+JSON.stringify(pipe));
		for (x = 0; x <= length && step > 0; x += step) {
			const density = inlet.d + (pipe.d-inlet.d)*(x/length);
			const visc = inlet.visc + (pipe.visc-inlet.visc)*(x/length);
			const innerDiameter = inletInnerDiameter + (pipeInnerDiameter - inletInnerDiameter)*(x/length);
			const outerDiameter = inletOuterDiameter + (pipeOuterDiameter - inletOuterDiameter)*(x/length);
			pressureDrop += getEndwallPressureDrop(visc, vector*massFlow/density, density, step*toInnerLength, innerDiameter, step*toOuterLength, outerDiameter);
			if (Number.isNaN(pressureDrop)) {
				console.log("pipe="+JSON.stringify(pipe)+" inlet="+JSON.stringify(inlet));
				throw new Error("pressureDrop === NaN");
			}
			step = 1.5*step;
			if (x+step > length) step = length - x;
		}
		const hZeroLoss = Module.PropsSI('H','P', pipe.p, 'S', inlet.s, name);
		const loss = Math.abs((pipe.h - hZeroLoss)/(pipe.h-inlet.h));
		console.log("rel pressureDrop: "+(pressureDrop/pipe.p)+", inlet="+JSON.stringify(inlet)+", pipe="+JSON.stringify(pipe)+", loss="+loss);
		return pressureDrop;
	}
	
	// Conductive heat transfer of various rocks seems to be quite constant in a wide temperature range, it starts to decree when stone starts to frack
	// see https://en.wikipedia.org/wiki/List_of_thermal_conductivities 
	// Average heat transfer rate of gabbro rock seems to be 2.5 W/mK,  the measured values of granite are 1.5-3
	// 
	var gravelConductiveHeatTransfer = 0;
	function processGravelHeatTransfer(cache, items, i, trace) 
	{
		//return true;
		if (i+1 == items.length) {
			items[i].tRock = items[i].tRock - items[i].heatFlowedOut/cache.gravelDensityKgInM3/getRockHeatCapasityJinKgK(items[i].tRock);  
			return true;
		}
		const rockThermalConductivity = 2.5; // W/mK, 
		const stefanBolzman = 0.0000000567;
		const rockEmissivity = 0.94;
		const gravelViewFactor = 1;	// rule: enclosed surface
		const area = 4;  // gravel has a very irregular surface => multiply m2 by 4, this is my best guess for the forward radiating surface of an average gravel particle
		const dp2AverageDistance = 1; //heat flow route network must be extremely complex
		if (!gravelConductiveHeatTransfer) {
			// see https://trepo.tuni.fi/bitstream/handle/10024/135911/Convective_heat_transfer_in_crushed.pdf?sequence=1
			// 5/16 crushed stone top to down heat conducticity 0.37 W/m/K, median partice diameter is 11 mm, but average particle diameter is less, mid temp 294 K =>
			const htRadiative = area*gravelViewFactor*rockEmissivity*stefanBolzman*(Math.pow(294+0.011*dp2AverageDistance,4)-Math.pow(294,4));
			// 1/0.37 = (1-porosity)/rockThermalConductivity + (1/(gravelConductiveHeatTransfer + htRadiative);
			// => 1/0.37 - (1-porosity)/rockThermalConductivity = 1/(gravelConductiveHeatTransfer + htRadiative)
			// => gravelConductiveHeatTransfer = 1/(1/0.37 - (1-porosity)/rockThermalConductivity) - htRadiative;
			gravelConductiveHeatTransfer = 1/(1/0.37 - (1-cache.porosity)/rockThermalConductivity) - htRadiative;
console.log("gravelConductiveHeatTransfer="+gravelConductiveHeatTransfer+"; htRadiative="+htRadiative+", 1/R="+(1/((1-cache.porosity)/rockThermalConductivity + (1/(gravelConductiveHeatTransfer + htRadiative)))));
		}
		const tMid = (items[i].tRock + items[i+1].tRock) / 2;
		const tDiff = items[i+1].tRock - items[i].tRock;
		// assume the radiate heat transfer of m3 gravel to be equal n m2 plates where n 1 m/median particle diameter splitting the temp diff to n parts
		const htRadiative = area*gravelViewFactor*rockEmissivity*stefanBolzman*(Math.pow(tMid+cache.medianDP*dp2AverageDistance,4)-Math.pow(tMid,4)); // W/m/K
		const R = 1/(htRadiative + gravelConductiveHeatTransfer) + (1-cache.porosity)/rockThermalConductivity;
		items[i].heatTransferCoefficient = 1/R;	// W/mK
		const heatFlowInJoules = tDiff * cache.rockHeatingTime * items[i].heatTransferCoefficient;	// temp diff (K) * time (s) * 1(m2)/1(m) * htc (W/m/K) == J
		const hc = getRockHeatCapasityJinKgK(items[i].tRock);  // J/kg/K
		items[i].hc = hc;
		items[i].tDiff = tDiff;
		const netHeatFlow = (heatFlowInJoules-(items[i].heatFlowedOut ? items[i].heatFlowedOut : 0))/cache.gravelDensityKgInM3/hc; 
		items[i].tRock = items[i].tRock + netHeatFlow;
		items[i+1].heatFlowedOut = heatFlowInJoules;	// J/m3/K  (in hour)
		if (!items[i].tRock || !items[i].heatTransferCoefficient) {
			console.trace("A zero value: i="+i+", item:"+JSON.stringify(items[i])+", heatFlowInJoules="+heatFlowInJoules+", tMid="+tMid+", htRadiative="+htRadiative+", cache.medianDP="+cache.medianDP);
			return false;
		}
		if (false && trace) {
			console.log("i="+i+", item:"+JSON.stringify(items[i])+", netHeatFlow="+netHeatFlow+", tMid="+tMid+", htRadiative="+htRadiative+", cache.medianDP="+cache.medianDP);
		}
		return true;
	}
	function getEnthalpy( cache, tRock )
	{
		var hRock;
		if (!cache.ENTHALPY) {
			cache.ENTHALPY = new Array(cache.size+1);
			cache.SAT_ENTHALPY = new Array(200);
		}
		/*if (true) {
			hRock = Module.PropsSI('H', 'P', cache.p, 'T', tRock, name);
			if (hRock == 'Infinity') {
				hRock = Module.PropsSI('H', 'P', cache.p, 'Q', 1, name);
			}
		}
		else */
		if (cache.tSat && tRock < (cache.tSat+20)) { // temp/enthalpy relation is not linear near to the saturation => we use 0.1 K resolution in lookup
			const tDecFromSat = (tRock-cache.tSat)*10;
			const tSatIndex = Math.floor(tDecFromSat);
			const tSatDiff = tDecFromSat - tSatIndex;
			const checkIt = !cache.SAT_ENTHALPY[tSatIndex] || !cache.SAT_ENTHALPY[tSatIndex+1];
			if (!cache.SAT_ENTHALPY[tSatIndex]) 
				cache.SAT_ENTHALPY[tSatIndex] = tSatIndex == 0 ? Module.PropsSI('H', 'P', cache.p, 'Q', 1, name) 
															   : Module.PropsSI('H', 'P', cache.p, 'T', cache.tSat+tSatIndex/10, name);
			if (!cache.SAT_ENTHALPY[tSatIndex+1]) cache.SAT_ENTHALPY[tSatIndex+1] = Module.PropsSI('H', 'P', cache.p, 'T', cache.tSat+(tSatIndex+1)/10, name);
			hRock = cache.SAT_ENTHALPY[tSatIndex] + (cache.SAT_ENTHALPY[tSatIndex+1]-cache.SAT_ENTHALPY[tSatIndex])*tSatDiff;
			
			if (checkIt) {
				const hActual = Module.PropsSI('H', 'P', cache.p, 'T', tRock, name);
				if (Math.abs(hActual-hRock) > 20) {
					console.log("Bad lookup t="+tRock+": hLookup="+hRock+", hActual="+hActual+", tFromSat="+(tRock-cache.tSat)+", hLookup["+tSatIndex+"]="+cache.SAT_ENTHALPY[tSatIndex]+", hLookup["+(tSatIndex+1)+"]="+cache.SAT_ENTHALPY[tSatIndex+1]+
						", p="+cache.p+", hSat="+Module.PropsSI('H', 'P', cache.p, 'Q', 1, name)+", tSat="+Module.PropsSI('T', 'P', cache.p, 'Q', 1, name));
				}
			}
		}
		else {
			const tRockIndex = Math.floor(tRock) - cache.tMin;
			const tRockDiff = tRock-Math.floor(tRock);
			if (!cache.ENTHALPY[tRockIndex]) cache.ENTHALPY[tRockIndex] = Module.PropsSI('H', 'P', cache.p, 'T', Math.floor(tRock), name);
			if (cache.ENTHALPY[tRockIndex] == 'Infinity') {
				hRock = cache.ENTHALPY[tRockIndex] = Module.PropsSI('H', 'P', cache.p, 'T', tRock, name);
				if (hRock == 'Infinity') {
					hRock = cache.ENTHALPY[tRockIndex] = Module.PropsSI('H', 'P', cache.p, 'Q', 1, name);
				}
			}
			else {
				if (!cache.ENTHALPY[tRockIndex+1]) cache.ENTHALPY[tRockIndex+1] = Module.PropsSI('H', 'P', cache.p, 'T', Math.floor(tRock)+1, name);
				hRock = cache.ENTHALPY[tRockIndex] + (cache.ENTHALPY[tRockIndex+1]-cache.ENTHALPY[tRockIndex])*tRockDiff;
			}
			/*if (cache.tSat && tRock < (cache.tSat+10)) {
				hRockTest = Module.PropsSI('H', 'P', cache.p, 'T', tRock, name);
				if (Math.abs(hRock-hRockTest) > 100) {
					console.log("Lookup hRock="+hRock+", actual hRock="+hRockTest+", tDiff="+tRockDiff+", lookup["+tRockIndex+"]="+cache.ENTHALPY[tRockIndex]+", lookup["+(tRockIndex+1)+"]="+cache.ENTHALPY[tRockIndex+1]);
				}
			}*/
		}
		if (hRock < cache.hLow || hRock > cache.hHigh) {
			if (hRock < cache.hLow && (cache.hLow-hRock) < 20) hRock = cache.hLow;
			else if (hRock > cache.hHigh && (hRock - cache.hHigh)< 20) hRock = cache.hHigh;
			else {
				const hBad = hRock;
				hRock = Module.PropsSI('H', 'P', cache.p, 'T', tRock, name);
				//console.log("Fix hRock "+hBad+"=>"+hRock+", tRock="+tRock+", diff from hLow="+(hRock < cache.hLow ? hRock - cache.hLow : hRock - cache.hHigh));
			}
		}
		return hRock;
	}

var cDbg = 0;
	function processGasToGravelHeatExchange( cache, item, tGas, hGas, massFlow, calcMaxHeatExchange, trace)
	{
		massFlow *= 1000;
		hGas = getEnthalpy( cache, tGas );

		if (!cache.m3Area) 
		{
			// all gravel particles are perfect balls => shapeFactor = 1,  if perfect cubics sape factor = 1.91, 2 is probably a low end estimation
			const shapeFactor = 2; // for the irregular surface, shape and high aspect ratio
			const dStep = (cache.gravelMax - cache.gravelMin) / 10;
			var m3A = 0, pD;
			for (pD = cache.gravelMin; pD<cache.gravelMax; pD += dStep) {
					m3A += (4 * Math.PI * Math.pow(pD/2, 2)    	// surface area of perfect ball : 4*PI*r*r
							* 1 / (Math.PI * 4 * Math.pow(pD/2,3)/3))	// number of items / m3, ignore here the porosity of balls
			}
			cache.m3Area = shapeFactor*(1-cache.porosity)*m3A/10;
console.log(cache.gravelMin+"/"+cache.gravelMax+" gravel m3 surface area:"+cache.m3Area);
		}
		const G = massFlow / item.area;
		if (calcMaxHeatExchange) {
			const t = Math.floor(tGas);
			const tIndex = t - cache.tMin;
			const tDiff = tGas-t;

			if (!cache.VISCOSITY) {
				cache.VISCOSITY = new Array(cache.size);
				cache.PRANDTL = new Array(cache.size);
				cache.CONDUCTIVITY = new Array(cache.size);
				cache.DENSITY = new Array(cache.size);
			}
			if (!cache.VISCOSITY[tIndex]) {
				cache.VISCOSITY[tIndex] = Module.PropsSI('V', 'P', cache.p, 'T', t, name);
				cache.PRANDTL[tIndex] = Module.PropsSI('PRANDTL', 'P', cache.p, 'T', t, name);
				cache.CONDUCTIVITY[tIndex] = Module.PropsSI('CONDUCTIVITY', 'P', cache.p, 'T', t, name);
				cache.DENSITY[tIndex] = Module.PropsSI('D', 'P', cache.p, 'T', t, name);
				if (!cache.VISCOSITY[tIndex] || !cache.PRANDTL[tIndex]  || !cache.CONDUCTIVITY[tIndex] || !cache.DENSITY[tIndex] 
					|| cache.VISCOSITY[tIndex] == 'Infinity' || cache.PRANDTL[tIndex]  == 'Infinity' || cache.CONDUCTIVITY[tIndex] == 'Infinity' || cache.DENSITY[tIndex] == 'Infinity') {
					// on saturation line, fetch values for gas
					cache.VISCOSITY[tIndex] = Module.PropsSI('V', 'P', cache.p,'Q', 1, name);
					cache.PRANDTL[tIndex] = Module.PropsSI('PRANDTL', 'P', cache.p,'Q', 1, name);
					cache.CONDUCTIVITY[tIndex] = Module.PropsSI('CONDUCTIVITY', 'P', cache.p,'Q', 1, name);
					cache.DENSITY[tIndex] = Module.PropsSI('D', 'P', cache.p,'Q', 1, name);
					if (!cache.VISCOSITY[tIndex] == 'Infinity' || cache.PRANDTL[tIndex]  == 'Infinity' || cache.CONDUCTIVITY[tIndex] == 'Infinity' || cache.DENSITY[tIndex]) {
						console.trace("A zero value: "+cache.VISCOSITY[tIndex]+", "+cache.PRANDTL[tIndex] +", "+cache.CONDUCTIVITY[tIndex]+", "+cache.DENSITY[tIndex]
							+ ", h="+tIndex+", item:"+JSON.stringify(item));
						return false;
					}
				}
				cache.PRANDTL[tIndex] = Math.pow(cache.PRANDTL[tIndex],1/3); // pre-calc the used exponent
			}
			// https://shop.tarjomeplus.com/UploadFileEn/TPLUS_EN_4259.pdf
			const ReDp = G*cache.medianDP / (6*(1-cache.porosity)*cache.VISCOSITY[tIndex]);
			const NuDp = 8.74+9.34*Math.pow(6*(1-cache.porosity), 0.2)*Math.pow(ReDp, 0.2)*cache.PRANDTL[tIndex];
			// NuDp = h * Dp / k => h = NuDp*k/Dp; 
			const heCofficient = NuDp * cache.CONDUCTIVITY[tIndex] / cache.medianDP;
			// the heat exhange power in 1 m3 of gravel
			//item.NuDp = NuDp; 
			//item.heCofficient = heCofficient;
			item.heCofficientInM3 = heCofficient*cache.m3Area;
			//console.log("heCofficientInM3="+heCofficientInM3+" W/K, G="+G+", ReDp="+ReDp+", NuDp="+NuDp+", heCofficient="+heCofficient+", tGas="+tGas);
		}
//console.log("item="+JSON.stringify(item)+", tGas="+tGas+", massFlow="+massFlow+", cache.medianDP="+cache.medianDP+", tIndex="+tIndex+", tDiff="+tDiff);
		if (hGas) {
			// OK
		}
		else {
			hGas = getEnthalpy( cache, tGas );
		}
		if (Math.abs(tGas - item.tRock) < 0.01) {
			if (Math.abs(tGas - cache.tLow) < 0.01) {
				hGas = cache.hLow;
				tGas = cache.tLow;
			}
			else if (Math.abs(tGas - cache.tHigh) < 0.01) {
				hGas = cache.hHigh;
				tGas = cache.tHigh;
			}
			else if (tGas == cache.tHigh) hGas = cache.hHigh;
			item.deltaH = item.hGasOut-hGas;
			item.hGasOut = hGas;
			item.tRock = tGas;
			item.deltaT = 0;
			return true; 	// OK, no heat exchange is possible
		}
		const tRock = item.tRock;
		const rockHC = getRockHeatCapasityJinKgK((tRock+tGas) / 2, item.type);
		var hGasOut, tRockNew = tRock;
		
		const hRockTest = getEnthalpy( cache, tRock );
		if ((tGas-tRock)*(hGas-hRockTest) < 0) {
			hGasOut = getEnthalpy( cache, tGas );
console.log("Fixed hGas: tGas="+tGas+", tRock="+tRock+", hGas="+hGas+"->"+hGasOut+", hRock="+hRockTest);
			//return false;
		}
		// The gas flow is 14-50 g/m2 => its enthalpy is very small compared to the heat exchange capabilty of Gravel
		// So we can assume, that after 1h heatin/cooling the rock temp is the same as incoming gas temp (and enthalpy) difference with rock temp is lost in the heat exchange.
		// If the incoming gas temp is the max or min temp, the actual gas ethalpy change is only half of the enthalpy of temp difference.
		// Otherwise the gravel-gas temp diff and enthapy are constant, because the temp of incoming gas increase in the same time with gravel temp
		// heCofficient can be udes to calc the temp difference of gas and rock
		if (!testResult( 0, tGas < tRock ? tGas : tRock, tGas < tRock ? tRock : tGas, 10,	// diff in Joules, typical amount per K: 800*2100(kg/m3)/K for gravel, 1(J/g/K)*35(g/s)*3600s for gas
			function (t) { 
					tRockNew = t;
					hGasOut = getEnthalpy( cache, tRockNew );
					return rockHC*cache.gravelDensityKgInM3*(tRockNew-tRock)*cache.stepLen + cache.rockHeatingTime*(hGasOut-hGas)*G;
				}, 30)) 
		{
			var dbgCount = 0;
hGasActual = getEnthalpy( cache, tGas );
console.log("tGas="+tGas+", tRock="+tRock+", hGas="+hGas+", hGasActual="+hGasActual+", hRock="+getEnthalpy(cache,tRock)+", rockHC="+rockHC);
			testResult( 0, tGas < tRock ? tGas : tRock, tGas < tRock ? tRock : tGas, 10,	// diff in Joules, typical amount per K: 800*2100(kg/m3)/K for gravel, 1(J/g/K)*35(g/s)*3600s for gas
				function (t) { 
						tRockNew = t;
						hGasOut = getEnthalpy( cache, tRockNew );
						const diff =  rockHC*cache.gravelDensityKgInM3*(tRockNew-tRock)*cache.stepLen + cache.rockHeatingTime*(hGasOut-hGas)*G;
console.log((dbgCount++)+":t="+t+"=> hGasOut="+hGasOut+", hGas="+hGas+", diff: "+diff+"="+rockHC+"*"+cache.gravelDensityKgInM3+"*"+(tRockNew-tRock)+"*"+cache.stepLen+" + "+cache.rockHeatingTime+"*"+(hGasOut-hGas)+"*"+G);
						return diff;
					}, 30); 
			console.trace("tGas="+tGas+", hGas="+hGas+"=> tRockNew="+tRockNew+", hGasOut="+hGasOut+"=>"+JSON.stringify(item)+", rockHC="+rockHC+", cache.p="+cache.p+", tSat="+cache.tSat+", tMin="+cache.tMin+", G="+G+",tLow="+cache.tLow+", tHigh="+cache.tHigh);
			return false;
		}
		if (hGasOut <= cache.hLow || tRockNew <= cache.tLow) {
			hGasOut = cache.hLow;
			tRockNew = cache.tLow;
		}
		else if (hGasOut >= cache.hHigh || tRockNew >= cache.tHigh) {
			hGasOut = cache.hHigh;
			tRockNew = cache.tHigh;
		}
		item.deltaH = hGasOut-hGas;	// enthalpy change of gas
		item.hGasOut = hGasOut;
		item.tRock = tRockNew;
		// deltaT == difference of rock and gas temprature in the slice
		item.deltaT = calcMaxHeatExchange ? item.deltaH*G/(cache.stepLen*item.heCofficientInM3) : 0;

		if (!item.tRock || !item.hGasOut) { //  || !item.tGas || item.tGas<cache.tLow || item.tGas>cache.tHigh || !rockHC
			console.log((!item.tRock)+" || "+(item.tRock<cache.tLow)+" || "+(item.tRock>cache.tHigh)); //+" || "+(!item.tGas)+" || "+(item.tGas<cache.tLow)+" || "+(item.tGas>cache.tHigh)+" || "+(!rockHC));
			console.trace("tGas="+tGas+", hGas="+hGas+"=> tRock="+tRock+", hGasOut="+hGasOut+"=>"+JSON.stringify(item)+", rockHC="+rockHC+", cache.p="+cache.p+", tSat="+cache.tSat+", tMin="+cache.tMin+", G="+G+",tLow="+cache.tLow+", tHigh="+cache.tHigh);
			return false;
		}
		if (trace && false) {
			console.log("tGas="+tGas+", hGas="+hGas+", tRock="+tRock+"*3600s=>"+JSON.stringify(item)+", heatAddedToRock="+heatAddedToRock+", rockHC="+rockHC+", G="+G+",tLow="+cache.tLow+", tHigh="+cache.tHigh);
		}
		return true;
	}


	function simulateStorageHeatExchange(cycleData) {
		if (!cycleData) cycleData = lastCycleData;
		const randomBalancedDays = getFloatParam('chargeDays', 10); 
		//const hLowLpDischarge = Module.PropsSI('H', 'P', cycleData.coldCycle[1].pOut, 'Q', 1, name); 
		const swapTHighLpAndTLowHp = metrics.topFillUsedAsColdStorage || metrics.topFillWithIceWithStorage;
		var tHighLp = swapTHighLpAndTLowHp ? cycleData.coldCycle[0].tOut : cycleData.hotCycle[1].tIn;
		var tLowHp = swapTHighLpAndTLowHp ?  cycleData.hotCycle[1].tIn : cycleData.coldCycle[0].tOut;
		const tHighHp = cycleData.hotCycle[1].tOut;
		const pLowCompressor = metrics.pLowCompressor ? metrics.pLowCompressor : metrics.pLow;
		const tLowLp = Module.PropsSI('T', 'P', pLowCompressor, 'Q', 1, name)+0.01; 
		const pLow = metrics.pLow;
		const hLowLp = Module.PropsSI('H', 'P', pLowCompressor, 'T', tLowLp, name);
		const hHighLp = Module.PropsSI('H', 'P', pLowCompressor, 'T', tHighLp, name);
		const hLowHp = Module.PropsSI('H', 'P', metrics.pHigh, 'T', tLowHp, name);
		const hHighHp = Module.PropsSI('H', 'P', metrics.pHigh, 'T', tHighHp, name);
		// getLiquidHeatStorage( storageGas, inConstantVolume, pFrom, workingGasName, pWorkingGas, tLowWorkingGas )
//console.log("hpLiquidStorage="+JSON.stringify(hpLiquidStorage));
		var lpTemps = [];
		var hpTemps = [];
		var lpHeCCache = {};
		var lpHeCache = {};
		var hpHeCache = {};
		var gasWeight = 0;
		var gasWeightMin = 0;
		var lpInitialRockTemp, hpInitialRockTemp;
		const stepLen = 	  getFloatParam("heSimulationStepLen", 0.1);	// the height (m) of each calclulated storace slice
		const rockHeatingTime = getIntParam("heSimulationTimeResolution", 900);	// the resolution time in seconds
		const lpMaxLowDiff = 	getIntParam("lpMaxLowDiff", 50);
		const lpMaxHighDiff = 	getIntParam("lpMaxHighDiff", getIntParam("maxHighDiff",100));
		const hpMaxLowDiff = 	getIntParam("hpMaxLowDiff", swapTHighLpAndTLowHp ? 200 : 50);
		const hpMaxHighDiff = 	getIntParam("hpMaxHighDiff", getIntParam("maxHighDiff",100));		// die fast??
		const simulations = getIntParam("heSimulations", 2 );
		const calcHeatExchangeCoeffcient = getBooleanParam("calcHeatExchangeCoeffcient", false );
console.log("calcHeatExchangeCoeffcient="+calcHeatExchangeCoeffcient);		
		/*
		const lpLiquidStorageSizeGWh= name != 'Argon' ? 0.0000001 : getIntParam("lpLiquidStorageSizeGWh", 95);
		const hpLiquidStorageSizeGWh= name != 'Argon' ? 0.0000001 : getIntParam("hpLiquidStorageSizeGWh", 115);
		const lpLiquidStorage = getLiquidHeatStorage( "Methane", true, 3000000, name, pLow, tLowLp, lpLiquidStorageSizeGWh); // Methane storage max capasity 
		const hpLiquidStorage = getLiquidHeatStorage( "Water", false, 101325, name,  cycleData.coldCycle[0].pOut, tLowHp, hpLiquidStorageSizeGWh); // water storage max capasity
		*/
		
		if (!lpHeCCache.size) {
			lpHeCCache.stepLen = stepLen;
			//lpHeCCache.liquidStorage = lpLiquidStorage;
			lpHeCCache.size = (Math.floor(tHighLp) - Math.floor(tLowLp) + 2);
			lpHeCCache.tMin = Math.floor(tLowLp);
			lpHeCCache.tLow = tLowLp;
			lpHeCCache.tHigh = tHighLp;
			lpHeCCache.hLow = hLowLp;
			lpHeCCache.hHigh = hHighLp;
			lpHeCCache.p = pLowCompressor;
			lpHeCCache.tSat = Module.PropsSI('T', 'P', lpHeCCache.p, 'Q', 1, name);
			lpHeCCache.hSat = Module.PropsSI('H', 'P', lpHeCCache.p, 'Q', 1, name);
console.log("lpHeCCache: tSat="+lpHeCCache.tSat+", hSat="+lpHeCCache.hSat+", tLow="+lpHeCCache.tLow+", hLow="+lpHeCCache.hLow+", p="+lpHeCCache.p);
			lpHeCCache.porosity = metrics.lpGravelPorosity;
			lpHeCCache.gravelMin = metrics.gravelMinLp / 1000;
			lpHeCCache.gravelMax = metrics.gravelMaxLp / 1000;
			lpHeCCache.medianDP = (lpHeCCache.gravelMin + lpHeCCache.gravelMax) / 2;
//console.log("lpHeCCache.gravelMin="+lpHeCCache.gravelMin+", metrics.gravelMaxLp="+metrics.gravelMaxLp+", lpHeCCache.medianDP="+lpHeCCache.medianDP);
			lpHeCCache.gravelDensityKgInM3 = metrics.lpGravelDensity * 1000;
			lpHeCCache.rockHeatingTime = rockHeatingTime;	// recalc rock temperature in 1 h steps
		}
		if (!lpHeCache.size) {
			lpHeCache.stepLen = stepLen;
			//lpHeCCache.liquidStorage = lpLiquidStorage;
			lpHeCache.size = (Math.floor(tHighLp) - Math.floor(tLowLp) + 2);
			lpHeCache.tMin = Math.floor(tLowLp);
			lpHeCache.tLow = tLowLp;
			lpHeCache.tHigh = tHighLp;
			lpHeCache.hLow = hLowLp;
			lpHeCache.hHigh = Module.PropsSI('H', 'P', pLow, 'T', tHighLp, name);;
			lpHeCache.p = pLow;
			lpHeCache.tSat = Module.PropsSI('T', 'P', lpHeCache.p, 'Q', 1, name);
			lpHeCache.hSat = Module.PropsSI('H', 'P', lpHeCache.p, 'Q', 1, name);
console.log("lpHeCache: tSat="+lpHeCache.tSat+", hSat="+lpHeCache.hSat+", tLow="+lpHeCache.tLow+", hLow="+lpHeCache.hLow+", p="+lpHeCache.p);
			lpHeCache.porosity = metrics.lpGravelPorosity;
			lpHeCache.gravelMin = metrics.gravelMinLp / 1000;
			lpHeCache.gravelMax = metrics.gravelMaxLp / 1000;
			lpHeCache.medianDP = (lpHeCache.gravelMin + lpHeCache.gravelMax) / 2;
//console.log("lpHeCache.gravelMin="+lpHeCache.gravelMin+", metrics.gravelMaxLp="+metrics.gravelMaxLp+", lpHeCache.medianDP="+lpHeCache.medianDP);
			lpHeCache.gravelDensityKgInM3 = metrics.lpGravelDensity * 1000;
			lpHeCache.rockHeatingTime = rockHeatingTime;	// recalc rock temperature in 1 h steps
		}
		if (!hpHeCache.size) {
			hpHeCache.stepLen = stepLen;
			//lpHeCCache.liquidStorage = hpLiquidStorage;
			hpHeCache.size = (Math.floor(tHighHp) - Math.floor(tLowHp) + 2);
			hpHeCache.tMin = Math.floor(tLowHp) - 1;
			hpHeCache.tLow = tLowHp;
			hpHeCache.tHigh = tHighHp;
			hpHeCache.hLow = hLowHp;
			hpHeCache.hHigh = hHighHp;
			hpHeCache.porosity = metrics.hpGravelPorosity;
			hpHeCache.p = metrics.pHigh;
			hpHeCache.gravelMin = metrics.gravelMinHp / 1000;
			hpHeCache.gravelMax = metrics.gravelMaxHp / 1000;
			hpHeCache.medianDP = (hpHeCache.gravelMin + hpHeCache.gravelMax) / 2;
			hpHeCache.gravelDensityKgInM3 = metrics.gravelDensity * 1000;
			hpHeCache.rockHeatingTime = rockHeatingTime;	// recalc rock temperature in 1 h steps
		}

		var getInitialRockTemp = function(h, hMid, hMax, heLength, tMin, tMax ) {
			const heTop = hMid + heLength/2;
			const heBottom = hMid - heLength/2;
			if (h >= heTop) {
				return tMax; // - 5*(hMax-h)/(hMax-heTop);
			}
			else if (h <= heBottom) {
				return tMin; // + 5*h/heBottom;
			}
			else if (h <= hMid) {
				return tMin + Math.pow((h-heBottom)/(heLength/2),2) * (tMax-tMin)/2;
			}
			else  {
				return tMax - Math.pow((heTop-h)/(heLength/2),2) * (tMax-tMin)/2;
			}
		}
		// metrics.heLengthHp, metrics.heLengthLp,  metrics.hColdHpGravel, metrics.hMidLpFromGround;
		const hIce = metrics.externalIceStorage ? cycleData.iceStorage.height : 0;
		const iceArea = 1.2*metrics.lowPressureStorageVolume / hIce;	// start with something
		const hLP = metrics.topFillWithIceWithStorage ? cycleData.iceStorage.height : hIce+metrics.hBelowActual+(metrics.topFillUsedAsWeight ? 0 : metrics.hAbove);
		
		if (lpTemps.length == 0) {
			lpInitialRockTemp = [];
			const hMidLp = metrics.hBelowActual+metrics.hMidLpFromGround;
			var volume = 0;
			for (h = stepLen; h < hLP; h += stepLen) {
				var item = {};
				// Set lp storage to the min energy level
				//item.tRock = getInitialRockTemp(h, hLP/5, hLP, hLP*2/5, lpLiquidStorage.tHigh, tHighLp);
				item.tRock =  metrics.topFillWithIceWithStorage ? tHighLp : tLowLp; // getInitialRockTemp(h, hLP*0.1, hLP, metrics.topFillWithIceWithStorage ? 1 : metrics.heLengthLp, tLowLp, tHighLp);
				//item.tRock = 283; // 10 C
				//item.tRock = h < hMidLp ? tLowLp : tHighLp;
				//item.hGasOut = h < hMidLp ? hLowLp : hHighLp;
				lpInitialRockTemp.push(item.tRock);
				if (metrics.topFillWithIceWithStorage) {
					item.area = cycleData.iceStorage.areaM2;
				}
				else if (h < hIce) {
					item.area = cycleData.iceStorage.getArea(h);
					item.type = 'ice';
				}
				else {
					var r;
					if (h > metrics.hBelowActual) {
						const hAboveCur = h - metrics.hBelowActual;
						r = metrics.rGround - (metrics.rGround-metrics.rTop)*hAboveCur/metrics.hAbove;
						if (!r) {
							console.log(r+" = "+metrics.rGround+" - ("+metrics.rGround+"-"+metrics.rTop+")*"+hAboveCur+"/"+metrics.hAbove);
						}
					}
					else {
						r = metrics.rOpenBottomActual + (metrics.rGroundBelowActual-metrics.rOpenBottomActual)*h/metrics.hBelowActual;
					}
					item.area = (r*r*Math.PI);		// correction factor for low heat capasity
				}
				volume += item.area * stepLen;
if (!item.area) {
// Bad area=NaN, r=NaN, h=59.5, metrics.rOpenBottomActual=148.37160254662282, metrics.rGroundBelowActual=166.47297467271602, metrics.hBelowActual=59.2069204167878
	console.log("Bad area="+item.area+", r="+r+", h="+h+", metrics.rOpenBottomActual="+metrics.rOpenBottomActual+", metrics.rGroundBelowActual="+metrics.rGroundBelowActual+", metrics.hBelowActual="+metrics.hBelowActual);
	return false;
}
				lpTemps.push(item);
			}
			const lpCpToGasCp = getAverageRockHeatCapasitykJinKg(tLowLp, tHighLp)*1000*(tHighLp-tLowLp)*volume 
					/ (Module.PropsSI('H', 'P', pLow, 'T', tHighLp, name)-Module.PropsSI('H', 'P', pLow, 'T', tLowLp, name));
			const cpHighGravel = getRockHeatCapasityJinKgK(tHighLp), cpLowGravel = getRockHeatCapasityJinKgK(tLowLp);
			const cpLowIce = getRockHeatCapasityJinKgK(tLowLp, 'ice');
			// iceVolume*metrics.lpGravelDensity*cpLowIce+ cpLowGravel*volume*metrics.lpGravelDensity=cpHighGravel*volume*metrics.lpGravelDensity =>
			const iceVolume = (cpHighGravel*volume-cpLowGravel*volume) / cpLowIce;
console.log("LP Storage size:"+myRound(volume*metrics.lpGravelDensity/1000000, 1)+" Mton, lpCpToGasCp="+lpCpToGasCp+", iceVolume="+(iceVolume/1000000));
		}
		else {
			for (i = 0; i < lpTemps.length; i++) {
				lpInitialRockTemp[i] = lpTemps[i].tRock;
			}
		}
//console.log("lpTemps:"+JSON.stringify(lpTemps));
		if (hpTemps.length == 0) {
			const hMidHp = metrics.hColdHpGravel;
			hpInitialRockTemp = [];
			volume = 0;
			//const tLowHp= Module.PropsSI('T', 'P', hpHeCache.p, 'H', hLowHp, name);
			//const tHighHp= Module.PropsSI('T', 'P', hpHeCache.p, 'H', hHighHp, name);
			for (h = stepLen; h < metrics.dome.hBottomI+stepLen; h += stepLen) {
				var item = {};
				//item.tRock = getInitialRockTemp(h, metrics.dome.hBottomI-metrics.heLengthHp/2, metrics.dome.hBottomI, metrics.heLengthHp, tLowHp, tHighHp-hpMaxHighDiff);
				item.tRock = metrics.topFillWithIceWithStorage || h < (metrics.dome.hBottomI/2) ? tLowHp : tHighHp; // getInitialRockTemp(h, metrics.dome.hBottomI*0.9, metrics.dome.hBottomI, metrics.heLengthHp, tLowHp, tHighHp);
				//item.tRock = 283; // 10 C
				//item.tRock = h < hMidHp ? tLowHp : tHighHp;
				//item.hGasOut = h < hMidHp ? hLowHp : hHighHp;
				hpInitialRockTemp.push(item.tRock);
				const r = metrics.dome.rBottomI + (metrics.dome.rTopI-metrics.dome.rBottomI)*h/metrics.dome.hBottomI;
				item.area = (r*r*Math.PI);
				volume += item.area * stepLen;
				
if (!item.area) {
	console.log("Bad area="+item.area+", r="+r+", h="+h);
	return false;
}
				hpTemps.push(item);
			}
			const hpCpToGasCp = getAverageRockHeatCapasitykJinKg(tLowHp, tHighHp)*1000*(tHighHp-tLowHp)*volume 
					/ (Module.PropsSI('H', 'P', metrics.pHigh, 'T', tHighHp, name)-Module.PropsSI('H', 'P', metrics.pHigh, 'T', tLowHp, name));
console.log("HP Storage size:"+myRound(volume*metrics.gravelDensity/1000000, 1)+" Mton, hpCpToGasCp="+hpCpToGasCp);
			//console.log("hpTemps="+JSON.stringify(hpTemps));
		}
		else {
			for (i = 0; i < hpTemps.length; i++) {
				hpInitialRockTemp[i] = hpTemps[i].tRock;
			}
		}
		var loop = -1, hour, tGas, height;
		var tMaxIceStorage = 0, tMinIceStorage = 0, tMax;

		// TBD: randomBalancedDays
//console.log("hpTemps:"+JSON.stringify(hpTemps));
		var simulateCharge = function(calcHC, hours )
		{
			for (hour = 0; hour < hours; hour++) {
				tGas = tLowLp;
				hGas = hLowLp;
				//lpLiquidStorage.useStorage(cycleData.hotCycle[1].massFlow*1000, hGas, tGas, rockHeatingTime, true);
				//tGas = lpLiquidStorage.tOut;
				hGas = 0;
				for (height = 0; height < lpTemps.length; height++) {
					if (!processGasToGravelHeatExchange( lpHeCCache, lpTemps[height], tGas, hGas, cycleData.hotCycle[1].massFlow, calcHC, loop == 0 && height<10 )) {
						console.log(height+":lpTemps["+(height-10)+"-"+(height+10)+"]="+JSON.stringify(lpTemps.slice(height >= 10 ? height-10 : 0,(height+10) < lpTemps.length ? height+10 : lpTemps.length)));
						return fromHere(loop,height);
					}
					tGas = lpTemps[height].tRock;
					hGas = lpTemps[height].hGasOut;
					if (!processGravelHeatTransfer(lpHeCCache, lpTemps, height, loop == 0 && (height < 5 || height > lpTemps.length-5))) {
						console.log(height+":"+JSON.stringify(lpTemps));
						return fromHere(loop,height);
					}
				}
				tGas = tHighHp;
				hGas = hHighHp;
				for (height = hpTemps.length-1; height >= 0; height--) {
					if (!processGasToGravelHeatExchange( hpHeCache, hpTemps[height], tGas, hGas, cycleData.hotCycle[1].massFlow, calcHC, loop == 0 && height > hpTemps.length-10 )) {
						console.log(height+":"+JSON.stringify(hpTemps));
						return fromHere(loop,height);
					}
					tGas = hpTemps[height].tRock;
					hGas = hpTemps[height].hGasOut;
					/*if (!tGas || !hGas) {
						console.log(height+": bad item:"+JSON.stringify(lpTemps[height]));
						return false;
					}*/
				}
				for (height = 0; height < hpTemps.length; height++) {
					if (!processGravelHeatTransfer(hpHeCache, hpTemps, height, loop == 0 && (height < 5 || height > hpTemps.length-5))) return fromHere(loop,height);
				}
				//hpLiquidStorage.useStorage(cycleData.hotCycle[1].massFlow*1000, hGas, tGas, rockHeatingTime, false);
			}
			tMinIceStorage = lpTemps[0].tRock;
			return true;
		}
		var simulateDischarge = function(calcHC, hours )
		{
			for (hour = 0; hour < hours; hour++) {
				tGas = tHighLp;
				hGas = lpHeCache.hHigh;
				for (height = lpTemps.length-1; height >= 0; height--) {
					if (!processGasToGravelHeatExchange( lpHeCache, lpTemps[height], tGas, hGas, cycleData.hotCycle[0].massFlow, calcHC, loop == 0 && height > lpTemps.length-10 )) {
						console.log(height+":lpTemps["+(height-10)+"-"+(height+10)+"]="+JSON.stringify(lpTemps.slice(height-10,height+10)));
						return fromHere(hour,height*stepLen);
					}
					tGas = lpTemps[height].tRock;
					hGas = lpTemps[height].hGasOut;
				}
				//lpLiquidStorage.useStorage(cycleData.hotCycle[0].massFlow*1000, hGas, tGas, rockHeatingTime, false, lpHeCache.p, lpHeCache.tLow);
				for (height = 0; height < lpTemps.length; height++) {
					if (!processGravelHeatTransfer(lpHeCache, lpTemps, height, loop == 0 && (height < 5 || height > lpTemps.length-5))) {
						console.log(JSON.stringify(lpTemps));
						return fromHere(loop,height);
					}
				}
				tGas = tLowHp;
				hGas = hLowHp;
				//hpLiquidStorage.useStorage(cycleData.hotCycle[0].massFlow*1000, hGas, tGas, rockHeatingTime, true);
				//tGas = hpLiquidStorage.tOut;
				hGas = 0; // hpLiquidStorage.hOut;
				for (height = 0; height < hpTemps.length; height++) {
					if (!processGasToGravelHeatExchange( hpHeCache, hpTemps[height], tGas, hGas, cycleData.hotCycle[0].massFlow, calcHC, loop == 0 && height<10 )) return fromHere(loop,height*stepLen);
					tGas = hpTemps[height].tRock;
					hGas = hpTemps[height].hGasOut;
					if (!processGravelHeatTransfer(hpHeCache, hpTemps, height, loop == 0 && (height < 5 || height > hpTemps.length-5))) {
						console.log(JSON.stringify(hpTemps));
						return fromHere(loop,height);
					}
				}
			}
			if (metrics.externalIceStorage) {
				const h = Math.round(cycleData.iceStorage.height/stepLen);
				if (lpTemps[h].tRock > tMaxIceStorage) tMaxIceStorage = lpTemps[h].tRock;
				tMax = lpTemps[lpTemps.length-1].tRock;
			}
			return true;
		}
//console.log("lpTemps:"+JSON.stringify(lpTemps, null, 2));
//console.log("hpTemps:"+JSON.stringify(hpTemps, null, 2));
		drawHeatExchangeDiagram2 = function( id, items, title, bottomLines, arraysOfVals, minMaxDefault, fpCustomizer ) 
		{
			//console.log(id+":"+title+", bottomLines="+JSON.stringify(bottomLines)); //+", arraysOfVals="+JSON.stringify(arraysOfVals));
			xVals = [];
			yTitles =  [];
			yTitles.push("K");
			for (i = 1; i < arraysOfVals.length; i++) yTitles.push("");
			for (h = 0; h < items.length; h++) {
				xVals.push((h+0.5)*stepLen);
			}
			drawDiagram4Y( id, xVals, 'm', arraysOfVals, yTitles, title, bottomLines, minMaxDefault, fpCustomizer );
		}
		drawStoneAndIceEnthalpies = function( id, tLowLp, tHighHp, fpCustomizer) {
			tLowLp = Math.round(tLowLp), tHighHp = Math.round(tHighHp);
			var xVals = [], arraysOfVals = [], yTitles = [], bottomLines = [];
			minMaxDefault = {min : Math.round(tLowLp/10)*10, max : (1+Math.round(tHighHp/10))*10};
			var iceCp = [], iceH = [], rockCp = [], rockH = [], h = 0;
			bottomLines.push('Gravel heat capasity kJ/m3/K');
			bottomLines.push('Crushed ice heat capasity kJ/m3/K');
			bottomLines.push('Gravel enthalpy MJ/m3, density '+Math.round(1000*metrics.lpGravelDensity)+' kg/m3');
			bottomLines.push('Crushed ice enthalpy MJ/m3, density '+Math.round(1000*metrics.crushedIceDensity)+' kg/m3');
			const dLiq = Module.PropsSI('D', 'P', lpHeCache.p, 'Q', 0, name);
			const extraTitle = "Gas weigth in tons min/max: "+Math.round(gasWeightMin/1000)+' / '+Math.round(gasWeight/1000)+" => Max liquid volume: "+Math.round((gasWeight-gasWeightMin)/dLiq)+" m3";
			yTitles.push('kJ/m3/K');
			yTitles.push('kJ/m3/K');
			yTitles.push('MJ/m3');
			yTitles.push('MJ/m3');
			for (t = tLowLp; t <= 273; t++) {
				const cp = getIceHeatCapasityKJinKgK(t)*1000*metrics.crushedIceDensity;	// ice density
				iceCp.push(cp);
				h = h + (cp/1000);
				iceH.push(h);
			}
//console.log(JSON.stringify(iceH));
			h = 0;
			for (t = tLowLp; t <= tHighHp; t++) {
				xVals.push(t);
				const cpRock = getRockHeatCapasityJinKgK(t) * metrics.lpGravelDensity;
				rockCp.push(cpRock);
				h = h + (cpRock/1000);
				rockH.push(h);
			}
//console.log(JSON.stringify(rockH));
//console.log(JSON.stringify(iceCp));
//console.log(JSON.stringify(rockCp));
//console.log("Ice enthalpy(t): "+Math.round(tLowLp+50)+"="+iceH[50]+", "+Math.round(tLowLp+100)+"="+iceH[100]+", "+Math.round(tLowLp+150)+"="+iceH[150]+", 273="+iceH[Math.round(273-tLowLp)]);
//console.log("RockEnthalpy(t): "+Math.round(tLowLp+50)+"="+rockH[50]+", "+Math.round(tLowLp+100)+"="+rockH[100]+", "+Math.round(tLowLp+150)+"="+rockH[150]+", 273="+rockH[Math.round(273-tLowLp)]);
			arraysOfVals.push(rockCp);
			arraysOfVals.push(iceCp);
			arraysOfVals.push(rockH);
			arraysOfVals.push(iceH);

			showIceEndEnthalpy = function (ctx, dg) {
				const i = iceH.length-1;
				ctx.font = "12px Arial";
				ctx.fillStyle = 'blue';
				ctx.fillText( Math.round(iceH[i]/metrics.crushedIceDensity)+" kJ/kg", toX(dg, xVals[i]), toY(dg, iceH[i]));
			};
			drawDiagram4Y( id, xVals, 'K', arraysOfVals, yTitles, "Crushed ice and gravel heat capasities and enthalpies in this simulation,"+extraTitle, bottomLines, null, showIceEndEnthalpy );
		}
		
		drawHeatExchangeDiagram = function( id, items, title, initialTemps, minMaxDefault ) 
		{
			var xVals = [], bottomLines = [], arrayOfyVals = [], yTitles =  [], i;
			var bottomLines = [];

			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			xVals = [];

			bottomLines.push("Gravel temp after "+chargeDays+" charge days");
			yTitles.push("K");
			bottomLines.push(+chargeDischargeDays+" days 16h charge+8h discharge");
			yTitles.push("");
			bottomLines.push(dischargeDays+" days 16h discharge+8 charge");
			yTitles.push("");
			bottomLines.push("Gravel temp after "+idleDays+" idle days");
			yTitles.push("");
			//bottomLines.push("Initial gravel temp");
			//yTitles.push("");
/*
			for (h = 0; h < initialTemps.length; h++) {
				arrayOfyVals[3].push(initialTemps[h]);
			}
*/
			//bottomLines.push("Gas/gravel heat exchange W/m3/K");
			//yTitles.push("W/m3/K");
			//bottomLines.push("Gravel heat transfer W/m");
			//yTitles.push("W/m");
			//bottomLines.push("Gas temp after charge and discharge");
	//console.log("items="+JSON.stringify(items));
	//console.log("initialTemps="+JSON.stringify(initialTemps));


			for (h = 0; h < items.length; h++) {
				xVals.push((h+0.5)*stepLen);
				try {
					//arrayOfyVals[0].push(items[h].heCofficientInM3);
					//arrayOfyVals[1].push(items[h].heatTransferCoefficient);
					arrayOfyVals[0].push(items[h].tC);
					arrayOfyVals[1].push(items[h].tCDC);
					arrayOfyVals[2].push(items[h].tDC);
					arrayOfyVals[3].push(items[h].tRock);
				}
				catch (e) {
					console.log("Ignored h="+h+":"+JSON.stringify(items[h]));
				}
			}
	/*		
			bottomLines.push("Initial gravel temp");
			yTitles.push("K");
			for (h = 0; h < initialTemps.length; h++) {
				arrayOfyVals[2].push(initialTemps[i]);
			}
			bottomLines.push("Gravel temp after "+idleDays+" idle days");
			for (h = 0; h < items.length; h++) {
				arrayOfyVals[3].push(items[h].tRock);
			}
		*/
	//console.log(JSON.stringify(arrayOfyVals))
			drawDiagram4Y( id, xVals, 'm', arrayOfyVals, yTitles, title, bottomLines, minMaxDefault);
		}
		readYVals = function(items, addDeltaT) {
			yVals = [];
			for (j = 0; j < items.length; j++) yVals.push(items[j].tRock + (addDeltaT && items[j].deltaT ? items[j].deltaT : 0));
			return yVals;
		}
		//const lpMaxLowDiff = 2, lpMaxHighDiff  = 20 , hpMaxLowDiff = 20, hpMaxHighDiff = 40;
		//const lpMaxLowDiff = 1, lpMaxHighDiff  = 1 , hpMaxLowDiff = 1, hpMaxHighDiff = 1;		// die fast!
	
		getUnusedLength = function (lpCache) {
			var topSpace = 0, bottomSpace = 0;
			try  {
				for (bottomSpace = 0; (lpTemps[bottomSpace].tRock-lpCache.tLow) < lpMaxLowDiff && bottomSpace < lpTemps.length-1 && lpTemps[bottomSpace] != null; bottomSpace++);
			}
			catch (e) {
				console.log("bottomSpace="+bottomSpace+", lpTemps.length="+lpTemps.length+", lpTemps:"+JSON.stringify(lpTemps));
				throw e;
			}
			for (topSpace = 0; (lpCache.tHigh - lpTemps[lpTemps.length-1-topSpace].tRock) < lpMaxHighDiff && topSpace < lpTemps.length-1; topSpace++);
			ret = bottomSpace+", "+topSpace;
			for (bottomSpace = 0; (hpTemps[bottomSpace].tRock-hpHeCache.tLow) < hpMaxLowDiff && bottomSpace < hpTemps.length-1; bottomSpace++);
			for (topSpace = 0; (hpHeCache.tHigh - hpTemps[hpTemps.length-1-topSpace].tRock) < hpMaxHighDiff && topSpace < hpTemps.length-1; topSpace++);
			ret += ", "+bottomSpace+" ,"+topSpace;
			return ret;
		}
		drawIceStorage = function (ctx, dg) {
console.log("drawIceStorage...");
			const hIce = metrics.externalIceStorage ? cycleData.iceStorage.height : 0;
			ctx.beginPath();
			//ctx.moveTo(toX(dg,0),toY(dg,tMinIceStorage)); 
			//ctx.moveTo(toX(dg,hIce),toY(dg,tMinIceStorage)); 
			ctx.moveTo(toX(dg,hIce),toY(dg,tMaxIceStorage)); 
			ctx.lineTo(toX(dg,0),toY(dg,tMaxIceStorage)); 
			ctx.lineTo(toX(dg,0),toY(dg,tMinIceStorage)); 
			//ctx.closePath();
			ctx.strokeStyle = 'blue';
			ctx.lineWidth = 2;
			ctx.stroke();
			ctx.font = "12px Arial";
			ctx.fillStyle = 'blue';
			var text = "tMax="+Math.round(tMaxIceStorage)+" K";
			ctx.fillText( text, toX(dg,hIce/2),toY(dg,tMaxIceStorage)); // -ctx.measureText(text).width
			ctx.font = "16px Arial";
			text = myRound(cycleData.iceStorage.totalMassInTons/1000000,1)+" mt crushed ice";
			ctx.fillText( text, toX(dg,0)+10,toY(dg,tMaxIceStorage/2));

			ctx.beginPath();
			//ctx.moveTo(toX(dg,hIce+10),toY(dg,tMinIceStorage-3));
			//ctx.moveTo(toX(dg,hLP),toY(dg,tMinIceStorage));
			ctx.moveTo(toX(dg,hLP),toY(dg,tMax)-3);
			ctx.lineTo(toX(dg,hIce),toY(dg,tMax)-3);
			ctx.lineTo(toX(dg,hIce),toY(dg,tMinIceStorage));
			//ctx.closePath();
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 2;
			ctx.stroke();
			text = myRound(metrics.lowPressureStorageVolume * metrics.lpGravelDensity/1000000,1)+" mt crushed stone";
			ctx.fillStyle = 'black';
			ctx.fillText( text, toX(dg,hIce)+60,toY(dg,tMax/2));
		}
		lpArraysOfVals = [], hpArraysOfVals = [], bottomLines = [];
		//const lpMaxLowDiff = 1, lpMaxHighDiff  = 20 , hpMaxLowDiff = 10, hpMaxHighDiff = 50;
console.log("Starting...");
		maxLpOutDeltaT = maxHpOutDeltaT = 0;
		minLpOutDeltaT = minHpOutDeltaT = 0;
		const modal = document.getElementById("myModal");
		const modTitle = document.getElementById("modalTitle");
		const modContent = document.getElementById("modalContent");
		
		modTitle.innerText = "Press button to start the simulation";
		modContent.innerText = "The charge/discharge simulation will take "+(simulations*30)+" seconds or more. The browser will be unresponsive, please wait ...";
		modal.style.display = "block";
		document.getElementById("modalStopButton").style.display = "none";
		document.getElementById("modalStartButton").style.display = "block";
		stopChargeDischargeSimulation = false;
		var hTotal = 0;
		fnSimulateChargeDischarge = function() {
			if (name == 'Hydrogen' || name == 'Helium') {
				alert("Storage simulatio is not possible with Hydrogen or Helium. They have too low saturation temperatures.");
				modal.style.display = "none";
				return;
			}
			var startTime = Date.now();
			//document.getElementById("modalStartButton").style.display = "none";
			//document.getElementById("modalStopButton").style.display = "block";
			var i;
			for (i = 0; i < simulations; i++) {
				hCount = 0;
				var tLpOut, tHpOut;
				var prevHour = 0;
				//modTitle.innerText = "Discharging the storage ...";
				//modContent.innerText = "hour 0";
				//sleep(50);

				do {
					if (!simulateDischarge( calcHeatExchangeCoeffcient, 1)) {
						console.log("hCount="+hCount);
						return;
					}
					//console.log(hCount+":9.t="+hpTemps[9].tRock+",h="+hpTemps[9].hGasOut+";10.t="+hpTemps[10].tRock+",h="+hpTemps[10].hGasOut+";11.t="+hpTemps[11].tRock+",h="+hpTemps[11].hGasOut);
					hCount += rockHeatingTime/3600;
					if (Math.round(prevHour/10) < Math.round(hCount/10)) {
						prevHour = Math.round(hCount);
						//modContent.innerText = "hour "+prevHour;
						//sleep(10);
					}
					if (Math.abs(minLpOutDeltaT) < Math.abs(lpTemps[0].deltaT)) minLpOutDeltaT = lpTemps[0].deltaT;
					if (Math.abs(maxHpOutDeltaT) < Math.abs(hpTemps[hpTemps.length-1].deltaT)) maxHpOutDeltaT = hpTemps[hpTemps.length-1].deltaT;
					tLpOut = lpTemps[0].tRock + lpTemps[0].deltaT;
					tHpOut = hpTemps[hpTemps.length-1].tRock + hpTemps[hpTemps.length-1].deltaT;
				} while (tHpOut>(tHighHp-hpMaxHighDiff) && tLpOut<(tLowLp+lpMaxLowDiff) && !stopChargeDischargeSimulation);
				// calculate the weigth of gas after discharge when all gas is in the storage
				if (!gasWeight &&  !stopChargeDischargeSimulation)
				{
					// calc total gas weight in discarge
					gasWeight = 0; 
					var k, d, tPrev = 0, h = stepLen/2
					for (k = 0; k < lpTemps.length; k++) {
						if (Math.abs(lpTemps[k].tRock - tPrev)>1)
						{
							d = Module.PropsSI('D', 'P', lpHeCache.p, 'T', lpTemps[k].tRock, name);
							tPrev = lpTemps[k].tRock;
						}
						if (h < hIce) {
							gasWeight += d*lpTemps[k].area*stepLen*metrics.crushedIcePorosity;
						}
						else {
							gasWeight += d*lpTemps[k].area*stepLen*metrics.lpGravelPorosity;
						}
					}
					h = stepLen/2, tPrev = 0;
					for (k = 0; k < hpTemps.length; k++) {
						if (Math.abs(hpTemps[k].tRock - tPrev)>1)
						{
							d = Module.PropsSI('D', 'P', hpHeCache.p, 'T', hpTemps[k].tRock, name);
							tPrev = hpTemps[k].tRock;
						}
						gasWeight += d*hpTemps[k].area*stepLen*metrics.hpGravelPorosity;
					}
				}
				hTotal += hCount;
				console.log("Reason NOT:"+tHpOut+">"+(tHighHp-hpMaxHighDiff)+" && "+tLpOut+"<"+(tLowLp+lpMaxLowDiff)+", hCount="+hCount);
	//console.log("hpLiquidStorage="+JSON.stringify(hpLiquidStorage));
				console.log("Discharged "+hCount+" hours, minLpOutDeltaT="+minLpOutDeltaT+", maxHpOutDeltaT="+maxHpOutDeltaT);
				lpArraysOfVals.push(readYVals(lpTemps));
				hpArraysOfVals.push(readYVals(hpTemps));
				bottomLines.push("Gravel temp after "+Math.round(hCount)+" hours discharge"); // : "+getUnusedLength(lpHeCache));

				if (calcHeatExchangeCoeffcient && i == (simulations-1)) {
					lpArraysOfVals.push(readYVals(lpTemps, true));
					hpArraysOfVals.push(readYVals(hpTemps, true));
					bottomLines.push("Gas temperature in last discharge (dots)"); // : "+getUnusedLength(lpHeCCache));
				}

				//modTitle.innerText = "Charging the storage ...";
				//modContent.innerText = "hour 0";
				//sleep(50);
				hCount = 0;
				prevHour = 0;
				for (;;) {
					if (!simulateCharge( calcHeatExchangeCoeffcient, 1)) return;
					if (false && i == 0 && hCount==0) {
						console.log(JSON.stringify(hpTemps));
						return;
					}
					hCount += rockHeatingTime/3600;
					/*
					if (Math.round(prevHour/10) < Math.round(hCount/10)) {
						prevHour = Math.round(hCount);
						modContent.innerText = "hour "+prevHour;
						sleep(10);
					}*/
					if (Math.abs(maxLpOutDeltaT) < Math.abs(lpTemps[lpTemps.length-1].deltaT)) maxLpOutDeltaT = lpTemps[lpTemps.length-1].deltaT;
					if (Math.abs(minHpOutDeltaT) < Math.abs(hpTemps[0].deltaT)) minHpOutDeltaT = hpTemps[0].deltaT;

					tLpOut = lpTemps[lpTemps.length-1].tRock + lpTemps[lpTemps.length-1].deltaT;
					tHpOut = hpTemps[0].tRock + hpTemps[0].deltaT;
					if (tHpOut>(tLowHp+hpMaxLowDiff) || tLpOut<=(tHighLp-lpMaxHighDiff) || stopChargeDischargeSimulation) 
					{
						console.log("Reason NOT:"+tLpOut+">"+(tHighLp-lpMaxHighDiff)+" && "+tHpOut+"<"+(tLowHp+hpMaxLowDiff)+", hCount="+hCount);
						break;
					}
					/*if (!swapTHighLpAndTLowHp) {
						if (tLpOut<=(tHighLp-lpMaxHighDiff)) {
							console.log("Reason:"+tLpOut+">"+(tLowHp+hpMaxLowDiff)+", hCount="+hCount);
							break;
						}
					}*/
				}
				if (!gasWeightMin && !stopChargeDischargeSimulation)
				{
					// calc total gas weight in discarge
					gasWeightMin = 0; 
					var k, d, tPrev = 0, h = stepLen/2
					for (k = 0; k < lpTemps.length; k++) {
						if (Math.abs(lpTemps[k].tRock - tPrev)>1)
						{
							d = Module.PropsSI('D', 'P', lpHeCCache.p, 'T', lpTemps[k].tRock, name);
							tPrev = lpTemps[k].tRock;
						}
						if (h < hIce) {
							gasWeightMin += d*lpTemps[k].area*stepLen*metrics.crushedIcePorosity;
						}
						else {
							gasWeightMin += d*lpTemps[k].area*stepLen*metrics.lpGravelPorosity;
						}
					}
					h = stepLen/2, tPrev = 0;
					for (k = 0; k < hpTemps.length; k++) {
						if (Math.abs(hpTemps[k].tRock - tPrev)>1)
						{
							d = Module.PropsSI('D', 'P', hpHeCache.p, 'T', hpTemps[k].tRock, name);
							tPrev = hpTemps[k].tRock;
						}
						gasWeightMin += d*hpTemps[k].area*stepLen*metrics.hpGravelPorosity;
					}
					const dLiq = Module.PropsSI('D', 'P', lpHeCache.p, 'Q', 0, name);
					const gasWeightText = "Gas min weigth "+Math.round(gasWeightMin/1000)+" tons, max weigth"+Math.round(gasWeight/1000)+" tons, => max liquid volume: "+Math.round((gasWeight-gasWeightMin)/dLiq)+" M3";
					//document.getElementById("modGasWeight").innerText = gasWeightText;
					console.log(gasWeightText);
					//sleep(10);
				}
				hTotal += hCount;
				console.log("Charged "+hCount+" hours, maxLpOutDeltaT="+maxLpOutDeltaT+", minHpOutDeltaT="+minHpOutDeltaT);
				lpArraysOfVals.push(readYVals(lpTemps));
				hpArraysOfVals.push(readYVals(hpTemps));
				bottomLines.push("Gravel temp after "+Math.round(hCount)+" hours charge"); // : "+getUnusedLength(lpHeCCache));
				
				if (calcHeatExchangeCoeffcient && i == (simulations-1)) {
					lpArraysOfVals.push(readYVals(lpTemps, true));
					hpArraysOfVals.push(readYVals(hpTemps, true));
					bottomLines.push("Gas temperature in last charge (dots)"); // : "+getUnusedLength(lpHeCCache));
				}
				if (stopChargeDischargeSimulation) break;
			}
		    var elapsedTime = Date.now() - startTime;
			console.log("elapsedTime="+Math.round(elapsedTime/1000)+" seconds "); 

	//console.log("lpTemps="+JSON.stringify(lpTemps));
	//console.log("hpTemps="+JSON.stringify(hpTemps));

	//console.log("lpHeCCache="+JSON.stringify(lpHeCCache.SAT_ENTHALPY.slice(0, 30)));
	//console.log("lpHeCache="+JSON.stringify(lpHeCache.SAT_ENTHALPY.slice(0, 30)));
	console.log("Showing diagarm...");
			//console.log("Water storage size: "+hpLiquidStorage.sizeInM3()+" m3, capasity: "+hpLiquidStorage.capasityInGWh()+" GWh");
			//console.log("Methane storage size: "+lpLiquidStorage.sizeInM3()+" m3, capasity: "+lpLiquidStorage.capasityInGWh()+" GWh");

			minMaxDefault = {min : Math.round(tLowLp/10)*10, max : (1+Math.round(tHighLp/10))*10};
			drawHeatExchangeDiagram2( 'lpHeatExchangeDiagram', lpTemps, Math.round(hTotal)+ " hours simulation of low-pressure storage", bottomLines, lpArraysOfVals, minMaxDefault, 
				metrics.externalIceStorage ? drawIceStorage : null );
	var rect = document.getElementById('lpHeatExchangeDiagram').getBoundingClientRect();
	console.log("lpHeatExchangeDiagram pos:"+rect.top, rect.right, rect.bottom, rect.left);
			drawStoneAndIceEnthalpies( 'usedHeatCapasitiesAndEnthalpies', tLowLp, tHighHp );
			minMaxDefault = {min : Math.round(tLowHp/100)*100, max : (1+Math.round(tHighLp/100))*100};
			drawHeatExchangeDiagram2('hpHeatExchangeDiagram', hpTemps, Math.round(hTotal)+ " hours simulation of high-pressure storage", bottomLines, hpArraysOfVals, minMaxDefault,	
						function (ctx, dg) {
							text = myRound(metrics.highPressureStorageVolume * metrics.gravelDensity/1000000,1)+" mt crushed stone";
							ctx.font = "16px Arial";
							ctx.fillStyle = 'black';
							const height = metrics.dome.hBottomI;
//console.log("Hp storage text="+text+", pxX="+toX(dg,height/4)+", pxY="+toY(dg,tHighHp/2));							
							ctx.fillText( text, toX(dg,height/4),toY(dg,tHighHp/2));
						});
			modal.style.display = "none";
			document.getElementById("lpHeatExchangeDiagram").scrollIntoView();
		}
	}
	function fromHere(loop,height) { console.trace("From here, height:"+height+", loop="+loop); }
	
	function sleep(ms) {
	  return new Promise(resolve => setTimeout(resolve, ms));
	}
	function calcDiagrams() {
		metrics = {};
		//const cEfficiencyFrom = getFloatParam('cEfficiencyFrom', 0.87);
		//const cEfficiencyTo = getFloatParam('cEfficiencyTo', 0.93);
		const tEfficiencyFrom = getFloatParam('tEfficiencyFrom', 0.87);
		const tEfficiencyTo = getFloatParam('tEfficiencyTo', 0.93);
console.log("tEfficiencyTo="+tEfficiencyTo);
		const pRatioFrom = getIntParam('pRatioFrom', 10);
		const pRatioTo = getIntParam('pRatioTo', 50);
		const hpStorageSizeFrom = getFloatParam('hpStorageSizeFrom', 10);
		const hpStorageSizeTo = getFloatParam('hpStorageSizeTo', 50);
		const tHighFrom = getIntParam('tHighFrom', 800);
		const tHighTo = getIntParam('tHighTo', 900);
		const cryogenicCooling = true; // getBooleanParam('cryogenicCooling');
		const adjustedCompressorPlow = false; //getBooleanParam('adjustedCompressorPlow');

		const tEfficiency= getFloatParam('tEfficiency', 0.92);
		const cEfficiency= getFloatParam('cEfficiency', 0.92);

		const tHigh = getFloatParam('tHigh', 1033);
		const tLow = getFloatParam('tLow', 273);
		//const pHigh = getFloatParam('pHigh_kPa', 2500) *  1000;
		//const pLow = getFloatParam('pLow_kPa', 100) * 1000;
		
		if (!getMetrics()) {
			return;
		}
		const pHigh = metrics.pHigh;
		const pLow = metrics.pLow;
	
		var xVals, bottomLines, arrayOfyVals, yTitles, topTitle;
		xVals = [], bottomLines = [], arrayOfyVals = [], yTitles =  [];
		yTitles.push("€/kWh");
		bottomLines.push("Cost of storage €/kWh");
		yTitles.push("€/kW");
		bottomLines.push("Cost of capasity €/kW");
		yTitles.push("%");
		bottomLines.push("Discharged as electricity %");
		yTitles.push("TWh");
		bottomLines.push("Stored electricity TWh");
		bottomLines.push("Stored District heat TWh");
		bottomLines.push("Extra available District heat above 50°C TWh");
		
		var extra = [];
		var extra2 = [];
		if (document.getElementById('tEffRange').checked)
		{					
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			var eff = tEfficiencyFrom;
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			xVals = [];
			while ((eff - tEfficiencyTo)<0.01) {
				var hotCycle = []
				var coldCycle = []
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, eff, eff, cryogenicCooling, adjustedCompressorPlow, false, eff, eff );
				xVals.push(eff);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				eff += 0.01;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
//console.log("extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram0', xVals, '', arrayOfyVals, yTitles, "1. Turbin and Compressor stage efficiency from "+tEfficiencyFrom+" to "+tEfficiencyTo
					+", tHigh:"+tHigh+" K, pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
						(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" Mt", bottomLines );
			document.getElementById('tEffRange').checked = false;
		}

		if (document.getElementById('tHighRange').checked)
		{
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			var t = tHighFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			while (t <= tHighTo) {
				var hotCycle = []
				var coldCycle = []
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, t, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(t);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				t += 50;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
console.log(xVals.length+"="+extra.length+"="+extra2.length+", extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram1', xVals, 'K', arrayOfyVals, yTitles, "2. Hot storage temperature from "+tHighFrom+" K to "+tHighTo+" K"
					+", pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" Mt", bottomLines );
			document.getElementById('tHighRange').checked = false;
		}
		var p;
		if (document.getElementById('pRatioRange').checked)
		{
			p = pRatioFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			xVals = [];
			extra = [];
			extra2 = [];
			xVals = [];
			var sizeFrom = 0;
			var log = '';
			pLowParam = "pLowPressureRatio";
			while (p <= pRatioTo) {
				var hotCycle = []
				var coldCycle = []
				metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
				metrics = getMetrics(p);
				if (!metrics) return;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, metrics.pHigh, metrics.pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				if (!sizeFrom) sizeFrom = Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000);
				xVals.push(p);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
//log += "pRatio:"+p+", size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+"\n";
				if (p == pRatioTo) break;
				p *= 1.15;
				if (p > pRatioTo) p = pRatioTo;
			}
			pLowParam = null;
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
//console.log("xVals="+JSON.stringify(xVals));
//console.log("arrayOfyVals="+JSON.stringify(arrayOfyVals));
			const sizeTo = Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000);
			drawDiagram4Y( 'diagram2', xVals, 'pHigh/pLow', arrayOfyVals, yTitles, "3. High/Low pressure ratio from "+pRatioFrom+" to "+pRatioTo
					+", tHigh:"+tHigh+" K, pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+(sizeTo != sizeFrom ? (sizeFrom+" - "+sizeTo) : sizeTo)+" Mt", bottomLines );
			metrics = {};
			document.getElementById('pRatioRange').checked = false;
//console.log(log);
		}
		if (document.getElementById('hpStorageSize').checked)
		{
			p = hpStorageSizeFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			pLowParam = "pLowStorageSize";
			while (p <= hpStorageSizeTo) {
				var hotCycle = []
				var coldCycle = []
				metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
				if (!getMetrics(null, p)) return;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, metrics.pHigh, metrics.pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(p);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(null);
				arrayOfyVals[2].push(null);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				p += 2;	// increment by 500 000 m3
				document.getElementById('hpStorageSize').checked = false;
			}
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
			drawDiagram4Y( 'diagram3', xVals, 'Mm3', arrayOfyVals, yTitles, "4. Hot storage size from "+hpStorageSizeFrom+" to "+hpStorageSizeTo+" Mm3"
					+", tHigh:"+tHigh+" K, pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa", bottomLines );
			pLowParam = null;
			metrics = {};
		}
		if (document.getElementById('dischargeMassFlowRange').checked)
		{
			metrics = {};	// high pressure defines the minumum depth of the cut, storage size and dimensions
			if (!getMetrics()) return;
			const dischargeMassFlowFrom = getFloatParam('dischargeMassFlowFrom', 600);
			const dischargeMassFlowTo = getFloatParam('dischargeMassFlowTo', 6000);
			var t = dischargeMassFlowFrom;
			arrayOfyVals = [];
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			arrayOfyVals.push([]);
			extra = [];
			extra2 = [];
			xVals = [];
			while (t <= dischargeMassFlowTo) {
				var hotCycle = []
				var coldCycle = []
				dischargeMassFlowValue = t;
				const cycleData = doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, false );
				xVals.push(t);
				arrayOfyVals[0].push(cycleData.costOfStoragekWh);
				arrayOfyVals[1].push(cycleData.costOfPowerKW);
				arrayOfyVals[2].push(cycleData.efficiency*100);
				arrayOfyVals[3].push(cycleData.storedElectricity_kWh/1000000000);	// kWh => TWh
				extra.push(cycleData.storedDistrictHeat_kWh/1000000000);	// kWh => TWh
				extra2.push(cycleData.extraAvailableDistrictHeat_kWh/1000000000);
				t += 400;
			}
			dischargeMassFlowValue = null;
			var i;
			for (i = 0; i < extra.length; i++) arrayOfyVals[3].push(extra[i]);
			for (i = 0; i < extra2.length; i++) arrayOfyVals[3].push(extra2[i]);
console.log(xVals.length+"="+extra.length+"="+extra2.length+", extra2="+JSON.stringify(extra2));
			drawDiagram4Y( 'diagram4', xVals, 'MW', arrayOfyVals, yTitles, "5. Main turbins mass flow from "+dischargeMassFlowFrom+" kg to "+dischargeMassFlowTo+" kg"
					+", pHigh/pLow:"+metrics.highToLowPressureRatio+", pLow:"+Math.round(metrics.pLow/1000)+
					(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa, size:"+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" Mt", bottomLines );
			document.getElementById('dischargeMassFlowRange').checked = false;
		}
	}
	function getActualTempAtP( t, pFrom, pTo ) {
		const h = Module.PropsSI('H', 'P', pFrom, 'T', t, name);
		return Module.PropsSI('T', 'P', pTo, 'H', h, name);
	}

	function getEnergyLevelChangeOf1000KgGasFlow( hotCompressor, coldCompressor ) 
	{
			var tc = {};
			// The volume changing the temperature in second for 1000kg mass flow in high pressure storage
			if (metrics.topFillUsedAsColdStorage || metrics.topFillWithIceWithStorage) {
				tc.hpGravelVolume = (hotCompressor.hOut - hotCompressor.hIn) / 
					(1000*metrics.gravelDensity*getAverageRockHeatCapasitykJinKg(hotCompressor.tIn,hotCompressor.tOut)*(hotCompressor.tOut-hotCompressor.tIn));
			}
			else {
				tc.hpGravelVolume = (hotCompressor.hOut - coldCompressor.hOut) / 
					(1000*metrics.gravelDensity*getAverageRockHeatCapasitykJinKg(coldCompressor.tOut,hotCompressor.tOut)*(hotCompressor.tOut-coldCompressor.tOut));
			}
			tc.hpGravelWeight = tc.hpGravelVolume * metrics.gravelDensity;
			tc.hpGasVolume = tc.hpGravelVolume *(metrics.rockDensityHp-metrics.gravelDensity)/metrics.rockDensityHp;
			tc.hpGasCharged = tc.hpGasVolume * hotCompressor.dOut;
			if (metrics.topFillUsedAsColdStorage || metrics.topFillWithIceWithStorage) {
				const d = Module.PropsSI('D', 'T', hotCompressor.tIn, 'P', hotCompressor.pOut, name);
				tc.hpGasDischarged = tc.hpGasVolume * d;
				tc.hpStorageChange = tc.hpGasVolume * (d - hotCompressor.dOut);
			}
			else {
				tc.hpGasDischarged = tc.hpGasVolume * coldCompressor.dOut;
				tc.hpStorageChange = tc.hpGasVolume * (coldCompressor.dOut - hotCompressor.dOut);
			}

			// actualDensity = x * dLiquid + (1-x) * dGas 
			// => x = (actualDensity - dGas) / (dLiquid - dGas);
			tc.dLiq = Module.PropsSI('D', 'T', coldCompressor.tIn, 'Q', 0, name);
			tc.dGas = Module.PropsSI('D', 'T', coldCompressor.tIn, 'Q', 1, name);

			// We must assume, that extra heat of turbin out will sooner or later cooled to compressor in temperature, BUT low pressure may rise until then!!!
			if (metrics.topFillWithIceWithStorage || metrics.topFillUsedAsColdStorage) {
				tc.lpGravelVolume = (coldCompressor.hOut - coldCompressor.hIn) / 
					(1000*metrics.lpGravelDensity*getAverageRockHeatCapasitykJinKg(coldCompressor.tIn,coldCompressor.tOut)*(coldCompressor.tOut-coldCompressor.tIn));
				tc.lpGravelVolume *= 1.1;	// correction factor because of heat convection behaviour
				tc.lpGravelWeight =  tc.lpGravelVolume * metrics.lpGravelDensity;
				tc.lpGasVolume = tc.lpGravelVolume*metrics.crushedIcePorosity;
				const d = Module.PropsSI('D', 'T', coldCompressor.tOut, 'P', coldCompressor.pIn, name);
				tc.lpGasDischarged = tc.lpGasVolume * d;
				//tc.lpGasCharged = tc.lpGasVolume * coldCompressor.dIn;
				tc.lpGasCharged = tc.hpGasDischarged + tc.lpGasDischarged - tc.hpGasCharged;	
				tc.lpDensityCharged = tc.lpGasCharged / tc.lpGasVolume;
				tc.maxPartLiquid = (tc.lpDensityCharged - tc.dGas)/(tc.dLiq - tc.dGas);
				tc.lpStorageChange = tc.lpGasVolume * (d - coldCompressor.dIn);
			}
			else {
				tc.lpGravelVolume = (hotCompressor.hIn - coldCompressor.hIn) / 
					(1000*metrics.lpGravelDensity*getAverageRockHeatCapasitykJinKg(coldCompressor.tIn,hotCompressor.tIn)*(hotCompressor.tIn-coldCompressor.tIn));
				tc.lpGravelWeight =  tc.lpGravelVolume * metrics.lpGravelDensity;
				tc.lpGasVolume = tc.lpGravelVolume*(metrics.rockDensityLp-metrics.lpGravelDensity)/metrics.rockDensityLp;
				tc.lpGasDischarged = tc.lpGasVolume * hotCompressor.dIn;
				tc.lpGasCharged = tc.hpGasDischarged + tc.lpGasDischarged - tc.hpGasCharged;
				tc.lpDensityCharged = tc.lpGasCharged / tc.lpGasVolume;
				tc.maxPartLiquid = (tc.lpDensityCharged - tc.dGas)/(tc.dLiq - tc.dGas);
				tc.lpStorageChange = tc.lpGasVolume * (hotCompressor.dIn - coldCompressor.dIn);
				if (metrics.externalIceStorage) {
					// External ice store must be ice all the time and max temp of ice in the upper part must be hard enough for air pressure and the roof weight
					const tInMaxToIceStorage = 253;	// -20 C
					const hInMaxToIceStorage = Module.PropsSI('H', 'P', coldCompressor.pIn, 'T', tInMaxToIceStorage, name);
					tc.lpGravelVolume = (hotCompressor.hIn - hInMaxToIceStorage) / 
						(1000*metrics.lpGravelDensity*getAverageRockHeatCapasitykJinKg(tInMaxToIceStorage,hotCompressor.tIn)*(hotCompressor.tIn-tInMaxToIceStorage));
					// lp/hp grave relatio seems to be black magic
					tc.lpGravelWeight =  tc.lpGravelVolume * metrics.lpGravelDensity * (name == 'Argon' ? 0.875 : 0.95);
				}
				else {
					tc.lpGravelWeight *= 1.92;	// because of very low rock heat capasity at 76 K (see wiki Debye model)
				}
			}
			tc.changeKg1000 = tc.hpStorageChange + tc.lpStorageChange;
console.log("tc="+JSON.stringify(tc, null, 2));
			return tc;
	}

	function doChargeDischargeCycle( hotCycle, coldCycle, tHigh, tLow, pHigh, pLow, tEfficiency, cEfficiency, cryogenicCooling, adjustedCompressorPlow, showLog, ctEfficiency, ccEfficiency )
	{
		const metrics = getMetrics();
		if (!metrics) return;
		if (typeof ctEfficiency === 'undefined') ctEfficiency= getFloatParam('tHeatPumpEfficiency', getFloatParam('tLowEfficiency', tEfficiency));
		if (typeof ccEfficiency === 'undefined') ccEfficiency= getFloatParam('cHeatPumpEfficiency', getFloatParam('cLowEfficiency', cEfficiency));
		const dischargeMassFlow = dischargeMassFlowValue ? dischargeMassFlowValue : getFloatParam('dischargeMassFlow', 2000);
		const maxPressureDrop = getFloatParam('maxPressureDrop', 0.01);
		const maxOutSpeed = getFloatParam('maxMainTurbinOutSpeed', 100);  // 20 m/s=> kinetic energy 0.025%, 30=>~0.055%, 40m/s=>0.1%
		const powerAndHeat = metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false );
		const coldHeatExchangerLoss = metrics.topFillUsedAsColdStorage || metrics.topFillWithIceWithStorage ? metrics.heatExchangeDeltaT*2 : 0;
		// Heat exchanger delatT = 1/<gas heat exchange coefficient> => deltaT is smaller in warm side,   
		const warmHeatExchangerLoss = metrics.topFillUsedAsColdStorage || metrics.topFillWithIceWithStorage ? 0.74 * 2/metrics.heatExchangeDeltaT*2 : 0;
/*
		metrics.pipeToColdExpander = metrics.pipeFromColdCompressor; 
		metrics.heightOfColdExpanderIn = metrics.heightOfColdCompressorOut;
		metrics.heightAboveColdExpanderIn = metrics.heightAboveColdCompressorOut;
		metrics.heightOfColdExpanderOut = metrics.heightOfColdCompressorIn; 
		metrics.heightAboveColdExpanderOut = metrics.heightAboveColdCompressorIn; 
		metrics.pipeFromColdExpander = metrics.pipeToColdCompressor;
	metrics.heightOfMainCompressorOut = metrics.heightOfMainTurbinIn;
	metrics.pipeToMainCompressor = metrics.pipeFromMainTurbin;
	metrics.heightOfMainCompressorIn = metrics.heightOfMainTurbinOut;
	metrics.pipeFromMainCompressor = metrics.pipeToMainTurbin;
*/
		const pLowInCompressor = pLow;
		var pHighInTurbin = pHigh+getHeadLossPT(pHigh, tHigh, metrics.heightOfMainTurbinIn) ;
// XXX getHeatExchangeDeltaT( midHE, massFlowKg, tHot )
		var tHighActual = getActualTempAtP( tHigh, pHigh, pHighInTurbin );
		if (!powerAndHeat) {
			const testMainCompressor = doAdiabaticProcessWithS( name, pHigh, pLow, tHighActual, 1/cEfficiency,showLog ? "Hot compressor TEST" : null );
			const testMainTurbin = doAdiabaticProcessWithS( name, pHigh, pLow/4, tHighActual, tEfficiency, showLog ? "Hot turbin TEST" : null, null, testMainCompressor.tIn+warmHeatExchangerLoss );
			pLow = metrics.pLow = testMainTurbin.pOut;
			metrics.pLowCompressor = pLowInCompressor;
		}
		else {
			metrics.pLowCompressor = 0;
		}
		var pHighFromCompressor = pHigh+getHeadLossPT(pHigh, tHigh, metrics.heightOfMainTurbinIn);
		var pLowInTurbin = generatorLocation == 'TOP' || generatorLocation == 'GROUND' ? pLow : pLow;	// we do not know out density yet???
		var mainTurbin = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin, tHighActual, tEfficiency, showLog ? "Hot turbin" : null );

		if (generatorLocation != 'TOP' && generatorLocation != 'GROUND') {
			pLowInTurbin = (pLow + getHeadLoss(mainTurbin.dOut, metrics.heightOfMainTurbinOut)); // * (1-maxPressureDrop);
			mainTurbin = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin, tHighActual, tEfficiency, showLog ? "Hot turbin" : null );
		}
		const turbinMassFlow = dischargeMassFlow/1000; // grossWorkOut*1000/mainTurbin.workProduced;
		mainTurbin.massFlow = turbinMassFlow;

		//  Main turbin process producing the gross electricity
		hotCycle.push(mainTurbin);
		var mainHeatExchanger;
		const compressorMassFlow = powerAndHeat ? turbinMassFlow/1.255 : turbinMassFlow/1.0809;/// APPROXIMATION TO CALC THE PRESSURE DROPS!!!
		// Main charge process, the compression from warm pLow => hot pHigh calculated as reverse turbin, because we we know only the high temperature
		var tc;
		const cycleData = {};

		if (true) { //cryogenicCooling) {
			var mainCompressor = doAdiabaticProcessWithS( name, pHighFromCompressor, pLowInCompressor, tHighActual, 1/cEfficiency,showLog ? "Hot compressor" : null, null, powerAndHeat ? null : mainTurbin.tOut-warmHeatExchangerLoss )
			mainCompressor.massFlow = compressorMassFlow;
			hotCycle.push(mainCompressor)

			// First the rough approximations of cold expansion and compression 
			const tSatInMinP = Module.PropsSI('T', 'P', pLowInCompressor, 'Q', 0, name);
			var coldExpander = name == 'TEST_Helium' ? doAdiabaticProcessWithLiquidAirCooling( name, pLowInCompressor, pHigh, 1/ctEfficiency, compressorMassFlow, showLog ? "Cold turbin" : null, tSatAir, 1.37 ) :
					doAdiabaticProcessWithS( name, pLowInCompressor, pHigh, tSatInMinP+0.1, 1/ctEfficiency, showLog ? "Cold turbin" : null);
			coldExpander.massFlow = compressorMassFlow;
			var coldCompressor = name == 'TEST_Helium' ? doAdiabaticProcessWithLiquidAirCooling( name, pLow*(1-maxPressureDrop), pHigh*(1+maxPressureDrop), ccEfficiency, turbinMassFlow, showLog ? "Cold compressor" : null, tSatAir, 1.37 ) :
				doAdiabaticProcessWithS( name, pLow*(1-maxPressureDrop), pHigh*(1+maxPressureDrop), tSatInMinP+0.1, ccEfficiency, showLog ? "Cold compressor" : null); //, null, null, coldExpander.tIn );
			coldCompressor.massFlow = turbinMassFlow;

			if (metrics.topFillWithIceWithStorage || metrics.topFillUsedAsColdStorage) {
				mainHeatExchanger = calcHeatExchanger( turbinMassFlow*1000, hotCycle[0].tOut, coldCompressor.tOut, pHigh, pLow, 0.0025, {sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: 2});
			}
			var dischargePDrops = {};
/*  
The first version produced bullshit:
  "diameterPipeToColdCompressor": 0.07152092219983532,
  "diameterPipeFromColdCompressor": 142.74082452368916,
  "diameterPipeToHotTurbin": 0.04853111548244174,
*/
			var ret = getPipeDiameterAndPressureDrop( coldCompressor.viscIn, coldCompressor.flowIn*coldCompressor.massFlow, coldCompressor.dIn, 
													 metrics.pipeToColdCompressor, maxPressureDrop*coldCompressor.pIn,  0, 25);
			coldCompressor.diameterIn = ret.diameter;
			dischargePDrops.diameterPipeToColdCompressor = ret.diameter;
			dischargePDrops.speedInPipeToColdCompressor = ret.speed;
			dischargePDrops.toColdCompressor = ret.pressureDrop 
											  + getHeadLoss( coldCompressor.dIn, metrics.heightOfColdCompressorIn )
											  + getHeadLoss( mainCompressor.dIn, metrics.heightAboveColdCompressorIn );
			
			// getPipeDiameterAndPressureDrop(visc, flow, density, length, maxPressureDrop,height, heightAbove, densityAbove, pipeDiameter, maxSpeed)
			ret = getPipeDiameterAndPressureDrop( coldCompressor.viscOut, coldCompressor.flowOut*coldCompressor.massFlow, coldCompressor.dOut, 
															metrics.pipeFromColdCompressor, maxPressureDrop*coldCompressor.pOut, 0, 25);
			coldCompressor.diameterOut = ret.diameter;
			dischargePDrops.diameterPipeFromColdCompressor = ret.diameter;
			dischargePDrops.speedInPipeFromColdCompressor = ret.speed;
			dischargePDrops.fromColdCompressor = ret.pressureDrop
											  + getHeadLoss( coldCompressor.dOut, metrics.heightOfColdCompressorOut )
											  + getHeadLoss( mainCompressor.dOut, metrics.heightAboveColdCompressorOut );

			ret = getPipeDiameterAndPressureDrop( mainTurbin.viscIn, mainTurbin.flowIn*mainTurbin.massFlow, mainTurbin.dIn, 
     											  metrics.pipeToMainTurbin, maxPressureDrop*pHigh);
			mainTurbin.diameterIn = ret.diameter;
			dischargePDrops.diameterPipeToHotTurbin = ret.diameter;
			dischargePDrops.speedInPipeToHotTurbin = ret.speed;
			dischargePDrops.toMainTurbin = ret.pressureDrop
											  + getHeadLoss( mainTurbin.dIn, metrics.heightOfMainTurbinIn )

			ret = getPipeDiameterAndPressureDrop( mainTurbin.viscOut, mainTurbin.flowOut*mainTurbin.massFlow, mainTurbin.dOut, 
     											  metrics.pipeFromMainTurbin, 
												  // we have to decrease the allowed pressure drpm, because out pipe may be very short => out speed 160 m/s => 2% efficiency drop
												  maxPressureDrop/10*pLow);
			if (ret.speed > maxOutSpeed) {  //  && name!='Hydrogen' && name!='Helium'
				ret = getPipeDiameterAndPressureDrop( mainTurbin.viscOut, mainTurbin.flowOut*mainTurbin.massFlow, mainTurbin.dOut, 
													  metrics.pipeFromMainTurbin, 
													  maxPressureDrop/10*pLow, 0, maxOutSpeed);
			}
			mainTurbin.diameterOut = ret.diameter;
			dischargePDrops.diameterPipeFromHotTurbin = ret.diameter;
			dischargePDrops.speedInPipeFromHotTurbin = ret.speed;
			dischargePDrops.fromMainTurbin = ret.pressureDrop
										  + getHeadLoss( mainTurbin.dOut, metrics.heightOfMainTurbinOut )


			dischargePDrops.inColdStorage = metrics.topFillWithIceWithStorage ? 
											getHeatExchangerPressureDrop( mainHeatExchanger, mainTurbin.massFlow*1000, false, name ) :  // heat exchanger will be designed for 1% pressure drop, ice storage pressure drop is ~0
											(getColdStoragePressureDrop(0.45, coldCompressor.viscIn, coldCompressor.dIn, coldCompressor.flowIn*coldCompressor.massFlow, metrics.rGroundBelowActual, 
												pLow, coldCompressor.tIn) +
											// most of distance mainCompressor dIn and viscIn applies: 
											getColdStoragePressureDrop(0.55, mainCompressor.viscIn, mainCompressor.dIn, mainTurbin.flowOut*mainTurbin.massFlow, 
												(metrics.topFillUsedAsWeight ? (3*metrics.rGround+metrics.rGroundBelowActual)/4 : (metrics.rGround+3*metrics.rTop)/4), 
												pLow, mainCompressor.tIn));
			dischargePDrops.inHotStorage = (metrics.topFillWithIceWithStorage ? 
												getHotStoragePressureDrop(0.7, mainTurbin.viscOut, mainTurbin.dOut, mainTurbin.flowOut*mainTurbin.massFlow, 
													(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3, 
													pHigh, mainTurbin.tOut) :	// approximation
												getHotStoragePressureDrop(0.7, coldCompressor.viscOut, coldCompressor.dOut, coldCompressor.flowOut*coldCompressor.massFlow, 
													(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3, 
													pHigh, coldCompressor.tOut)) +	// approximation
										  getHotStoragePressureDrop(0.3, mainTurbin.viscIn, mainTurbin.dIn, mainTurbin.flowIn*mainTurbin.massFlow,
												(9*metrics.dome.rTopI+3*metrics.dome.rBottomI)/12, 
												pHigh, mainCompressor.tOut);	
console.log("dischargePDrops:"+JSON.stringify(dischargePDrops, null, 2));
			metrics.dischargePDrops = dischargePDrops;
			var chargePDrops = {};
			// same pipes, main turbin flow is bigger, so the discharge flow defines the pipe diameters
			chargePDrops.diameterPipeFromColdExpander = dischargePDrops.diameterPipeToColdCompressor;
			chargePDrops.diameterPipeToColdExpander = dischargePDrops.diameterPipeFromColdCompressor;
			chargePDrops.diameterPipeFromHotCompressor = dischargePDrops.diameterPipeToHotTurbin;
			mainCompressor.diameterOut = chargePDrops.diameterPipeFromHotCompressor;
			chargePDrops.diameterPipeToHotCompressor = dischargePDrops.diameterPipeFromHotTurbin;
			mainCompressor.diameterIn = chargePDrops.diameterPipeToHotCompressor;
			chargePDrops.inColdStorage = metrics.topFillWithIceWithStorage ? 
										// heat exchanger will be designed for 1% pressure drop, ice storage pressure drop is ~0
										getHeatExchangerPressureDrop( mainHeatExchanger, mainCompressor.massFlow*1000, false, name ) :  
										(getColdStoragePressureDrop(0.55, mainCompressor.viscIn, mainCompressor.dIn, mainCompressor.flowIn*mainCompressor.massFlow,
												(metrics.topFillUsedAsWeight ? (3*metrics.rGround+metrics.rGroundBelowActual)/4 : (metrics.rGround+3*metrics.rTop)/4), 
												pLow, mainCompressor.tIn)+
										 getColdStoragePressureDrop(0.45, coldExpander.viscOut, coldExpander.dOut, coldExpander.flowOut*coldExpander.massFlow, 
												metrics.rGroundBelowActual, pLow, coldCompressor.tIn));
			chargePDrops.inHotStorage = (metrics.topFillWithIceWithStorage ? 
										getHotStoragePressureDrop(0.7, mainCompressor.viscIn, mainCompressor.dIn, mainCompressor.flowIn*mainCompressor.massFlow,
												(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3,
												pHigh, mainCompressor.tIn) :	// approximation
										getHotStoragePressureDrop(0.7, coldCompressor.viscOut, coldCompressor.dOut, coldCompressor.flowOut*mainCompressor.massFlow,
												(metrics.dome.rTopI+2*metrics.dome.rBottomI)/3,
												pHigh, coldCompressor.tOut)) +	// approximation
										getHotStoragePressureDrop(0.3, mainCompressor.viscOut, mainCompressor.dOut, mainCompressor.flowOut*mainCompressor.massFlow,
												(9*metrics.dome.rTopI+3*metrics.dome.rBottomI)/12,
												pHigh, mainCompressor.tOut);	
			ret = getPipeDiameterAndPressureDrop( coldExpander.viscIn, coldExpander.flowIn*coldExpander.massFlow, coldExpander.dIn,
     											  metrics.pipeToColdExpander, maxPressureDrop*pHigh, chargePDrops.diameterPipeToColdExpander);
			coldExpander.diameterIn = ret.diameter;
			chargePDrops.diameterPipeToColdExpander = ret.diameter;
			chargePDrops.speedInPipeToColdExpander = ret.speed;
			chargePDrops.toColdExpander = ret.pressureDrop
										  + getHeadLoss( coldExpander.dIn, metrics.heightOfColdExpanderIn )
										  + getHeadLoss( mainTurbin.dIn, metrics.heightAboveColdExpanderIn );

																		
			// coldCompressor out values apply to the cold side of high pressure storage
			ret = getPipeDiameterAndPressureDrop( coldExpander.viscOut, coldExpander.flowOut*coldExpander.massFlow, coldExpander.dOut,
     											  metrics.pipeFromColdExpander, maxPressureDrop*pLowInCompressor, chargePDrops.diameterPipeFromColdExpander);
			coldExpander.diameterOut = ret.diameter;
			chargePDrops.diameterPipeFromColdExpander = ret.diameter;
			chargePDrops.speedInPipeFromColdExpander = ret.speed;
			chargePDrops.fromColdExpander = ret.pressureDrop
										  + getHeadLoss( coldExpander.dOut, metrics.heightOfColdExpanderOut )
										  + getHeadLoss( mainTurbin.dOut, metrics.heightAboveColdExpanderOut );

			ret = getPipeDiameterAndPressureDrop( mainCompressor.viscOut, mainCompressor.flowOut*mainCompressor.massFlow,  mainCompressor.dOut,
       											  metrics.pipeToMainTurbin, maxPressureDrop*pHigh, mainCompressor.diameterOut );
			chargePDrops.speedInPipeFromMainCompressor = ret.speed;
			chargePDrops.fromMainCompressor = ret.pressureDrop
											  + getHeadLoss( mainCompressor.dOut, metrics.heightOfMainCompressorOut );

			ret = getPipeDiameterAndPressureDrop( mainCompressor.viscIn, mainCompressor.flowIn*mainCompressor.massFlow,  mainCompressor.dIn,
       											  metrics.pipeFromMainTurbin, maxPressureDrop*pLow, mainCompressor.diameterIn );
			chargePDrops.speedInPipeToMainCompressor = ret.speed;
			chargePDrops.toMainCompressor = ret.pressureDrop
											  + getHeadLoss( mainCompressor.dIn, metrics.heightOfMainCompressorIn );
console.log("chargePDrops:"+JSON.stringify(chargePDrops, null, 2));
			metrics.chargePDrops = chargePDrops;
			metrics.dischargePDrops = dischargePDrops;
/*
"rockDensity":2.65,"gravelDensity":2.1,"insGravelDensity":1.6,"rockHeatCapasity":0.8,"hpAverageGravelDensity":2.0019739765394906,*/
			// gas budjet in turbin case: 
			tc = getEnergyLevelChangeOf1000KgGasFlow( mainCompressor, coldCompressor);
			metrics.maxPartLiquid=tc.maxPartLiquid;
			metrics.lpGasVolume = tc.lpGasVolume;
/*{
	const mainTurbinTest = doAdiabaticProcessWithS( name, pHighInTurbin, pLowInTurbin/2, tHighActual, tEfficiency, showLog ? "TEST Hot turbin" : null, null, mainCompressor.tIn );
	const coldCompressorTest = doAdiabaticProcessWithS( name, mainTurbinTest.pOut, pHighInTurbin,  coldCompressor.tIn, ccEfficiency, showLog ? "TEST Cold compressor" : null);
	const dCold = dInTP = Module.PropsSI('D', 'T', mainTurbinTest.tOut, 'P', mainTurbinTest.pOut, name);
	const lpGasVolume = metrics.lpGravelPorosity*metrics.lowPressureStorageVolume;
	const hotDiff = (lpGasVolume*(mainCompressor.dIn-mainTurbinTest.dOut));
	const coldDiff = (lpGasVolume*(coldCompressor.dIn-dCold));
	console.log("Pin/Pout="+(mainTurbinTest.pIn/mainTurbinTest.pOut)+" lpGasVolume="+lpGasVolume+", hotDiff:"+hotDiff+", changeTime:"+(hotDiff/2000)+", coldDiff="+coldDiff+". changeTime:"+(coldDiff/2000));
	//console.log(JSON.stringify(mainTurbinTest,null,0));
}*/


/* cc == tc => tc.changeKg/1000 is the wetness
			var cc = {};
			// we must ignore here all cooled coldExpander in values and use the actuak hp storage values of coldCompressor out !!!
			cc.hpGravelVolume = (hotCycle[1].hOut - coldCompressor.hOut) / (1000*metrics.gravelDensity*metrics.rockHeatCapasity*(hotCycle[1].tOut-coldCompressor.tOut))
			cc.hpGasVolume = cc.hpGravelVolume*(metrics.rockDensity - metrics.gravelDensity)/metrics.rockDensity;
			cc.hpStorageChange = cc.hpGasVolume * (hotCycle[1].dOut - coldCompressor.dOut);
			cc.lpGravelVolume = (hotCycle[1].hIn - coldExpander.hOut) / (1000*metrics.insGravelDensity*metrics.rockHeatCapasity*(hotCycle[1].tIn-coldExpander.tOut));
			cc.lpGasVolume = cc.lpGravelVolume*(metrics.rockDensity-metrics.insGravelDensity)/metrics.rockDensity;
			cc.lpStorageChange = cc.lpGasVolume * (coldExpander.dOut-hotCycle[1].dIn);
			cc.changeKg = cc.lpStorageChange + cc.hpStorageChange;
console.log("cc="+JSON.stringify(cc));
*/
			// What is the required wetness to keep nitrogen in balance: what is the net gas weight change in charge and recharge
			// (should be the same)
			// The calclulated the pressure drops must be adjusted in the cold side pressures
			
			// The cold expander outP > cold compressor inP, but the low pressure cold storage tempreature must be that of compressor. 
			// So we must increase the wetness of cold expander to have the same enthalpy  
			const pLowColdCompressor = pLow - dischargePDrops.inColdStorage - dischargePDrops.toColdCompressor;
console.log("pLowColdCompressor:"+pLowColdCompressor+" = "+pLow+" - "+dischargePDrops.inColdStorage+" - "+dischargePDrops.toColdCompressor);
			const pHighColdCompressor = pHigh + dischargePDrops.inHotStorage + dischargePDrops.fromColdCompressor;
			const pLowColdExpander = pLowInCompressor + chargePDrops.inColdStorage + chargePDrops.fromColdExpander;
console.log("pLowColdExpander:"+pLowColdExpander+" = "+pLowInCompressor+" + "+chargePDrops.inColdStorage+" + "+chargePDrops.fromColdExpander);
			const pHighColdExpander = pHigh - chargePDrops.inHotStorage - chargePDrops.toColdExpander;

			var wetness = name == 'TEST_Helium' ? 0 : Math.abs(tc.changeKg1000/1000);		// wetness in discharge!
			const wetnessOfColdExpander = name == 'TEST_Helium' ? 0 : powerAndHeat ? getWetnessOfP2( name, pLowColdCompressor, pLowColdExpander, wetness ) : wetness;
console.log(pLowColdExpander+", "+pHighColdExpander+", "+wetnessOfColdExpander+", wetness="+wetness);
// 97341.00906709408+ +2473574.4313408597, 0.0033383167053469896, wetness=0.0033383167053469896
			const coldExpander2 = name == 'TEST_Helium' ? doAdiabaticProcessWithLiquidAirCooling( name, pLowColdExpander, pHighColdExpander,  1/ctEfficiency, compressorMassFlow, showLog ? "Cold turbin" : null, tSatAir, 1.37 ) :
									doWetAdiabaticProcessWithS( name, pLowColdExpander, pHighColdExpander, wetnessOfColdExpander, 1/ctEfficiency, showLog ? "Cold turbin" : null);
			coldExpander2.diameterIn = coldExpander.diameterIn;
			coldExpander2.diameterOut = coldExpander.diameterOut;
			coldExpander = coldExpander2;
			coldExpander2.items[0].wetness = wetnessOfColdExpander;	// 1st because in reversed order!
			coldExpander2.wetness = wetnessOfColdExpander;
			
			var tCooled = 0;
			if (!powerAndHeat && name != 'TEST_Helium') {
				wetness = getWetnessOfP2( name, pLowColdExpander, pLowColdCompressor, wetness );
				if (wetness == 0) {
					tCooled = Module.PropsSI('T', 'P', pLowColdCompressor, 'H', coldExpander2.hOut, name);
				}
console.log("Cold compressor tIn: "+coldExpander2.tOut+"=>"+tCooled+", wetness="+wetness+", pLowColdExpander="+pLowColdExpander+", pLowColdCompressor="+pLowColdCompressor );
			}
			const coldCompressor2 = 
				name == 'TEST_Helium' ? doAdiabaticProcessWithLiquidAirCooling( name, pLowColdCompressor, pHighColdCompressor, ccEfficiency, turbinMassFlow, showLog ? "Cold compressor" : null, tSatAir, 1.37 ) :
				tCooled ? doAdiabaticProcess( name, pLowColdCompressor, pHighColdCompressor, coldExpander2.hOut, ccEfficiency, showLog ? "Cold compressor" : null) :
				//doAdiabaticProcessWithS( name, pLowColdCompressor, pHighColdCompressor, tCooled, ccEfficiency, showLog ? "Cold compressor" : null) :
				doWetAdiabaticProcessWithS( name, pLowColdCompressor, pHighColdCompressor, wetness, ccEfficiency, showLog ? "Cold compressor" : null); //, null, null, coldExpander.tIn );
			coldCompressor2.diameterIn = coldCompressor.diameterIn;
			coldCompressor2.diameterOut = coldCompressor.diameterOut;
			coldCompressor2.wetness = wetness;
			coldCompressor = coldCompressor2;
			coldCompressor2.items[0].wetness = wetness;
			coldExpander2.massFlow = compressorMassFlow;
			coldCompressor2.massFlow = turbinMassFlow;
			coldCycle.push(coldCompressor2); 
			coldCycle.push(coldExpander2);
			// TBD: The pressure drop in pipe does not change the enthalpy.  There is probably a small change in temperature, but we ignore it for now

//			const testRun = doAdiabaticProcessWithS( name, pHigh, pLow, hotCycle[0].tOut+5, tEfficiency, null);
//			testRun.massFlow = (hotCycle[0].hOut - hotCycle[1].hIn)/(testRun.hIn-testRun.hOut);
//console.log("SecondTurbin: "+JSON.stringify(testRun));

			if (name == 'TEST_Helium')
			{
				// we must ne mix flows here because mass flow in time unit is the same in charge and discharge
				const hCooled = coldCompressor.hCooled - coldExpander.hCooled;
console.log("Heat pump hCooled="+hCooled);
				const heatPumpHighP = getFloatParam('hpHighPressureKPa', 300)*1000;
				coldCycle.push(doAdiabaticProcessWithLiquidAirCooling( name, heatPumpHighP, pLowInCompressor, ctEfficiency, compressorMassFlow, showLog ? "Heat pump turbin" : null, tSatAir, 1.37));
				coldCycle.push(doAdiabaticProcessWithLiquidAirCooling( name, pLowInCompressor, heatPumpHighP, ccEfficiency, compressorMassFlow, showLog ? "Heat pump compressor" : null, metrics.coolingWaterTemp, 1.37));
			}
			else {

				// coldHeatExchangerLoss is the round trip lost when gas flows twice through main heat exhanger, metrics.heatExchangeDeltaT is temp diff in heat pump heat exchanger
				const heatPumpHighP = getFloatParam('hpHighPressureKPa', 300)*1000;
				const hpFluid = getInputParam('hpFluid', 'Argon' );
				const hpTurbin = doAdiabaticProcessWithS( hpFluid, metrics.heatPumpHighP, metrics.heatPumpHighP/10, coldCycle[0].tOut, // +coldHeatExchangerLoss, 
														  ctEfficiency, showLog ? "Heat pump turbin" : null, null, coldExpander.tIn-metrics.heatExchangeDeltaT );
				coldCycle.push(hpTurbin) // -2 to heat exchanger smaller
				// Heat exchange coldExpander.tOut-2 <=> 
				var heatPumpPin = coldCycle[2].pOut*(1-metrics.heatExchangePressureLoss)*(1-metrics.heatExchangePressureLoss);
				
				if (true || !powerAndHeat) {
					// split 
					const pRelSplit = Math.sqrt(metrics.heatPumpHighP/heatPumpPin);
					const pCool = heatPumpPin*pRelSplit;
					const splitOne = doAdiabaticProcessWithS( hpFluid, heatPumpPin, pCool*(1+metrics.heatExchangePressureLoss), metrics.coolingWaterTemp, ccEfficiency, null );
					const splitTwo = doAdiabaticProcessWithS( hpFluid, pCool, metrics.heatPumpHighP*(1+metrics.heatExchangePressureLoss)*(1+metrics.heatExchangePressureLoss), metrics.coolingWaterTemp, ccEfficiency, null );
					splitOne.pRelSplit = pRelSplit;
					coldCycle.push(addCycleDataI( hpFluid, splitOne, splitTwo, showLog ? "Heat pump compressor" : null  ));
					cycleData.heatPumpCompressorOne = splitOne;
					cycleData.heatPumpCompressorTwo = splitTwo;
// TBD 4 heat pump heat exchangers
//				mainHeatExchanger = calcHeatExchanger( turbinMassFlow*1000, hotCycle[0].tOut, coldCompressor.tOut, pHigh, pLow, 0.0025, {sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: 2});
				}
				else {
					coldCycle.push(doAdiabaticProcessWithS( hpFluid, heatPumpPin, metrics.heatPumpHighP, powerAndHeat ? metrics.heatPumpCompressorTin : metrics.coolingWaterTemp, ccEfficiency, showLog ? "Heat pump compressor" : null ))
				}
			}
//X  TBD:  Laske lämpöpumpun massavirta ja sen h-kerroin x,  teho MW == h * x / 1000, 1 == 1000 kg> 
		}
/*
		else if (adjustedCompressorPlow) {
			hotCycle.push(doAdiabaticProcessWithS( name, pHigh, pLow, tHigh, 1/ccEfficiency, null, hotCycle[0].tOut, showLog ? "Hot compressor" : null))
			const coldExpander = doAdiabaticProcessWithS( name, pHigh, hotCycle[1].pIn, tLow, ctEfficiency, showLog ? "Cold turbin" : null )
			coldCycle.push(doAdiabaticProcessWithS( name, pLow, pHigh, coldExpander.tOut, ccEfficiency ))
			coldCycle.push(coldExpander)
		}
		else {
			hotCycle.push(doAdiabaticProcessWithS( name, pHigh, pLow, tHigh, 1/ccEfficiency,showLog ? "Hot compressor" : null))
			const coldExpander = doAdiabaticProcessWithS( name, pHigh, pLow, tLow, ctEfficiency, showLog ? "Cold turbin" : null )
			coldCycle.push(doAdiabaticProcessWithS( name, pLow, pHigh, coldExpander.tOut, ccEfficiency, showLog ? "Cold compressor" : null ))
			coldCycle.push(coldExpander)
		}
*/		
		cycleData.mainHeatExchanger = mainHeatExchanger;
		cycleData.constantRpmHot = true; // $('#hotCompressorTypeConstantRpm').prop('checked');
		cycleData.constantRpmCold = true; // $('#coldCompressorTypeConstantRpm').prop('checked');
		cycleData.tc = tc;

		if (cryogenicCooling && coldCycle.length>2) {
		{
				const hpFluid = getInputParam('hpFluid', 'Argon' );
				const hAfterCooling = Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[0].tOut-metrics.heatExchangeDeltaT, hpFluid);
				const hAfterHeating = Module.PropsSI('H', 'P', coldCycle[3].pOut, 'T', metrics.coolingWaterTemp+metrics.heatExchangeDeltaT, hpFluid);
				const cooling = (coldCycle[0].hOut - coldCycle[1].hIn) * coldCycle[1].massFlow;	// We must use the charge massFlow !!!
				const hpFluidDeltaH = Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[0].tOut-metrics.heatExchangeDeltaT, hpFluid) - 
									   Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[1].tIn-metrics.heatExchangeDeltaT, hpFluid);

				console.log(cooling+" = "+coldCycle[0].hOut+" * "+coldCycle[0].massFlow+" - "+coldCycle[1].hIn+" * "+coldCycle[1].massFlow);
				cycleData.cooling = cooling;
				console.log("hAfterCooling="+hAfterCooling+" ("+(coldCycle[0].tOut-metrics.heatExchangeDeltaT)+" K,"+coldCycle[2].pOut+")");
				console.log("hAfterHeating="+hAfterHeating+" ("+(metrics.coolingWaterTemp+metrics.heatExchangeDeltaT)+","+coldCycle[3].pOut+")");
/*				
	console.log("coldCycle[3].hIn="+coldCycle[3].hIn+" ("+coldCycle[3].tIn+","+coldCycle[3].pIn+")");
	console.log("=="+(coldCycle[3].hIn-hAfterCooling));
	console.log("- coldCycle[2].hIn="+coldCycle[2].hIn+" ("+coldCycle[2].tIn+","+coldCycle[2].pIn+")");
	console.log("=="+(hAfterHeating - coldCycle[2].hIn));*/
				cycleData.internalExtraCooling = (hAfterHeating - coldCycle[2].hIn) - (coldCycle[3].hIn-hAfterCooling);
//console.log("cycleData.internalExtraCooling:"+cycleData.internalExtraCooling+" = ("+hAfterHeating+" - "+coldCycle[2].hIn+") - ("+coldCycle[3].hIn+"-"+hAfterCooling);
				coldCycle[2].massFlow = coldCycle[3].massFlow = cooling/(hpFluidDeltaH-cycleData.internalExtraCooling); // enthaply change is the same 
console.log("Heat pump massFlow:"+coldCycle[3].massFlow+"="+cooling+"/("+hpFluidDeltaH+"-"+cycleData.internalExtraCooling+")"); //+"hAfterCooling+" - "+coldCycle[2].hOut+" - "+cycleData.internalExtraCooling+")");
				cycleData.heatPumpCompressorOne.massFlow = cycleData.heatPumpCompressorTwo.massFlow = coldCycle[2].massFlow;
				cycleData.heatPumpNetWorkIn = (coldCycle[3].workConsumed-coldCycle[2].workProduced) * coldCycle[2].massFlow; //metrics.frequencyConverterEfficiency;
				cycleData.heatPumpFrequencyConverterLoss1000 = cycleData.heatPumpNetWorkIn1000 * 0; //(1-metrics.frequencyConverterEfficiency);
				cycleData.heatPumpHeating = (cycleData.heatPumpCompressorOne.hOut - cycleData.heatPumpCompressorTwo.hIn + cycleData.heatPumpCompressorTwo.hOut - hAfterHeating) * coldCycle[2].massFlow;
				cycleData.heatPumpCooling = cooling;
				cycleData.heatPumpHeatExchange = (hAfterHeating - coldCycle[2].hIn) * coldCycle[2].massFlow;
				cycleData.heatPumpLoss = cycleData.heatPumpNetWorkIn + cycleData.heatPumpCooling; // cycleData.heatPumpHeating
				cycleData.heatPumpNetWorkIn1000 = cycleData.heatPumpNetWorkIn / coldCycle[2].massFlow;
				cycleData.heatPumpHeating1000 = cycleData.heatPumpHeating / coldCycle[2].massFlow;
console.log("*****cycleData.heatPumpNetWorkIn1000="+cycleData.heatPumpNetWorkIn1000+"= "+cycleData.heatPumpNetWorkIn+" / "+coldCycle[2].massFlow+", workConsumed="+coldCycle[3].workConsumed+", workProduced="+coldCycle[2].workProduced);
			}
			//if (cycleData.heatPumpHeatExchange < 0) cycleData.heatPumpHeatExchange = 0;
			//cycleData.heatPumpHeatExchange1000 = (cycleData.heatPumpHeatExchange + cooling + cycleData.heatPumpHeating)/ coldCycle[1].massFlow;
//console.log( "Heat pump: mass flow: "+Math.round(coldCycle[2].massFlow*1000)+", hAfterCooling="+hAfterCooling+", coldCycle[2].hOut="+coldCycle[2].hOut);
			//mainHeatExchanger = calcHeatExchanger( turbinMassFlow*1000, hotCycle[0].tOut, coldCompressor.tOut, pHigh, pLow, 0.0025, {sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: 2});
		}
		else {
			cycleData.cooling = 0;
			cycleData.heatPumpNetWorkIn = 0;
			cycleData.heatPumpHeating = 0;
			cycleData.heatPumpCooling = 0;
			cycleData.heatPumpHeatExchange = 0;
			cycleData.heatPumpNetWorkIn1000 = 0;
		}
		// scale heatPumpNetWorkIn to charge massFlow=1
		const hotGearEfficiency = (cycleData.constantRpmHot ? 1 : metrics.gearEfficiency);
		const coldGearEfficiency = (cycleData.constantRpmCold ? 1 : metrics.gearEfficiency);
		cycleData.turbinMassFlow1000 = hotCycle[0].massFlow;
		cycleData.compressorMassFlow1000 = hotCycle[1].massFlow;
		cycleData.workConsumed1000 = (hotCycle[1].workConsumed/hotGearEfficiency 
									 -coldCycle[1].workProduced*hotGearEfficiency*coldGearEfficiency) / metrics.generatorEfficiency;
		cycleData.gearLoss1000 = hotCycle[1].workConsumed*(1-hotGearEfficiency) + coldCycle[1].workProduced*(1 - hotGearEfficiency*coldGearEfficiency);
		cycleData.generatorLoss1000 = cycleData.workConsumed1000 * (1-metrics.generatorEfficiency);
//console.log("gearLoss: "+cycleData.gearLoss1000+" = "+(hotCycle[1].workConsumed*(1 - hotGearEfficiency))+" + "+(coldCycle[1].workProduced*(1 - hotGearEfficiency*coldGearEfficiency))+", cycleData.workConsumed1000="+cycleData.workConsumed1000);
//console.log("hotCycle[0].massFlow="+hotCycle[0].massFlow+", hotCycle[1].massFlow="+hotCycle[1].massFlow);
		cycleData.workConsumed1000 += cycleData.heatPumpNetWorkIn; 	
		cycleData.workProduced1000 = (hotCycle[0].workProduced*hotGearEfficiency
									  - coldCycle[0].workConsumed/(hotGearEfficiency*coldGearEfficiency)) 
									  * metrics.generatorEfficiency;
//console.log("gearLoss2: "+cycleData.gearLoss+" = "+(hotCycle[0].workProduced*(1-metrics.gearEfficiency))+" + "+(coldCycle[0].workConsumed*(1 - metrics.gearEfficiency*metrics.gearEfficiency)));
		cycleData.efficiency =  cycleData.workProduced1000 / cycleData.workConsumed1000;
		if (motorGenerator) {
			const workProduced0 = hotCycle[0].workProduced * hotCycle[0].massFlow*hotGearEfficiency;
			const workConsumed0 = coldCycle[0].workConsumed * coldCycle[0].massFlow/hotGearEfficiency;
			const workConsumed1 = hotCycle[1].workConsumed * hotCycle[1].massFlow/(coldGearEfficiency*hotGearEfficiency);
			const workProduced1 = coldCycle[1].workProduced * coldCycle[1].massFlow*coldGearEfficiency*hotGearEfficiency;
			const netWorkOut = (workProduced0-workConsumed0)*metrics.generatorEfficiency;
			const netWorkIn = (workConsumed1 + cycleData.heatPumpNetWorkIn - workProduced1)/metrics.generatorEfficiency; // + cycleData.heatPumpNetWorkIn;
			const oldChargeMassflow = hotCycle[1].massFlow;

			const scaleToTurbinMassFlow = netWorkOut / netWorkIn;
console.log("scaleToTurbinMassFlow="+scaleToTurbinMassFlow);
//			const scaleToTurbinMassFlow = ((hotCycle[0].workProduced*metrics.gearEfficiency-coldCycle[0].workConsumed/(metrics.gearEfficiency*metrics.gearEfficiency))*hotCycle[0].massFlow*metrics.generatorEfficiency) //
//				/ ((hotCycle[1].massFlow*(hotCycle[1].workConsumed/metrics.gearEfficiency-coldCycle[1].workProduced*(metrics.gearEfficiency*metrics.gearEfficiency)))/ metrics.generatorEfficiency); //
//console.log("(("+hotCycle[0].workProduced+"-"+coldCycle[0].workConsumed+")*"+hotCycle[0].massFlow+")/("+hotCycle[1].massFlow+"*("+hotCycle[1].workConsumed+"-"+coldCycle[1].workProduced+"))");
			coldCycle[1].massFlow *= scaleToTurbinMassFlow;
			hotCycle[1].massFlow *= scaleToTurbinMassFlow;
			coldCycle[2].massFlow *= scaleToTurbinMassFlow;
			coldCycle[3].massFlow *= scaleToTurbinMassFlow;
			cycleData.heatPumpCompressorOne.massFlow = cycleData.heatPumpCompressorTwo.massFlow = coldCycle[2].massFlow;
			cycleData.heatPumpNetWorkIn *= scaleToTurbinMassFlow;
			cycleData.heatPumpHeating *= scaleToTurbinMassFlow;
			cycleData.heatPumpCooling *= scaleToTurbinMassFlow;
			cycleData.heatPumpHeatExchange *= scaleToTurbinMassFlow;
console.log("hotCycle[0].massFlow="+hotCycle[0].massFlow+", hotCycle[1].massFlow="+hotCycle[1].massFlow+", scaleToTurbinMassFlow="+scaleToTurbinMassFlow+"; heat pump mass flows:"+coldCycle[2].massFlow+"=="+coldCycle[3].massFlow);
//console.log("hotCycle[0].massFlow="+hotCycle[0].massFlow+", hotCycle[1].massFlow="+oldChargeMassflow+"=>"+hotCycle[1].massFlow+", scaleToTurbinMassFlow="+scaleToTurbinMassFlow+
//			",  coldCycle[0].massFlow="+coldCycle[0].massFlow+", coldCycle[1].massFlow="+coldCycle[1].massFlow+
//			",  coldCycle[2].massFlow="+coldCycle[2].massFlow+", coldCycle[2].massFlow="+coldCycle[2].massFlow);

			cycleData.gearLoss1000 *= scaleToTurbinMassFlow;
			cycleData.generatorLoss1000 *= scaleToTurbinMassFlow;
			cycleData.heatPumpLoss *= scaleToTurbinMassFlow;
		}
		const scaleToCompressor = hotCycle[1].massFlow/hotCycle[0].massFlow;
		const tmp = cycleData.generatorLoss1000;
		cycleData.gearLoss1000 += scaleToCompressor*hotCycle[0].workProduced*(1-hotGearEfficiency) + coldCycle[0].workConsumed*(1 - hotGearEfficiency*coldGearEfficiency); 
		cycleData.generatorLoss1000 += scaleToCompressor*cycleData.workProduced1000 * (1-metrics.generatorEfficiency);
		cycleData.totalLoss1000 = cycleData.heatPumpNetWorkIn + cycleData.gearLoss1000 + cycleData.generatorLoss1000 + cycleData.heatPumpFrequencyConverterLoss1000 + cycleData.coolingLoss1000;;
//console.log("Generator loss: "+tmp+"=>"+cycleData.generatorLoss1000+", cycleData.totalLoss1000="+cycleData.totalLoss1000);
		metrics.insLpSides = metrics.ins*hotCycle[1].tIn/tHigh;
		//calcHeatExchanger( hotCycle[0].massFlow*1000, hotCycle[0].tOut, coldCycle[0].tOut, pHigh, pLow, 0.005, {sheetThickness : 0.0001, sheetDistance :0.00135, heatExchangeDeltaT: 2});
		//cycleData.mainHeatExchanger = calcHeatExchanger( hotCycle[0].massFlow*1000, hotCycle[0].tOut, coldCycle[0].tOut, pHigh, pLow, 0.005, {sheetThickness : 0.0001, sheetDistance :0.000675, heatExchangeDeltaT: 0.5});
//throw new Error("done");
		
		hotCycle[0].workProduced *= hotCycle[0].massFlow*hotGearEfficiency;
		coldCycle[0].workConsumed *= coldCycle[0].massFlow/hotGearEfficiency;
		hotCycle[1].workConsumed *= hotCycle[1].massFlow/(coldGearEfficiency*hotGearEfficiency);
		coldCycle[1].workProduced *= coldCycle[1].massFlow*coldGearEfficiency*hotGearEfficiency;
		cycleData.totalWork = (hotCycle[1].workConsumed - coldCycle[1].workProduced) + cycleData.heatPumpNetWorkIn;
		cycleData.hotWorkConsumed = hotCycle[1].workConsumed;
		cycleData.netWorkOut = (hotCycle[0].workProduced-coldCycle[0].workConsumed)*metrics.generatorEfficiency;
		cycleData.netWorkIn = (hotCycle[1].workConsumed  + cycleData.heatPumpNetWorkIn - coldCycle[1].workProduced)/metrics.generatorEfficiency; // + cycleData.heatPumpNetWorkIn;

		/*
			{"heatPumpCompressorTin":313,"heatExchangeDeltaT":2,"heatPumpHighP":20000000,"r":150,"ins":10,"costOfSurfaceM2":1500,"costOfMiningM3":12,
			"generatorCostOfKW":250,"tcCostOfKW":50,"heCostOfKW":50,"rockDensity":2.65,"gravelDensity":2.1,"insGravelDensity":1.6,"rockHeatCapasity":0.8,
			"V1":6668474.972242486,"totalMiningVolume":13336949.944484971,"hpExpectedAverageDensity":2,"pHighStorageHeight":125,
			"highPressureStorageVolume":6877951.6283572065,"highPressureInsulationMVolume":1957777.7098640874,"hpAverageGravelDensity":1.9892124444444448,
			"V2":2215170.7770067565,"V3":4453304.195235729,"V4":4376186.7005341295,"highPressureStorageSurfaceArea":259181.39392115793,
			"hBelow":71.29999999999998,"hAbove":55.20481933477791,"r2":130.44518066522207,"lowPressureStorageSurfaceArea":318262.12135286065}
		cycleData:{
  "cooling": 49551.11157810138,
  "heatPumpNetWorkIn": 75626.77530681873,
  "heatPumpHeating": 125177.88688492011,
  "heatPumpCooling": 49551.11157810138,
  "heatPumpHeatExchange": 132373.83675519063,
  "efficiency": 0.6606327440961022,
  "totalWork": 709657.4471919491,
  "hotWorkConsumed": 724996.1882342198,
  "netWorkOut": 709657.4471919491,
  "netWorkIn": 634030.6718851303,
  "costOfStorage": 1026208672.2448474,
  "storedElectricity_kWh": null,
  "costOfStorageEkWh": null,
  "costOfPowerKW": 306646249.8139391
}
		*/
		// Heat below 50C cannot be used as District heat
		const hAt323K = Module.PropsSI('H', 'P', hotCycle[1].pIn, 'T', 323, name);
		const hMinDistrictHeat = hotCycle[1].tIn > 323 ? hotCycle[1].hIn : hAt323K;
		cycleData.heatOutInDischarge1000 = (hotCycle[0].hOut- hMinDistrictHeat);
		if (!powerAndHeat || cycleData.heatOutInDischarge1000 < 0) cycleData.heatOutInDischarge1000 = 0;
		cycleData.distictHeatPercent = 100 * (cycleData.heatOutInDischarge1000) / cycleData.workConsumed1000;
		cycleData.heatOutInDischarge = cycleData.heatOutInDischarge1000 * hotCycle[0].massFlow;

		// How long it takes to discharge the high pressure storage with gas flow 1000kg* hotCycle[0].massFlow and deltaH = hotCycle[0].hIn - coldCycle[0].hOut;
//"dischargeTimeS": 3492.9504982300864, ??????
		if (metrics.topFillWithIceWithStorage) {
console.log("Average Cp ("+hotCycle[1].tIn+"-"+hotCycle[0].tIn+")="+getAverageRockHeatCapasitykJinKg(hotCycle[1].tIn,hotCycle[0].tIn));
			// only 50% of theoretical capasity is available because or low Cp 
			cycleData.hpStorageHeatCapacity = 0.5 * 1000*getAverageRockHeatCapasitykJinKg(hotCycle[1].tIn,hotCycle[0].tIn)*metrics.highPressureStorageVolume*1000*metrics.gravelDensity*(hotCycle[0].tIn-hotCycle[1].tIn);
			cycleData.dischargeTimeS = cycleData.hpStorageHeatCapacity / ((hotCycle[0].hIn-hotCycle[1].hIn) * 1000 * hotCycle[0].massFlow); // 
			cycleData.iceStorage = calcIceStorage( hotCycle[0].massFlow*1000, cycleData.dischargeTimeS/3600, coldCycle[0].tIn, coldCycle[0].tOut, pLow );
		}
		else {
			if (metrics.externalIceStorage) {
				cycleData.iceStorage = getExternalIceStorage(coldCycle[0].tIn);
				// With the reference rock heat capasity, temperature and pressure difference
				// 53% of theoretical max capasity is available because of low Cp in cryogenic temprerature // 710/1347
				cycleData.hpStorageHeatCapacity = getFloatParam('hpStorageUtilization', 53)/100 * 1000*getAverageRockHeatCapasitykJinKg(coldCycle[0].tOut,hotCycle[0].tIn)*metrics.highPressureStorageVolume*1000*metrics.gravelDensity*(hotCycle[0].tIn-coldCycle[0].tOut);
			}
			else {
				// only 42% of theoretical max capasity is available because of low rock Cp in cryogenic temprerature
				cycleData.hpStorageHeatCapacity = getFloatParam('hpStorageUtilization', 100/2.36)/100 * 1000*getAverageRockHeatCapasitykJinKg(coldCycle[0].tOut,hotCycle[0].tIn)*metrics.highPressureStorageVolume*1000*metrics.gravelDensity*(hotCycle[0].tIn-coldCycle[0].tOut);
			}
			cycleData.dischargeTimeS = cycleData.hpStorageHeatCapacity / ((hotCycle[0].hIn - coldCycle[0].hOut) * 1000 * hotCycle[0].massFlow); // 
		}
		cycleData.costOfStorage = metrics.totalMiningVolume * metrics.costOfMiningM3 //+ (metrics.highPressureStorageSurfaceArea+metrics.lowPressureStorageSurfaceArea)*metrics.costOfSurfaceM2;
						+ getFloatParam('costOfInsulationM3', 25)*(metrics.vLpInsulation + metrics.highPressureInsulationMVolume)
						+ getFloatParam('costOfRockSurfaceM2', 25)*(Math.PI*metrics.sideBelow*(metrics.rGroundBelow+metrics.rOpenBottom) + metrics.dome.sideArea)
						+ getFloatParam('costOfSteelSurfaceM2', 250)*(metrics.dome.topArea + 
																	(metrics.topFillWithIceWithStorage ? 0 : Math.PI*metrics.rGroundBelow*metrics.rGroundBelow))
						+ getFloatParam('costOfChannelsM2', 25)*(metrics.dome.topArea+Math.PI*(metrics.dome.rBottomI*metrics.dome.rBottomI+
																(metrics.topFillWithIceWithStorage ? 0 :
																 metrics.rOpenBottomActual*metrics.rOpenBottomActual+metrics.topFillUsedAsWeight ? metrics.rGroundBelowActual * metrics.rGroundBelowActual : metrics.rTop+metrics.rTop)))
						+ (metrics.topFillUsedAsWeight || metrics.topFillWithIceWithStorage ? 0 : getFloatParam('costOfWallAndRoofAboveM2', 300)*(Math.PI*(metrics.rTop*metrics.rTop+metrics.sideAbove*(metrics.rGround+metrics.rTop))))
						+ (metrics.topFillWithIceWithStorage || metrics.externalIceStorage ? cycleData.iceStorage.cost : 0);
		cycleData.costOfHeatExchangers = 
						+ (metrics.topFillWithIceWithStorage ? cycleData.mainHeatExchanger.cost : 0);
		cycleData.storedElectricity_kWh = cycleData.netWorkOut * cycleData.dischargeTimeS / 3600;
		cycleData.storedDistrictHeat_kWh = cycleData.heatOutInDischarge * cycleData.dischargeTimeS / 3600;
		cycleData.storedEnergy_kWh = cycleData.storedElectricity_kWh + cycleData.storedDistrictHeat_kWh;	// only about 50% of capasity is available because of Debye model
		cycleData.extraAvailableDistrictHeat_kWh = (hAt323K < hMinDistrictHeat ? (hMinDistrictHeat-hAt323K) : 0) * hotCycle[0].massFlow * cycleData.dischargeTimeS / 3600;
		cycleData.costOfStoragekWh = cycleData.costOfStorage / (cycleData.storedElectricity_kWh + cycleData.storedDistrictHeat_kWh);

		if (cryogenicCooling) {
			coldCycle[3].workConsumed = coldCycle[3].workConsumed * coldCycle[3].massFlow;
			coldCycle[2].workProduced = coldCycle[2].workProduced * coldCycle[2].massFlow;
			cycleData.heatPumpCompressorOne.workConsumed *= coldCycle[3].massFlow;
			cycleData.heatPumpCompressorTwo.workConsumed *= coldCycle[3].massFlow;
		}
		cycleData.costOfMachineryKW = metrics.generatorCostOfKW + 
			(metrics.tcCostOfKW * (hotCycle[0].workProduced*hotCycle[0].getRelativeSize() + 
								   coldCycle[0].workConsumed*coldCycle[0].getRelativeSize() + 
								   hotCycle[1].workConsumed*hotCycle[1].getRelativeSize() + 
								   coldCycle[1].workProduced*coldCycle[1].getRelativeSize() + 
					(cryogenicCooling ? (coldCycle[3].workConsumed*coldCycle[3].getRelativeSize() + 
										 coldCycle[2].workProduced*coldCycle[2].getRelativeSize()) : 0))  + 
			metrics.heCostOfKW * (cycleData.heatPumpHeating + cycleData.cooling + cycleData.heatPumpHeatExchange + (hotCycle[0].hOut - hotCycle[1].hIn) * hotCycle[0].massFlow))
			/ cycleData.netWorkOut;
console.log("*****"+tHigh+": metrics.otherCostOfKW="+metrics.otherCostOfKW+", cycleData.costOfMachineryKW="+cycleData.costOfMachineryKW);
		cycleData.costOfPowerKW = metrics.otherCostOfKW + cycleData.costOfMachineryKW;
		cycleData.costOfPower = cycleData.costOfMachineryKW * cycleData.netWorkOut;
		cycleData.costOfPlant = metrics.otherCostOfKW * cycleData.netWorkOut;

		if (motorGenerator) {
			// 
			cycleData.efficiency = (cycleData.netWorkIn*metrics.generatorEfficiency - cycleData.heatPumpLoss)*metrics.generatorEfficiency/cycleData.netWorkIn;
			cycleData.efficiency = hotCycle[1].massFlow/hotCycle[0].massFlow;
//			cycleData.efficiency = (cycleData.netWorkOut/cycleData.netWorkIn)*(hotCycle[0].massFlow/hotCycle[1].massFlow);
		}
		//cycleData.efficiencyOfCapital = cycleData.netWorkOut / cycleData.totalWork;
		// cycleData.kWhPerTonGross = (hotCycle[0].hIn - hotCycle[0].hOut) / 3600;  // h == J/kg = 
		//if (showLog) 

		heatPumpMassFlow = coldCycle[2].massFlow;
		hotCycleG = hotCycle;
		coldCycleG = coldCycle;

		console.log("cycleData:"+JSON.stringify(cycleData, null, 2));
		return cycleData;
	}
	function getLpExpansion( cycleData, length ) {
		return length * (cycleData.hotCycle[1].tIn-cycleData.coldCycle[1].tOut)/metrics.lpGravelExpansionIn100K;
	}


	function getHeatExchangeWidth(tHigh, tLow, p, r, massFlow, gravelMinMM, gravelMaxMM, porosity, deltaT ) 
	{
		// all gravel particles are perfect balls => shapeFactor = 1,  if perfect cubics sape factor = 1.91, 2 is probably a low end estimation
		const gravelMax = gravelMaxMM/1000; 
		const gravelMin = gravelMinMM/1000;
		const medianDP = (gravelMin+gravelMax)/2;
		const shapeFactor = 2; // for the irregular surface, shape and high aspect ratio
		const dStep = (gravelMax - gravelMin) / 10;
		var m3A = 0, pD;
		for (pD = gravelMin; pD < gravelMax; pD += dStep) {
			m3A += (4 * Math.PI * Math.pow(pD/2, 2)    	// surface area of perfect ball : 4*PI*r*r
					* 1 / (Math.PI * 4 * Math.pow(pD/2,3)/3))	// number of items / m3, ignore here the porosity of balls
		}
		const m3Area = shapeFactor*(1-porosity)*m3A/10;
		const G = massFlow * 1000 / (Math.PI * r * r);
		const tStep = (tHigh-tLow)/10;
		var width = 0;
		while (!isFinite(Module.PropsSI('H', 'T', tLow, 'P', p, name))) tLow += 0.1;

		const deltaStepQm2 = G*(Module.PropsSI('H', 'T', tHigh, 'P', p, name) - Module.PropsSI('H', 'T', tLow, 'P', p, name)) / 10;

		for (t = tHigh - tStep/2; t > tLow; t-= tStep) {
			const VISCOSITY = Module.PropsSI('VISCOSITY', 'T', t, 'P', p, name);
			const PRANDTL = Module.PropsSI('PRANDTL', 'T', tLow, 'P', p, name);
			const CONDUCTIVITY = Module.PropsSI('CONDUCTIVITY', 'T', tLow, 'P', p, name);
			// https://shop.tarjomeplus.com/UploadFileEn/TPLUS_EN_4259.pdf
			const ReDp = G*medianDP / (6*(1-porosity)*VISCOSITY);
			const NuDp = 8.74+9.34*Math.pow(6*(1-porosity), 0.2)*Math.pow(ReDp, 0.2)*PRANDTL;
			// NuDp = h * Dp / k => h = NuDp*k/Dp; 
			const heCofficient = NuDp * CONDUCTIVITY / medianDP;
			//const NuDp2 =  0.789*(6*(1-porosity))*Math.pow(ReDp, 0.49)*Math.pow(PRANDTL,1/3); // 0.5 of prev 
//console.log(t+"/"+p+": ReDp="+ReDp+", NuDp="+NuDp+" => heCofficient="+heCofficient);
			//  the heat exhange power in 1 m3 of gravel
			width += deltaStepQm2/(heCofficient*m3Area*deltaT);
		}
		return width;
	}
	
	function getHeatExchangeWidthOld(tHigh, tLow, p, r, massFlow, gravelMinMM, gravelMaxMM, porosity, deltaT ) 
	{
		// First calculate the area/m3
		var m3A = 0;
		const gravelMax = gravelMaxMM/1000; 
		const gravelMin = gravelMinMM/1000;
		const dStep = (gravelMax - gravelMin)/10;
		const massFlowM2 = massFlow * 1000 / (Math.PI * r * r);
		var pD;
		for (pD = gravelMin; pD<gravelMax; pD += dStep) {
			m3A += (4 * Math.PI * Math.pow( pD/2, 2) 
					* 1/(4*Math.PI*Math.pow(pD/2,3)/3));	// number of items having that size, ignore here the porosity of balls 
		}
		m3A = (1-porosity)*m3A/10;
		
		// heat transfer in convection:
		// https://www.engineeringtoolbox.com/convective-heat-transfer-d_430.html,  2 b) approximation for dry air, for air flows 2 - 10 m/s)
		var hcAir;  // low end approximation for air, we scale it to actual density
		const dAir = 1.13;
		const tStep = (tHigh-tLow)/10;
		while (!isFinite(Module.PropsSI('H', 'T', tLow, 'P', p, name))) tLow += 0.1;
		// returns h as J/kg
		const deltaStepQm2 = massFlowM2*(Module.PropsSI('H', 'T', tHigh, 'P', p, name) - Module.PropsSI('H', 'T', tLow, 'P', p, name));
		const NuD = 5; // The range for a full laminar flow: 4 - 9, not perfect balls 
		const hD = gravelMin/2;	// a guess: the average width of flow channels between gravel 
		const conductivity = Module.PropsSI('CONDUCTIVITY', 'T', (tLow+tHigh)/2, 'P', p, name);
		const heatCoefficient = NuD*conductivity/hD;
		width = deltaStepQm2/(m3A*heatCoefficient*deltaT);
/*		
		const deltaStepQm2 = massFlowM2*(Module.PropsSI('H', 'T', tHigh, 'P', p, name) - Module.PropsSI('H', 'T', tLow, 'P', p, name)) / 10;
		var t;
		var width = 0;
		for (t = tHigh; t > tLow; t-= tStep) {
			const dInTP = Module.PropsSI('D', 'T', t, 'P', p, name) / dAir;		// scale hcAir to actual density
			const v = massFlowM2 / dInTP;
			// https://pubmed.ncbi.nlm.nih.gov/36074290/
			// The average convective heat and mass transfer coefficients varied between 2.64 and 8.30 W/m2 °C and 0.0025 to 0.0076 m/s for temperature ranges, at the different air velocities, respectively.
			// forced flow
			hcAir = 12.12 - 1.16*v + 11.6*Math.pow(v,0.5);
//console.log("***  hcAir="+hcAir);
			// Q = h*A == hcAir*dInTP*m3A*length*deltaT
			// => length = Q/(hcAir*dInTP*m3A*deltaT)
			width += deltaStepQm2 / (hcAir*dInTP*m3A*deltaT);
		}
*/
//console.log( "width="+width+", m3A="+m3A+", massFlowM2="+massFlowM2+", deltaStepQm2="+deltaStepQm2+", deltaT="+deltaT);
//console.log("getHeatExchangeWidth("+tHigh+', '+tLow+', '+p+', '+r+', '+massFlow+', '+gravelMinMM+', '+gravelMaxMM+', '+porosity+', '+deltaT+")="+width); 
		return width;
	}
		
	var traceXY = false;
	var xyLog = '';
	function toX( dg, val ) {
		var ret = dg.baseX ? Math.abs(dg.baseX + val*dg.meterToPixels) 
				: Math.abs(dg.marginX + (dg.cWidth)*(val - dg.minX)/(dg.maxX-dg.minX));
		if (traceXY) xyLog += ', ('+ret;
		return ret;
	}

	function toY( dg, val ) {
		var ret = dg.baseY ? dg.baseY + (dg.cheight - val*dg.meterToPixels) 
			: dg.marginTop + (dg.cheight)*(dg.maxY-val)/(dg.maxY-dg.minY);
		if (traceXY) xyLog += ','+ret+')';
		return ret;
	}
	function minMaxVal( dg, vals, minMax ) {
		if (!minMax) {
			minMax = {};
			minMax.min = minMax.max = vals[0];
		}
		var i;
		for (i = 1; i < vals.length; i++) {
			if (vals[i] == null) continue;
			if (vals[i] > minMax.max) minMax.max = vals[i];
			if (vals[i] < minMax.min) minMax.min = vals[i];
		}
		const maxSteps = dg.maxSteps ? dg.maxSteps : 5;
/*
		var diff = minMax.max - minMax.min;
		var multiplier = 1;
		
		for (;;) {
			if (diff < 10) {
				diff *= 10;
				multiplier *= 10;
			}
			else if (diff > 100) {
				diff /= 10;
				multiplier /= 10;
			}
			else {
				break;
			}
		}
		minMax.min = Math.floor(minMax.min * multiplier / 10) / multiplier * 10;
		minMax.max = Math.floor((minMax.max+10) * multiplier / 10) / multiplier * 10;
*/
		minMax.step = (minMax.max - minMax.min) / maxSteps;
		return minMax;
	}
/*

{"heatPumpCompressorTin":313,"heatExchangeDeltaT":2,"heatPumpHighP":20000000,
"r":150,
"ins":10,
"costOfSurfaceM2":1000,
"costOfMiningM3":12,"generatorCostOfKW":250,"tcCostOfKW":50,"heCostOfKW":50,
"rockDensity":2.65,"gravelDensity":2.1,
"insGravelDensity":1.6,
"rockHeatCapasity":0.8,
"hCylinder":94.33962264150944,
"pHighStorageHeight":81.03962264150944,
"V1":6668474.972242486,"hpExpectedAverageDensity":2,
"highPressureStorageVolume":4990032.269549,
"highPressureInsulationMVolume":1678442.7026934854,
"hpAverageGravelDensity":1.9741509333333331,"V2":1700710.4098415514,
"V3":4967764.562400934,
"V4":6076897.110375681,
"totalMiningVolume":11636239.53464342,
"highPressureStorageSurfaceArea":230284.6690414405,
"hBelow":77.67,
"hAbove":91.20424824550723,
"r2":97.63075175449278,
"lowPressureStorageSurfaceArea":340794.56804748066}
*/
	function workToMW( work, units ) {
		return (units ? Math.round(Math.round(work/1000) / units) : Math.round(work/1000))+' MW';
	}
	function toCelsius( t, speed ) {
		return Math.round(t - 273.15)+"\u2103" + (speed ? myRound(speed,2)+' m/s' : ''); 
	}
	function drawStorage( canvasId, metrics, cycleData, bottomLines ) {
		if (metrics.isCylinder) {
			drawCylinderStorage( canvasId, metrics, cycleData, bottomLines );
		}
		else {
			drawConeStorage( canvasId, metrics, cycleData, bottomLines );
		}
	}
	function testResult( expected, from, to, maxError, calcResult, maxLoops ) {
		var min=from, max=to;
		var testValue = (min + max) / 2;
if (typeof testValue === 'undefined' || typeof expected === 'undefined'  || typeof maxError === 'undefined') 
return confirm(loop+":testValue="+testValue+",  min/max:"+min+"/"+max+", expected:"+expected+", maxError"+maxError);
		var loop=0;
		if (!maxLoops) maxLoops = 10;
		for (;;) {
			var result = calcResult(testValue);
			if (loop > maxLoops || Math.abs(expected-result)<= maxError) {
if (loop > maxLoops && Math.abs(expected-result)>maxError) {
	console.trace(loop+":expected="+expected+", result="+result+", testValue="+testValue+", min/max:"+from+"/"+to+", error:"+Math.abs(expected-result));
	return false;
}
//else console.log(loop+":expected="+expected+", result="+result+", testValue="+testValue+", min/max:"+from+"/"+to+", error:"+Math.abs(expected-result));
				return testValue;
			}
			if (result > expected) max = testValue;
			else min = testValue;
			testValue = (min + max) / 2;
			loop++;
		}
	}

	var delayedCenteredTexts = [];
	function pushCenterText( ctx, text, xCenterPx, yPx, color ) {
		var item = {};
		item.fillStyle = ctx.fillStyle;
		item.font = ctx.font;
		item.text = text;
		item.xCenterPx = xCenterPx;
		item.yPx = yPx;
		item.color = color;
		delayedCenteredTexts.push(item);
	}
	function flushCenteredTexts( ctx ) {
		var i;
		for (i = 0; i < delayedCenteredTexts.length; i++) {
			const item = delayedCenteredTexts[i];
			ctx.fillStyle = item.fillStyle;
			ctx.font = item.font;
			centerText( ctx, item.text, item.xCenterPx, item.yPx, item.color );
		}
		delayedCenteredTexts = [];
	}
	
	function centerText( ctx, text, xCenterPx, yPx, color ) {
		const textMetrics = ctx.measureText(text);
		const xPx = xCenterPx-textMetrics.width/2;
		if (color) {
			const height = textMetrics.fontBoundingBoxAscent;
			const region = new Path2D();
			region.moveTo(xPx, yPx );
			region.lineTo(xPx+textMetrics.width, yPx );
			region.lineTo(xPx+textMetrics.width, yPx-height );
			region.lineTo(xPx, yPx-height );
			region.closePath();
			const oldStyle = ctx.fillStyle;
			ctx.fillStyle = color;
			ctx.fill(region);
			ctx.fillStyle = oldStyle;
		}
		ctx.fillText(text,xPx, yPx );
	}
	
	function drawConeStorage( canvasId, metrics, cycleData, bottomLines ) {
		const dg = {};
		var gasName = getInputParam('name', 'Nitrogen' ).toLowerCase();
		const canvas = document.getElementById(canvasId);
		const powerAndHeat = !metrics.topFillWithIceWithStorage && (metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false ));
		
		var title = //Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million crushed stone ton "+
			Math.round(cycleData.storedEnergy_kWh/1000000)+" GWh / "+workToMW(cycleData.netWorkOut)+" pumped thermal energy storage";
		// let's keep this very simple, set scale 1 m == 2 px, 
		dg.marginX = 30;
		dg.marginTop = (isCone ? 40 : 180) + (title ? 20 : 0);	// for the facility and pipes
		dg.marginBottom = 10 + (bottomLines ? bottomLines.length * 12 : 0);
		dg.meterToPixels = 2;
		const width = ((metrics.externalIceStorage || metrics.topFillWithIceWithStorage ? 400 : 200)+metrics.rGround*2)*dg.meterToPixels + dg.marginX; // 280m == space for turbin pictures
		//const height = (metrics.hCylinder+metrics.hBelow+metrics.hAbove+(metrics.externalIceStorage ? metrics.hBelowActual : 0))*dg.meterToPixels+dg.marginTop+dg.marginBottom;
		const height = (metrics.hCylinder+metrics.hBelow+metrics.hAbove)*dg.meterToPixels+dg.marginTop+dg.marginBottom;
		canvas.setAttribute("width", width ); 
		canvas.setAttribute("height", height); 
//console.log("width="+width+", height="+height);
		const ctx = canvas.getContext("2d");
		dg.maxX = metrics.rGround*2;
		dg.minX = 0;
		dg.maxY = metrics.hCylinder+metrics.hBelow+metrics.hAbove+metrics.dome.hTop;
		dg.minY = 0;
		dg.baseX = width/2;
		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black';
		dg.ctx = ctx;
		ctx.font = "10px Arial";
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		dg.width = canvas.getAttribute("width");
		dg.cWidth = dg.width - 2 * dg.marginX;
		dg.height = canvas.getAttribute("height");
		dg.cheight = dg.height - dg.marginTop - dg.marginBottom;
		if (title) {
			ctx.font = "18px arial";
			ctx.fillStyle = 'black'; 
			var x = toX(dg,0)-ctx.measureText(title).width/2;
//console.log("x="+x+", title:"+title);			
			if (x < 0) x = 2;
			ctx.fillText(title, x, 20);
		}
		// Start with rock, https://www.w3schools.com/colors/colors_shades.asp
		const colorRock = '#A9A9A9'; //	
		const colorConcrete = '#CCD1D1';	// ligh gray
		const colorTopFill = '#d5dbdb';
		const colorInsulation = '#808080'; // gray, 
		const colorHotHpGravel = '#FFFF00'; //#FFCC00'; 
		const colorColdHpGravel = '#66FFFF';
		const colorWarmLpGravel = '#FFCC99'; 
		const colorHotLpGravel2 = '#FF9900';
		const colorHotLpGravel = powerAndHeat ? '#FF9900' : colorWarmLpGravel; 
		const colorColdLpGravel = '#6666FF'; 
		const colorLiquidLpGravel = '#0000FF'; 

		// draw first the base rock
		dg.baseY = dg.marginTop;
		const hGround = metrics.hBelow+metrics.hCylinder
		const groundY = toY(dg,hGround);
		
		var region = new Path2D();
		region.moveTo(0, groundY); 
		region.lineTo(dg.width, groundY); 
		region.lineTo(dg.width, dg.height);
		region.lineTo(0, dg.height);
		region.lineTo(0, groundY); 
		region.closePath();
		ctx.fillStyle = colorRock;
		ctx.fill(region);
		$("#"+canvasId).css('display','block');
//console.log("groundY="+groundY+", dg="+JSON.stringify(dg));
		const xIceEnd = (width/2)/dg.meterToPixels;
		const iceStorage = metrics.topFillWithIceWithStorage ? cycleData.iceStorage : (metrics.externalIceStorage ? cycleData.iceStorage : null);
		// + iceStorage.rBottom-iceStorage.rTop
		//const fromSideM = metrics.topFillWithIceWithStorage ? iceStorage.earthWorkHeight : (metrics.externalIceStorage ? (iceStorage.height)/2+(iceStorage.rBottom-iceStorage.rTop) : 0);
		const fromSideM = metrics.topFillWithIceWithStorage ? iceStorage.earthWorkHeight : (metrics.externalIceStorage ? (iceStorage.height*1.2)+(iceStorage.rBottom-iceStorage.rTop) : 0);
// BXXXXXX
		if (metrics.externalIceStorage) {
			const hTopFillM = 5;
			const hTopFill = hTopFillM *  dg.meterToPixels;
			const xSide = iceStorage.sideWidth * dg.meterToPixels;
			const yBottom = toY(dg,hGround-iceStorage.depth);
			const yTop = toY(dg,hGround+iceStorage.height-iceStorage.depth);
			const xBottom = toX(dg,xIceEnd-fromSideM);
			const xBottomLeft = toX(dg,-(xIceEnd-fromSideM));
			const xTop = toX(dg,xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop));
			const xTopActual = toX(dg,xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop)+hTopFillM/metrics.topFillTan)-xSide;
			const xTopLeft = toX(dg,-(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop)));
			const xTopLeftActual = toX(dg,-(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop)+hTopFillM/metrics.topFillTan))+xSide;
			var y, x;
			var region = new Path2D();
			region.moveTo(xBottom-xSide, yBottom);
			region.lineTo(xTopActual, yTop-hTopFill);
			region.lineTo(toX(dg,xIceEnd), yTop-hTopFill); 
			region.lineTo(toX(dg,xIceEnd), yBottom); 
			region.lineTo(xBottom-xSide, yBottom); 
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			var region = new Path2D();
			region.moveTo(xBottomLeft+xSide, yBottom);
			region.lineTo(xTopLeftActual, yTop-hTopFill);
			region.lineTo(toX(dg,-xIceEnd), yTop-hTopFill); 
			region.lineTo(toX(dg,-xIceEnd), yBottom); 
			region.lineTo(xBottomLeft+xSide, yBottom); 
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			const hIceBottom = toY(dg, hGround-iceStorage.depth+iceStorage.insForBottom);
			var region = new Path2D();
			region.moveTo(xBottom, hIceBottom); 
			region.lineTo(xTop, yTop); 
			region.lineTo(toX(dg,xIceEnd), yTop); 
			region.lineTo(toX(dg,xIceEnd), hIceBottom); 
			region.lineTo(xBottom, hIceBottom); 
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);

			var region = new Path2D();
			region.moveTo(xBottomLeft, hIceBottom); 
			region.lineTo(xTopLeft, yTop); 
			region.lineTo(toX(dg,-xIceEnd), yTop); 
			region.lineTo(toX(dg,-xIceEnd), hIceBottom); 
			region.lineTo(xBottomLeft, hIceBottom); 
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);


			ctx.fillStyle = "white";
			ctx.font = "12px arial";
			ctx.fillText("r="+Math.round(iceStorage.rTop)+" m, h="+Math.round(iceStorage.height)+" m", x = xBottom*0.5+xTop*0.5+20, y = (yTop*0.5+hIceBottom*0.5)-15);
			ctx.fillText(myRound(iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice and", x-14/metrics.topFillTan, y+14);
			ctx.fillText(toCelsius(cycleData.coldCycle[0].tIn) + " " + Math.round((metrics.pLowCompressor ? metrics.pLowCompressor : metrics.pLow)/1000)+" kPa "+gasName, x-28/metrics.topFillTan,  y+28);
			ctx.fillText("Covered by frozen earth-", x-42/metrics.topFillTan, y+42);
			ctx.fillText("Mixed crushed stone and insulation", x-42/metrics.topFillTan, y+56);

			ctx.fillText("r="+Math.round(iceStorage.rTop)+" m, h="+Math.round(iceStorage.height)+" m", x = toX(dg,-xIceEnd)+5, y = (yTop+hIceBottom)/2-15);
			ctx.fillText(myRound(iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice and", x, y+14);
			ctx.fillText(toCelsius(cycleData.coldCycle[0].tIn)+" "+Math.round(metrics.pLow/1000)+" kPa "+gasName, x, y+28);
			ctx.fillText("Covered by frozen earth-", x, y+42);
			ctx.fillText("Mixed crushed stone and insulation", x, y+56);
		}
		else if (metrics.topFillWithIceWithStorage) {
			var y, x;
			var region = new Path2D();
			region.moveTo(toX(dg,xIceEnd-fromSideM-iceStorage.earthWorkHeight), groundY); 
			region.lineTo(toX(dg,xIceEnd-fromSideM), y = toY(dg,hGround+iceStorage.earthWorkHeight)); 
			region.lineTo(toX(dg,xIceEnd), y); 
			region.lineTo(toX(dg,xIceEnd), groundY); 
			region.lineTo(toX(dg,xIceEnd-fromSideM-iceStorage.earthWorkHeight), groundY); 
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			ctx.font = "12px arial";
			ctx.fillStyle = "black";
			ctx.fillText(myRound(iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice", toX(dg,xIceEnd-fromSideM-5), y-14);
			ctx.fillText(Math.round(iceStorage.height)+"*"+Math.round(iceStorage.side)+"*"+Math.round(iceStorage.side)+" m", toX(dg,xIceEnd-fromSideM), y-2);

			ctx.fillText("Frozen earth", toX(dg,xIceEnd-fromSideM-iceStorage.earthWorkHeight)+20, groundY);

			var region = new Path2D();
			region.moveTo(toX(dg,-(xIceEnd-fromSideM-iceStorage.earthWorkHeight)), groundY); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM)), y = toY(dg,hGround+iceStorage.earthWorkHeight)); 
			region.lineTo(toX(dg,-xIceEnd), y); 
			region.lineTo(toX(dg,-xIceEnd), groundY); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM-iceStorage.earthWorkHeight)), groundY); 
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			ctx.font = "12px arial";
			ctx.fillStyle = "black";
			ctx.fillText(myRound(iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice", toX(dg,-xIceEnd)+5, y-14);
			ctx.fillText(Math.round(iceStorage.height)+"*"+Math.round(iceStorage.side)+"*"+Math.round(iceStorage.side)+" m", toX(dg,-xIceEnd)+10, y-2);
			ctx.fillText("Frozen earth", toX(dg,-(xIceEnd-fromSideM))+5, groundY);

			const hIceBottom = toY(dg, hGround-iceStorage.depth+iceStorage.insForBottom);
			const hIceTop = toY(dg,hGround+iceStorage.earthWorkHeight-4);
			const hIceMiddle = (hIceBottom+hIceTop)/2;
			var region = new Path2D();
			region.moveTo(toX(dg,xIceEnd-fromSideM), hIceBottom); 
			region.lineTo(toX(dg,xIceEnd-fromSideM), hIceMiddle); 
			region.lineTo(toX(dg,xIceEnd), hIceMiddle); 
			region.lineTo(toX(dg,xIceEnd), hIceBottom); 
			region.lineTo(toX(dg,xIceEnd-fromSideM), hIceBottom); 
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);

			var region = new Path2D();
			region.moveTo(toX(dg,-(xIceEnd-fromSideM)), hIceBottom); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM)), hIceMiddle); 
			region.lineTo(toX(dg,-xIceEnd), hIceMiddle); 
			region.lineTo(toX(dg,-xIceEnd), hIceBottom); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM)), hIceBottom); 
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);

			ctx.fillStyle = "white";
			ctx.fillText(toCelsius(cycleData.coldCycle[0].tIn), toX(dg,xIceEnd-fromSideM)+20, (hIceMiddle+hIceBottom)/2);
			ctx.fillText(toCelsius(cycleData.coldCycle[0].tIn), toX(dg,-xIceEnd)+20, (hIceMiddle+hIceBottom)/2);
			
			//ctx.fillText(Math.round(iceStorage.)/1000)+" kPa "+gasName+" gas in", toX(dg,xIceEnd-fromSideM)+2, (hIceMiddle+hIceBottom)/2+12);
			//myRound(cycleData.iceStorage.totalMassInTons/1000000,1)+" Mt ice
//XXXXX
//ctx.fillText("\u21D1 in charge"+heatExchangeText, toX(dg,-metrics.rGround+5), toY(dg, hGround-hLpWarmFromGround));
//var pDropText = ",  \u0394P: "+pDrop;
			var region = new Path2D();
			region.moveTo(toX(dg,xIceEnd-fromSideM), hIceMiddle); 
			region.lineTo(toX(dg,xIceEnd-fromSideM), hIceTop); 
			region.lineTo(toX(dg,xIceEnd), hIceTop); 
			region.lineTo(toX(dg,xIceEnd), hIceMiddle); 
			region.lineTo(toX(dg,xIceEnd-fromSideM), hIceMiddle); 
			region.closePath();
			ctx.fillStyle = colorColdHpGravel;
			ctx.fill(region);

			var region = new Path2D();
			region.moveTo(toX(dg,-(xIceEnd-fromSideM)), hIceMiddle); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM)), hIceTop); 
			region.lineTo(toX(dg,-xIceEnd), hIceTop); 
			region.lineTo(toX(dg,-xIceEnd), hIceMiddle); 
			region.lineTo(toX(dg,-(xIceEnd-fromSideM)), hIceMiddle); 
			region.closePath();
			ctx.fillStyle = colorColdHpGravel;
			ctx.fill(region);

			ctx.fillStyle = "black";
			ctx.fillText(toCelsius(cycleData.coldCycle[0].tOut), toX(dg,xIceEnd-fromSideM)+20, hIceTop+24);
			ctx.fillText(Math.round((metrics.pLowCompressor ? metrics.pLowCompressor : metrics.pLow)/1000)+" kPa "+gasName, toX(dg,xIceEnd-fromSideM)+2, hIceTop+36);
			ctx.fillText("in crushed ice", toX(dg,xIceEnd-fromSideM)+2, hIceTop+48);
			//ctx.fillText(myRound(iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice", toX(dg,xIceEnd-fromSideM)+2, hIceTop+48);

			//ctx.fillText("\u0394P of channels:", toX(dg,xIceEnd-fromSideM)+2, (hIceMiddle+hIceTop)/2+12);
			//ctx.fillText(Math.round(iceStorage.pressureDrop)+" Pa", toX(dg,xIceEnd-fromSideM)+2, (hIceMiddle+hIceTop)/2+24);

			ctx.fillText(toCelsius(cycleData.coldCycle[0].tOut), toX(dg,-xIceEnd)+20, hIceTop+24);
			ctx.fillText(Math.round(metrics.pLow/1000)+" kPa "+gasName, toX(dg,-xIceEnd)+2, hIceTop+36);
			ctx.fillText("in crushed ice", toX(dg,-xIceEnd)+2, hIceTop+48);
			//ctx.fillText("\u0394P of channels:", toX(dg,-xIceEnd)+2, (hIceMiddle+hIceTop)/2+12);
			//ctx.fillText(Math.round(iceStorage.pressureDrop)+" Pa", toX(dg,-xIceEnd)+2, (hIceMiddle+hIceTop)/2+24);

//ctx.fillText("\u21D1 in charge"+heatExchangeText, toX(dg,-metrics.rGround+5), toY(dg, hGround-hLpWarmFromGround));
//var pDropText = ",  \u0394P: "+pDrop;
		}
		// rampSlope, rampWidth
		var aRampX = [];
		var aRampY = [];
		{
			var rampX = metrics.rGroundBelow, rampY = hGround;
			aRampX.push(rampX); aRampY.push(rampY);
			var nextY = rampY;
			while ((--nextY) > 0) {
				// For opposite double ramps
				// nextX =  nextY/h * (rTop - rBottom) + rBottom;
				// rampY - (rampX + nextX) * (PI * 2 * rampSlope) = nextY
				// => nextX =  (rampY - (rampX + nextX) * (PI * 2 * rampSlope))/h * (rTop - rBottom) + rBottom;
				if (nextY > metrics.dome.hBottom) {
					nextX =  (nextY-metrics.dome.hBottom)/metrics.hBelow * (metrics.rGround - metrics.dome.rTop) + metrics.dome.rTop;
					if ((rampY-nextY)*metrics.rampSlope > (rampX + nextX)*Math.PI) {
						rampX = nextX, rampY = nextY;
						aRampX.push(rampX); aRampY.push(rampY);
					}
				}
				else {
					nextX =  nextY/metrics.dome.hBottom * (metrics.dome.rTop-metrics.dome.rBottom) + metrics.dome.rBottom;
					if ((rampY-nextY)*metrics.rampSlope > (rampX + nextX) * Math.PI) {
						rampX = nextX, rampY = nextY;
						aRampX.push(rampX); aRampY.push(rampY);
					}
				}
			}
			var i;
			for (i = 0; i < aRampX.length-1; i++) {
				region = new Path2D();
				region.moveTo(toX(dg,-aRampX[i]),toY(dg,aRampY[i]));
				region.lineTo(toX(dg,-aRampX[i+1]-metrics.rampWidth),toY(dg,aRampY[i+1]));
				region.lineTo(toX(dg,-aRampX[i+1]),toY(dg,aRampY[i+1]));
				region.lineTo(toX(dg,-aRampX[i]),toY(dg,aRampY[i]));
				region.closePath();
				ctx.fillStyle = colorTopFill;
				ctx.fill(region);
			}
			for (i = 0; i < aRampX.length-1; i++) {
				region = new Path2D();
				region.moveTo(toX(dg,aRampX[i]),toY(dg,aRampY[i]));
				region.lineTo(toX(dg,aRampX[i+1]+metrics.rampWidth),toY(dg,aRampY[i+1]));
				region.lineTo(toX(dg,aRampX[i+1]),toY(dg,aRampY[i+1]));
				region.lineTo(toX(dg,aRampX[i]),toY(dg,aRampY[i]));
				region.closePath();
				ctx.fillStyle = colorTopFill;
				ctx.fill(region);
			}
		}

		var y, x;
		/*  Simple cylinder
  "hCylinder": 132.49328067269875,
  "hBelow": 65.61992687447108,
  "hAbove": 66.87335379822768,
  "pHighStorageHeight": 119.19328067269875,
  "rCylinder": 126.75594836325249,
  "rGround": 126.75594836325249,
  "rTop": 126.75594836325249, */
		region = new Path2D();
		// Insulation layer
		region.moveTo(toX(dg,-metrics.rGroundBelow),groundY); 
		region.lineTo(toX(dg,-metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		region.lineTo(toX(dg,-metrics.dome.rBottom), toY(dg,0));
		region.lineTo(toX(dg,metrics.dome.rBottom), toY(dg,0));
		region.lineTo(toX(dg,metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
		region.lineTo(toX(dg,metrics.rGroundBelow),groundY); 
		region.closePath();
		//ctx.fillStyle = 'white';
		//ctx.fill(region);
		ctx.fillStyle = colorInsulation;
		ctx.fill(region);
		if (!metrics.topFillWithIceWithStorage) {
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rGround),groundY+2); 
			ctx.lineTo(toX(dg,metrics.rGround),groundY+2); 
			ctx.strokeStyle = colorInsulation;
			ctx.lineWidth = 5;
			ctx.stroke();
		}
	
		{
			var i, midX, midY;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-aRampX[0]),toY(dg,aRampY[0]));
			for (i = 1; i < aRampX.length; i++) {
				ctx.lineTo(toX(dg,-aRampX[i]-metrics.rampWidth),toY(dg,aRampY[i]));
				ctx.lineTo(toX(dg,-aRampX[i]),toY(dg,aRampY[i]));
				if (aRampY[i] < metrics.dome.hBottom && aRampY[i-1] > metrics.dome.hBottom) {
					midY = aRampY[i] + (metrics.dome.hBottom - aRampY[i]);
					midX = aRampX[i]+metrics.rampWidth + (aRampX[i-1]-aRampX[i])*(metrics.dome.hBottom - aRampY[i])/(aRampY[i-1] - aRampY[i])
				}
			}
			ctx.lineTo(toX(dg,-metrics.dome.rBottom), toY(dg,0));
			ctx.lineTo(toX(dg,metrics.dome.rBottom), toY(dg,0));
			while ((--i) >= 0) {
				ctx.lineTo(toX(dg,aRampX[i]),toY(dg,aRampY[i]));
				ctx.lineTo(toX(dg,aRampX[i]+metrics.rampWidth),toY(dg,aRampY[i]));
			}
			ctx.lineTo(toX(dg,aRampX[0]),toY(dg,aRampY[0]));
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 1;
			ctx.stroke();
/*
			ctx.beginPath();
			ctx.moveTo(toX(dg,-midX+2),toY(dg,midY-1));	// hide the error ???
			ctx.lineTo(toX(dg,midX-2),toY(dg,midY-1));
			ctx.lineWidth = 2;
			ctx.stroke();
*/
		}
		/* without ramps
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rGround),groundY); 
			ctx.lineTo(toX(dg,-metrics.rGroundBelow),groundY); 
			ctx.lineTo(toX(dg,-metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
			ctx.lineTo(toX(dg,-metrics.dome.rBottom), toY(dg,0));
			ctx.lineTo(toX(dg,metrics.dome.rBottom), toY(dg,0));
			ctx.lineTo(toX(dg,metrics.dome.rTop),toY(dg,metrics.dome.hBottom));
			ctx.lineTo(toX(dg,metrics.rGroundBelow),groundY);
			ctx.lineTo(toX(dg,metrics.rGround),groundY);
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 1;
			ctx.stroke();
		*/

		// fill partially overwritten warm gravel in the grave dome in the top
/*
		ctx.lineWidth = 1;
		ctx.fillStyle = 'black';
		ctx.moveTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.hAbove+hGround)); 
		ctx.lineTo(toX(dg,0),y = toY(dg,2*metrics.dome.hTop+metrics.hAbove+hGround));
		ctx.lineTo(toX(dg,-metrics.dome.s/2),toY(dg,metrics.hAbove+hGround));
		ctx.stroke();
*/
		if (!isCone) {
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.dome.s/2),toY(dg,metrics.hAbove+hGround));
			region.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			region.closePath();
			ctx.fillStyle = colorWarmLpGravel;
			ctx.fill(region);
		}
		const freeSpaceOnTop = 0;
		var roofInsulation = metrics.insLpSides; // 1.5 * /metrics.ins; // scale the gravel mix to ordinary insulation and add 50%
		if (roofInsulation<2) roofInsulation = 2;
		const xyAddRoof = (freeSpaceOnTop+roofInsulation);
		const xyAddRoofInsulation = (freeSpaceOnTop+roofInsulation/2); // only half, because it is a line
//console.log("roofInsulation="+roofInsulation+", xyAddRoof="+xyAddRoof+", xyAddRoofInsulation="+xyAddRoofInsulation+", metrics.insLpSides="+metrics.insLpSides);
		// roof insulation
		const pxRoofInsulation = roofInsulation * dg.meterToPixels;
		ctx.lineWidth = pxRoofInsulation;
		if (metrics.topFillUsedAsWeight || metrics.topFillWithIceWithStorage) {
			// nop
		}
		else if (metrics.externalEclosure) {
			ctx.beginPath();
			if (isCone) {
				ctx.moveTo(toX(dg,-metrics.rTop-1+metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
				ctx.lineTo(toX(dg,metrics.rTop+1-metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+freeSpaceOnTop+roofInsulation/2)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.strokeStyle = 'gray'; 
			ctx.stroke();
			// roof Insulation
			ctx.beginPath();
			if (isCone) {
				ctx.moveTo(toX(dg,-metrics.rTop-metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
				ctx.lineTo(toX(dg,metrics.rTop+metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+1+roofInsulation+freeSpaceOnTop)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
		else {
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rGround-1 ),toY(dg,hGround));
			if (isCone) {
				ctx.lineTo(toX(dg,-metrics.rTop-1+metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
				ctx.lineTo(toX(dg,metrics.rTop+1-metrics.toSideX(xyAddRoofInsulation)),toY(dg,hGround+metrics.hAbove+xyAddRoofInsulation)+1); //+xyAddRoofInsulation
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+freeSpaceOnTop+roofInsulation/2)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineTo(toX(dg,metrics.rGround+1),toY(dg,hGround));
			ctx.strokeStyle = 'gray'; 
			ctx.stroke();

			// roof Insulation
			ctx.beginPath();
			ctx.lineWidth =  1;
			ctx.moveTo(toX(dg,-metrics.rGround-3),toY(dg,hGround));
			if (isCone) {
				ctx.lineTo(toX(dg,-metrics.rTop-2+metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
				ctx.lineTo(toX(dg,metrics.rTop+2-metrics.toSideX(xyAddRoof)),toY(dg,hGround+metrics.hAbove+xyAddRoof));
			}
			else {
				ctx.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							(metrics.dome.r+1+roofInsulation+freeSpaceOnTop)*dg.meterToPixels, Math.PI*5/4, Math.PI*7/4);
			}
			ctx.lineTo(toX(dg,metrics.rGround+3),toY(dg,hGround));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
/*
		ctx.moveTo(toX(dg,0),toY(dg,2*metrics.dome.hTop+metrics.hAbove+hGround)); 
		ctx.lineTo(toX(dg,0),toY(dg,0)); 
		ctx.stroke();
*/
		// 50% charged, 10% turbin out heat => 10% + 40% + 50 - 10m insulation + 
		const insLpX = metrics.insLpSides * metrics.sideBelow / metrics.hBelow;
		var hTop = metrics.hCylinder+metrics.hBelow+metrics.hAbove;
		// tOutGravelV:  0.1*lowPressureStorageVolume = PI * h * h * (r - h/3);
		// 0.3*V/PI = 3*r*x^2 - x^3
//if (!confirm("A, hLpHot="+hLpHot)) return; 
/*
		const rLpHot = Math.sqrt(metrics.dome.r*metrics.dome.r-(metrics.dome.r-hLpHot)*(metrics.dome.r-hLpHot));
		// next "hot" lp gravel in the top of grave "dome"
		region.moveTo(toX(dg,rLpHot),toY(dg,metrics.dome.hTop-dg.hLpHot+metrics.hAbove+hGround)); 
		region.arcTo(toX(dg,0),toY(dg.hLpHot+metrics.dome.hTop+metrics.hAbove+hGround),
					 toX(dg,-rLpHot),toY(dg,metrics.dome.hTop-dg.hLpHot+metrics.hAbove+hGround), metrics.dome.r*dg.meterToPixels);
*/
		var hLpHot; 
		var rLpHot;
		if (isCone) {
			// (hAbove-hX)/hAbove = (rX-rTop)/(rGound-rTop)
			// => rX = (rGound-rTop)*(hAbove-hX)/hAbove+rTop;
			// 0.1*metrics.lowPressureStorageVolume
			const vCut = Math.PI/3*Math.pow(metrics.rTop,2)*metrics.hAbove*(1-metrics.rTop/metrics.rGround);
//console.log("vCut="+vCut);
			hLpHot = testResult( 0.1*metrics.lowPressureStorageVolume, 0, metrics.hAbove, 
						0.001*metrics.lowPressureStorageVolume, 	// max error
						function (h) { 
							const r = metrics.toSideX(h) + metrics.rTop;
//console.log("h="+h+"=>r="+r);
							return Math.PI/3*h*(r*r + r*metrics.rTop + metrics.rTop*metrics.rTop);
						});
			 rLpHot = metrics.topFillUsedAsWeight ? metrics.rGroundBelow - metrics.toSideX(hLpHot) : metrics.toSideX(hLpHot) + metrics.rTop; // angle=45!
			 hLpHot = metrics.topFillUsedAsWeight ? -hLpHot : metrics.hAbove - hLpHot;
console.log("hLpHot="+hLpHot+", rLpHot="+rLpHot+", metrics.rTop="+metrics.rTop);
		}
		else if (0.1*metrics.lowPressureStorageVolume > metrics.dome.vCaveTop) {
			hLpHot = metrics.dome.hTop;	// ignore the volume in cone
		}
		else {
			hLpHot = testResult( 0.1*metrics.lowPressureStorageVolume, 10, metrics.dome.hTop, 
						0.001*metrics.lowPressureStorageVolume, 	// max error
						function (h) { return Math.PI * h * h * (metrics.dome.r - h/3)});
		}
		region = new Path2D();
		region.moveTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
		region.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
		region.lineTo(toX(dg,-metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.lineTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove));
		region.closePath();
		ctx.fillStyle = metrics.topFillUsedAsWeight || metrics.topFillWithIceWithStorage ? colorTopFill : colorWarmLpGravel;
		ctx.fill(region);
		
		if (metrics.topFillWithIceWithStorage) {
			ctx.fillStyle = 'black'; 
			ctx.font = "14px arial";
			centerText(ctx, "Top fill used only as weight because of insulation cost and thermal expansion", toX(dg,0), toY(dg,hGround+0.75*metrics.hAbove));
		}

		if (powerAndHeat) {
			region = new Path2D();
			if (isCone) {
				region.moveTo(toX(dg,-rLpHot),		toY(dg,hGround+hLpHot));
				region.lineTo(toX(dg,-metrics.rTop),toY(dg,hGround+(metrics.topFillUsedAsWeight ? 0 : metrics.hAbove)));
				region.lineTo(toX(dg,metrics.rTop),	toY(dg,hGround+(metrics.topFillUsedAsWeight ? 0 : metrics.hAbove)));
				region.lineTo(toX(dg,rLpHot),		toY(dg,hGround+hLpHot));
			}
			else {
				var asin =  Math.asin((metrics.dome.r-hLpHot)/ metrics.dome.r);
				region.arc(toX(dg,0),toY(dg,metrics.hAbove+hGround-(metrics.dome.r-metrics.dome.hTop)),
							metrics.dome.r*dg.meterToPixels, Math.PI+asin, 2*Math.PI-asin);
			}
			region.closePath();
			ctx.fillStyle = colorHotLpGravel;
			ctx.fill(region);

			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.font = px < 14 ? px+"px arial" : "14px arial";
				centerText( ctx, toCelsius(cycleData.hotCycle[0].tOut), toX(dg,0), 
							toY(dg, isCone ? (hGround+hLpHot) : (metrics.hAbove+hGround+metrics.dome.hTop-hLpHot) ));
			}
		}
//if (!confirm("B")) return; 
/*
	Metrics of the cone inside the insulation
	metrics.hBelowActual = (metrics.sideBelow - metrics.sideBelow*metrics.ins/metrics.hBelow)/metrics.sideBe;
	metrics.rGroundBelowActual = x;
	metrics.rOpenBottomActual = metrics.rOpenBottom *(metrics.rGround-metrics.rTop)*(metrics.hBelow-metrics.hBelowActual)/metrics.hBelow
*/
		// always: V4 < V3 and all gravel-insulation in below ground in V3
		// and we can assume, that the high pressure dome and its Insulation is below the 50% level
		var rLpWarmBottom;
		var hLpWarmFromGround;
		var hColdTop;

		var rColdTop;
		const hBottomPx = metrics.dome.hBottom*dg.meterToPixels
		var px = Math.floor(hBottomPx/7);
		if (px > 14) px = 14;
console.log("px="+px);
		if (!metrics.topFillUsedAsWeight && !metrics.topFillWithIceWithStorage && metrics.lowPressureStorageVolume/2 < metrics.V4) {
			const coldV4 = metrics.V4 - 0.5*metrics.lowPressureStorageVolume;
			hColdTop = testResult( coldV4, 0, metrics.hAbove/2, 0.01*coldV4,
						function (h) { 
							const r = metrics.rGround - metrics.toSideX(h);
							rColdTop = r;
							return 1/3*Math.PI*h*(r*r + r*metrics.rGround+  Math.pow(metrics.rGround,2));
						});
			region = new Path2D();
			region.moveTo(toX(dg,-rColdTop), toY(dg,hGround+hColdTop));
			region.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
			region.lineTo(toX(dg,rColdTop), toY(dg,hGround+hColdTop));
			region.lineTo(toX(dg,-rColdTop), toY(dg,hGround+hColdTop));
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);
	//if (!confirm("E")) return; 
			var heatExchangeText = '';
			if (cycleData) {
				ctx.fillStyle = 'black';
				ctx.font = px+"px arial"; 
				//centerText( ctx, ,toX(dg,0), toY(dg,hGround+hColdTop)-40);
				const gasFlowText = toCelsius(cycleData.hotCycle[1].tIn)+', '
					+getGasFlow('Lp', cycleData.hotCycle[1],LAST_ITEM,rColdTop,metrics.rTop, (metrics.gravelMinLp+metrics.gravelMaxLp)/2, metrics.lpGravelPorosity);
				const gravelText = Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa "+gasName+" gas in "
							+myRound(metrics.lpGravelDensity*metrics.lowPressureStorageVolume/1000000,1)+" Mt compacted "
							+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" crushed stone";
				if (ctx.measureText(gasFlowText+", "+gravelText).width < 2*metrics.rGround*dg.meterToPixels)
				{
					centerText( ctx, gasFlowText+", "+gravelText, toX(dg,0), toY(dg,hGround+hLpHot)+(metrics.topFillUsedAsWeight ? -30 : 25));
				}
				else 
				{
					centerText( ctx, gasFlowText, toX(dg,0), toY(dg,hGround+hLpHot)+(metrics.topFillUsedAsWeight ? -30 : 25));
					centerText( ctx, gravelText,toX(dg,0), toY(dg,hGround+hLpHot)+(metrics.topFillUsedAsWeight ? -30-px : 25+px));
				}
				const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
									cycleData.hotCycle[1].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
				heatExchangeText = ""; //", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T="+toCelsius(274);
				metrics.heLengthLp = heLength;
			} 
			
			ctx.fillStyle = 'black'; 
			ctx.font = px < 12 ? px+"px arial" : "12px arial";
			centerText(ctx, "\u21D1 in charge"+heatExchangeText, toX(dg,0), toY(dg, hGround+hColdTop));

			rLpWarmBottom = metrics.rGroundBelowActual;
			hLpWarmFromGround = 0;
			metrics.hMidLpFromGround = hColdTop;
		}
		else if (metrics.topFillWithIceWithStorage) {
			metrics.rOpenBottomActual = metrics.rGroundBelowActual - (metrics.hBelowActual/Math.tan(Math.PI*metrics.dome.maxAngle/180));
		
			region = new Path2D();
			region.moveTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rOpenBottomActual), y=toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,-metrics.rOpenBottomActual), y);
			region.lineTo(toX(dg,-metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.closePath();
			ctx.fillStyle = colorTopFill;
			ctx.fill(region);
		}
		else {
			metrics.rOpenBottomActual = metrics.rGroundBelowActual - (metrics.hBelowActual/Math.tan(Math.PI*metrics.dome.maxAngle/180));

			const coldV3 = 0.5*metrics.lowPressureStorageVolume;
			const warmV3 = 0.5*metrics.lowPressureStorageVolume - (metrics.topFillUsedAsWeight ? 0 : metrics.V4);
			// warmV3 = 1/3*PI*hCone*rGroundActual^2-1/3*PI*(hCone-x)*((rGroundActual*(hCone-x)/hCone)^2;
			var rLpWarmBottom;
			hLpWarmFromGround = testResult( warmV3, 0, metrics.hBelowActual/2, 0.01*warmV3,
						function (h) { 
							const r = metrics.rGroundBelowActual - (h/Math.tan(Math.PI*metrics.dome.maxAngle/180));
							rColdTop = r;
							rLpWarmBottom = r;
							return 1/3*Math.PI*h*(r*r + r*metrics.rGroundBelowActual+  Math.pow(metrics.rGroundBelowActual,2));
						});
			metrics.hMidLpFromGround = -hLpWarmFromGround;
	//if (!confirm("C")) return; 
			
		console.log("rLpWarmBottom="+rLpWarmBottom+',hLpWarmFromGround='+hLpWarmFromGround+", metrics.rGroundBelowActual="+metrics.rGroundBelowActual);

	//$("#"+canvasId).css('display','block');
	//return;

			region = new Path2D();
	//traceXY = true;		
			region.moveTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-metrics.rGroundBelowActual), toY(dg,hGround));
			region.lineTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
			region.closePath();
	//console.log(xyLog);
	//traceXY = false; xyLog = '';
			ctx.fillStyle = metrics.topFillWithIceWithStorage ? colorTopFill : colorWarmLpGravel;
			ctx.fill(region);
			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.font = px+"px arial";
				//centerText( ctx, toCelsius(cycleData.hotCycle[1].tIn),toX(dg,0), toY(dg,hGround)-40);
				//centerText( ctx, Math.round(metrics.pHigh/1000)+" kPa "+gasName+" gas in "+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" gravel",toX(dg,0), toY(dg,hGround)-20);
				const gasFlowText = toCelsius(cycleData.hotCycle[1].tIn)+', '+getGasFlow('Lp', cycleData.hotCycle[1],LAST_ITEM,rColdTop,metrics.rTop, 
									(metrics.gravelMinLp+metrics.gravelMaxLp)/2, metrics.lpGravelPorosity);
				const gravelText = Math.round(metrics.pLow/1000)+(metrics.pLowCompressor ? "/"+Math.round(metrics.pLowCompressor/1000) : "")+" kPa "+gasName
								+" gas in "+myRound(metrics.lpGravelDensity*metrics.lowPressureStorageVolume/1000000,1)
								+" Mt compacted "+metrics.gravelMinLp+"/"+metrics.gravelMaxLp+" crushed stone"
				if (ctx.measureText(gasFlowText+", "+gravelText).width < 2*metrics.rOpenBottom*dg.meterToPixels)
				{
					pushCenterText( ctx, gasFlowText+", "+gravelText,toX(dg,0), toY(dg,hGround+hLpHot)+20, colorWarmLpGravel);
				}
				else {
					pushCenterText( ctx, gasFlowText, toX(dg,0), toY(dg,hGround+hLpHot)+20, colorWarmLpGravel);
					pushCenterText( ctx, gravelText,toX(dg,0), toY(dg,hGround+hLpHot)+20+px, colorWarmLpGravel);
				}

				const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
									cycleData.hotCycle[1].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
				heatExchangeText = ""; //", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T=1";
				metrics.heLengthLp = heLength;
			}
			ctx.fillStyle = 'black'; 
			ctx.font = px < 12 ? px+"px arial" : "12px arial";
			if (Math.abs(hLpWarmFromGround) < 6) {
				ctx.fillText("\u21D1 in charge"+heatExchangeText, toX(dg,-metrics.rGround+5), toY(dg, hGround-hLpWarmFromGround));
			}
			else {
				pushCenterText(ctx, "\u21D1 in charge"+heatExchangeText, toX(dg,-40), toY(dg, hGround-hLpWarmFromGround), colorWarmLpGravel);
			}
		}
		if (metrics.topFillUsedAsWeight) {
			ctx.beginPath();
			ctx.moveTo(toX(dg,metrics.rGround)-2, y = toY(dg,hGround+1.5));
			ctx.lineTo(toX(dg, 10)+7.5, y);
			ctx.closePath();
			ctx.strokeStyle = colorInsulation;
			ctx.lineWidth = 3;
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rGround)+2, y = toY(dg,hGround+1.5));
			ctx.lineTo(toX(dg, -10)-7.5, y);
			ctx.closePath();
			ctx.strokeStyle = colorInsulation;
			ctx.lineWidth = 3;
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "14px arial";
			centerText(ctx, "Top fill used only as weight because of horizontal thermal expansion", toX(dg,0), toY(dg,hGround+0.75*metrics.hAbove));
		}
		else if (!metrics.topFillWithIceWithStorage) {
			ctx.beginPath();
			ctx.moveTo(toX(dg,metrics.rTop-1.5), toY(dg, hGround+metrics.hAbove));
			ctx.lineTo(toX(dg,metrics.rGround-1.5), toY(dg,hGround));
			ctx.lineTo(toX(dg,metrics.rGround-1.5), toY(dg,hGround)+5);
			ctx.strokeStyle = colorInsulation;
			ctx.lineWidth = 4;
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rTop+1.5), toY(dg, hGround+metrics.hAbove));
			ctx.lineTo(toX(dg,-metrics.rGround+1.5), toY(dg,hGround));
			ctx.lineTo(toX(dg,-metrics.rGround+1.5), toY(dg,hGround)+5);
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(toX(dg,metrics.rTop), toY(dg, hGround+metrics.hAbove+2));
			ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
			ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround)+5);
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 2;
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rTop), toY(dg, hGround+metrics.hAbove+2));
			ctx.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround));
			ctx.lineTo(toX(dg,-metrics.rGround), toY(dg,hGround)+5);
			ctx.strokeStyle = 'black';
			ctx.lineWidth = 2;
			ctx.stroke();
		}

	//if (!confirm("D")) return; 
	//traceXY = true;
		if (!metrics.topFillWithIceWithStorage)
		{
			region = new Path2D();
			region.moveTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.lineTo(toX(dg,-rLpWarmBottom), toY(dg,hGround-hLpWarmFromGround));
			region.closePath();
			ctx.fillStyle = colorColdLpGravel;
			ctx.fill(region);
		//console.log(xyLog);
		//traceXY = false; xyLog = '';
			if (cycleData) {
				ctx.fillStyle = 'white'; 
				ctx.font = px < 14 ? px+"px arial" : "14px arial";
				//pushCenterText(ctx, toCelsius(cycleData.coldCycle[1].tOut), toX(dg,0), toY(dg,hGround-hLpWarmFromGround)+40 );
				const heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tIn, cycleData.coldCycle[1].tOut, cycleData.hotCycle[1].pIn, rColdTop, 
									cycleData.hotCycle[0].massFlow, metrics.gravelMinLp, metrics.gravelMaxLp, metrics.lpGravelPorosity, 1 );
				heatExchangeText = ""; //", heat exchange area width ~"+myRound(heLength,0)+" m if \u0394T=1";
				metrics.heLengthLp = heLength;
			}
	//if (!confirm("E")) return; 
			
			if (hLpWarmFromGround > 0) {
				ctx.font = px < 12 ? px+"px arial" : "12px arial";
				ctx.fillStyle = 'white'; 
				pushCenterText(ctx, "\u21D3 in discharge"+heatExchangeText, toX(dg,0), toY(dg,hGround-hLpWarmFromGround)+(px < 12 ? px : 12), colorColdLpGravel);
			}
			else {
				ctx.font = px < 12 ? px+"px arial" : "12px arial";
				ctx.fillStyle = 'white'; 
				centerText(ctx, "\u21D3 in discharge"+heatExchangeText, toX(dg,0), toY(dg,hGround+hColdTop)+(px < 12 ? px : 12));
			}
			ctx.font = px+"px arial";
			pushCenterText(ctx,getGasFlow('Lp', cycleData.coldCycle[0],LAST_ITEM,rLpWarmBottom,metrics.rOpenBottomActual,
				(metrics.gravelMinLp+metrics.gravelMaxLp)/2, metrics.lpGravelPorosity), toX(dg,0), toY(dg,hGround-metrics.hBelowActual)-px, colorColdLpGravel);

			// always: V4 < V3 and all gravel-insulation in below ground in V3
			// and we can assume, that the high pressure dome and its Insulation is below the 50% level
			var hLiquid = 0, hLiquidStorage=0, rLiquidStorage=0, liquidM3 = 0;
			if (powerAndHeat) {
				
				const liquidV3 = metrics.maxPartLiquid/2*metrics.lowPressureStorageVolume; // 50%
				var rLiquid;
				hLiquid = testResult( liquidV3, 0, metrics.hBelowActual/2, 0.01*liquidV3,
							function (h) { 
									const r = metrics.rOpenBottomActual + (h/Math.tan(Math.PI*metrics.dome.maxAngle/180));
									rLiquid = r;
									return 1/3*Math.PI*h*(r*r + r*metrics.rOpenBottomActual+  Math.pow(metrics.rOpenBottomActual,2));
								});
				region = new Path2D();
				region.moveTo(toX(dg,-rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
				region.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
				region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
				region.lineTo(toX(dg,rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
				region.lineTo(toX(dg,-rLiquid), toY(dg,hGround-metrics.hBelowActual+hLiquid));
				region.closePath();
				ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
				ctx.fill(region);
			}
		}
		if (!powerAndHeat)
		{
			//const dLiquid = Module.PropsSI('D', 'P', metrics.pLow, 'Q', 1, name);
			liquidM3 = cycleData.tc.changeKg1000 * cycleData.hotCycle[0].massFlow*cycleData.dischargeTimeS / cycleData.tc.dLiq;
			/*
			liquidM3 = Math.abs(metrics.maxPartLiquid * (
						metrics.topFillWithIceWithStorage ? cycleData.iceStorage.sizeM3*metrics.crushedIcePorosity :
						metrics.lowPressureStorageVolume*(metrics.rockDensityLp-metrics.lpGravelDensity)/metrics.rockDensityLp));*/
			hLiquidStorage = Math.pow(liquidM3, 1/3);
			rLiquidStorage = Math.sqrt(liquidM3/(hLiquidStorage*Math.PI));
console.log("liquidM3="+liquidM3+" => hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
		}
		logHeatCapasities();
		if (isCone) {
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.lineTo(toX(dg,-metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			region.lineTo(toX(dg,metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			region.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual));
			region.closePath();
			ctx.fillStyle = colorInsulation;
			ctx.fill(region);
/*
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			ctx.lineTo(toX(dg,metrics.rOpenBottom), toY(dg,hGround-metrics.hBelow));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
*/
			if (powerAndHeat) {
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(toX(dg,-metrics.rGround), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rGroundBelow), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rGroundBelowActual), toY(dg,hGround));
				ctx.lineTo(toX(dg,-metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual)+1);
				ctx.lineTo(toX(dg,metrics.rOpenBottomActual), toY(dg,hGround-metrics.hBelowActual)+1);
				ctx.lineTo(toX(dg,metrics.rGroundBelowActual), toY(dg,hGround));
				ctx.lineTo(toX(dg,metrics.rGroundBelow), toY(dg,hGround));
				ctx.lineTo(toX(dg,metrics.rGround), toY(dg,hGround));
				ctx.strokeStyle = 'black'; 
				ctx.stroke();
			}
		}
		else 
		{
			const hExtIns = metrics.extDomeIns.h - metrics.ins*Math.cos(Math.PI/4);
			const sExtIns = metrics.extDomeIns.s - 2 * metrics.ins*Math.cos(Math.PI/4);
			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
										(metrics.extDomeIns.r)*dg.meterToPixels, Math.PI+metrics.extDomeIns.rads, 2*Math.PI-metrics.extDomeIns.rads);
			region.lineTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.dome.hBottom));
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, 
						2*Math.PI-Math.PI/4,
						Math.PI+Math.PI/4, 
						true );
			region.closePath();
			ctx.fillStyle = colorInsulation;
			ctx.fill(region);
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
								(metrics.extDomeIns.r)*dg.meterToPixels, Math.PI+metrics.extDomeIns.rads, 2*Math.PI-metrics.extDomeIns.rads);

			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						(metrics.extDome.r)*dg.meterToPixels, Math.PI+Math.PI/4, 2*Math.PI-Math.PI/4);
			region.lineTo(toX(dg,metrics.dome.s/2),toY(dg,metrics.dome.hBottom));
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
						metrics.dome.r*dg.meterToPixels, 
						2*Math.PI-Math.PI/4,
						Math.PI+Math.PI/4, 
						true );
			region.closePath();
			ctx.fillStyle = colorConcrete;
			ctx.fill(region);

			const	rhDeltaTop = metrics.dome.rTop - metrics.dome.rTopI;
			region = new Path2D();
			region.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					metrics.dome.r*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			region.closePath();
			ctx.fillStyle = colorHotHpGravel; 
			ctx.fill(region);
		}
		if (!metrics.topFillWithIceWithStorage)
		{
			ctx.font = px+"px arial";
			ctx.fillStyle = 'white'; 
			const text = toCelsius(cycleData.coldCycle[1].tOut)+" "+gasName+" gas in crushed stone"+(powerAndHeat ? ", liquid "+gasName+" max "+Math.round(100*metrics.maxPartLiquid)+"% of volume" : "");
			pushCenterText(ctx, text, toX(dg,0), toY(dg,hGround-metrics.hBelowActual)-2*px, colorColdLpGravel);
		}

		{
//if (!confirm("G")) return; 
			region = new Path2D();
			region.moveTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			region.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			region.lineTo(toX(dg,metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.lineTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			region.closePath();
			ctx.fillStyle = colorHotHpGravel;
			ctx.fill(region);

			//const rhDeltaTopIns = metrics.caveTopInsulation * Math.sin( Math.PI/4);
			//const rhExpansionSpace = rhDeltaTopIns + (metrics.maxHpGravelExpansionUpM/2+1)* Math.sin( Math.PI/4);
		}
		if (!isCone) {
			ctx.lineWidth = metrics.caveTopInsulation * dg.meterToPixels;
			ctx.beginPath();
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					(metrics.dome.r-metrics.caveTopInsulation/2)*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			ctx.strokeStyle = 'black'; 
			ctx.stroke();

			const hExpansion = metrics.maxHpGravelExpansionUpM/2+1;
			ctx.lineWidth = hExpansion * dg.meterToPixels;
			ctx.beginPath();
			ctx.arc(toX(dg,0),toY(dg,metrics.dome.hBottom-(metrics.dome.r-metrics.dome.hTop)),
					(metrics.dome.r-metrics.caveTopInsulation-hExpansion/2)*dg.meterToPixels, 
					Math.PI+Math.PI/4, 
					2*Math.PI-Math.PI/4);
			ctx.strokeStyle = 'white'; 
			ctx.stroke();
		}
//if (!confirm("H")) return; 

		var rColdHpGravel;
		const testVolume = metrics.highPressureStorageVolume/2;
		const hTemp = testResult( testVolume, 0, metrics.dome.hBottomI/2, 0.01*testVolume,
					function (h) { 
						const r = metrics.dome.rTopI - (metrics.dome.rTopI - metrics.dome.rBottomI)*h/metrics.dome.hBottomI;
//console.log("h="+h+", r="+r);
						rColdHpGravel = r;
						return 1/3*Math.PI*h*(r*r + r*metrics.dome.rTopI+  Math.pow(metrics.dome.rTopI,2));
					});


			const hColdHpGravel = metrics.dome.hBottomI - hTemp;
			const hpStoragetext3 = Math.round(metrics.pHigh/1000)+" kPa "+gasName+" gas in "+myRound(metrics.gravelDensity*metrics.highPressureStorageVolume/1000000,1)+" Mt compacted "
								+metrics.gravelMinHp+"/"+metrics.gravelMaxHp+" crushed stone";
			if (cycleData) {
				ctx.fillStyle = 'black'; 
				ctx.strokeStyle = 'black'; 
				const text2 = "Mass flow "+Math.round(1000*cycleData.hotCycle[1].massFlow)+" kg/s in charge and "+Math.round(1000*cycleData.hotCycle[0].massFlow)+" kg/s in discharge";
				const pxHotHeight = (metrics.dome.hBottom - hColdHpGravel)*dg.meterToPixels;
				if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel) || pxHotHeight < px*3) {
					if (px > 13) px = 13;
					if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel) || pxHotHeight < px*3) {
						if (px > 12) px = 12;
						if (ctx.measureText(text2).width/2 > (metrics.dome.rTopI+rColdHpGravel) || pxHotHeight < px*3) {
							if (px > 11) px = 11;
						}
					}
				}
				ctx.font = px+"px arial";
				centerText( ctx, toCelsius(cycleData.hotCycle[0].tIn)+', '+getGasFlow('Hp', cycleData.hotCycle[0],FIRST_ITEM,metrics.dome.rTopI,rColdHpGravel,
					(metrics.gravelMinHp+metrics.gravelMaxHp)/2, metrics.hpGravelPorosity), toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px);
//console.log(ctx.measureText(text2+", "+text3).width+" < "+ (rColdHpGravel+metrics.dome.rTopI)*2);
				if (ctx.measureText(text2+", "+hpStoragetext3).width < (rColdHpGravel+metrics.dome.rTopI)*2) {
					centerText( ctx, text2+", "+hpStoragetext3, toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px*2 );
				}
				else {
					centerText( ctx, text2, toX(dg,0), toY(dg,metrics.dome.hBottomI)+7+px*2 );
				}
			}
//console.log("rColdHpGravel="+rColdHpGravel+", hColdHpGravel="+hColdHpGravel);
		region = new Path2D();
		region.moveTo(toX(dg,-rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
		region.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
		region.lineTo(toX(dg,rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.lineTo(toX(dg,-rColdHpGravel), 			toY(dg,hColdHpGravel));
		region.closePath();
		ctx.fillStyle = metrics.topFillWithIceWithStorage ?  colorHotLpGravel : colorColdHpGravel;
		ctx.fill(region);
//if (!confirm("I")) return; 

		if (false && powerAndHeat) {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.lineTo(toX(dg,-metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			ctx.lineTo(toX(dg,metrics.dome.rBottomI), toY(dg,metrics.insCaveBottom));
			ctx.lineTo(toX(dg,metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.lineTo(toX(dg,-metrics.dome.rTopI), toY(dg,metrics.dome.hBottomI));
			ctx.closePath();
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}
		else {
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(toX(dg,-metrics.dome.rTop)-1, toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop));
			ctx.lineTo(toX(dg,metrics.dome.rTop)+1, toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop));
			ctx.strokeStyle = 'black'; 
			ctx.stroke();
		}

		var heDischargeText = '';
		metrics.hColdHpGravel = hColdHpGravel;
		if (cycleData) {
			ctx.fillStyle = 'black'; 
			ctx.strokeStyle = 'black'; 
			ctx.font = px+"px arial";
			if (metrics.topFillWithIceWithStorage) {
				var item = {};
				item.t = cycleData.hotCycle[1].tIn;	
				item.p = cycleData.hotCycle[1].pOut; // after heat exchange	
				item.h = Module.PropsSI('H', 'P', item.p, 'T', item.t, name);
				item.d = Module.PropsSI('D', 'P', item.p, 'T', item.t, name);
				item.visc = Module.PropsSI('V', 'P', item.p, 'T', item.t, name);
				item.massFlow = cycleData.hotCycle[0].massFlow;  // first case (turbin)
				centerText( ctx, toCelsius(cycleData.hotCycle[1].tIn)+', '+getGasFlow('Hp', item, false, rColdHpGravel,metrics.dome.rBottomI,
					(metrics.gravelMinHp+metrics.gravelMaxHp)/2, metrics.hpGravelPorosity),toX(dg,0), toY(dg,hColdHpGravel/2));
			}
			else {
				centerText( ctx, toCelsius(cycleData.coldCycle[0].tOut)+', '+getGasFlow('Hp', cycleData.coldCycle[0],FIRST_ITEM,rColdHpGravel,metrics.dome.rBottomI,
					(metrics.gravelMinHp+metrics.gravelMaxHp)/2, metrics.hpGravelPorosity),toX(dg,0), toY(dg,hColdHpGravel/2));
			}
			centerText( ctx, hpStoragetext3, toX(dg,0), toY(dg,hColdHpGravel)+px*3-2);//toY(dg,metrics.dome.hBottomI)+7+px*3);

			var heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tOut, cycleData.coldCycle[1].tIn, cycleData.hotCycle[1].pOut,rColdHpGravel , 
								cycleData.hotCycle[1].massFlow, metrics.gravelMinHp, metrics.gravelMaxHp, metrics.hpGravelPorosity, 1);
			heatExchangeText = ""; //", heat exchange area width ~"+myRound(heLength,1)+" m if \u0394T=1";
			heLength = getHeatExchangeWidth(cycleData.hotCycle[1].tOut, cycleData.coldCycle[1].tIn, cycleData.hotCycle[1].pOut,rColdHpGravel , 
								cycleData.hotCycle[0].massFlow, metrics.gravelMinHp, metrics.gravelMaxHp, metrics.hpGravelPorosity, 1 );
			heDischargeText = ""; //", heat exchange area width ~"+myRound(heLength,1)+" m if \u0394T=1";
			metrics.heLengthHp = heLength;
		}
		ctx.font = px < 12 ? px+"px arial" : "12px arial";
		ctx.fillStyle = 'black'; 
		centerText( ctx, "\u21D3 in charge"+heatExchangeText, toX(dg,0), toY(dg,hColdHpGravel)+(px < 12 ? px : px));

		ctx.font = px < 12 ? px+"px arial" : "12px arial";
		ctx.fillStyle = 'black'; 
		centerText( ctx, "\u21D1 in discharge"+heDischargeText, toX(dg,0), toY(dg,hColdHpGravel));

		hTop = hGround;
		const towerH = hTop + 20;
		const towerLeftX = toX( dg, -metrics.rGround - 8 ); 
		const towerRightX = toX( dg, metrics.rGround + 8 ); 

		const yLpTop = towerH, yLpBottom = 2+hTop, yHpTop = towerH-7.5, yHpBottom = hTop+7.5;
		const ctWidth = 20*dg.meterToPixels;
		const hotCompHpX = towerRightX + ctWidth;
		const xTurbinLp = towerLeftX;
		const xTurbinHp = xTurbinLp-ctWidth;
		var xLeftMHE = towerRightX-10, xRightMHE = towerRightX+60;
		var yTopMHE = toY(dg,yLpTop)-35, yBottomMHE = toY(dg,yLpTop)-5;

		if (metrics.topFillWithIceWithStorage) {
			ctx.lineWidth = 15;
			ctx.strokeStyle = colorWarmLpGravel;
			ctx.beginPath();
			ctx.moveTo(towerRightX-2, toY(dg,(yHpBottom+yHpTop)/2)-6);
			ctx.lineTo(towerRightX-2, toY(dg,yLpTop)-4);
			ctx.stroke();

			ctx.font = "bold 16px serif";
			ctx.fillStyle = 'black';
			ctx.fillText("\u21B3", towerRightX-8, toY(dg,yLpTop)+12);

			ctx.beginPath();
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.moveTo(xLeftMHE, yBottomMHE);
			ctx.lineTo(xLeftMHE, yTopMHE);
			ctx.lineTo(xRightMHE, yTopMHE);
			ctx.lineTo(xRightMHE, yBottomMHE);
			ctx.lineTo(xLeftMHE, yBottomMHE);
			ctx.closePath();
			ctx.stroke();

			ctx.font = "bold 12px serif";
			ctx.fillStyle = 'black';
			ctx.fillText("Main heat", towerRightX-4, toY(dg,yLpTop)-20);
			ctx.fillText("exchanger", towerRightX-4, toY(dg,yLpTop)-8);

			const hIceTop = toY(dg,hGround+cycleData.iceStorage.earthWorkHeight-4);
			ctx.beginPath();
			ctx.strokeStyle = colorColdHpGravel;
			ctx.lineWidth = 10;
			ctx.moveTo(toX(dg,xIceEnd-fromSideM)+7, hIceTop+7);
			ctx.lineTo(toX(dg,xIceEnd-fromSideM)+7-hIceTop, 10);
			ctx.lineTo(xRightMHE-6, 10);
			ctx.lineTo(xRightMHE-6, yTopMHE);
			ctx.stroke();

			ctx.fillStyle = 'black';
			ctx.font = "bold 20px serif";
			ctx.fillText("\u2196", toX(dg,xIceEnd-fromSideM)-20, hIceTop);
			ctx.fillText("\u2193", xRightMHE-11, yTopMHE-4);
		}
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		//ctx.moveTo(x = towerRightX, y = toY(dg, yLpTop));
		ctx.moveTo(x = towerRightX, toY(dg, yLpBottom));
		ctx.lineTo(x = hotCompHpX, toY(dg,yHpBottom));
		ctx.lineTo(x, toY(dg,yHpTop));
		ctx.lineTo(towerRightX, y = toY(dg, yLpTop));
		ctx.closePath();
		ctx.stroke();

		if (metrics.topFillWithIceWithStorage) {
			ctx.font = "bold 20px serif";
			ctx.fillStyle = 'white';
			ctx.fillText("Charge mode", towerRightX+2*ctWidth, toY(dg,hGround-21));
			ctx.fillStyle = 'black';
		}
		else if (!metrics.externalIceStorage) {
			ctx.font = "bold 14px serif";
			ctx.fillText("Charge mode", towerRightX, y-18);
		}
/*
		ctx.beginPath();
		ctx.lineTo(towerRightX-ctWidth-8, y);
		ctx.stroke();
*/
		if (!metrics.topFillWithIceWithStorage)
		{
			ctx.lineWidth = 15;
			ctx.strokeStyle = colorWarmLpGravel;
			ctx.beginPath();
			var x2;
//console.log("toSideX("+metrics.hAbove+")+"+metrics.rTop+"="+(metrics.toSideX(metrics.hAbove)+metrics.rTop)+"=="+metrics.rGround);
			ctx.moveTo(towerRightX+5, y = toY(dg,(yHpBottom+yHpTop)/2)-4);
			var xFrom, xTo;

			if (metrics.topFillUsedAsWeight) {
				ctx.lineTo(toX(dg,10), y );
				ctx.lineTo(toX(dg,10), y = toY(dg,hGround+hLpHot));
				xFrom = toX(dg,0);
				xTo = toX(dg, metrics.rGround);
				x2 = xTo-5;
				y = toY(dg,hGround);
				ctx.stroke();
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.moveTo(x2, y);
				ctx.lineTo(toX(dg, 10)+7.5, y);
				ctx.stroke();
			}
			else {
				ctx.lineTo(x2 = towerRightX-10, y);
				const pixelsUp = powerAndHeat ? y - toY(dg,hGround+hLpHot-4) : y - (toY(dg,hGround+metrics.hAbove)+7.5);
				ctx.lineTo(x2 = x2-metrics.toSideX(pixelsUp), y-pixelsUp );
				ctx.lineTo(x2-40, y=y-pixelsUp);
				xFrom = x2-20;
				xTo = toX(dg,4);
				y -= 7.5;
				x2 -= 40;
				ctx.stroke();
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.moveTo(x2, y);
				ctx.lineTo(toX(dg, 4), y);
				ctx.stroke();
			}
			ctx.setLineDash([3, 3]);
			ctx.beginPath();
			ctx.moveTo(xTo, y+4);
			ctx.lineTo(xFrom, y+15);
			if (metrics.topFillUsedAsWeight) ctx.lineTo(toX(dg, -metrics.rGround), y+4);
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.fillStyle = 'black'; 
			ctx.font = "bold 18px serif";
			if (!metrics.topFillUsedAsWeight) ctx.fillText("\u2192", x2-40, y+15);
			ctx.fillText("\u2192", towerRightX-12, toY(dg, yLpBottom+6));
		}
		ctx.fillText("C", towerRightX+10, toY(dg, yLpBottom+4));

		const xColdTurbinLp = x + ctWidth/2;
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x, y = toY(dg, towerH-10 ));
		ctx.lineTo(xColdTurbinLp, y);
		ctx.stroke();

/*
  "diameterPipeFromColdExpander": 4.671124802092986,	9
  "diameterPipeFromHotCompressor": 2.674133432823774,	5
  "diameterPipeToHotCompressor": 7.859972449531066,		15
  "diameterPipeToColdExpander": 2.119501593112965,		4
*/
		ctx.lineWidth = 5;
		ctx.strokeStyle = colorHotHpGravel;
		ctx.beginPath();
		if (metrics.topFillUsedAsWeight) {
			ctx.moveTo(hotCompHpX-2, toY(dg,yHpTop));
			ctx.lineTo(hotCompHpX-2, y = toY(dg,yLpTop)-5);
			ctx.lineTo(x = toX(dg,3), y);
			const y2 = toY(dg,metrics.dome.hBottomI-1.5);
			ctx.lineTo(x, y2);
			ctx.stroke();
			ctx.lineWidth = 1;

			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(toX(dg,metrics.dome.rTopI-2), y2+2.5);
			ctx.lineTo(toX(dg,-metrics.dome.rTopI+2), y2+2.5);
			ctx.stroke();
			ctx.setLineDash([]);
			ctx.fillStyle = 'black'; 
			ctx.font = "16px serif";
			ctx.fillText("\u2191", hotCompHpX-5, toY(dg,yHpTop+2));
		}
		else {
			ctx.moveTo(hotCompHpX-3, y = toY(dg,yHpBottom));
			if (metrics.topFillWithIceWithStorage) {
				ctx.lineTo(hotCompHpX-3, y = toY(dg, yHpBottom-6));
				ctx.lineTo(x = toX(dg,3), y);
				const y2 = toY(dg,metrics.dome.hBottomI-1.5);
				ctx.lineTo(x, y2);
				ctx.stroke();
				ctx.lineWidth = 1;

				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.setLineDash([3, 3]);
				ctx.moveTo(toX(dg,metrics.dome.rTopI-2), y2+2.5);
				ctx.lineTo(toX(dg,-metrics.dome.rTopI+2), y2+2.5);
				ctx.stroke();
				ctx.setLineDash([]);
				ctx.fillStyle = 'black'; 
				ctx.font = "16px serif";
			}
			else {
				ctx.lineTo(hotCompHpX-3, y = toY(dg, yHpBottom-11));
				ctx.lineTo(x = toX(dg,metrics.rGroundBelow+3), y );

				const y2 = toY(dg,metrics.dome.hBottomI-1.5);
				var x2 = x - Math.cos(Math.PI*metrics.dome.maxAngle/180)*(y2-y) + 6;
				ctx.lineTo(x2, y2 );
				ctx.lineTo(x2=toX(dg,metrics.dome.rTopI-2),y2);
				ctx.stroke();

				ctx.lineWidth = 1;
				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.setLineDash([3, 3]);
				ctx.moveTo(x2, y2+2.5);
				ctx.lineTo(toX(dg,-metrics.dome.rTopI+2), y2+2.5);
				ctx.stroke();
			}
/*
			ctx.beginPath();
			ctx.moveTo(x2-20, y+15);
			ctx.lineTo(toX(dg, 4), y+4);
			ctx.stroke();
*/
			ctx.setLineDash([]);
			ctx.fillStyle = 'black'; 
			ctx.font = "16px serif";
			ctx.fillText("\u2193", hotCompHpX-6, toY(dg,yHpBottom)+16);
		}

		const xColdTurbinHp = xColdTurbinLp + ctWidth/2;
		const yColdLpTop = towerH-5, yColdLpBottom = hTop+5, yColdHpTop = yLpTop-8, yColdHpBottom = yLpBottom+6;

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xColdTurbinLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xColdTurbinHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xColdTurbinLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 12px serif";
		ctx.fillText("T", xColdTurbinLp+4, toY(dg,yColdLpBottom+1));

		ctx.lineWidth = 8;
		ctx.beginPath();
		const rPipeLpCold = metrics.rOpenBottom + (metrics.hBelow-metrics.hBelowActual)/Math.tan(Math.PI*metrics.dome.maxAngle/180);
		var yColdChannel;
		if (metrics.topFillWithIceWithStorage) {
			// xRightMHE
			const hIceBottom = toY(dg, hGround-cycleData.iceStorage.depth+cycleData.iceStorage.insForBottom);
			ctx.strokeStyle = colorColdLpGravel;
			ctx.moveTo(xColdTurbinLp+4, toY(dg,yColdLpBottom+1));
			ctx.lineTo(xColdTurbinLp+4, hIceBottom-4);
			ctx.lineTo(toX(dg,xIceEnd-fromSideM), hIceBottom);
			ctx.stroke();
			ctx.fillStyle = 'white'; 
			ctx.font = "bold 20px serif";
			ctx.fillText("\u2193", xColdTurbinLp+1, toY(dg,yColdLpBottom-10));
			ctx.fillText("\u2192", toX(dg,xIceEnd-fromSideM)-20, hIceBottom+10);
			ctx.font = "10px serif";
			for (x = toX(dg,xIceEnd-fromSideM)+5; x < toX(dg,xIceEnd); x += 10) {
				ctx.fillText("\u2191", x, hIceBottom )
			}
		}
		else 
		{
			if (metrics.topFillUsedAsWeight) {
				ctx.strokeStyle = colorLiquidLpGravel;
				ctx.moveTo(xColdTurbinLp+4, toY(dg,yColdLpTop-1));
				ctx.lineTo(xColdTurbinLp+4, y = toY(dg,yLpTop)-13);
				ctx.lineTo(x = toX(dg,-1.5), y);
				ctx.lineTo(x, y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
				ctx.stroke();
				yColdChannel = y-1;
				y += 3;
				ctx.fillStyle = 'white'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2191", xColdTurbinLp-1, toY(dg,yColdLpTop+1));
			}
			else if (metrics.externalIceStorage) {
				ctx.strokeStyle = colorColdLpGravel;
				ctx.moveTo(xColdTurbinLp+4, toY(dg,yColdLpBottom+1));
				ctx.lineTo(xColdTurbinLp+4, y = toY(dg, yHpBottom-25)+12);
				ctx.lineTo(x = toX(dg,(xIceEnd-fromSideM))+40, y);
				ctx.lineTo(x, y = toY(dg,hGround-iceStorage.depth)-10);
				ctx.stroke();

				ctx.moveTo(x = toX(dg,(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop))), y = toY(dg,hGround+iceStorage.height-iceStorage.depth)+4);
				ctx.lineTo(x-20, y = y - 20);
				ctx.lineTo(xColdTurbinLp-8, y);
				ctx.lineTo(xColdTurbinLp-8, y = toY(dg, yHpBottom-10)+12);
				ctx.lineTo(toX(dg,metrics.rGroundBelow+8), y );
				ctx.lineTo(toX(dg,rPipeLpCold+13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
				ctx.lineTo(x = toX(dg,rPipeLpCold-insLpX),y);
				ctx.stroke();
				ctx.fillStyle = 'white'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2190", x+5, y+10 );
				ctx.fillText("\u2191", toX(dg,(xIceEnd-fromSideM))+36, toY(dg,hGround-iceStorage.depth) + 20 );
				ctx.fillText("\u2196", toX(dg,(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop))) - 20, toY(dg,hGround+iceStorage.height-iceStorage.depth)+2);
				ctx.fillText("\u2193", xColdTurbinLp+1, toY(dg,yColdLpBottom-10));
			}
			else {
				ctx.strokeStyle = colorColdLpGravel;
				ctx.moveTo(xColdTurbinLp+4, toY(dg,yColdLpBottom+1));
				ctx.lineTo(xColdTurbinLp+4, y = toY(dg, yHpBottom-10)+12);
				ctx.lineTo(toX(dg,metrics.rGroundBelow+8), y );
				ctx.lineTo(toX(dg,rPipeLpCold+13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
				ctx.lineTo(toX(dg,rPipeLpCold-insLpX),y);
				ctx.stroke();
				yColdChannel = y-2;
				ctx.fillStyle = 'white'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2193", xColdTurbinLp+1, toY(dg,yColdLpBottom-10));
			}
			ctx.lineWidth = 1;
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(toX(dg,rPipeLpCold-insLpX), y);
			ctx.lineTo(toX(dg,0), yColdChannel);
			ctx.lineTo(toX(dg,-rPipeLpCold+insLpX), y);
			ctx.stroke();
			//ctx.moveTo(toX(dg,rPipeLpCold-insLpX), y-4.5);
			//ctx.lineTo(toX(dg,-rPipeLpCold+insLpX), y-4.5);
			//ctx.stroke();
			ctx.setLineDash([]);
		}
		if (!powerAndHeat && metrics.maxPartLiquid > 0.002) { // gas contect is in balance => no need to store liquid gas
console.log("hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
//console.log("Dry air tSat="+Module.PropsSI('T', 'P', 101325, 'Q', 0, 'Air')+" hSat="+(Module.PropsSI('H', 'P', 101325, 'Q', 1, 'Air')-Module.PropsSI('H', 'P', 101325, 'Q', 0, 'Air')));

			ctx.lineWidth = 2;
			ctx.strokeStyle = colorLiquidLpGravel;
			ctx.beginPath();
			ctx.moveTo(xColdTurbinLp+1, toY(dg,yColdLpBottom+1));
			ctx.lineTo(x = xColdTurbinLp+1, y = toY(dg, yHpBottom-30)+12);
			ctx.stroke();
			var x1 = x - dg.meterToPixels*rLiquidStorage*0.5;
			var x2 = x + dg.meterToPixels*rLiquidStorage*1.5;
			var y1 = y;
			var y2 = y+dg.meterToPixels*hLiquidStorage;;

			region = new Path2D();
			region.moveTo(x1, y1);
			region.lineTo(x2, y1);
			region.lineTo(x2, y2);
			region.lineTo(x1,y2);
			region.closePath();
			ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
			ctx.fill(region);
			ctx.fillStyle = 'white'; 
			ctx.font = "12px serif";

			if (dg.meterToPixels*hLiquidStorage < 62) {
				y2 = y1 + 62;
			}
			ctx.fillText("Liquid "+gasName, x1, y2-36);
			ctx.fillText("separated", x1, y2-24);
			ctx.fillText("after T-out", x1, y2-12);
			ctx.fillText("Vol "+Math.round(liquidM3)+" m3", x1, y2);

			ctx.fillStyle = 'white'; 
			ctx.font = "bold 12px serif";
			ctx.fillText("\u2193 "+Math.round(cycleData.coldCycle[1].wetness*1000)+" ‰ of gas", xColdTurbinLp-1, y1+12);
		}

		const hpYShift = metrics.topFillWithIceWithStorage ? (yLpTop+4 -(yHpBottom-4-26)) : 0;

		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		if (metrics.topFillWithIceWithStorage) {
			ctx.moveTo(xColdTurbinHp-2, toY(dg,yColdHpTop-1));
			ctx.lineTo(xColdTurbinHp-2, y = toY(dg,hpYShift+ yHpBottom-6));
			ctx.lineTo(xRightMHE+6, y);
			ctx.lineTo(xRightMHE+6, y = (yTopMHE+yBottomMHE)/2);
			ctx.lineTo(xRightMHE, y);
			ctx.stroke();

			ctx.fillStyle = 'black'; 
			ctx.font = "bold 16px serif";
			ctx.fillText("\u2193", xColdTurbinHp-6, toY(dg,yColdHpTop+2));
			ctx.fillText("\u2191", xRightMHE+2, y);

			ctx.lineWidth = 7;
			ctx.strokeStyle = colorHotLpGravel;
			ctx.beginPath();
			ctx.moveTo(xLeftMHE, y=(yTopMHE+yBottomMHE)/2);
			ctx.lineTo(xLeftMHE-6, y);
			ctx.lineTo(xLeftMHE-6, hGround+20);
			ctx.lineTo(toX(dg,metrics.dome.rBottom+12), y = toY(dg,metrics.insCaveBottom)-4);
			ctx.lineTo(x = toX(dg,metrics.dome.rBottomI), y);
			ctx.stroke();

			ctx.fillText("\u2192", x+2, y+8);
			ctx.fillText("\u2191", xLeftMHE-9, (yTopMHE+yBottomMHE)/2+20);
		}
		else {
			ctx.moveTo(xColdTurbinHp-2, toY(dg,yColdHpBottom+1));
			ctx.lineTo(xColdTurbinHp-2, y = toY(dg, yHpBottom-10)+20);
			ctx.lineTo(toX(dg,metrics.rGroundBelow+12), y );
			ctx.lineTo(toX(dg,metrics.dome.rBottom+12), y = toY(dg,metrics.insCaveBottom)-4);
			ctx.lineTo(x = toX(dg,metrics.dome.rBottomI), y);
			ctx.stroke();

			ctx.lineWidth = 1;
			ctx.strokeStyle = 'black';
			ctx.setLineDash([3, 3]);
			ctx.beginPath();
			ctx.moveTo(toX(dg,metrics.dome.rBottomI), y-2);
			ctx.lineTo(toX(dg,metrics.dome.rBottomI/2), y);
			ctx.stroke();
			ctx.setLineDash([]);

			ctx.fillStyle = 'black'; 
			ctx.font = "bold 16px serif";
			ctx.fillText("\u2191", xColdTurbinHp-6, toY(dg,yColdHpBottom)+20);
		}
		const heatPumpColor = metrics.topFillWithIceWithStorage ? 'black' : 'white';

		var xGeneratorLeft = xColdTurbinHp + ctWidth/2;
		var xGeneratorRight = xGeneratorLeft + ctWidth*2;
		const xChargeGeneratorRight = xGeneratorRight;

		ctx.lineWidth = 2;
		ctx.strokeStyle = heatPumpColor;
		ctx.beginPath();
		ctx.moveTo(xColdTurbinHp-7, toY(dg,hpYShift+ yHpBottom-4-18));    
		ctx.lineTo(xColdTurbinHp-7, y = toY(dg,hpYShift+ yHpBottom-4-6));
		ctx.lineTo(xGeneratorRight, y );
		ctx.lineTo(xGeneratorRight, y = toY(dg,hpYShift+ yHpBottom-4-18));
		ctx.closePath(); //lineTo(xColdTurbinHp-7, y);
		ctx.stroke();
		ctx.font = "bold 12px arial";
		ctx.fillStyle = heatPumpColor; 
		ctx.fillText("Heat exchangers", xColdTurbinHp+6, toY(dg,hpYShift+ yHpBottom-4-15.5)-1)
		if (metrics.topFillWithIceWithStorage) {
			ctx.fillText(powerAndHeat ? "District heat" : "Cooling water", xGeneratorRight+20, toY(dg,hpYShift+ yHpBottom-4-11));//toY(dg, yHpBottom-4-13));
			if (cycleData) ctx.fillText(workToMW(cycleData.heatPumpHeating), xGeneratorRight+20, toY(dg,hpYShift+ yHpBottom-4-11-6));
			if (cycleData) ctx.fillText(workToMW(-cycleData.heatPumpCooling), xColdTurbinHp-17, toY(dg,hpYShift+ yHpBottom));
		}
		else if (metrics.externalIceStorage) {
			ctx.fillText(workToMW(cycleData.heatPumpHeating),  xGeneratorRight-5+20, toY(dg,hpYShift+ yHpBottom-4-13));
			ctx.fillText("Cooling water ", xGeneratorRight-5+20, toY(dg,hpYShift+ yHpBottom-4-20));
			if (cycleData) ctx.fillText(workToMW(-cycleData.heatPumpCooling), xColdTurbinHp-5, toY(dg,hpYShift+ yHpBottom-4-26));
		}
		else {
			ctx.fillText(powerAndHeat ? "District heat" : "Cooling water", xGeneratorLeft+25, toY(dg,hpYShift+ yHpBottom-4-26));//toY(dg, yHpBottom-4-13));
			if (cycleData) ctx.fillText(workToMW(cycleData.heatPumpHeating), xGeneratorLeft+25, toY(dg,hpYShift+ yHpBottom-4-26-6));
			if (cycleData) ctx.fillText(workToMW(-cycleData.heatPumpCooling), xColdTurbinHp-17, toY(dg,hpYShift+ yHpBottom-4-26));
		}

		ctx.font = "bold 20px arial";
		ctx.fillStyle = 'red'; 
		ctx.fillText("\u2192",  xGeneratorRight-5, toY(dg,hpYShift+ yHpBottom-4-13));
		ctx.font = "bold 20px arial";
		ctx.fillStyle = 'blue'; 
		ctx.fillText("\u2190",  xGeneratorRight-5, toY(dg,hpYShift+ yHpBottom-4-20));


		var genMotUpPx = metrics.topFillWithIceWithStorage ? 0 : (yLpTop-yLpBottom)*1.2*2; 
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xColdTurbinHp, y = toY(dg,towerH-10));
		ctx.lineTo(x+ctWidth/4, y);
		ctx.lineTo(x+ctWidth/4, y-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y-genMotUpPx);
		ctx.stroke();

		const xHeatPumpTurbinLp = xGeneratorLeft + ctWidth/4;
		const xHeatPumpTurbinHp = xHeatPumpTurbinLp + ctWidth/2;
/*
*/
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.moveTo(xColdTurbinHp, y);
		ctx.lineTo(xHeatPumpTurbinLp, y);
		ctx.stroke();

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpTurbinLp, y = toY(dg,hpYShift+yColdLpTop));
		ctx.lineTo(x, toY(dg,hpYShift+ yColdLpBottom));
		ctx.lineTo(x = xHeatPumpTurbinHp, toY(dg,hpYShift+yColdHpBottom));
		ctx.lineTo(x, toY(dg,hpYShift+yColdHpTop));
		ctx.lineTo(xHeatPumpTurbinLp, toY(dg,hpYShift+yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("T", xHeatPumpTurbinLp+4, toY(dg,hpYShift+yColdLpBottom+1));

		ctx.font = "bold 14px serif";
		ctx.fillText("Heat pump",  xHeatPumpTurbinLp, toY(dg,hpYShift+yColdLpTop)-1);

		const xHeatPumpCompressorLp = xHeatPumpTurbinHp+ctWidth/2;
		const xHeatPumpCompressorHp = xHeatPumpCompressorLp + ctWidth/2;
		
		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(xHeatPumpTurbinLp, y = toY(dg,hpYShift+yColdLpBottom)-3);
		ctx.lineTo(x = xColdTurbinHp+5, y);
		ctx.lineTo(x, y = toY(dg,hpYShift+ yHpBottom-10)+20);
		ctx.lineTo(x = xHeatPumpCompressorLp-5, y );
		ctx.lineTo(x, y = toY(dg,hpYShift+yColdLpBottom)-3);
		ctx.lineTo(xHeatPumpCompressorLp, y);
		ctx.stroke();
		//ctx.fillText("\u2190", xColdTurbinHp+3, toY(dg,yColdLpBottom)+4);

		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		ctx.beginPath();
		ctx.moveTo(x = xHeatPumpCompressorHp-2,toY(dg,hpYShift+yColdHpBottom));
		ctx.lineTo(x, y = toY(dg,hpYShift+ yHpBottom-4-8));
		ctx.lineTo(xHeatPumpTurbinHp-2,  y );
		ctx.lineTo(x = xColdTurbinHp+12, y);
		ctx.lineTo(x, y = toY(dg,hpYShift+yColdHpBottom)+16);
		ctx.lineTo(x = xHeatPumpTurbinHp-2,  y );
		ctx.lineTo(x, y= toY(dg,hpYShift+yColdHpBottom));
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 16px serif";
		ctx.fillText("\u2193", xHeatPumpCompressorHp-2-5, toY(dg,hpYShift+yColdHpBottom)+16);
		ctx.fillText("\u2191", x-4, y+18);
		ctx.fillText("\u2193", xColdTurbinHp+1, toY(dg,hpYShift+yColdHpBottom)+18);
		ctx.fillText("\u2191", xHeatPumpCompressorLp-5-4, toY(dg,hpYShift+yColdLpBottom)-3+18);

		ctx.beginPath();
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 5;
		ctx.moveTo(xHeatPumpTurbinHp, y = toY(dg,hpYShift+ towerH-10));
		ctx.lineTo(xHeatPumpCompressorLp, y);
		ctx.stroke();

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpCompressorLp, y = toY(dg,hpYShift+yColdLpTop));
		ctx.lineTo(x, toY(dg,hpYShift+ yColdLpBottom));
		ctx.lineTo(x = xHeatPumpCompressorHp, toY(dg,hpYShift+yColdHpBottom));
		ctx.lineTo(x, toY(dg,hpYShift+yColdHpTop));
		ctx.lineTo(xHeatPumpCompressorLp, toY(dg,hpYShift+yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("C", xHeatPumpCompressorLp+4, toY(dg,hpYShift+yColdLpBottom+1));

/*
		const xHeatPumpMotor = xHeatPumpCompressorHp+ctWidth/4;
		const xHeatPumpMotorEnd = xHeatPumpMotor+ctWidth/3+2;
		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xHeatPumpMotor, toY(dg,hpYShift+yColdLpTop));
		ctx.lineTo(x, y = toY(dg,hpYShift+ yColdLpBottom));
		ctx.lineTo(x = xHeatPumpMotorEnd, y);
		ctx.lineTo(x, toY(dg,hpYShift+yColdLpTop));
		ctx.lineTo(xHeatPumpMotor, toY(dg,hpYShift+yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 12px serif";
		ctx.fillText("M", xHeatPumpMotor+2, y=toY(dg,hpYShift+yColdLpBottom+1));
		ctx.fillText(Math.round(cycleData.heatPumpNetWorkIn/1000)+" MW", xHeatPumpMotor+17, y-12);
		ctx.font = "bold 20px serif";
		ctx.fillText("\u21DC", xHeatPumpMotor+15, y);
		
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.moveTo(xHeatPumpCompressorHp, y= toY(dg,hpYShift+ towerH-10));
		ctx.lineTo(xHeatPumpMotor, y);
		ctx.stroke();
*/

		ctx.beginPath();
		ctx.lineWidth = 2;
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xGeneratorLeft, toY(dg,yLpTop)-genMotUpPx);
		ctx.lineTo(x, y = toY(dg, yLpBottom)-genMotUpPx);
		ctx.lineTo(x = xGeneratorRight, y);
		ctx.lineTo(x, y = toY(dg, yLpTop)-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y);
		ctx.closePath();
		ctx.stroke();
		ctx.fillStyle = 'black'; 
		ctx.font = "bold 13px arial";
		ctx.fillText("M / G", xGeneratorLeft+20, toY(dg,yLpBottom+8)-genMotUpPx);
		if (cycleData) ctx.fillText(metrics.cUnits+"*"+workToMW(cycleData.netWorkIn, metrics.cUnits), xGeneratorLeft+5, toY(dg,yLpBottom+1)-genMotUpPx);

		ctx.fillText("Motor-Generator", xGeneratorLeft-10, toY(dg,yLpTop+1)-genMotUpPx);
//		ctx.fillText("Charge", xGeneratorRight+1, toY(dg,yLpBottom+10));

		ctx.font = "bold 20px serif";
		ctx.fillText("\u21DC", xGeneratorRight+1, toY(dg, towerH-14)-genMotUpPx);
		if (metrics.externalIceStorage) {
			ctx.fillText("Charge mode", xGeneratorLeft-20, toY(dg,yLpBottom+8)-genMotUpPx-50);
		}
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.strokeStyle = 'black';
		ctx.moveTo(x = xTurbinHp, y = toY(dg, yHpTop));
		ctx.lineTo(x, toY(dg,yHpBottom));
		ctx.lineTo(x = xTurbinLp, toY(dg,yLpBottom));
		ctx.lineTo(x, toY(dg,yLpTop));
		ctx.lineTo(xTurbinHp, toY(dg, yHpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 16px serif";
		ctx.fillText("T", xTurbinHp+15, toY(dg, yLpBottom+4));

		ctx.lineWidth = 5;
		ctx.strokeStyle = colorHotHpGravel;
		ctx.beginPath();
		if (metrics.topFillUsedAsWeight) {
			ctx.moveTo(xTurbinHp+3, toY(dg,yHpTop));
			ctx.lineTo(xTurbinHp+3, y = toY(dg,yLpTop)-5);
			//ctx.moveTo(xTurbinHp+3, toY(dg,yHpBottom));
			//ctx.lineTo(xTurbinHp+3, y = toY(dg,yHpBottom-1));
			ctx.lineTo(x = toX(dg,6), y);
			const y2 = toY(dg,metrics.dome.hBottomI-1.5);
			//ctx.lineTo(x, y2);
			ctx.stroke();
			ctx.lineWidth = 1;

			ctx.fillStyle = 'black'; 
			ctx.font = "16px serif";
			ctx.fillText("\u2193", xTurbinHp, toY(dg,yHpTop+2));
		}
		else if (metrics.topFillWithIceWithStorage) {
			ctx.moveTo(xTurbinHp+3, toY(dg,yHpBottom));
			ctx.lineTo(xTurbinHp+3, y = toY(dg, yHpBottom-6));
			ctx.lineTo(toX(dg,10), y);
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "16px serif";
			ctx.fillText("\u2191", xTurbinHp-1, toY(dg,yHpBottom)+16);
			ctx.fillText("\u2190", toX(dg,-10), y+8);
			ctx.fillText("\u2190", toX(dg,10), y+8);
		}
		else {
			ctx.moveTo(xTurbinHp+3, toY(dg,yHpBottom));
			ctx.lineTo(xTurbinHp+3, y = toY(dg, yHpBottom-11));
			ctx.lineTo(x = toX(dg,-metrics.rGroundBelow-3), y );
			{
				const y2 = toY(dg,metrics.dome.hBottomI-1.5);
				const x2 = x + Math.cos(Math.PI*metrics.dome.maxAngle/180)*(y2-y)-6;
				ctx.lineTo(x2, y2 );
				ctx.lineTo(toX(dg,metrics.dome.rTopI+2),y2);
			}
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "16px serif";
			ctx.fillText("\u2191", xTurbinHp-2, toY(dg,yHpBottom)+16);
		}

		ctx.lineWidth = 15;
		ctx.strokeStyle = colorHotLpGravel;
/*		{
			ctx.beginPath();
			var x2;
			ctx.moveTo(towerRightX+5, y = toY(dg,(yHpBottom+yHpTop)/2)-4);
			ctx.lineTo(x2 = towerRightX-10, y);
			const pixelsUp = y - toY(dg,hGround+hLpHot-4);
			ctx.lineTo(x2 = x2-metrics.toSideX(pixelsUp), y-pixelsUp );
			ctx.lineTo(x2-30, y-pixelsUp);
			ctx.stroke();
		}*/
		xRightMHE = towerLeftX+10, xLeftMHE = towerLeftX-60;

		if (metrics.topFillWithIceWithStorage) {
			ctx.lineWidth = 15;
			ctx.strokeStyle = metrics.powerAndHeat ? colorHotLpGravel2 : colorWarmLpGravel;
			ctx.beginPath();
			ctx.moveTo(towerLeftX+2, toY(dg,(yHpBottom+yHpTop)/2)-6);
			ctx.lineTo(towerLeftX+2, toY(dg,yLpTop)-4);
			ctx.stroke();

			ctx.font = "bold 16px serif";
			ctx.fillStyle = 'black';
			ctx.fillText("\u2191", towerLeftX-4, toY(dg,yLpTop)+12);

			ctx.strokeStyle = colorWarmLpGravel;
			ctx.beginPath();
			ctx.lineWidth = 2;
			ctx.strokeStyle = 'black';
			ctx.beginPath();
			ctx.moveTo(xLeftMHE, yBottomMHE);
			ctx.lineTo(xLeftMHE, yTopMHE);
			ctx.lineTo(xRightMHE, yTopMHE);
			ctx.lineTo(xRightMHE, yBottomMHE);
			ctx.lineTo(xLeftMHE, yBottomMHE);
			ctx.closePath();
			ctx.stroke();
			
			ctx.font = "bold 12px serif";
			if (metrics.powerAndHeat) {
				ctx.beginPath();
				ctx.moveTo(towerLeftX+2, yTopMHE-1 );
				ctx.lineTo(towerLeftX+2, yTopMHE-21);
				ctx.strokeStyle = colorHotLpGravel2;
				ctx.lineWidth = 4;
				ctx.stroke();
				ctx.fillText(Math.round(cycleData.heatOutInDischarge/1000)+" MW to steam turbin", xLeftMHE+14, yTopMHE-21);
				ctx.fillText(toCelsius(cycleData.hotCycle[0].tOut-metrics.heatExchangeDeltaT*2), towerLeftX+6, yTopMHE-2 );
			}
			ctx.fillStyle = 'black';
			ctx.fillText("Main heat", xLeftMHE+4, toY(dg,yLpTop)-20);
			ctx.fillText("exchanger", xLeftMHE+4, toY(dg,yLpTop)-8);

			const hIceTop = toY(dg,hGround+cycleData.iceStorage.earthWorkHeight-4);
			ctx.beginPath();
			ctx.strokeStyle = colorColdHpGravel;
			ctx.lineWidth = 10;
			ctx.moveTo(toX(dg,-(xIceEnd-fromSideM))-7, hIceTop+7);
			ctx.lineTo(toX(dg,-(xIceEnd-fromSideM))-7+hIceTop, 10);
			ctx.lineTo(xLeftMHE+6, 10);
			ctx.lineTo(xLeftMHE+6, yTopMHE);
			ctx.stroke();

			ctx.fillStyle = 'black';
			ctx.font = "bold 20px serif";
			ctx.fillText("\u2199", toX(dg,-(xIceEnd-fromSideM))+3, hIceTop);
			ctx.fillText("\u2191", xLeftMHE, yTopMHE-4);
		}
		else 
		{
			ctx.beginPath();
			var x2, y2;
			var xFrom, xTo;
//console.log("toSideX("+metrics.hAbove+")+"+metrics.rTop+"="+(metrics.toSideX(metrics.hAbove)+metrics.rTop)+"=="+metrics.rGround);
			var pixelsUp;
			if (metrics.topFillUsedAsWeight) {
				ctx.moveTo(towerLeftX-5, y2 = toY(dg,(yHpBottom+yHpTop)/2)-4);
				pixelsUp = y2 - (toY(dg,hGround+metrics.hAbove)+7.5);
				ctx.lineTo(toX(dg,-10), y2 );
				ctx.lineTo(toX(dg,-10), y = toY(dg,hGround+hLpHot));
				ctx.stroke();
				xFrom = toX(dg, 0);
				xTo = toX(dg, -metrics.rGround);
				x2 = xTo-5;
				y = toY(dg,hGround);
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.moveTo(x2, y);
				ctx.lineTo(toX(dg, -10)-7.5, y);
				ctx.stroke();
				ctx.fillStyle = 'black'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2192", towerLeftX-10, y2+10);
			}
			else {
				ctx.moveTo(towerLeftX-5, y2 = toY(dg,(yHpBottom+yHpTop+2)/2));
				pixelsUp = y2 - (toY(dg,hGround+metrics.hAbove)+7.5);
				ctx.lineTo(x2=towerLeftX+10, y2 );
				ctx.lineTo(x2 = x2+metrics.toSideX(pixelsUp), y2-pixelsUp );
				ctx.lineTo(x2+40, y2-pixelsUp);
				ctx.stroke();
				ctx.fillStyle = 'black'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2192", towerLeftX-10, y2+10);
				ctx.fillText("\u2192", x2+40, y2-pixelsUp+10);
				xFrom = x2+17;
				xTo = toX(dg, -4);
				ctx.lineWidth = 1;
				ctx.strokeStyle = 'black';
			}
			y = y2-pixelsUp - 7.5;
			/*
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(x2+20, y);
			ctx.lineTo(toX(dg, -4), y);
			ctx.stroke();
			*/
			ctx.beginPath();
			ctx.setLineDash([3, 3]);
			ctx.moveTo(xFrom, y+15);
			ctx.lineTo(xTo, y+4);
			ctx.stroke();
			ctx.setLineDash([]);
		}
		const xColdCompressorLp = xTurbinHp - ctWidth/2;
		ctx.beginPath();
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.moveTo(xTurbinHp, y = toY(dg, towerH-10));
		ctx.lineTo(xColdCompressorLp, y);
		ctx.stroke();
		const xColdCompressorHp = xColdCompressorLp - ctWidth/2;

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x = xColdCompressorLp, y = toY(dg,yColdLpTop));
		ctx.lineTo(x, toY(dg, yColdLpBottom));
		ctx.lineTo(x = xColdCompressorHp, toY(dg,yColdHpBottom));
		ctx.lineTo(x, toY(dg,yColdHpTop));
		ctx.lineTo(xColdCompressorLp, toY(dg,yColdLpTop));
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 12px serif";
		ctx.fillText("C", xColdCompressorHp+5, toY(dg,yColdLpBottom+1));

		ctx.lineWidth = 8;
		if (metrics.topFillWithIceWithStorage) {
			const hIceBottom = toY(dg, hGround-cycleData.iceStorage.depth+cycleData.iceStorage.insForBottom);
			ctx.strokeStyle = colorColdLpGravel;
			ctx.beginPath();
			ctx.moveTo(xColdCompressorLp-4, toY(dg,yColdLpBottom+1));
			ctx.lineTo(xColdCompressorLp-4, hIceBottom-4);
			ctx.lineTo(toX(dg,-(xIceEnd-fromSideM)), hIceBottom);
			ctx.stroke();
			ctx.fillStyle = 'white'; 
			ctx.font = "bold 20px serif";
			ctx.fillText("\u2191", xColdCompressorLp-10, toY(dg,yColdLpBottom-10));
			ctx.fillText("\u2192", toX(dg,-(xIceEnd-fromSideM))+20, hIceBottom+10);
			ctx.font = "10px serif";
			for (x = toX(dg,-(xIceEnd-fromSideM))-5; x > toX(dg,-xIceEnd); x -= 10) {
				ctx.fillText("\u2193", x, hIceBottom )
			}
		}
		else 
		{
			ctx.beginPath();
			ctx.moveTo(xColdCompressorLp-4, toY(dg,yColdLpBottom+1));
			if (metrics.topFillUsedAsWeight) {
				ctx.strokeStyle = colorLiquidLpGravel;
				ctx.moveTo(xColdCompressorLp-4, toY(dg,yColdLpTop-1));
				ctx.lineTo(xColdCompressorLp-4, y = toY(dg,yLpTop)-13);
				ctx.lineTo(x = toX(dg,-1.5), y);
				ctx.stroke();
				yColdChannel = y+2.5;
				ctx.fillStyle = 'white'; 
				//ctx.fillStyle = 'black'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2193", xColdCompressorLp-9, toY(dg,yColdLpTop));
			}
			else if (metrics.externalIceStorage) {
				ctx.strokeStyle = colorColdLpGravel;
				ctx.lineTo(xColdCompressorLp-4, y = toY(dg, yHpBottom-24)+12);
				ctx.lineTo(x = toX(dg,-(xIceEnd-fromSideM))-40, y);
				ctx.lineTo(x, y = toY(dg,hGround-iceStorage.depth)-10);
				ctx.stroke();

				ctx.moveTo(x = toX(dg,-(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop))), y = toY(dg,hGround+iceStorage.height-iceStorage.depth)+4);
				ctx.lineTo(x+20, y = y-20);
				ctx.lineTo(xColdCompressorLp+8, y);
				ctx.lineTo(xColdCompressorLp+8, y = toY(dg, yHpBottom-10)+12);
				ctx.lineTo(toX(dg,-metrics.rGroundBelow-8), y );
				ctx.lineTo(toX(dg,-rPipeLpCold-13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
				ctx.lineTo(x = toX(dg,-rPipeLpCold+insLpX),y);
				ctx.stroke();
				ctx.fillStyle = 'white'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2190", x-25, y+10 );
				ctx.fillText("\u2193", toX(dg,-(xIceEnd-fromSideM))-44, toY(dg,hGround-iceStorage.depth) + 20 );
				ctx.fillText("\u2199", toX(dg,-(xIceEnd-fromSideM+(iceStorage.rBottom-iceStorage.rTop))), toY(dg,hGround+iceStorage.height-iceStorage.depth)+6);
				ctx.fillText("\u2191", xColdCompressorLp-9, toY(dg,yColdLpBottom-10));
			}
			else {
				ctx.strokeStyle = colorColdLpGravel;
				ctx.lineTo(xColdCompressorLp-4, y = toY(dg, yHpBottom-10)+12);
				ctx.lineTo(toX(dg,-metrics.rGroundBelow-8), y );
				ctx.lineTo(toX(dg,-rPipeLpCold-13), y = toY(dg,hGround-metrics.hBelowActual+hLiquid*2+4));
				ctx.lineTo(toX(dg,-rPipeLpCold+insLpX),y);
				ctx.stroke();
				ctx.fillStyle = 'white'; 
				ctx.font = "bold 20px serif";
				ctx.fillText("\u2191", xColdCompressorLp-9, toY(dg,yColdLpBottom-10));
			}
		}
		if (!powerAndHeat && metrics.maxPartLiquid > 0.002) { // gas contect is in balance => no need to store liquid gas
//console.log("hLiquidStorage="+hLiquidStorage+", rLiquidStorage="+rLiquidStorage);
			ctx.lineWidth = 2;
			ctx.strokeStyle = colorLiquidLpGravel;
			ctx.beginPath();
			ctx.moveTo(xColdCompressorLp-1, toY(dg,yColdLpBottom+1));
			ctx.lineTo(x = xColdCompressorLp-1, y = toY(dg, yHpBottom-30)+12);
			ctx.stroke();
			var x1 = x - dg.meterToPixels*rLiquidStorage*0.5;
			var x2 = x + dg.meterToPixels*rLiquidStorage*1.5;
			var y1 = y;
			var y2 = y+dg.meterToPixels*hLiquidStorage;

			region = new Path2D();
			region.moveTo(x1, y1);
			region.lineTo(x2, y1);
			region.lineTo(x2, y2);
			region.lineTo(x1,y2);
			region.closePath();
			ctx.fillStyle = ctx.fillStyle = colorLiquidLpGravel;
			ctx.fill(region);
			ctx.fillStyle = 'white'; 
			ctx.font = "12px serif";
			const titleWidth = ctx.measureText("Boiling to C-in").width;
			if (dg.meterToPixels*hLiquidStorage < 62) {
				y2 = y1 + 62;
			}
			ctx.fillText("Liquid "+gasName, x1, y2-36);
			ctx.fillText("storage", x1, y2-24);
			ctx.fillText("Boiling to C-in", x1, y2-12);
			ctx.fillText("Vol "+Math.round(liquidM3)+" m3", x1, y2);

			ctx.fillStyle = 'white'; 
			ctx.font = "bold 12px serif";
			ctx.fillText("\u2191 "+Math.round(cycleData.coldCycle[1].wetness*1000)+" ‰ of gas", xColdCompressorLp-4, y1+12);
		}
		ctx.lineWidth = 4;
		ctx.strokeStyle = colorColdHpGravel;
		if (metrics.topFillWithIceWithStorage) {
			ctx.beginPath();
			ctx.moveTo(xColdCompressorHp+2, toY(dg,yColdHpTop-1));
			//ctx.lineTo(xColdCompressorHp+2, y = toY(dg,hpYShift+ yHpBottom-6));
			//ctx.lineTo(xLeftMHE+6, y);
			ctx.lineTo(xColdCompressorHp+2, y = (yTopMHE+yBottomMHE)/2);
			ctx.lineTo(xLeftMHE, y);
			ctx.stroke();

			ctx.fillStyle = 'black'; 
			ctx.font = "bold 16px serif";
			ctx.fillText("\u2191", xColdCompressorHp-2, toY(dg,yColdHpTop+2));
			ctx.fillText("\u2192", xLeftMHE-18, y+7);

			ctx.lineWidth = 7;
			ctx.strokeStyle = colorHotLpGravel;
			ctx.beginPath();
			ctx.moveTo(xRightMHE, y=(yTopMHE+yBottomMHE)/2);
			ctx.lineTo(xRightMHE+6, y);
			ctx.lineTo(xRightMHE+6, hGround+20);
			ctx.lineTo(toX(dg,-(metrics.dome.rBottom+12)), y = toY(dg,metrics.insCaveBottom)-4);
			ctx.lineTo(x = toX(dg,-metrics.dome.rBottomI), y);
			ctx.stroke();

			ctx.fillText("\u2192", x-20, y+8);
			ctx.fillText("\u2193", xRightMHE+2, (yTopMHE+yBottomMHE)/2+20);
		}
		else {
			ctx.beginPath();
			ctx.moveTo(xColdCompressorHp+2, toY(dg,yColdHpBottom+1));
			ctx.lineTo(xColdCompressorHp+2, y = toY(dg, yHpBottom-10)+20);
			ctx.lineTo(toX(dg,-metrics.rGroundBelow-12), y );
			ctx.lineTo(toX(dg,-metrics.dome.rBottom-12), y = toY(dg,metrics.insCaveBottom)-4);
			ctx.lineTo(toX(dg,-metrics.dome.rBottomI), y);
			ctx.stroke();

			ctx.fillStyle = 'black'; 
			ctx.font = "bold 16px serif";
			ctx.fillText("\u2193", xColdCompressorHp-2, toY(dg,yColdHpBottom)+20);
		}
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo(toX(dg,-metrics.dome.rBottomI), y-2);
		ctx.lineTo(toX(dg,-metrics.dome.rBottomI/4), y);
		ctx.stroke();
		ctx.setLineDash([]);

		genMotUpPx = 0;		// syncronous connection => move to the same level
//console.log("genMotUpPx="+genMotUpPx);
 		xGeneratorRight = xColdCompressorHp - ctWidth/2;
		xGeneratorLeft = xGeneratorRight - 2*ctWidth;
		ctx.lineWidth = 5;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(xColdCompressorHp, y = toY(dg, towerH-10));
		ctx.lineTo(x = xColdCompressorHp-ctWidth/4, y);
		//ctx.lineTo(x, y-genMotUpPx);
		ctx.lineTo(xGeneratorRight, y-genMotUpPx);
		ctx.stroke();

		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.beginPath();
		ctx.moveTo(x = xGeneratorLeft, toY(dg,yLpTop)-genMotUpPx);
		ctx.lineTo(x, y = toY(dg, yLpBottom)-genMotUpPx);
		ctx.lineTo(x = xGeneratorRight, y);
		ctx.lineTo(x, y = toY(dg, yLpTop)-genMotUpPx);
		ctx.lineTo(xGeneratorLeft, y);
		ctx.closePath();
		ctx.stroke();
		ctx.font = "bold 13px arial";
		ctx.fillText("M / G", xGeneratorLeft+15, toY(dg,yLpBottom+8)-genMotUpPx);
		if (cycleData) ctx.fillText(metrics.cUnits+"*"+workToMW(cycleData.netWorkOut, metrics.cUnits), xGeneratorLeft+10, toY(dg,yLpBottom+1)-genMotUpPx);
		ctx.fillText("Motor-Generator", xGeneratorLeft-10, toY(dg,yLpTop+1)-genMotUpPx);
		if (metrics.topFillWithIceWithStorage) {
			ctx.font = "bold 20px serif";
			ctx.fillStyle = 'white';
			const titleWidth = ctx.measureText("Discharge mode").width;
			ctx.fillText("Discharge mode", towerLeftX-2*ctWidth-titleWidth, toY(dg,hGround-21));
			ctx.fillStyle = 'black';
		}
		else if (metrics.externalIceStorage) {
			ctx.font = "bold 20px serif";
			ctx.fillText("Discharge mode", xGeneratorLeft-30, toY(dg,yLpBottom+8)-genMotUpPx-50);
		}
		else {
			ctx.fillText("Discharge mode", xColdCompressorHp, toY(dg,yLpTop+1)-16);
		}
		
		//ctx.fillText("Discharge", xGeneratorLeft-1-ctx.measureText("Discharge").width, toY(dg,yLpBottom+11));
		ctx.font = "bold 20px serif";
		ctx.fillText("\u21DC", xGeneratorLeft-19, toY(dg, towerH-14)-genMotUpPx);
		
		ctx.font = "20px arial";
		ctx.fillStyle = 'white'; 
		ctx.fillText("bedrock", x = toX(dg,-metrics.rGround-50), y = toY(dg,metrics.dome.hBottom/2));
		ctx.fillText("bedrock",x = toX(dg,metrics.rGround+10), y);
		ctx.font = "14px arial";
		const depth = metrics.hBelow+metrics.hCylinder;
//console.log( depthM+", yPx="+toY(dg,depth))
		ctx.fillText( "-"+Math.round(hGround-metrics.dome.hBottomI)+" m", toX(dg,metrics.dome.rTopI-22), toY(dg,metrics.dome.hBottomI));
		ctx.fillText( "-"+Math.round(depth)+" m", toX(dg,metrics.dome.rBottom+14), toY(dg,0));
		ctx.fillStyle = 'black'; 
		{
			const heightText = "+"+Math.round(metrics.hAbove)+" m";
			if (metrics.topFillWithIceWithStorage) {
				ctx.fillText(  heightText, toX(dg,metrics.rTop)+2, toY(dg,hGround+metrics.hAbove)+4);
			}
			else {
				ctx.fillText(  heightText, toX(dg,-metrics.rTop)-ctx.measureText(heightText).width-5, toY(dg,hGround+metrics.hAbove)-4);
			}
		}

		ctx.font = "bold "+px+"px arial";
		ctx.fillStyle = 'black'; 
		ctx.fillText("r="+Math.round(metrics.dome.rBottom)+" m \u21A6", toX(dg,0), toY(dg,metrics.insCaveBottom)+2);

		ctx.fillStyle = 'white'; 

		ctx.fillStyle = metrics.topFillUsedAsWeight ? 'black' : 'white'; 
		if (Math.round(metrics.rGroundBelow) != Math.round(metrics.rGround)) {
			ctx.fillText("r="+Math.round(metrics.rGround)+" m \u21A6", toX(dg,-metrics.rGroundBelow)+15,toY(dg,hGround));
			ctx.fillText("r="+Math.round(metrics.rGroundBelow)+" m \u21A6", toX(dg,-metrics.rGroundBelowActual)+15, toY(dg,hGround-6));
		}
		else {
			if (hLpWarmFromGround > 0 && !metrics.topFillUsedAsWeight) {
				ctx.fillText("r="+Math.round(metrics.rGround)+" m \u21A6", toX(dg,-metrics.rGroundBelow)+15,toY(dg,hGround));
			}
			else {
				ctx.fillText("r="+Math.round(metrics.rGroundBelow)+" m \u21A6", toX(dg,-metrics.rGroundBelowActual)+10, toY(dg,hGround-6));
			}
		}
		ctx.fillStyle = 'black';
		ctx.fillText("r="+Math.round(metrics.rTop)+" m \u21A6", toX(dg,0), toY(dg,hGround+metrics.hAbove)-4);

		ctx.font = "12px arial";
		ctx.fillStyle = 'white'; 
		// , r="+Math.round(metrics.dome.rTop)+" m \u21A6"
		pushCenterText(ctx, "Insulated with sorted crushed stone+stone wool 50/50 mix", toX(dg,0), toY(dg,metrics.dome.hBottomI+metrics.gasEnclosureFromHpTop)-2, colorInsulation );
		flushCenteredTexts( ctx );
		const txt = "\u2193Weight "+Math.round(metrics.pHighActual/1000)+" kPa";
		ctx.fillText(txt, toX(dg,-metrics.dome.rTop), toY(dg,metrics.dome.hBottomI));

		if (powerAndHeat) {
			ctx.beginPath();
			{
				const y1 = toY(dg,hGround+metrics.hAbove)-1;
				const y2 = toY(dg,hGround+hLpHot)-2;
				const x1 = toX(dg,metrics.rTop*0.10);
				const x2 = toX(dg,metrics.rTop)-5;
				const x3 = toX(dg,metrics.rTop+metrics.toSideX(metrics.hAbove-hLpHot+2)+xyAddRoof+4) + 20;
				
				ctx.lineWidth = 1;
				ctx.strokeStyle='black';
				for (x = x1; x < x2; x +=5) {
					ctx.beginPath();
					ctx.moveTo(x, y1);
					ctx.lineTo(x, y2);
					ctx.stroke();
				}
				ctx.lineWidth = 3;
				ctx.strokeStyle='red';
				ctx.beginPath();
				ctx.moveTo(x1, y1+2);
				ctx.lineTo(x3, y1+2);
				ctx.stroke();
				ctx.strokeStyle='blue';
				ctx.beginPath();
				ctx.moveTo(x1, y2);
				ctx.lineTo(x3, y2);
				ctx.stroke();
	/*			
				ctx.moveTo(toX(dg,metrics.rTop+1), y1);
				ctx.lineTo(toX(dg,metrics.rTop+xyAddRoof+4),y);
				ctx.lineTo(toX(dg,metrics.rTop+metrics.toSideX(metrics.hAbove-hLpHot+2)+xyAddRoof+4),y = toY(dg,hGround+hLpHot-2));
				ctx.lineTo( x=toX(dg,metrics.rTop+1+metrics.toSideX(metrics.hAbove-hLpHot+2)),y );
				ctx.closePath();
				ctx.stroke();
	*/
			}
			x=toX(dg,metrics.rTop+1+metrics.toSideX(metrics.hAbove-hLpHot+2));
			/*
			ctx.font = "bold 20px arial";
			ctx.fillStyle = colorHotLpGravel; 
			ctx.fillText("\u21D2", toX(dg,metrics.rTop), toY(dg,hGround+metrics.hAbove-7));
			ctx.fillStyle = colorWarmLpGravel; 
			ctx.fillText("\u21D0", x-5, y+6);
			*/
			ctx.font = "14px arial";
			ctx.fillStyle = 'black'; 
			ctx.fillText((cycleData ? workToMW(cycleData.heatOutInDischarge) : '')+" for heating or combined power", toX(dg,metrics.rTop+xyAddRoof+metrics.toSideX(10)), toY(dg,hGround+metrics.hAbove));
		}
/*
		ctx.font = "20px serif";
		ctx.fillText("\u21DC", xGeneratorLeft-20, toY(dg, towerH-14));
		ctx.fillStyle = 'white'; 
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.2 * lpActH));
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.3 * lpActH));
		ctx.fillText("\u21D4", towerRightX-11, toY(dg, hTop- ins/2 - 0.4 * lpActH));
		ctx.fillText("\u21D4", towerLeftX-12, hMaxTopLiquid+4);
		ctx.fillStyle = 'black'; 
		ctx.fillText("\u21D5", toX(dg,metrics.rCylinder)-8, hpStorageTopY+6);
*/

$("#"+canvasId).css('display','block');
return;
}
	
	function drawDiagram4Y( canvasId, xVals, xTitle, arrayOfyVals, yTitles, topTitle, bottomLines, minMaxDefault, fpCustomizer) {
//console.log("X lines...");
		const dg = {};
		dg.ySign = 1;
		dg.marginTop = topTitle ? (topTitle.indexOf(',')>0 ? 50 : 30) : 10;
		dg.baseX = 0;
		dg.baseY = 0;
		dg.marginBottom = 12 + (bottomLines ? bottomLines.length * 8 : 0);
		const canvas = document.getElementById(canvasId);
		const newHeight = (typeof canvas.height === 'string' ? parseInt(canvas.height) : canvas.height)+dg.marginBottom+dg.marginTop;
console.log("Increasing canvas "+canvasId+" height from "+canvas.height+" to "+newHeight);
		canvas.height = newHeight;
		const ctx = canvas.getContext("2d");
		ctx.font = "8px Arial";
		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black'; 
		dg.marginX = ctx.measureText(yTitles[0]).width + 6;
		dg.ctx = ctx;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		dg.width = canvas.getAttribute("width");
		dg.cWidth = dg.width - 2 * dg.marginX;
		dg.height = canvas.getAttribute("height");
		dg.cheight = dg.height - dg.marginTop - dg.marginBottom;
		if (topTitle) {
			ctx.font = "15px serif";
			var subTitle = null;
			const iPos = topTitle.indexOf(',');
			if (iPos>0) {
				subTitle = topTitle.substring(iPos+1);
				topTitle = topTitle.substring(0, iPos);
			}
			textOnWhite(ctx, topTitle, (dg.width-ctx.measureText(topTitle).width) / 2, 17);
			if (subTitle) {
				textOnWhite(ctx, subTitle, (dg.width-ctx.measureText(subTitle).width) / 2, 37);
			}
		}
		const xMinMax = minMaxVal( dg, xVals );
		var yMinMax = minMaxVal( dg, arrayOfyVals[0], minMaxDefault );
		if (arrayOfyVals[1]) {
			yMinMax = minMaxVal( dg, arrayOfyVals[1], yMinMax );
		}
console.log("xMinMax="+JSON.stringify(xMinMax)+"yMinMax="+JSON.stringify(yMinMax)+", minMaxDefault="+(minMaxDefault ? JSON.stringify(minMaxDefault) : null)); 
		dg.maxX = xMinMax.max + xMinMax.step / 2;
		dg.minX = xMinMax.min - xMinMax.step / 2;
		dg.maxY = yMinMax.max + yMinMax.step / 2;
		dg.minY = yMinMax.min - yMinMax.step / 2;
//console.log("dg:"+JSON.stringify(dg));
		ctx.beginPath();
		ctx.setLineDash([]);
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.moveTo(toX(dg,dg.minX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.maxX), toY(dg, dg.minY));
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,dg.minX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.minX), toY(dg, dg.maxY));
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(toX(dg,dg.maxX), toY(dg, dg.minY));
		ctx.lineTo(toX(dg,dg.maxX), toY(dg, dg.maxY));
		ctx.stroke();

		var t, x, i;
		ctx.fillStyle = 'black';
		ctx.strokeStyle = 'grey';
		ctx.font = "12px Arial";
		const height = dg.marginTop + dg.cheight + 10;
		ctx.strokeStyle = 'grey';
//console.log("X- lines...");
		const xMinMaxDiff = xMinMax.max - xMinMax.min;
		for (t = xMinMax.min; t <= xMinMax.max; t += xMinMax.step) {
			ctx.beginPath();
			ctx.setLineDash([10,10]);
			ctx.moveTo(x = toX(dg, t), toY(dg, dg.minY));
			ctx.lineTo(x, toY(dg, dg.maxY));
			ctx.stroke();
//console.log(t+": ("+x+","+toY(dg, yMinMax.min)+")->("+x+","+toY(dg, yMinMax.max)+")");
			textOnWhite(ctx,''+(xMinMaxDiff > 100 ? Math.round(t) : myRound(t)), x, height);
		}
		dg.xDone = true;
		if (xTitle) textOnWhite(ctx, xTitle, dg.width-dg.marginX, height);

//console.log("Y- lines...");
		var oldStrokeStyle = null;
		var oldFillStyle = null;
		var usedYs = [];
		var prevMinMax = null;
		//if (typeof iFrom === 'undefined') iFrom = 0;
		for (i = 0; i < arrayOfyVals.length; i++) {
			ctx.font = "12px Arial";
			const yVals = arrayOfyVals[i];
			if (yVals[0] == null) {
				console.lg(i+": no yVals!");
				continue;
			}
			if (prevMinMax && (!yTitles[i] || yTitles[i] == yTitles[i-1])) {
				yMinMax = prevMinMax;
			}
			else {
				prevMinMax = yMinMax = minMaxVal( dg, yVals, minMaxDefault );
			}
//console.log(i+":yMinMax="+JSON.stringify(yMinMax)); 
			dg.maxY = yMinMax.max + yMinMax.step / 2;
			dg.minY = yMinMax.min - yMinMax.step / 2;
			const yMinMaxDiff = yMinMax.max - yMinMax.minM;
			ctx.lineDashOffset = i * 2;
			if (i == 1) {
				ctx.strokeStyle = 'blue';
				ctx.fillStyle = 'blue'; 
			}
			else if (i == 2) {
				ctx.strokeStyle = 'red';
				ctx.fillStyle = 'red'; 
			}
			else if (i == 3) {
				ctx.strokeStyle = 'green';
				ctx.fillStyle = 'green'; 
			}
			else if (i == 4) {
				ctx.strokeStyle = 'orange';
				ctx.fillStyle = 'orange'; 
			}
			else if (i == 5) {
				ctx.strokeStyle = 'purple';
				ctx.fillStyle = 'purple'; 
			}
			if (bottomLines[i].indexOf("Gas temperature in ") == 0) {
				oldStrokeStyle = ctx.strokeStyle;
				oldFillStyle = ctx.fillStyle;
				ctx.setLineDash([1,5]);
				ctx.strokeStyle = 'black';
				ctx.fillStyle = 'black';
			}
			else if (oldStrokeStyle) {
				ctx.strokeStyle = oldStrokeStyle;
				ctx.fillStyle = oldFillStyle;
				oldStrokeStyle = oldFillStyle = null;
			}
			var p, y, j;
			var textX;
			
			for (p = yMinMax.min; p <= (yMinMax.max + yMinMax.step/4); p += yMinMax.step) {
				y = toY(dg, p);
				if (i == 0) {
					ctx.setLineDash([10,10]);
					ctx.beginPath();
					ctx.strokeStyle = 'gray';
					ctx.moveTo( toX(dg, dg.minX), y);
					ctx.lineTo( toX(dg, dg.maxX), y);
					ctx.stroke();
					ctx.strokeStyle = 'black';
				}
				if (yTitles[i]) {
					const text = ''+(xMinMaxDiff > 100 ? Math.round(p) : myRound(p));
					if (i == 0) {
						textX = dg.marginX - 2 - ctx.measureText(text).width;
						if (textX <= 0) textX = 1;
					}
					else if (i == 1) textX = dg.marginX + 2;
					else if (i == 2) {
						textX =  dg.marginX + dg.cWidth - 2 - ctx.measureText(text).width;
					}
					else if (i == 3) textX = dg.marginX + dg.cWidth + 2;
	//console.log(i+": titleX="+textX+", titleY="+(y-1)+", text="+text);
					textOnWhite(ctx, text, textX, y-1);
				}
			}

			if (yTitles[i]) {
				if (i == 0) {
					textX = dg.marginX - 1 - ctx.measureText(yTitles[i]).width;
					if (textX <= 0) textX = 1;
				}
				else if (i == 1) textX = dg.marginX + 1;
				else if (i == 2) {
					textX =  dg.marginX + dg.cWidth - 1 - ctx.measureText(yTitles[i]).width;
				}
				else if (i == 3) textX = dg.marginX + dg.cWidth + 1;
				if (i <= 3) {
					textOnWhite(ctx, yTitles[i], textX, dg.marginTop-1);
				}
			}
			if (bottomLines && i < bottomLines.length) {
				ctx.font = "12px Arial";
				if (i < (bottomLines.length/2)) {
					textOnWhite(ctx, bottomLines[i], 10, dg.marginTop + dg.cheight + 25 + 15 * i );
				}
				else {
					textOnWhite(ctx, bottomLines[i], dg.cWidth/2, dg.marginTop + dg.cheight + 25 + 15 * (i-(bottomLines.length/2)) );
				}
			}
			ctx.beginPath();
			y = toY(dg,yVals[0]);
//console.log("Y="+Math.round(y));
/*
			if (usedYs.includes(Math.round(y/10))) {
				ctx.setLineDash([]); 
			}
			else {
				ctx.setLineDash([10,10]); 
			}
			usedYs.push(Math.round(y/10));
*/
			//y = Math.round(toY(dg,yVals[0]));
			//var dashStart = usedYs.includes(y) ? 14.14 : 0;
			//usedYs.push(y);
			//ctx.moveTo(toX(dg,xVals[0])+dashStart, y + y > yVals[1] ? -dashStart : dashStart);
			if (false && bottomLines[i].indexOf("Gravel temp after")==0) {
				ctx.lineDashOffset = i * 2;;
				ctx.setLineDash([2,10]);
			}
			ctx.moveTo(toX(dg,xVals[0]), y);
//console.log(i+": x="+toX(dg,xVals[0])+", y="+toY(dg,yVals[0])+", ctx.strokeStyle="+ctx.strokeStyle);
			for (j = 1; j < yVals.length; j++) {
				if (j == xVals.length) break;
				ctx.lineTo(toX(dg,xVals[j]), toY(dg,yVals[j]));
//if (i == 0) console.log(i+": x="+toX(dg,xVals[j])+", y="+toY(dg,yVals[j]));
			}
			ctx.stroke();
			ctx.setLineDash([10,10]);
			ctx.lineDashOffset = 0;

			if (j < yVals.length) {
				var yFrom = xVals.length;
				var yTo = yFrom + xVals.length;
				ctx.strokeStyle = 'purple';
				ctx.fillStyle = 'purple'; 
				ctx.beginPath();
				ctx.moveTo(toX(dg,xVals[0]), toY(dg,yVals[j]));
				for (; j < yTo; j++) {
					ctx.lineTo(toX(dg,xVals[j-yFrom]), toY(dg,yVals[j]));
//console.log(i+": x="+toX(dg,xVals[j-yFrom])+", y="+toY(dg,yVals[j]));
				}
				ctx.stroke();
				if (bottomLines && (i+1) < bottomLines.length) {
					textOnWhite(ctx, bottomLines[i+1], dg.cWidth/2, dg.marginTop + dg.cheight + 30 + 15 * (i-2) );
				}
				if (j < yVals.length) {
					yFrom = xVals.length*2;
					yTo = yFrom + xVals.length;
					ctx.strokeStyle = 'orange';
					ctx.fillStyle = 'orange'; 
					ctx.beginPath();
					ctx.moveTo(toX(dg,xVals[0]), toY(dg,yVals[j]));
					for (; j < yVals.length; j++) {
						ctx.lineTo(toX(dg,xVals[j-yFrom]), toY(dg,yVals[j]));
//console.log(j+": yVal="+yVals[j]+", x="+toX(dg,xVals[j-yFrom])+", y="+toY(dg,yVals[j]));
					}
					ctx.stroke();
					if (bottomLines && (i+2) < bottomLines.length) {
						textOnWhite(ctx, bottomLines[i+2], dg.cWidth/2, dg.marginTop + dg.cheight + 30 + 15 * (i-1) );
					}
				}
			}
		}
		ctx.setLineDash([10,10]);
		ctx.lineDashOffset = 0;
		if (typeof fpCustomizer === 'function') {
			fpCustomizer( ctx, dg );
		}
		$("#"+canvasId).css('display','block');
	}
	
	function iDrawBraytonCycle( canvasId, hotCycle, coldCycle, cycleData, drawCompressors ) 
	{
console.log("drawBraytonCycle..., maxPressure="+maxPressure);
		var canvas = document.getElementById(canvasId);
		var ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		width = canvas.getAttribute("width");
		cWidth = width -2*marginX;
		height = canvas.getAttribute("height");
		cheight = height - 2*marginY;

//console.log("cWidth="+cWidth+", cheight="+cheight);
		var tDiff = maxTemp-minTemp; 
		var pDiff = maxPressure-minPressure;
		var showEnthalpyAndInternalEnergy=getBooleanParam("showEnthalpyAndInternalEnergy", false);
		
		minTemp = 0; // (minTemp - tDiff*0.05) > 0 ? Math.floor(minTemp - tDiff*0.05) : Math.floor(tTriplePoint+1);
		minPressure = 0; //(minPressure - pDiff*0.05) > 0 ? Math.floor((minPressure - pDiff*0.05)/1000) * 1000 : Math.floor(minPressure/1000) * 1000;
		//if (minPressure == 0) minPressure = 1000;

		var hMinTemp = minTemp;
		while (Math.floor(Module.PropsSI('H', 'T', hMinTemp, 'P', minPressure+1000, name) == 'Infinity')) {
			hMinTemp += 1;
			if (hMinTemp > 300) {
				console.log("out of scope: Module.PropsSI('H', 'T', "+hMinTemp+", 'P', "+(minPressure+1000)+", '"+name+"')=='Infinity'");
				return;
			}
		}
		minTemp = hMinTemp;
		maxPressure = Math.ceil((maxPressure + pDiff*0.05)/1000) * 1000;
console.log("maxPressure="+maxPressure+", ((maxPressure + "+pDiff+"*0.05)/1000="+((maxPressure + pDiff*0.05)/1000));
/*		
		var yPower = 1;
		Math.pow((maxPressure - p)/(maxPressure-minPressure), yLog)
		while (Math.pow((maxPressure - pCrit)/(maxPressure-minPressure), 1/yPower) > 2/3) {
			yPower -= 0.01;
		}
		yLog = 1/yPower;
if (!confirm("yPower="+yPower+" => yLog="+yLog)) return;
console.log("yPower="+yPower+" => yLog="+yLog);
*/
		maxTemp = Math.ceil(maxTemp + tDiff*0.05);
console.log("minPressure="+minPressure+", minTemp="+minTemp);
//console.log(JSON.stringify(turbinStages[turbinStages.length-1]));
//console.log(JSON.stringify(compressorStages[compressorStages.length-1].pOut));
		// TBD Available turbin work by background color, log-scale?????
//console.log("x="+tToX(minTemp)+", pToY("+minPressure+")="+pToY(minPressure)+", maxPressure="+maxPressure);
		// draw x - y coordinate lines
		ctx.beginPath();
		ctx.setLineDash([]);
		ctx.lineWidth = 1;
		ctx.strokeStyle = 'black';
		ctx.moveTo( tToX(minTemp), pToY(minPressure));
		optimzedLineTo(ctx,tToX(maxTemp), pToY(minPressure));
		ctx.stroke();
		ctx.moveTo( tToX(minTemp), pToY(minPressure));
		optimzedLineTo(ctx, tToX(minTemp), pToY(maxPressure));
		ctx.stroke();

		ctx.textAlign = "start";
		ctx.textBaseline = "bottom";
		ctx.fillStyle = 'black'; 

		// draw temp and temp lines, 
		// some max-min temps values: 0.1 Hydrogen: 30, Nitrogen: 65, Methane: 120, CarbonDioxide: 200, Water: 340
		// some max-min pressure values: Hydrogen(0.3): 350 kPa, Nitrogen: 600 kPa,  Methane: 2000 kPa, CarbonDioxide: 4000 kPa, Water: 2000 kPa
		ctx.font = "8px Arial";
		var tStep = 1;	// 2, 4, 8
		var pStep = 1;  //1, 2, 4, 8, 16, 32, 64 kPa ...
		// OK, if less than 55 vertical lines  44 horisontal ones
		while (((maxTemp-minTemp)/tStep) > 40) {
			if (tStep == 1)  tStep = 2;
			else if (tStep == 2) tStep = 5;
			else if (tStep == 5) tStep = 10;
			else if (tStep == 10) tStep = 20;
			else if (tStep == 20) tStep = 50;
			else {
				console.log("too many tSteps="+((maxTemp-minTemp)/tStep)); 
				break;
			}
		}
		while ((((maxPressure-minPressure)/1000)/pStep) > 30) {
			if (pStep == 1) pStep = 2;
			else if (pStep == 2) pStep = 5;
			else if (pStep == 5) pStep = 10;
			else if (pStep == 10) pStep = 20;
			else if (pStep == 20) pStep = 50;
			else if (pStep == 50) pStep = 100;
			else if (pStep == 100) pStep = 200;
			else if (pStep == 200) pStep = 500;
			else if (pStep == 500) pStep = 1000;
			else {
				console.log("too many pSteps="+(((maxPressure-minPressure)/1000)/pStep)); 
				break;
			}
		}
console.log("Temp lines...");
		var t, p, h, x, y;
		const tInc = (maxTemp-minTemp)/cWidth * 5;
		ctx.strokeStyle = 'grey';
		for (t = minTemp; t < maxTemp; t++) {
			if ((t % tStep) == 0) {
				ctx.beginPath();
				ctx.moveTo( x = tToX(t), pToY(minPressure));
				optimzedLineTo(ctx, x, pToY(maxPressure));
				ctx.stroke();
				ctx.fillStyle = 'black';
				if (t < (maxTemp-50)) {
					textOnWhite(ctx,''+t, x, height);
				}
			}
		}
		textOnWhite(ctx,'T K', width-marginX, height);
console.log("Pressure- lines...");
		for (p = minPressure; p < maxPressure; p += 1000) {
			if (((p/1000) % pStep) == 0) {
				ctx.beginPath();
				ctx.moveTo( tToX(minTemp), y = pToY(p));
				optimzedLineTo(ctx,tToX(maxTemp), y);
				ctx.stroke();
				ctx.fillStyle = 'black'; 
				textOnWhite(ctx,''+Math.round(p/1000), 1, y+1);
			}
		}
		textOnWhite(ctx,'P kPa', 1, 10);

		ctx.lineWidth = 1;
		var hMin = Math.floor((Module.PropsSI('H', 'T', hMinTemp, 'P', maxPressure, name)+9999)/10000) * 10000;
		while (hMin == 'Infinity') {
			hMin = Math.floor((Module.PropsSI('H', 'T', ++hMinTemp, 'P', maxPressure, name)+9999)/10000) * 10000;
			if (hMinTemp > 300) {
	console.log("ERROR: Module.PropsSI('H', 'T', "+hMinTemp+", 'P', "+maxPressure+", "+name+")="+Module.PropsSI('H', 'T', hMinTemp, 'P', maxPressure, name));
				return;
			}
		}
		var hMax = Math.floor(Module.PropsSI('H', 'T', maxTemp, 'P', minPressure+1000, name)/10000) * 10000;
		while (hMax == 'Infinity') {
console.log("ERROR: Module.PropsSI('H', 'T', "+maxTemp+", 'P', "+(minPressure+1000)+", "+name+")="+Module.PropsSI('H', 'T', maxTemp, 'P', (minPressure+1000), name));
			return;
		}
		ctx.strokeStyle = 'green';
		const tSatInMinP = Module.PropsSI('T', 'P', minPressure+1000, 'Q', 0, name);
		var hNextBottom = 0, hNextSat = 0, hNextTop = 0;
		const pInc = Math.round((maxPressure - minPressure)/cheight)*10;	// 

		if (showEnthalpyAndInternalEnergy) {
			var hInc = 10000;
			while ((hMax-hMin)/hInc > 50) {
				if (hInc == 10000) hInc = 20000;
				else if (hInc == 20000) hInc = 50000;
				else if (hInc == 50000) hInc = 100000;
				else if (hInc == 100000) hInc = 200000;
				else if (hInc == 200000) hInc = 500000;
				else if (hInc == 500000) hInc = 1000000;
				else {
					console.log("Too many enthalpy steps: "+((hMax-hMin)/hInc)+" > 45");
					break;
				 }
			}
	console.log("Enthalpy- lines... hInc="+(hInc/1000)+", hMin="+(hMin/1000)+", hMax="+(hMax/1000)+", pInc="+pInc );
			for (h = hMin; h <= hMax; h += hInc) {
				var isFirst = true;
				ctx.beginPath();
				for (p = minPressure+1000; p <= maxPressure; p += pInc) {
					var tSat = Module.PropsSI('T', 'P', p, 'Q', 0, name);
					t = Module.PropsSI('T', 'P', p, 'H', h, name);
					if (t > maxTemp && t != 'Infinity') {
						break;
					}
					if (isFirst && tSat != 'Infinity' && Math.abs(t-tSat)<0.001) {
						;
					}
					else if (t != 'Infinity' && (x = tToX(t)) != 'Infinity' && t >= minTemp) {
						if (isFirst) {
							const hText = 'h='+ (h/1000)+ ' J/g';
							const textWidth = ctx.measureText(hText).width;
							if ((p == minPressure && x >= hNextBottom) || (p > minPressure && tSat != 'Infinity' && (x-textWidth) > hNextSat)) {
								if (p == minPressure) {
									if (t < maxTemp && h > hMin) {
										textOnWhite(ctx,hText, x+1, pToY(p));
										hNextBottom = x + textWidth;
									}
								}
								else {
	//console.log("h="+h+", hNextSat="+hNextSat+", hText="+hText+", x="+(x-textWidth)+", y="+(pToY(p))+", t="+t+", p="+p+", tSat="+tSat);
									if (h > hMin) {
										textOnWhite(ctx,hText, x-textWidth, pToY(p));
									}
									hNextSat = x;
								}
							}
							ctx.moveTo( x, pToY(p));
							isFirst = false;
						}
						else {
							optimzedLineTo(ctx, x, pToY(p));
						}
					}
					else if (!isFirst && (t == 'Infinity' ||  x == 'Infinity')) {
						break;
					}
				}
				ctx.stroke();
				x = tToX(t) ;
				{
					if (p < maxPressure) {
	//console.log("h="+h+", p="+p+", t="+t);
						textOnWhite(ctx,(h/1000)+' J/g', t != 'Infinity' && t >= (maxTemp) ? tToX(maxTemp) : tToX(t == 'Infinity' ? minTemp : t), pToY(p)+10);
					}
					else if (x != 'Infinity' && x >= hNextTop) {
						var hText = 'h='+ (h/1000)+ ' J/g';
						if (t < maxTemp && h > hMin) {
							textOnWhite(ctx,hText, x, pToY(maxPressure));
							hNextTop = x + ctx.measureText(hText).width;
						}
	//console.log("hNextTop: "+hNextTop+"="+x+" + "+ctx.measureText(hText).width+", t="+t);
					}
				}
			}
		}
		if (false) {
			ctx.beginPath();
			var d;
			ctx.lineWidth = 1;
			const dMin = Math.ceil(Module.PropsSI('D', 'T', maxTemp, 'P', minPressure, name)/10) * 10;
			const dMax = Math.floor(Module.PropsSI('D', 'T', minTemp, 'P', maxPressure, name)/10) * 10;
			ctx.strokeStyle = 'brown';
			var xNextBottom = 9999, xNextTop = 9999;
			for (d = dMin; d <= dMax; d += 10) {
				var isFirst = true;
				ctx.beginPath();
				ctx.setLineDash([5, 10]);
				for (p = minPressure+1000; p <= maxPressure-1000; p += pInc) {
					t = Module.PropsSI('T', 'P', p, 'D', d, name);
					if (t >= maxTemp) break;
					if (t != 'Infinity' && t > minTemp) {
						if (isFirst)
						{
							x = tToX(t);
							if (x <= xNextBottom) {
								var dText = d+' kg/m3';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x - ctx.measureText(dText).width;
							}
							ctx.moveTo( tToX(t), pToY(p));
							isFirst = false;
						}
						else {
							optimzedLineTo(ctx, tToX(t), pToY(p));
						}
					}
				}
				ctx.stroke();
				x = tToX(t);
				if (p < (maxPressure-1000)) {
					textOnWhite(ctx,d+' kg/m3', tToX(maxTemp)-10, pToY(p)+10);
				}
				else if (x < xNextTop) {
					var dText = d+' kg/m3';
					textOnWhite(ctx,dText, x, pToY(maxPressure)+20);
					xNextTop = x - ctx.measureText(dText).width;
				}
			}
			ctx.setLineDash([]);
		}
		var tFix = 0;
		var dMin = Math.ceil(Module.PropsSI('S', 'T', minTemp, 'P',maxPressure, name)/100)*100;
		while (dMin == 'Infinity') {
			tFix++;
			dMin = Math.ceil(Module.PropsSI('S', 'T', minTemp+tFix, 'P',maxPressure, name)/100)*100;
		}
		if (showEnthalpyAndInternalEnergy) {
			var d, sInc = 100;
			ctx.lineWidth = 1;
			const dMax = Math.floor(Module.PropsSI('S', 'T', maxTemp, 'P', minPressure+200000, name)/100)*100;
			while ((dMax-dMin)/sInc > 40) {
				if (sInc == 100) sInc = 200;
				else if (sInc == 200) sInc = 500;
				else if (sInc == 500) sInc = 1000;
				else if (sInc == 1000) sInc = 2000;
				else if (sInc == 2000) sInc = 5000;
				else if (sInc == 5000) sInc = 10000;
				else if (sInc == 10000) sInc = 20000;
				else if (sInc == 20000) sInc = 50000;
				else if (sInc == 50000) sInc = 100000;
				else {
					console.log("Too may entropy steps: "+((dMax-dMin)/sInc));
					break;
				 }
			}
console.log("sMin="+dMin+", sMax="+dMax+"(t="+maxTemp+", p="+(minPressure+200000)+"), sInc="+sInc);
			var xNextBottom = 0, xNextTop = 0;
			var minH = 100000000;
			hInc = hInc;
			var hLines = {};
			var sNum = 0;
			for (d = dMin; d <= dMax; d += sInc) {
				sNum++;
				var isFirst = true;
				ctx.beginPath();
				ctx.strokeStyle = 'purple';
				ctx.setLineDash([5, 10]);
				var prevH = -1, prevX, prevY;
				var pSat;
				for (t = minTemp+tFix; t <= maxTemp; t += tInc) {
					p = Module.PropsSI('P', 'T', t, 'S', d, name);
					if (p >= maxPressure && p != 'Infinity') break;
					if (p < 50000) continue;
					if (p != 'Infinity' && p > minPressure) {
						pSat = Module.PropsSI('P', 'T', t, 'Q', 0, name);
						if (pSat != 'Infinity' && Math.abs(p - pSat) < 0.00001) {
							//console.log("s="+d+" on sat. line: (p-pSat)="+(p - pSat));
						}
						else if (pSat != 'Infinity' && p > pSat) {
							//console.log("s="+d+", t="+t+", "+p+">"+pSat+"(pSat)");
							break;
						}
						else if (isFirst) {
							x = tToX(t);
							if (false && x >= xNextBottom) {
								var dText = (d == dMin ? 's=' : '') + (d/1000)+' J/g/K';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x + ctx.measureText(dText).width;
							}
							ctx.moveTo( prevX = tToX(t), prevY = pToY(p));
							isFirst = false;
						}
						else {
							var x = tToX(t), y = pToY(p);
							if (Math.abs((prevY-y)/(x - prevX)) > 2) {
//console.log("s="+d+", t="+t+", "+"Math.abs("+(prevY-y)+"/"+(x - prevX)+") > 2");
								break; // continue with pressure increments!
							}
							optimzedLineTo(ctx, x, y);
							const h1 = Module.PropsSI('H', 'P', p, 'S', d, name);
							const h2 = Module.PropsSI('H', 'P', p*1.001, 'S', d, name);
							const curH = Math.floor((h2-h1)*1000 / hInc);
							if (curH > prevH && (pSat === 'Infinity' || (p < pSat && (p*1.001)<pSat) || (p > pSat && (p*1.001) > pSat))) {
								if (minH > curH) minH = curH; 
								const hField = 'h'+curH;
								if (typeof hLines[hField] === 'undefined') {
									hLines[hField] = [];
								}
if (curH == 1) {
	//console.log((y-prevY)+"/"+(x - prevX)+",  (p-pSat)="+(p - pSat));
	//console.log(d+"=>"+hField+":tToX("+t+")="+x+", pToY("+p+")="+y+", (p*1.001)="+(p*1.001)+" < pSat="+pSat );
}
								hLines[hField].push(sNum+":"+Math.round(x)+';'+Math.round(y));
								prevH = curH;
							}
							prevX = x, prevY = y;
						}
					}
					else if (!isFirst && (p == 'Infinity' ||  tToY(p) == 'Infinity')) {
						console.log(p+" or "+tToY(p));
						break;
					}
				}
				if (pSat !== 'Infinity' && p > pSat) {
					p = pSat + 1;
				}
				// we must use presure steps when Internal energy line of S is going almost straight up!
//console.log("s="+d+", p="+p+", t="+t);
				for (; p <= maxPressure && p != 'Infinity'; p += pInc) {
					t = Module.PropsSI('T', 'P', p, 'S', d, name);
					if (t >= maxTemp && t != 'Infinity') break;
					if (t != 'Infinity' && t >= (minTemp+tFix)) {
						if (isFirst)
						{
							x = tToX(t);
							if (x >= xNextBottom) {
								var dText = (d == dMin ? 's=' : '') + (d/1000)+' J/g/K';
								textOnWhite(ctx,dText, x+2, pToY(p)-20);
								xNextBottom = x + ctx.measureText(dText).width;
							}
							ctx.moveTo( tToX(t), pToY(p));
							isFirst = false;
						}
						else {
							var x, y;
							optimzedLineTo(ctx, x = tToX(t), y = pToY(p));
							const h1 = Module.PropsSI('H', 'P', p, 'S', d, name);
							const h2 = Module.PropsSI('H', 'P', p*1.001, 'S', d, name);
/*var pSat = Module.PropsSI('P', 'T', t, 'Q', 0, name);
if (pSat != 'Infinity' && (p-pSat) < 3*pInc)
{
	console.log(d+"/"+p+"/"+t+":"+((h2-h1)*1000 / hInc));
}*/
							const curH = Math.floor((h2-h1)*1000 / hInc);
							if (curH > prevH) {
								if (minH > curH) minH = curH; 
								const hField = 'h'+curH;
								if (typeof hLines[hField] === 'undefined') {
									hLines[hField] = [];
								}
if (curH == 1) {
	//console.log(d+"=>"+hField+":tToX("+t+")="+x+", pToY("+p+")="+y);
}
								hLines[hField].push(sNum+":"+Math.round(x)+';'+Math.round(y));
								prevH = curH;
							}
						}
					}
					else if (!isFirst && (t == 'Infinity' ||  tToX(t) == 'Infinity')) {
						console.log("t == 'Infinity'");
						break;
					}
				}
//console.log("s="+d+", p="+p+", t="+t);
				ctx.stroke();
				
				x = tToX(t);
//console.log("t="+t+", p="+p+", x="+x+", xNextTop="+xNextTop+", s="+(d/1000));
				if (p < (maxPressure-1000)) {
					textOnWhite(ctx,(d/1000)+' J/g/K', tToX(maxTemp)-30, pToY(p)+20);
				}
				else if (t != 'Infinity' && x > xNextTop) {
					var dText = (d/1000)+' J/g/K';
					textOnWhite(ctx,dText, x, pToY(maxPressure)+20);
					xNextTop = x + ctx.measureText(dText).width;
				}
			}
		}
console.log("Saturation curve ...");
		// Saturation curve + Critical Point!!
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.setLineDash([]);
		//ctx.setLineDash([10, 0]);
		var isFirst = true;
		for (t = minTemp+tFix; t <= tCrit; t += tInc) {
			p = Module.PropsSI('P', 'T', t, 'Q', 0, name);
			if (p == 'Infinity') continue;
			else break;
		}
		for (; p <= pCrit; p += pInc) {
			t = Module.PropsSI('T', 'P', p, 'Q', 0, name);
			if (t == 'Infinity') continue;
			if (p > maxPressure) {
				ctx.strokeStyle = 'black';
				ctx.stroke();
				break;
			}
			if (p >= minPressure+1000) {
				if (isFirst) {
					ctx.moveTo( tToX(t), pToY(p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(t), pToY(p));
				}
			}
		}
		if (p <= maxPressure) {
			optimzedLineTo(ctx, tToX(tCrit), pToY(pCrit));
			ctx.strokeStyle = 'black';
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite(ctx,'C.P: '+myRound(tCrit,1)+' K,'+Math.round(pCrit/1000)+' kPa', tToX(tCrit)-100, pToY(pCrit)); //  ()
		}
		if (false && minTemp <= tTriplePoint && minPressure <= pTriplePoint) {
			ctx.beginPath();
			ctx.moveTo( tToX(tToX(tTriplePoint)), pToY(pTriplePoint));
			ctx.lineWidth = 2;
			ctx.stroke();
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite(ctx,'T.P.', tToX(tTriplePoint), pToY(pTriplePoint)-14);
			//textOnWhite(ctx,'T.P. ('+tTriplePoint+' K, '+(pTriplePoint/1000)+' kPa)', tToX(tTriplePoint), pToY(pTriplePoint)-14);
		}

		// TBD Turbin/compressor curves + reheating/cooling lines
		//var allStages = turbinStages.concat(compressorStages);
		var i, j;
		ctx.lineWidth = 1;
		ctx.beginPath();
		if (hotCycle) {
			ctx.setLineDash([10, 0]);
			ctx.beginPath();
			hotCycle[0].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'red';
			ctx.stroke();
			drawDirectionArrow( ctx, hotCycle[0], hotCycle[0].pIn*0.50, 15, false, "Gas flow in discharge "+Math.round(hotCycle[0].massFlow*1000)+" kg/s" );
			//showPointData(ctx, hotCycle[0], FIRST_ITEM, -300, -30, hotCycle[1].massFlow, hotCycle[0].massFlow );
			ctx.beginPath();
			hotCycle[1].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'green';
			ctx.stroke();
			drawDirectionArrow( ctx, hotCycle[1], hotCycle[1].pOut*0.45, 15, true, "Gas flow in charge "+Math.round(hotCycle[1].massFlow*1000)+" kg/s" );

		}
		if (coldCycle) {
			ctx.beginPath();
			ctx.setLineDash([10, 0]);
			coldCycle[0].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'red';
			ctx.stroke();
			drawDirectionArrow( ctx, coldCycle[0], maxPressure*0.40, 15, false );
			//showPointData(ctx, coldCycle[0], LAST_ITEM, 20, -40,  );
			ctx.beginPath();
			coldCycle[1].items.forEach( function(item) {
				if (isFirst) {
					ctx.moveTo( tToX(item.t), pToY(item.p));
					isFirst = false;
				}
				else {
					optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
				}
			});
			ctx.strokeStyle = 'green';
			ctx.stroke();

			drawDirectionArrow( ctx, coldCycle[1], maxPressure*0.30, 15, coldCycle[1].isForward );
			
			if (cycleData.heatPumpNetWorkIn) {
//console.log("pTransformer="+JSON.stringify(pTransformer));
				const fillStyle = ctx.fillStyle;
				/*ctx.fillStyle = 'white';
				ctx.strokeStyle = 'white';
				ctx.rect( tToX(coldCycle[2].tOut)-10, pToY(coldCycle[0].pOut+400000)-10, tToX(coldCycle[3].tOut)+10, pToY(coldCycle[0].pOut+200000)+10);
				ctx.fill(); */
				pTransformer = {};
				pTransformer.highFrom = coldCycle[2].pIn;
				pTransformer.lowFrom = coldCycle[2].pOut;
//		maxPressure = pHigh * 18 / 12.5;
				pTransformer.lowTo = maxPressure / 18 * 15;
				pTransformer.highTo = maxPressure / 18 * 17;

				ctx.fillStyle = fillStyle;
				ctx.strokeStyle = 'green';
				isFirst = true;
				coldCycle[2].items.forEach( function(item) {
					if (isFirst) {
						ctx.moveTo( tToX(item.t), pToY(item.p));
						isFirst = false;
					}
					else {
						optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
					}
				});
				isFirst = true;
				ctx.stroke();
				drawDirectionArrow( ctx, coldCycle[2], (coldCycle[2].pIn+coldCycle[2].pOut)/2, 15, false );
				var i1, i2, i3, i4;
				i1 = showPointData(ctx, coldCycle[2], LAST_ITEM, -40, 20 );
				i2 = showPointData(ctx, coldCycle[2], FIRST_ITEM, 15, -15, coldCycle[3].massFlow );
				ctx.beginPath();
				coldCycle[3].items.forEach( function(item) {
					if (isFirst) {
						ctx.moveTo( tToX(item.t), pToY(item.p));
						isFirst = false;
					}
					else {
						optimzedLineTo(ctx, tToX(item.t), pToY(item.p));
					}
				});
				ctx.stroke();
				drawDirectionArrow( ctx, coldCycle[3], (coldCycle[3].pIn+coldCycle[3].pOut)/2, 15, false );
				i3 = showPointData(ctx, coldCycle[3], FIRST_ITEM, 15, 5 );
				i4 = showPointData(ctx, coldCycle[3], LAST_ITEM, 15, 5 );

				ctx.setLineDash([10, 10]);
				ctx.beginPath();
				ctx.moveTo( tToX(i1.t), pToY(i1.p));
				ctx.lineTo( tToX(i4.t), pToY(i4.p));
				ctx.stroke();
				ctx.beginPath();
				ctx.moveTo( tToX(i2.t), pToY(i2.p));
				ctx.lineTo( tToX(i3.t), pToY(i3.p));
				ctx.stroke();
				pTransformer = {};
			}
		}
		if (hotCycle && coldCycle) {
			ctx.beginPath();
			ctx.lineWidth = 1;
			var y, x1, x2;
			ctx.strokeStyle = 'red';
			var item = coldCycle[0].items[coldCycle[0].items.length-1];
console.log("item="+JSON.stringify(item));
			ctx.moveTo( tToX(item.t), pToY(item.p));
			drawPressureDropFromOutToIn( ctx, item.p, hotCycle[0].pIn, item.t, hotCycle[0].massFlow, cycleData.mainHeatExchanger )
			ctx.lineTo( tToX(hotCycle[0].tIn), pToY(hotCycle[0].pIn));
			ctx.lineDashOffset = 0;
			ctx.setLineDash([4, 4]);
			ctx.stroke();

			ctx.strokeStyle = 'green';
			ctx.beginPath();
			var item = hotCycle[1].items[0];
			//ctx.moveTo( tToX(hotCycle[1].tOut), pToY(hotCycle[1].pOut));
			ctx.moveTo( tToX(item.t), pToY(item.p));
			drawPressureDropFromOutToIn( ctx, hotCycle[1].pOut, coldCycle[1].pIn, item.t, hotCycle[1].massFlow, cycleData.mainHeatExchanger  )
			ctx.lineTo( tToX(coldCycle[1].tIn), pToY(coldCycle[1].pIn) );
			ctx.lineDashOffset = 5;
			ctx.setLineDash([4, 4]);
			ctx.stroke();
			
			ctx.strokeStyle = 'red';
			ctx.beginPath();
			ctx.moveTo( tToX(hotCycle[0].tOut), pToY(hotCycle[0].pOut));
			drawPressureDropFromOutToIn( ctx, hotCycle[0].pOut, coldCycle[0].pIn, hotCycle[0].tOut, hotCycle[0].massFlow, cycleData.mainHeatExchanger  )
			ctx.lineTo( tToX(coldCycle[0].tIn), pToY(coldCycle[0].pIn));
			ctx.lineDashOffset = 0;
			ctx.setLineDash([10, 10]);
			ctx.stroke();

			ctx.strokeStyle = 'green';
			ctx.beginPath();
			ctx.moveTo(tToX(hotCycle[1].tIn), pToY(hotCycle[1].pIn));
			drawPressureDropFromOutToIn( ctx, hotCycle[1].pIn, coldCycle[1].pOut, hotCycle[1].tIn, hotCycle[1].massFlow, cycleData.mainHeatExchanger )
			ctx.lineTo(tToX(coldCycle[1].tOut), pToY(coldCycle[1].pOut));
			ctx.setLineDash([10, 10]);
			ctx.lineDashOffset = 10;
			ctx.stroke();

			ctx.setLineDash([]);


			if (metrics.topFillWithIceWithStorage) {
				const mainHE = cycleData.mainHeatExchanger;
				item = coldCycle[0].items[coldCycle[0].items.length-1];
				ctx.lineWidth = 2;
				ctx.strokeStyle = 'black';
				ctx.beginPath();
				ctx.moveTo(tToX(mainHE.tCold)+5, pToY(item.p)+40);
				ctx.lineTo(tToX(mainHE.tCold)+5, pToY(item.p)-2);
				ctx.lineTo(tToX(mainHE.tHot), pToY(item.p)-2);
				ctx.lineTo(tToX(mainHE.tHot), pToY(item.p)+40);
				ctx.stroke();
				ctx.font = "14px serif";
				textOnWhite( ctx, "High pressure side of the main heat exchanger", tToX(mainHE.tCold)+20, pToY(item.p)+22);
				textOnWhite( ctx, "Hot storage", tToX(mainHE.tHot)+40, pToY(item.p)+20);

				ctx.moveTo(tToX(mainHE.tCold)+5, pToY(coldCycle[0].pIn)-40);
				ctx.lineTo(tToX(mainHE.tCold)+5, pToY(coldCycle[0].pIn)+2);
				ctx.lineTo(tToX(mainHE.tHot), pToY(coldCycle[0].pIn)+2);
				ctx.lineTo(tToX(mainHE.tHot), pToY(coldCycle[0].pIn)-40);
				ctx.stroke();
				textOnWhite( ctx, "Low pressure side of the main heat exchanger", tToX(mainHE.tCold)+20, pToY(coldCycle[0].pIn)-20);
				textOnWhite( ctx, "Ice storage", tToX(coldCycle[0].tIn)+2, pToY(coldCycle[0].pIn)+20);
			}

			showPointData(ctx, hotCycle[0], FIRST_ITEM, -350, 45, hotCycle[0].massFlow);
			showPointData(ctx, hotCycle[1], FIRST_ITEM, -350, -35, hotCycle[1].massFlow);
			showPointData(ctx, hotCycle[0], LAST_ITEM, 10, 10, hotCycle[0].massFlow );
			showPointData(ctx, hotCycle[1], LAST_ITEM, 16, -16, hotCycle[1].massFlow );

			showPointData(ctx, coldCycle[0], FIRST_ITEM, 25, 75, coldCycle[0].massFlow );
			showPointData(ctx, coldCycle[1], FIRST_ITEM, -15, -25, coldCycle[1].massFlow  );
			const item0 = coldCycle[0].items[0];
			showPointData(ctx, coldCycle[1], LAST_ITEM, 40, -40, coldCycle[1].massFlow, coldCycle[0].massFlow, item0.p, item0.t, item0.wetness );
			

			const powerAndHeat = metrics.powerAndHeat ? metrics.powerAndHeat : !getBooleanParam('powerOnly', false );

			ctx.font = "15px serif";
			x = width/5-25;
			y = height/2.5;
			ctx.fillStyle = 'black'; 
			textOnWhite( ctx, "Energy storage charge/discharge power for "+name+" gas flow "+Math.round(hotCycle[1].massFlow*1000)+"/"+Math.round(hotCycle[0].massFlow*1000)+" kg/s and turbin/compressor stage efficiency "+getFloatParam('tEfficiency', 0.90)+"/"+getFloatParam('cEfficiency', 0.90), x, y );
			y += 20;
			var title = "Metrics of "+Math.round(metrics.totalMiningVolume*metrics.rockDensity/1000000)+" million crushed stone ton "+Math.round(cycleData.storedEnergy_kWh/1000000)+" GWh energy storage";
			
			const ucGeneratorLoss=(hotCycle[0].workProduced-coldCycle[0].workConsumed)*(1-metrics.generatorEfficiency);

//District heating power "+Math.round(hotCycle[1].tIn)+" K - "+Math.round(hotCycle[0].tOut)+" K: 
 			const cryogenicCooling = true;// getBooleanParam('cryogenicCooling');
			const adjustedCompressorPlow = getBooleanParam('adjustedCompressorPlow');
			ctx.fillStyle = 'red'; 
			textOnWhite( ctx, "Discharge power: Turbin output "+Math.round(hotCycle[0].workProduced/1000)+" MW - cold gas compression "
				+Math.round(coldCycle[0].workConsumed/1000)+" MW"+
				" - generator loss "+Math.round(ucGeneratorLoss/1000)+" MW = "+Math.round(cycleData.netWorkOut/1000)+ " MW"+(powerAndHeat ? " and "
				+Math.round(cycleData.heatOutInDischarge/1000)+" MW heat ("+Math.round(hotCycle[0].tOut)+"=>"+Math.round(hotCycle[1].tIn)+" K)" : ""), x, y );
			y += 20;
			// For the case when the efficiency is >=1
			const hotWorkConsumed = hotCycle[1].workConsumed ? hotCycle[1].workConsumed : hotCycle[1].workProduced;
			const cGeneratorLoss= (hotWorkConsumed-coldCycle[1].workProduced)*(1/metrics.generatorEfficiency-1); // + (cryogenicCooling ? cycleData.heatPumpNetWorkIn : 0);
			/*const totalWork = 
				cycleData.heatPumpNetWorkIn ? 
					hotCycle[0].workProduced + hotWorkConsumed + coldCycle[1].workProduced + coldCycle[0].workConsumed + cycleData.heatPumpNetWorkIn
					: hotCycle[0].workProduced + hotWorkConsumed + coldCycle[1].workProduced + coldCycle[0].workConsumed;*/
			ctx.fillStyle = 'green'; 
			textOnWhite( ctx, "Charge power: Compressor work "+Math.round(hotWorkConsumed/1000)+" MW"+(cycleData.heatPumpNetWorkIn ? " + heat net pump work "+Math.round(cycleData.heatPumpNetWorkIn/1000)+" MW" : "")+" - cold gas expander "+Math.round((coldCycle[1].workProduced)/1000)+" MW"+
						" + motor loss "+Math.round(cGeneratorLoss/1000)+" MW = "+Math.round(cycleData.netWorkIn/1000)+" MW", x, y );
			y += 20;
			if (cycleData.heatPumpNetWorkIn) {
				textOnWhite( ctx, "Heat pump: Work consumed "+Math.round(cycleData.heatPumpNetWorkIn/1000)+
							" MW, Heat produced "+Math.round(cycleData.heatPumpHeating/1000)+" MW ("+Math.round(coldCycle[3].tOut)+"=>"+(Math.round(coldCycle[3].tIn+metrics.heatExchangeDeltaT))+" K), Cooling "+Math.round(cycleData.heatPumpCooling/1000)+" MW"+
							", Internal heat exchange "+Math.round(cycleData.heatPumpHeatExchange/1000)+" MW", x, y );
				y += 20;
			}
			ctx.fillStyle = 'black';
			const workIn = cycleData.netWorkIn; //  + cycleData.heatPumpNetWorkIn;
			const gearLoss = cycleData.compressorMassFlow1000*cycleData.gearLoss1000 * 100 / workIn;
			const generatorLoss = cycleData.compressorMassFlow1000*cycleData.generatorLoss1000 * 100 / workIn;
			const heatPumpLoss = cycleData.heatPumpLoss * 100 / workIn;

			if (powerAndHeat) {
				//const totalLoss = (cycleData.totalLoss1000 - cycleData.heatPumpHeating1000) * 100 / cycleData.workConsumed1000;
				const lostInProcess = 100 - 100*cycleData.efficiency - cycleData.distictHeatPercent - gearLoss - generatorLoss - heatPumpLoss;
				//const heatPumpLoss = (cycleData.heatPumpFrequencyConverterLoss1000) * 100 / cycleData.workConsumed1000;
				textOnWhite( ctx, "=> Electric power round trip efficiency "+myRound(100*cycleData.efficiency+(hotCycle[0].tOut>550 ? 0.35 : 0)*cycleData.distictHeatPercent,1)+" %", x, y );
				y += 20;
				textOnWhite( ctx, "   Lost in heat pump: "+myRound(heatPumpLoss,1)+" %"+(gearLoss ? (", gears: "+myRound(gearLoss,1)+" %"):"")+", motor-generators: "+myRound(generatorLoss,1)+" %, "+
						(hotCycle[0].tOut > 550 ? 
						("steam turbin: "+myRound(0.65*cycleData.distictHeatPercent,1)) : 
						("extra heat " +myRound(cycleData.distictHeatPercent,1)))+" %"+ (lostInProcess >= 0.05 ? (", elsewhere: "+myRound(lostInProcess,1)+" %") : ""), x, y );
			}
			else {
				//const totalLoss = cycleData.totalLoss1000 * 100 / cycleData.workConsumed1000;
				//const heatPumpLoss = (cycleData.heatPumpHeating1000 + cycleData.heatPumpFrequencyConverterLoss1000) * 100 / cycleData.workConsumed1000;
				const lostInProcess = 100 - 100*cycleData.efficiency - gearLoss - generatorLoss - heatPumpLoss;
				textOnWhite( ctx, "=> Electric power round trip efficiency "+myRound(100*cycleData.efficiency,1)+" %", x, y );
				y += 20;
				textOnWhite( ctx, "   Lost in heat pump "+myRound(heatPumpLoss,1)+" %"+(gearLoss ? (", gears: "+myRound(gearLoss,1)+" %"):"")+", motor-generators: "+myRound(generatorLoss,1)+
							" %"+ (lostInProcess >= 0.05  ? (", elsewhere: "+myRound(lostInProcess,1)+" %") : ""), x, y );
			}
			if (false && Math.abs(netWorkOut - cycleData.totalWork)>100) {
				y += 20;
				textOnWhite( ctx, "Discharge power % of all motor/generator power: "
					+Math.round(100*netWorkOut/cycleData.totalWork)+" % ("+Math.round(netWorkOut/1000)+" MW/ "+Math.round(cycleData.totalWork/1000)+" MW)", x, y );
			}
			y += 20;
			textOnWhite( ctx, "Stored electricity "+Math.round(cycleData.storedElectricity_kWh/1000000)+" GWh"+
				(powerAndHeat && !metrics.topFillWithIceWithStorage ? " and stored district heat "+Math.round(cycleData.storedDistrictHeat_kWh/1000000)+" GWh" : "")+
						", heat leak: <"+Math.round(getTotalHeatLost()/1000000)+" MW", x, y );
			y += 20;
			textOnWhite( ctx, "Cost of storage "+myRound(cycleData.costOfStoragekWh,2)+" €/kWh and cost of electric power capasity "+Math.round(cycleData.costOfPowerKW)+" €/kW", x, y );
			y += 20;
			textOnWhite( ctx, "Total cost "+Math.round((cycleData.costOfStorage+cycleData.costOfPower+cycleData.costOfPlant)/1000000)+" million Eur (storage: "+Math.round(cycleData.costOfStorage/1000000)+", power plant and generators: "+Math.round(cycleData.costOfPlant/1000000)+", turbomachinery: "+Math.round(cycleData.costOfPower/1000000)+")", x, y );
			y += 20;
			if (metrics.topFillWithIceWithStorage) {
				textOnWhite( ctx, "Hot storage size "+myRound(metrics.totalMiningVolume*metrics.rockDensity/1000000,1)
							 +" Mt crushed stone, cold storage size "+myRound(cycleData.iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice", x, y );
			}
			else if (metrics.externalIceStorage) {
				textOnWhite( ctx, "Storage size "+myRound((metrics.totalMiningVolume+cycleData.iceStorage.earthWorkVolume)*metrics.rockDensity/1000000,1)+" Mt crushed stone and "+myRound(cycleData.iceStorage.totalMassInTons/1000000,1)+" Mt crushed ice", x, y );
			}
			else {
				textOnWhite( ctx, "Storage size "+myRound(metrics.totalMiningVolume*metrics.rockDensity/1000000,1)+" Mt crushed stone", x, y );
			}
		}
	
		// draw temp and temp lines, 
		// some max-min temps values: 0.1 Hydrogen: 30, Nitrogen: 65, Methane: 120, CarbonDioxide: 200, Water: 340
		// some max-min pressure values: Hydrogen(0.3): 350 kPa, Nitrogen: 600 kPa,  Methane: 2000 kPa, CarbonDioxide: 4000 kPa, Water: 2000 kPa

		$("#"+canvasId).css('display','block');
		//$("#drawTurbin").css('display','block');
		$("#output").html("");
		ctx.setLineDash([]);

		$("#compressorDesignParams").css('display','block');
		if (name != 'TEST_Helium' && drawCompressors) {
			//if (redrawTpGraf) throw new Error("We should not be here!!!");
			var cUnits = getIntParam('cHotUnits2', metrics.cUnits);

			var rel = Math.sqrt(metrics.cUnits/cUnits);
			const hotCompressor = 
				getCompressorStages(hotCycle[1], LAST_ITEM, hotCycle[1].massFlow/cUnits, "Hot compressor", metrics.chargePDrops.diameterPipeToHotCompressor*rel, 
								metrics.chargePDrops.diameterPipeFromHotCompressor*rel, metrics.cEfficiency, (hotCycle[1].workConsumed*1000)/cUnits, cUnits);
			drawCompressor( "hotCompressorImage", hotCompressor, 125 );  // 1 m == 100 px

			cUnits = getIntParam('cColdUnits2', metrics.cUnits);
			rel = Math.sqrt(metrics.cUnits/cUnits);
			const coldCompressor = 
				getCompressorStages(coldCycle[0], FIRST_ITEM, coldCycle[0].massFlow/cUnits, "Cold compressor", metrics.dischargePDrops.diameterPipeToColdCompressor*rel, 
					metrics.dischargePDrops.diameterPipeFromColdCompressor*rel, metrics.cLowEfficiency, (coldCycle[0].workConsumed*1000)/cUnits, cUnits);//, true
			drawCompressor( "coldCompressorImage", coldCompressor, 150 );  // 1 m == 150 px

			cUnits = getIntParam('cHotTurbinUnits2', metrics.cUnits);
			rel = Math.sqrt(metrics.cUnits/cUnits);
			const hotTurbin = 
				getTurbinStages(hotCycle[0], FIRST_ITEM, hotCycle[0].massFlow/cUnits, "Hot turbin", metrics.dischargePDrops.diameterPipeToHotTurbin*rel, 
								metrics.dischargePDrops.diameterPipeFromHotTurbin*rel, metrics.tEfficiency, (hotCycle[0].workProduced*1000)/cUnits, cUnits);
			drawCompressor( "hotTurbinImage", hotTurbin, 150 );  // 1 m == 100 px

			cUnits = getIntParam('cColdTurbinUnits2', metrics.cUnits);
			rel = Math.sqrt(metrics.cUnits/cUnits);
			const coldTurbin = 
				getTurbinStages(coldCycle[1], LAST_ITEM, coldCycle[1].massFlow/cUnits, "Cold turbin", metrics.chargePDrops.diameterPipeToColdExpander*rel, 
					metrics.chargePDrops.diameterPipeFromColdExpander*rel, metrics.tLowEfficiency, (coldCycle[1].workProduced*1000)/cUnits, cUnits);//, true
			drawCompressor( "coldTurbinImage", coldTurbin, 225 );  // 1 m == 150 px

			cUnits = getIntParam('cHpUnits2', metrics.cUnits);
			const hpCompressor1 = cycleData.heatPumpCompressorOne;
			const hpCompressor2 = cycleData.heatPumpCompressorTwo;
			const hpTurbin = coldCycle[2];
			const orgFluid = name;
//console.log("hpCompressor1="+JSON.stringify(cycleData.heatPumpCompressorOne));
//console.log("hpCompressor2="+JSON.stringify(cycleData.heatPumpCompressorTwo));

			const ccEfficiency = getFloatParam('cHeatPumpEfficiency', getFloatParam('cLowEfficiency', metrics.cEfficiency));
			name = getInputParam('hpFluid', 'Argon' );
			const tIn_PLow = Module.PropsSI('T', 'P', hpTurbin.pOut, 
					'H', Module.PropsSI('H', 'P', hpTurbin.pOut, 'T', hpTurbin.tOut, name)+coldCycle[1].massFlow*(coldCycle[0].hOut-coldCycle[1].hIn)/hpTurbin.massFlow, name);
			gHeatExchangers.internal = calcHeatExchanger( hpCompressor1.massFlow*1000/cUnits, hpCompressor1.tIn, tIn_PLow, cycleData.heatPumpCompressorTwo.pOut, hpTurbin.pIn, 0.005,
						{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : name, hpCrossArea : 0.45 }, 'Internal '+name+" to "+name+" counter flow plate heat exchanger");
			gHeatExchangers.cooler = calcHeatExchanger( coldCycle[1].massFlow*1000/cUnits, coldCycle[0].tOut, coldCycle[1].tIn, coldCycle[2].pOut, coldCycle[1].pIn, 0.005,
							{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, 
							 pLowFluid : orgFluid, pHighFluid : name, tHotHigh : tIn_PLow, tColdHigh : hpTurbin.tOut}, orgFluid+' to '+name+' counter flow plate heat exchanger');
			gHeatExchangers.heater1 = calcHeatExchanger( hpCompressor1.massFlow*1000/cUnits, hpCompressor1.tOut, hpCompressor2.tIn, 120000, hpCompressor1.pOut, 0.001,
							{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : 'Water', hpCrossArea : 0.45}, name+' to water counter flow plate heat exchanger 1');
			gHeatExchangers.heater2 = calcHeatExchanger( hpCompressor2.massFlow*1000/cUnits, hpCompressor2.tOut, metrics.coolingWaterTemp+metrics.heatExchangeDeltaT, 120000, hpCompressor2.pOut, 0.001,
							{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : 'Water', hpCrossArea : 0.45}, name+' to water counter flow plate heat exchanger 2');
			cycleData.hpDiameterIn = Math.sqrt(gHeatExchangers.internal.totalCrossAreaM2/Math.PI)*2;
			cycleData.hpDiameterOut = Math.sqrt(gHeatExchangers.heater2.totalCrossAreaM2/Math.PI)*2;
			cycleData.hpTurbinDiameterIn = Math.sqrt(gHeatExchangers.internal.totalCrossAreaM2/Math.PI)*2;
			cycleData.hpTurbinDiameterOut = Math.sqrt(gHeatExchangers.cooler.totalCrossAreaM2/Math.PI)*2;
			cycleData.heVolumeM3 = cUnits*(gHeatExchangers.internal.volumeM3 + gHeatExchangers.cooler.volumeM3 + gHeatExchangers.heater1.volumeM3 + gHeatExchangers.heater2.volumeM3);
			cycleData.heCost = cUnits*(gHeatExchangers.internal.cost + gHeatExchangers.cooler.cost + gHeatExchangers.heater1.cost + gHeatExchangers.heater2.cost);
			gCycleData = cycleData;
			const hpOne = drawHpCompressor( true, 225 );
			const hpTwo = drawHpCompressor( false, 225 );
			const averageEfficiency = (hpOne.averageEfficiency + hpTwo.averageEfficiency)/2;

			name = orgFluid;
			const updateCompressorEfficiencies = document.getElementById('updateCompressorEfficiencies').checked;
			const updateTurbinEfficiencies = document.getElementById('updateTurbinEfficiencies').checked;

			if ($("#cHeatPumpEfficiency").val() != myRound(averageEfficiency,3)) {
console.log("Efficiency mismatch: "+$("#cHeatPumpEfficiency").val()+" != "+averageEfficiency);
if (typeof hpOne.averageEfficiency === 'undefined') console.log("Hp compressor 1:"+JSON.stringify(hpOne));
else if (typeof hpTwo.averageEfficiency === 'undefined') console.log("Hp compressor 2:"+JSON.stringify(hpTwo));
				if (updateCompressorEfficiencies) {
					$("#cHeatPumpEfficiency").val(myRound(averageEfficiency,3));
					redrawTpGraf = true;
				}
			}
			if (redrawTpGraf) {
				redrawTpGraf = false;
				drawIt(true, false, false);
			}
			drawHpTurbin( 225 );
		}

//console.log(JSON.stringify(compressorStages[0].items));
console.log("drawBraytonCycle done");
		if (false && increaseLowPressure) {
			alert("Fluid is partially saturated or frozed in the inlet.  The result is not realiable. Please decrease the pressure ratio or increase the low pressure");
		}
	}
	var redrawTpGraf = false;
	var hotCycleG, coldCycleG;
	var heatPumpMassFlow;
	var gCycleData;
	var gHeatExchangers = {};
	var gIsHpCompressorOne = true;


	function changeHeatPumpPressure(orgFluid, showLog)
	{
		const ctEfficiency = getFloatParam('tHeatPumpEfficiency', getFloatParam('tLowEfficiency', metrics.tEfficiency));
		const ccEfficiency = getFloatParam('cHeatPumpEfficiency', getFloatParam('cLowEfficiency', metrics.cEfficiency));
		const coldCycle = coldCycleG;
		const cycleData = gCycleData;
		const cUnits = getIntParam('cHpUnits2', metrics.cUnits);


		// coldHeatExchangerLoss is the round trip lost when gas flows twice through main heat exhanger, metrics.heatExchangeDeltaT is temp diff in heat pump heat exchanger
		metrics.heatPumpHighP = getFloatParam('hpHighPressureKPa', 300)*1000;
		const hpFluid = getInputParam('hpFluid', 'Argon' );
		const hpTurbin = doAdiabaticProcessWithS( hpFluid, metrics.heatPumpHighP, metrics.heatPumpHighP/10, coldCycle[0].tOut, // +coldHeatExchangerLoss, 
												  ctEfficiency, showLog ? "Heat pump turbin" : null, null, coldCycle[1].tIn-metrics.heatExchangeDeltaT );
		coldCycle[2] = hpTurbin // -2 to heat exchanger smaller
		// Heat exchange coldExpander.tOut-2 <=> 
		var heatPumpPin = coldCycle[2].pOut*(1-metrics.heatExchangePressureLoss)*(1-metrics.heatExchangePressureLoss);
		{
			// split 
			const pRelSplit = Math.sqrt(metrics.heatPumpHighP/heatPumpPin);
			const pCool = heatPumpPin*pRelSplit;
			const splitOne = doAdiabaticProcessWithS( hpFluid, heatPumpPin, pCool*(1+metrics.heatExchangePressureLoss), metrics.coolingWaterTemp, ccEfficiency, null );
			const splitTwo = doAdiabaticProcessWithS( hpFluid, pCool, metrics.heatPumpHighP*(1+metrics.heatExchangePressureLoss)*(1+metrics.heatExchangePressureLoss), metrics.coolingWaterTemp, ccEfficiency, null );
			splitOne.pRelSplit = pRelSplit;
			coldCycle[3] = addCycleDataI( hpFluid, splitOne, splitTwo, showLog ? "Heat pump compressor" : null  );
			cycleData.heatPumpCompressorOne = splitOne;
			cycleData.heatPumpCompressorTwo = splitTwo;
		}
		const hAfterCooling = Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[0].tOut-metrics.heatExchangeDeltaT, hpFluid);
		const hAfterHeating = Module.PropsSI('H', 'P', coldCycle[3].pOut, 'T', metrics.coolingWaterTemp+metrics.heatExchangeDeltaT, hpFluid);
		console.log("hAfterHeating="+hAfterHeating+" (t:"+(metrics.coolingWaterTemp+heatExchangeDeltaT)+", p:"+coldCycle[3].pOut+"), hpFluid="+hpFluid);
		const cooling = (coldCycle[0].hOut - coldCycle[1].hIn) * coldCycle[1].massFlow;	// We must use the charge massFlow !!!
		cycleData.cooling = cooling;
		const hpFluidDeltaH = Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[0].tOut-metrics.heatExchangeDeltaT, hpFluid) - 
							  Module.PropsSI('H', 'P', coldCycle[2].pOut, 'T', coldCycle[1].tIn-metrics.heatExchangeDeltaT, hpFluid);
		console.log(cooling+" = "+coldCycle[0].hOut+" * "+coldCycle[0].massFlow+" - "+coldCycle[1].hIn+" * "+coldCycle[1].massFlow);
		console.log("hAfterCooling="+hAfterCooling+" ("+(coldCycle[0].tOut-metrics.heatExchangeDeltaT)+" K,"+coldCycle[2].pOut+")");
/*
		console.log("coldCycle[3].hIn="+coldCycle[3].hIn+" ("+coldCycle[3].tIn+","+coldCycle[3].pIn+")");
		console.log("=="+(coldCycle[3].hIn-hAfterCooling));
		console.log("- coldCycle[2].hIn="+coldCycle[2].hIn+" ("+coldCycle[2].tIn+","+coldCycle[2].pIn+")");
		console.log("=="+(hAfterHeating - coldCycle[2].hIn));*/
		cycleData.internalExtraCooling = (hAfterHeating - coldCycle[2].hIn) - (coldCycle[3].hIn-hAfterCooling);
		//console.log("cycleData.internalExtraCooling:"+cycleData.internalExtraCooling+" = ("+hAfterHeating+" - "+coldCycle[2].hIn+") - ("+coldCycle[3].hIn+"-"+hAfterCooling);
		coldCycle[2].massFlow = coldCycle[3].massFlow = cooling/(hpFluidDeltaH-cycleData.internalExtraCooling); // enthaply change is the same 
		console.log("Heat pump massFlow:"+coldCycle[3].massFlow+"="+cooling+"/("+hpFluidDeltaH+" - "+cycleData.internalExtraCooling+")"); //+"hAfterCooling+" - "+coldCycle[2].hOut+" - "+cycleData.internalExtraCooling+")");
		cycleData.heatPumpCompressorOne.massFlow = cycleData.heatPumpCompressorTwo.massFlow = coldCycle[2].massFlow;
		cycleData.heatPumpNetWorkIn = (coldCycle[3].workConsumed-coldCycle[2].workProduced) * coldCycle[2].massFlow; //metrics.frequencyConverterEfficiency;
		cycleData.heatPumpFrequencyConverterLoss1000 = cycleData.heatPumpNetWorkIn1000 * 0; //(1-metrics.frequencyConverterEfficiency);
		cycleData.heatPumpHeating = (cycleData.heatPumpCompressorOne.hOut - cycleData.heatPumpCompressorTwo.hIn + cycleData.heatPumpCompressorTwo.hOut - hAfterHeating) * coldCycle[2].massFlow;
		cycleData.heatPumpCooling = cooling;
		cycleData.heatPumpHeatExchange = (hAfterHeating - coldCycle[2].hIn) * coldCycle[2].massFlow;
		cycleData.heatPumpLoss = cycleData.heatPumpNetWorkIn + cycleData.heatPumpCooling; // cycleData.heatPumpHeating
		cycleData.heatPumpNetWorkIn1000 = cycleData.heatPumpNetWorkIn / coldCycle[2].massFlow;
		cycleData.heatPumpHeating1000 = cycleData.heatPumpHeating / coldCycle[2].massFlow;
		console.log("*****cycleData.heatPumpNetWorkIn1000="+cycleData.heatPumpNetWorkIn1000+"= "+cycleData.heatPumpNetWorkIn+" / "+coldCycle[2].massFlow+", workConsumed="+coldCycle[3].workConsumed+", workProduced="+coldCycle[2].workProduced);

		const hpCompressor1 = cycleData.heatPumpCompressorOne;
		const hpCompressor2 = cycleData.heatPumpCompressorTwo;
		const tIn_PLow = Module.PropsSI('T', 'P', hpTurbin.pOut, 
				'H', Module.PropsSI('H', 'P', hpTurbin.pOut, 'T', hpTurbin.tOut, name)+coldCycle[1].massFlow*(coldCycle[0].hOut-coldCycle[1].hIn)/hpTurbin.massFlow, name);
		gHeatExchangers.internal = calcHeatExchanger( hpCompressor1.massFlow*1000/cUnits, hpCompressor1.tIn, tIn_PLow, cycleData.heatPumpCompressorTwo.pOut, hpTurbin.pIn, 0.005,
					{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : name, hpCrossArea : 0.45 }, 'Internal '+name+" to "+name+" counter flow plate heat exchanger");
		gHeatExchangers.cooler = calcHeatExchanger( coldCycle[1].massFlow*1000/cUnits, coldCycle[0].tOut, coldCycle[1].tIn, coldCycle[2].pOut, coldCycle[1].pIn, 0.005,
						{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, 
						 pLowFluid : orgFluid, pHighFluid : name, tHotHigh : tIn_PLow, tColdHigh : hpTurbin.tOut}, orgFluid+' to '+name+' counter flow plate heat exchanger');
		gHeatExchangers.heater1 = calcHeatExchanger( hpCompressor1.massFlow*1000/cUnits, hpCompressor1.tOut, hpCompressor2.tIn, 120000, hpCompressor1.pOut, 0.001,
						{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : 'Water', hpCrossArea : 0.45}, name+' to water counter flow plate heat exchanger 1');
		gHeatExchangers.heater2 = calcHeatExchanger( hpCompressor2.massFlow*1000/cUnits, hpCompressor2.tOut, metrics.coolingWaterTemp+metrics.heatExchangeDeltaT, 120000, hpCompressor2.pOut, 0.001,
						{sheetThickness : 0.00005, sheetDistance :0.001, heatExchangeDeltaT: metrics.heatExchangeDeltaT, pLowFluid : name, pHighFluid : 'Water', hpCrossArea : 0.45}, name+' to water counter flow plate heat exchanger 2');
		cycleData.heVolumeM3 = cUnits*(gHeatExchangers.internal.volumeM3 + gHeatExchangers.cooler.volumeM3 + gHeatExchangers.heater1.volumeM3 + gHeatExchangers.heater2.volumeM3);
		cycleData.heCost = cUnits*(gHeatExchangers.internal.cost + gHeatExchangers.cooler.cost + gHeatExchangers.heater1.cost + gHeatExchangers.heater2.cost);
		cycleData.hpDiameterIn = Math.sqrt(gHeatExchangers.internal.totalCrossAreaM2/Math.PI)*2;
if (!cycleData.hpDiameterIn) throw new Error("Bad heat exchanger");
		cycleData.hpDiameterOut = Math.sqrt(gHeatExchangers.heater2.totalCrossAreaM2/Math.PI)*2;
		cycleData.hpTurbinDiameterIn = Math.sqrt(gHeatExchangers.internal.totalCrossAreaM2/Math.PI)*2;
		cycleData.hpTurbinDiameterOut = Math.sqrt(gHeatExchangers.cooler.totalCrossAreaM2/Math.PI)*2;
	}

	function drawHpCompressor( isOne, scale )
	{
		var updateTurbin = false;
		const orgFluid = name;
		name = getInputParam('hpFluid', 'Argon' );

		if (metrics.heatPumpHighP != getFloatParam('hpHighPressureKPa', 2117)*1000) {
console.log("Update heap pump pressure ...");
			changeHeatPumpPressure(orgFluid);
			updateTurbin = true;
		}
		gIsHpCompressorOne = isOne;
		//heatPumpMassFlow = gCycleData.heatPumpCompressorOne.massFlow;
		const hpCompressor = isOne ? gCycleData.heatPumpCompressorOne : gCycleData.heatPumpCompressorTwo;
		const ccEfficiency = getFloatParam('cHeatPumpEfficiency', getFloatParam('cLowEfficiency', metrics.cEfficiency));
		const cUnits2 = getIntParam('cHpUnits2', metrics.cUnits);
		const grossPower = (hpCompressor.workConsumed*1000)/cUnits2;
console.log("hpCompressor grossPower:"+grossPower+"=("+hpCompressor.workConsumed+"*1000)/"+cUnits2+", isOne="+isOne+", hpCompressor.massFlow="+heatPumpMassFlow);
		const hpStages = getCompressorStages(hpCompressor, FIRST_ITEM, heatPumpMassFlow/cUnits2, 
								"Heat Pump Compressor"+ (isOne ? " 1" : " 2"), 
								isOne ? Math.pow(gCycleData.hpDiameterIn,1/cUnits2) : Math.pow(gCycleData.hpDiameterOut,1/cUnits2), 
								isOne ? Math.pow(gCycleData.hpDiameterOut,1/cUnits2) : Math.pow(gCycleData.hpDiameterIn,1/cUnits2), 
								ccEfficiency, 
								grossPower, cUnits2); //, true
		drawCompressor( "hpCompressorImage"+ (isOne ? "1" : "2"), hpStages, scale ? scale : 250, isOne, gHeatExchangers );  // 1 m == 150 px
		name = orgFluid;
/*
		const curHpHighPressureKPa = getFloatParam("hpHighPressureKPa");
		const actualHighPressureKPa = Math.round((isOne ? hpStages.pOut*gCycleData.heatPumpCompressorTwo.pOut/gCycleData.heatPumpCompressorTwo.pIn : hpStages.pOut)/1000);
		if (!isOne && curHpHighPressureKPa && curHpHighPressureKPa != actualHighPressureKPa && actualHighPressureKPa) {
			$("#hpHighPressureKPa").val(actualHighPressureKPa);
			console.log("Change hpHighPressureKPa="+actualHighPressureKPa);
		}
		console.log("actualHighPressureKPa="+actualHighPressureKPa+" hpStages.pOut="+hpStages.pOut+", two p2/p1="+(gCycleData.heatPumpCompressorTwo.pOut/gCycleData.heatPumpCompressorTwo.pIn));
*/
		if (updateTurbin) {
			//drawHpTurbin( null );
		}
		return hpStages;
	}

	function drawHpTurbin( scale )
	{
		const hpTurbin = coldCycleG[2];
		const orgFluid = name;
		const ctEfficiency = getFloatParam('tHeatPumpEfficiency', getFloatParam('tLowEfficiency', metrics.tEfficiency));
		name = getInputParam('hpFluid', 'Argon' );
		const cUnits2 = getIntParam('cHpTurbinUnits2', metrics.cUnits);
		const grossPower = (hpTurbin.workProduced*1000)/cUnits2;
console.log("hpTurbin grossPower: "+grossPower+"=("+hpTurbin.workProduced+"*"+heatPumpMassFlow+"*1000)/"+cUnits2);
		const hpTurbinStages = getTurbinStages(hpTurbin, FIRST_ITEM, heatPumpMassFlow/cUnits2, 
								"Heat Pump Turbin", 
								Math.pow(gCycleData.hpTurbinDiameterIn,1/cUnits2), 
								Math.pow(gCycleData.hpTurbinDiameterOut,1/cUnits2), 
								ctEfficiency, 
								grossPower, cUnits2); //, true
		drawCompressor( "hpTurbinImage", hpTurbinStages, scale ? scale : 250 );  // 1 m == 150 px
		name = orgFluid;

		const updateTurbinEfficiencies = document.getElementById('updateTurbinEfficiencies').checked;
		const averageEfficiency = myRound(hpTurbinStages.averageEfficiency,3);
		if (averageEfficiency && averageEfficiency != $("#tHeatPumpEfficiency").val() && updateTurbinEfficiencies) {
			$("#tHeatPumpEfficiency").val(averageEfficiency);
			// There is a forever loopback because of continuous massflow adaptation
			//redrawTpGraf = true;
		}
		return hpTurbinStages;
	}

	var isRedraw = false;
	function redrawColdCompressor() { redrawCompressor('Cold') }
	function redrawHotCompressor() { redrawCompressor('Hot') }
	function redrawColdTurbin() { redrawCompressor('ColdTurbin') }
	function redrawHotTurbin() { redrawCompressor('HotTurbin') }
	function redrawHpCompressor() { redrawCompressor('Hp') }
	function redrawHpTurbin() { redrawCompressor('HpTurbin') }
	function redrawCompressor(type) {
		//if (redrawTpGraf) throw new Error("We should not be here!!!");
		if (!metrics.chargePDrops) {
			console.log("metrics="+JSON.stringify(metrics, null, 2));
		}
		isRedraw = true;
		var cUnits = getIntParam('cHotUnits2', metrics.cUnits);
		const cColdUnits = getIntParam('cColdUnits2', metrics.cUnits);
		const hpUnits = getIntParam('hpUnits2', metrics.cUnits);
		var diameterPipeToHotCompressor = metrics.chargePDrops.diameterPipeToHotCompressor;
		var diameterPipeFromHotCompressor = metrics.chargePDrops.diameterPipeFromHotCompressor;
		var diameterPipeToColdCompressor = metrics.dischargePDrops.diameterPipeToColdCompressor;
		var diameterPipeFromColdCompressor = metrics.dischargePDrops.diameterPipeFromColdCompressor;
		
		// scale the pipes!
		if (cUnits != metrics.cUnits) {
			const rel = Math.sqrt(metrics.cUnits/cUnits);
			diameterPipeToHotCompressor = metrics.chargePDrops.diameterPipeToHotCompressor*rel;
			diameterPipeFromHotCompressor = metrics.chargePDrops.diameterPipeFromHotCompressor*rel;
		}
		if (cColdUnits != metrics.cUnits) {
			const rel = Math.sqrt(metrics.cUnits/cColdUnits);
			diameterPipeToColdCompressor = metrics.dischargePDrops.diameterPipeToColdCompressor*rel;
			diameterPipeFromColdCompressor = metrics.dischargePDrops.diameterPipeFromColdCompressor*rel;
		}
		const scale = getFloatParam('compressorScale'+type, 0);
		if (type == 'Hot') {
			const compressor = getCompressorStages(hotCycleG[1], LAST_ITEM, hotCycleG[1].massFlow/cUnits, "Hot compressor", 
				diameterPipeToHotCompressor, diameterPipeFromHotCompressor, metrics.cEfficiency, (hotCycleG[1].workConsumed*1000)/cUnits, cUnits);
			drawCompressor( "hotCompressorImage", compressor, scale ? scale : 125 );  // 1 m == 125 px
		}
		else if (type == 'Cold') {
			const compressor = getCompressorStages(coldCycleG[0], FIRST_ITEM, coldCycleG[0].massFlow/cColdUnits, "Cold compressor", 
				diameterPipeToColdCompressor, diameterPipeFromColdCompressor, metrics.cLowEfficiency, (coldCycleG[0].workConsumed*1000)/cColdUnits, cColdUnits);
			drawCompressor( "coldCompressorImage", compressor, scale ? scale : 150 );  // 1 m == 150 px
		}
		else if (type == 'HotTurbin') {
			cUnits = getIntParam('cHotTurbinUnits2', metrics.cUnits);
			const rel = Math.sqrt(metrics.cUnits/cUnits);
			const hotTurbin = 
				getTurbinStages(hotCycleG[0], FIRST_ITEM, hotCycleG[0].massFlow/cUnits, "Hot turbin", metrics.dischargePDrops.diameterPipeToHotTurbin*rel, 
					metrics.dischargePDrops.diameterPipeFromHotTurbin*rel, metrics.tEfficiency, (hotCycleG[0].workProduced*1000)/cUnits, cUnits);
			drawCompressor( "hotTurbinImage", hotTurbin, scale ? scale : 150 );  // 1 m == 125 px
			redrawTpGraf = false;
		}
		else if (type == 'ColdTurbin') {
			cUnits = getIntParam('cColdTurbinUnits2', metrics.cUnits);
			rel = Math.sqrt(metrics.cUnits/cUnits);
			const coldTurbin = 
				getTurbinStages(coldCycleG[1], LAST_ITEM, coldCycleG[1].massFlow/cUnits, "Cold turbin", metrics.chargePDrops.diameterPipeToColdExpander*rel, 
					metrics.chargePDrops.diameterPipeFromColdExpander*rel, metrics.tLowEfficiency, (coldCycleG[1].workProduced*1000)/cUnits, cUnits);
			drawCompressor( "coldTurbinImage", coldTurbin, scale ? scale : 225 );  // 1 m == 150 px
			redrawTpGraf = false;
		}
		else if (type == 'HpTurbin') {
			drawHpTurbin( scale );
		}
		else {
			var isOne = true; // $('#hpCompressorOne').prop('checked');
			const hpOne = drawHpCompressor( true, scale );
			const hpTwo = drawHpCompressor( false, scale );
			const averageEfficiency = myRound((hpOne.averageEfficiency + hpTwo.averageEfficiency)/2,3);
			if ($("#cHeatPumpEfficiency").val() != averageEfficiency) {
console.log("Efficiency mismatch: "+$("#cHeatPumpEfficiency").val()+" != "+averageEfficiency);
				$("#cHeatPumpEfficiency").val(averageEfficiency);
				//$("#tHeatPumpEfficiency").val(myRound(0.97+(averageEfficiency-0.95)*3/5,3));
				// There is a forever loopback because of continuous massflow adaptation
				//redrawTpGraf = true;
			}
		}
		if (redrawTpGraf) {
			redrawTpGraf = false;
			drawIt(true, false, false);
		}
		if (false && increaseLowPressure) {
			alert("Fluid is partially saturated or frozed in the inlet.  The result is not realiable. Please decrease the pressure ratio or increase the low pressure");
		}
	}

	function drawPressureDropFromOutToIn( ctx, pFrom, pTo, t, massFlow, mainHeatExchanger )
	{
		// heat exchanger is always first, then the drop in pipe and storage
/*
		if (mainHeatExchanger) {
			const isHighP = mainHeatExchanger.pHigh <= pFrom && mainHeatExchanger.pHigh >= pTo || mainHeatExchanger.pHigh >= pFrom && mainHeatExchanger.pHigh <= pTo;
			const p = isHighP ? mainHeatExchanger.pHigh : mainHeatExchanger.pLow;
			if (t < mainHeatExchanger.tHot) {
				ctx.lineTo( tToX(mainHeatExchanger.tHot), pToY(p));
			}
			else {
			}



			ctx.setLineDash([]);
			ctx.stroke();
			ctx.beginPath();
				
				
		midHE.pDropActual = getHeatExchangerPressureDrop( midHE, massFlowKg, false );
		midHE.deltaT_Hot = getHeatExchangeDeltaT( midHE, massFlowKg, tHot );
		midHE.deltaT_Cold = getHeatExchangeDeltaT( midHE, massFlowKg, tCold );
//midHE.pDropActual = getHeatExchangerPressureDrop( midHE, massFlowKg, false );
			ctx.beginPath();
			ctx.moveTo(tToX(coldCycle[1].tOut), pToY(coldCycle[1].pOut));
			drawPressureDropFromOutToIn( ctx, coldCycle[1].pOut, hotCycle[1].pIn, coldCycle[1].tOut, hotCycle[1].massFlow )
			ctx.lineTo( tToX(hotCycle[1].tIn), pToY(hotCycle[1].pIn));
			ctx.setLineDash([10, 10]);
			ctx.lineDashOffset = 10;
			ctx.stroke();

*/
		return;
		var p = pFrom;
		if (pFrom == pTo) {
			ctx.lineTo( tToX(t), pToY(pTo));
		}
		else {
			var pStep = pFrom > pTo ? 0.96 : 1.04;
			const h = Module.PropsSI('H', 'P', pFrom, 'T', t, name);  // constant enthalpy inside pipe
			for (;;) {
				p = p * pStep;
				if (pFrom > pTo && p < pTo) p = pTo;
				else if (pFrom < pTo && p > pTo) p = pTo;
				t = Module.PropsSI('T', 'P', p, 'H', h, name);  // constant enthalpy inside pipe and storage
				ctx.lineTo( tToX(t), pToY(p));
				if (p == pTo) break;
			}
		}
		var v = {};
		v.p = p;
		v.t = t;
		return v;
	}


	var prevX = -1;
	var prevY = -1;
	function optimzedLineTo( context, x, y ) {
		if (x != prevX || y != prevY) {
			context.lineTo( prevX = x, prevY = y);
		}
	}
	function textOnWhite( ctx, text, x, y )
	{
		const textMetrics = ctx.measureText(text);
		const height = parseFloat(ctx.font);
		//console.log("textMetrics.width="+textMetrics.width+", height="+height);
		ctx.clearRect( x, y-height, textMetrics.width, height);
		ctx.fillText(text, x, y );
	}
	function drawDirectionArrow( ctx, data, pTarget, lineLen, isForward, text ) {
		const items = data.items;
		if (items.length < 10) return;
		var i = Math.floor((items.length-1)/2);
		var iBottom = 0, iPrev = -1;
		var iTop = items.length-1;
//console.log("data.isForward="+data.isForward+",  isForward="+isForward);
//stage.pIn =
		var growingP = items[1].p > items[0].p;

		while (i != iPrev && iBottom < iTop) {
			if (growingP) {
				if (items[i].p < pTarget) {
					iBottom = i;
				}
				else if (items[i].p > pTarget) {
					iTop = i;
				}
				else {
					break;
				}
			}
			else {
				if (items[i].p > pTarget) {
					iBottom = i;
				}
				else if (items[i].p < pTarget) {
					iTop = i;
				}
				else {
					break;
				}
			}
			iPrev = i;
			i = Math.floor((iBottom + iTop)/2);
		}
		const item1 = items[i];
//console.log("selected i="+i+", iBottom="+iBottom+", iTop"+iTop+", items.length="+items.length+", pTarget="+pTarget+", item.p="+item1.p);
		const item2 = items[i+(isForward ? 1 : -1)];
//console.log("items.length="+items.length); console.log(", item1="+JSON.stringify(item1)); console.log(", item2="+JSON.stringify(item2));
		const x1 = tToX(item1.t), y1 = pToY(item1.p);
		const x2 = tToX(item2.t), y2 = pToY(item2.p);
		const x = x2 - x1, y = y2 - y1;
		const r = Math.sqrt(x*x + y*y);
		const toPixels = lineLen; 
//console.log("x="+x+", y="+y+"=>r="+r+"=>toPixels="+toPixels);
		// r*r = x * x + y * y;
		var radian;  // range from 0 to 2 * Math.PI;
		if (x > 0 && y >= 0) radian = Math.atan(y/x);
		else  if (x > 0 && y < 0) radian = Math.atan(y/x) + 2 * Math.PI;
		else  if (x < 0) radian = Math.atan(y/x) + Math.PI;
		else  if (x = 0 && y > 0) radian = Math.PI / 2;
		else  if (x = 0 && y < 0) radian = -Math.PI / 2;
		ctx.beginPath();
		// Math.PI/12 == 15 degrees
		ctx.moveTo( x1 + Math.cos(radian + Math.PI/12)*toPixels, y1 + Math.sin(radian + Math.PI/12)*toPixels);
		ctx.lineTo( x1, y1);
		ctx.lineTo( x1 + Math.cos(radian - Math.PI/12)*toPixels, y1 + Math.sin(radian - Math.PI/12)*toPixels);
		ctx.lineTo( x1 + Math.cos(radian + Math.PI/12)*toPixels, y1 + Math.sin(radian + Math.PI/12)*toPixels);
		ctx.closePath();
		const fillStyle = ctx.fillStyle;
		ctx.fillStyle = ctx.strokeStyle;
		ctx.fill();
		if (text) {
			ctx.fillStyle = 'black'; 
			ctx.font = "12px serif";
			textOnWhite( ctx, text, x1+Math.abs(12*x/y), y1+6);
		}
		ctx.fillStyle = ctx.fillStyle;
	}

	function getGasFlow( type, data, isFirst, r1, r2, medianDP, porosity ) 
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		const item = data.items ? (isFirst ? data.items[data.items.length-1] : data.items[0]) : data;
		const flow = Math.round(data.massFlow * 1000/item.d)*(type == 'Hp' ? metrics.rockDensityHp/(metrics.rockDensityHp-metrics.gravelDensity) : metrics.rockDensityLp/(metrics.rockDensityLp-metrics.lpGravelDensity));

		if (typeof item.visc === 'undefined') item.visc = Module.PropsSI('V', 'P', item.p, 'H', item.h, name);
	
		var speed = Math.round(data.massFlow * 1000/item.d)/(r1*r1*Math.PI);
		var pDrop = Math.round(calcPressureDropInGravel(type, speed, item.visc, item.d, 1, item.p, item.t ));
		var pDropText = ",  \u0394P: "+pDrop;
		if (r2) {
			speed = Math.round(data.massFlow * 1000/item.d)/(r2*r2*Math.PI);
			var pDrop2 = Math.round(calcPressureDropInGravel(type, speed, item.visc, item.d, 1, item.p, item.t ));
			if (pDrop2 != pDrop) {
				pDropText = pDropText+" - "+pDrop2;
			}
		}
		pDropText += " Pa/m";
		if (medianDP && porosity) {
			// https://shop.tarjomeplus.com/UploadFileEn/TPLUS_EN_4259.pdf
			medianDP = medianDP / 1000; // mm => m
			const r = (r1+r2)/2;
			const G = data.massFlow / (r*r*Math.PI);
			const ReDp = G*medianDP / (6*(1-porosity)*item.visc);
			const NuDp = 8.74+9.34*Math.pow(6*(1-porosity), 0.2)*Math.pow(ReDp, 0.2)*Math.pow(Module.PropsSI('PRANDTL', 'P', item.p, 'H', item.h, name),1/3); 
			// NuDp = h * Dp / k => h = NuDp*k/Dp; 
			const k = Module.PropsSI('CONDUCTIVITY', 'P', item.p, 'H', item.h, name); // k=kVisc * Cp / kVisc; // thermal condutivity
			const heCofficient = NuDp * k / medianDP;
			//pDropText += ", h="+(heCofficient < 10 ? myRound(heCofficient,1) : Math.round(heCofficient)) +" W/m2/K";
//console.log("***** ReDp="+ReDp+", NuDp="+NuDp+", k="+k+", medianDP="+medianDP+" => heatTransferCoefficient="+heCofficient);
		}
		
		var speed1 = myRound(flow/(r1*r1*Math.PI),2);
		var speed2 = r2 ? myRound(flow/(r2*r2*Math.PI),2) : speed1;
		return 'gas flow: '+speed1+(speed1 && speed1!=speed2 ? ' - '+speed2 : '')+' m/s'+pDropText;
	}
	function showPointData( ctx, data, isFirst, xDiff, yDiff, massFlow, massFlow2, p1, t1, wetness1) 
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		const item = isFirst ? data.items[data.items.length-1] : data.items[0];
		const x = tToX(item.t), y = pToY(item.p);
		const lineDash = ctx.getLineDash();
		const font = ctx.font;
		const strokeStyle = ctx.strokeStyle;
		var speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'H', item.h, name);
		if (speedOfSound == Infinity) {
			speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'T', item.t+0.1, name);
		}
		const v = Module.PropsSI('V', 'P', item.p, 'H', item.h, name); // viscosity
		const d = Module.PropsSI('D', 'P', item.p, 'H', item.h, name); 
		const d1 = p1 ? Module.PropsSI('D', 'P', p1, 'H', item.h, name) : d;
		const kVisc = v / d; // kinematic viscosy
		//const prantdl = Module.PropsSI('PRANDTL', 'P', item.p, 'H', item.h, name); 
		// const Cp = Module.PropsSI('CP0MASS', 'P', item.p, 'H', item.h, name); 
		const k = Module.PropsSI('CONDUCTIVITY', 'P', item.p, 'H', item.h, name); // k=kVisc * Cp / kVisc; // thermal condutivity
		if (typeof massFlow === 'undefined') massFlow = data.massFlow;
		const text = myRound(item.t,1)+(t1 ? '/'+myRound(t1,1):'')+" K"+", "+Math.round(item.p/1000)+(p1 ? '/'+Math.round(p1/1000):'')+" kPa, h="+Math.round(item.h/1000)+" J/g, flow="+
					(massFlow2 ? Math.round(massFlow * 1000/item.d)+"/"+Math.round(massFlow2 * 1000/d1)+" m\u00B3/s, "+Math.round(massFlow*1000)+"/"+Math.round(massFlow2 * 1000)+" kg/s":
					 massFlow ? Math.round(massFlow * 1000/item.d)+" m3/s, "+Math.round(massFlow*1000)+" kg/s" : Math.round(1000/item.d)+" m\u00B3/s") 
						+", ν="+myRound(kVisc*1000000)+"μm\u00B2/s, mach:"+myRound(speedOfSound)+" m/s" // Mass specific entropy="+myRound((item.s/1000),2)+" J/g/K,
						+(item.wetness ? (', wetness='+myRound(item.wetness*100,2)+(typeof wetness1 !== 'undefined' ? '/'+myRound(wetness1*100,2):'')+'%') : '')
						+", k="+myRound(k,3)+" W/m/K";
		ctx.strokeStyle = 'black';
		ctx.setLineDash([3, 3]);
		ctx.beginPath();
		ctx.moveTo( x, y);
		const textMetrics = ctx.measureText(text);
		if (xDiff < -100) {
			ctx.lineTo( x+xDiff+textMetrics.width/2, y+yDiff+1);
		}
		else {
			ctx.lineTo( x+xDiff, y+yDiff+-5);
		}
		ctx.stroke();
		if (p1 && t1) {
			const x = tToX(t1), y = pToY(p1);
			ctx.beginPath();
			ctx.moveTo( x, y);
			if (xDiff < -100) {
				ctx.lineTo( x+xDiff+textMetrics.width/2+10, y+yDiff+1);
			}
			else {
				ctx.lineTo( x+xDiff+10, y+yDiff+-5);
			}
			ctx.stroke();
		}
		ctx.fillStyle = 'black'; 
		ctx.font = "12px serif";
		textOnWhite( ctx, text, x+xDiff+1, y+yDiff);
		
		ctx.setLineDash(lineDash);
		ctx.font = font;
		ctx.strokeStyle = strokeStyle;
		return item;
	}
	function getStageDeltaH( constantDeltaH, iStage, cStages, firstToLastDeltaH) {
		const iMid = (cStages-1)/2;
		if (iMid == 0) return constantDeltaH/cStages;
		const hStep = constantDeltaH*(firstToLastDeltaH - 1)/iMid;
		/*if (iStage == 0) hKinetic = constantDeltaH*0.12;
		else if (iStage == cStages-1) hKinetic = -constantDeltaH*0.12;
		else hKinetic = 0;*/
		//return (constantDeltaH-hKinetic) + (iMid - iStage)*hStep; 
		const ret = constantDeltaH + (iMid - iStage)*hStep; 
		if (Number.isNaN(ret)) throw new Error("stage.hDeltaPower="+ret);
		return ret;
	}

// TBD: Check the blade stress in https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf
// But: ~10000 rmp is the upper limit of no problems area?? Only U matters!
// stress 1/2*(density)*U^2*K(1-b^2) where typical K=0.55-0.65 for blades, depens on b
// 
	function getCompressorStage(stageData, item, rpm ) {
			var stage = {};
			stage.flowM3 = stageData.massFlowInKg /item.d;
			var speedOfSound = item.speedOfSound ? item.speedOfSound : Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'H', item.h, name);
			if (speedOfSound == Infinity) {
				speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', item.p, 'T', item.t+0.5, name);
			}
			stage.mach = item.speedOfSound = speedOfSound;

			if (stageData.constantDeltaH) {
				//stage.U = stageData.U; // Math.sqrt(stageData.constantDeltaH / stageData.stageLoadingCoefficientMin);
				stage.v = stageData.v; // stageData.flowCoefficientMin * stage.U;
				stage.hubToTipRatio = stageData.stages.length > 0 ? 
					stageData.stages[stageData.stages.length-1].rHub/stageData.stages[stageData.stages.length-1].rTip : stageData.getStageHubToTipRatio(item);
//console.log(stageData.constantDeltaH+"=>v="+stage.v);
			}
			else {
				stage.v = stageData.vMach*stage.mach;
				if (typeof item.v === 'undefined') item.v = stage.v;
				stage.hubToTipRatio = stageData.getStageHubToTipRatio(item);
			}
			// we need initial AR to to get blockage 
			if (stageData.aspectRatios.length > stageData.stages.length) {
				stage.aspectRatio =  stageData.aspectRatios[stageData.stages.length];
				//console.log(stageData.stages.length+":AR="+stage.aspectRatio);
			}
			else if (stageData.stages.length > 0) {
				stage.aspectRatio =  stageData.stages[stageData.stages.length-1].aspectRatio;
				//console.log(stageData.stages.length+":prev AR="+stage.aspectRatio);
			}
			else {
				stage.aspectRatio = 3; // blind guess
				//console.log(stageData.stages.length+":first AR="+stage.aspectRatio);
			}
			stage.blockageFactor = getBlockageFactor(stageData, stageData.stages.length, stage.aspectRatio);
			var area = stage.flowM3/stage.blockageFactor / (stage.v*(stageData.constantRpm ? 1 : 
				(stageData.horizontalVectors && stageData.horizontalVectors.length>stageData.stages.length) ?  stageData.horizontalVectors[stageData.stages.length] : stageData.horizontalVector));

			if (Number.isNaN(area)) {
				console.log(JSON.stringify(stage));
				throw Error("area="+area);
			}
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length]);
			if (!stageData.constantRpm || !rpm) {
				stage.rTip = Math.sqrt(area/(Math.PI*(1-stage.hubToTipRatio*stage.hubToTipRatio)));
				stage.rHub = stage.rTip * stage.hubToTipRatio;
				stage.rMid = Math.sqrt((stage.rTip*stage.rTip+stage.rHub*stage.rHub)/2);
			}
//console.log(stageData.stages.length+": area="+area+", stage.hubToTipRatio="+stage.hubToTipRatio+", rTip="+stage.rTip+", rHub="+stage.rHub);
			stage.d = item.d;
			stage.h = item.h;
			if (stageData.stages.length == 0 && stageData.inlet.h != item.h) throw new Error("Bad inlet");
			stage.s = item.s;
			stage.p = item.p;
			stage.t = item.t;
			stage.hDeltaKinetic = stageData.hDeltaKinetics.length > stageData.stages.length ? 
				stageData.hDeltaKinetics[stageData.stages.length] : 
				stageData.stages.length > 1 ? stageData.stages[stageData.stages.length-1].hDeltaKinetic : 0;

			if (!rpm) {
				// init inlet or outlet stage
				// A = PI*(rOut^2-rIn^2) ==  PI*rOut^2*(1-hubToTip^2)
				// => rOut = sqrt(A/(PI*(1-hubToTip^2))
				const meanU = stage.v/stageData.flowCoefficientMean;
				stageData.rpm = stage.rpm = 60*meanU/(stage.rTip*2*Math.PI);
				stageData.rpmStages = 1;
				stageData.rMid = stage.rMid = meanU/(2*Math.PI*rpm/60);
				area = stage.flowM3 / stage.blockageFactor / stage.v;
				stageData.rTip = stage.rTip = Math.sqrt(area/(2*Math.PI)+stage.rMid*stage.rMid);
				stageData.rHub = stage.rHub = Math.sqrt(stage.rMid*stage.rMid-area/(2*Math.PI));
				stageData.rpmCount++;
				stage.flowCoefficient = stageData.flowCoefficientMean*stage.rMid/stage.rTip;
				if (!stageData.flowCoefficientMin) stageData.flowCoefficientMin = stage.flowCoefficient;
				stage.stageLoadingCoefficient = stageData.flowCoefficientMean*((stage.rMid/stage.rTip)**2);
				if (!stageData.stageLoadingCoefficientMin) stageData.stageLoadingCoefficientMin = stage.stageLoadingCoefficient;
				stageData.getDeltaH( stageData, stage, item );
				if (Number.isNaN(stage.hDeltaPower)) throw new Error("stage.hDeltaPower="+stage.hDeltaPower);
//console.log("stageData.rpm="+stageData.rpm+", stage0:"+JSON.stringify(stage));
			}
			else {
				stage.rpm = rpm;
				if (stageData.constantRpm) {
					stage.hDeltaPower = getStageDeltaH(stageData.constantDeltaH, stageData.stages.length, stageData.cStages, stageData.firstToLastDeltaH) ;
					stage.deltaH = (stageData.isCompressor ? 1 : -1)*stage.hDeltaPower + stage.hDeltaKinetic;
					const flowCoefficientMeanOrg = stageData.flowCoefficientMean;
					if (!stageData.rpmCount) {
						const orgStages = stageData.cStages;
						const orgAxialSpeed = stage.v;
						const orgTip = stage.rTip;
						const orgFirstToLastDeltaH = stageData.firstToLastDeltaH;
						for (;;) {
							// mean
							const meanU = Math.sqrt(Math.abs(stage.hDeltaPower)/stageData.stageLoadingCoefficientMean);
							stageData.rMid = stage.rMid = meanU/(2*Math.PI*rpm/60);
							stage.v = stageData.v = meanU*stageData.flowCoefficientMean;
							area = stage.flowM3 / stage.blockageFactor / stage.v;
							stageData.rTip = stage.rTip = Math.sqrt(area/(2*Math.PI)+stage.rMid*stage.rMid);
							stageData.rHub = stage.rHub = Math.sqrt(stage.rMid*stage.rMid-area/(2*Math.PI));
							stage.midFlowCoefficient = stageData.flowCoefficientMean;
							stage.midStageLoadingCoefficient = stageData.stageLoadingCoefficientMean;
							if (Number.isNaN(stage.midStageLoadingCoefficient)) throw new Error("midStageLoadingCoefficient="+stage.midStageLoadingCoefficient);
							stage.flowCoefficient = stageData.flowCoefficientMin = stageData.flowCoefficientMean*stage.rMid/stage.rTip;
							stage.stageLoadingCoefficient = stageData.stageLoadingCoefficientMin = stageData.stageLoadingCoefficientMean*((stage.rMid/stage.rTip)**2);
							// area = PI*(minTip*minTip - minTip*0.65*minTip*0.65)
							// area = PI*minTip*minTip*(1-0.65*0.65)
							// => minTip = sqrt(area/(PI*(1-0.65*0.65)));
							stageData.U = stage.U = stage.rTip*2*Math.PI*rpm/60;
							const minTip = Math.sqrt(area/(Math.PI*(1-stageData.minHubToTip*stageData.minHubToTip)));
							if (stageData.pressureAdjusted || stage.rTip >= minTip) break;
							else if (stageData.cStages == 1) {
console.log("cStages=1, area="+area+", rTip="+stage.rTip+"=>"+minTip+", hDeltaPower="+stage.hDeltaPower+", stageData.cStages="+stageData.cStages+", stage.U="+stage.U+"=>"+(stage.rTip*(2*Math.PI*rpm/60))+", stage.v="+stage.v);
								stage.rTip = minTip;
								stage.U = stage.rTip*(2*Math.PI*rpm/60);
								stage.v = stageData.v = stageData.U*stageData.flowCoefficientMin;
								stageData.stageLoadingCoefficientMin = stage.hDeltaPower / (stage.U*stage.U);
								break;
							}
console.log("init: area="+area+", tip="+stage.rTip+" < minTip="+minTip+", hub/tip="+(stage.rHub/stage.rTip));
							if (stageData.firstToLastDeltaH > 2) 
							{
								stageData.cStages--;		// speed up by decrementing the stage count
							}
							else {
								//stageData.flowCoefficientMean -= 0.01;
								stageData.firstToLastDeltaH *= 1.01;	// speed the first stage by moving power to the first stage
							}
							stageData.constantDeltaH = (stageData.grossPower / stageData.cStages) / stageData.massFlowInKg;
							stage.hDeltaPower = getStageDeltaH(stageData.constantDeltaH, stageData.stages.length, stageData.cStages, stageData.firstToLastDeltaH) ;
							stage.deltaH = (stageData.isCompressor ? 1 : -1)*stage.hDeltaPower + stage.hDeltaKinetic;
							if (Number.isNaN(stage.deltaH)) throw new Error("stage.deltaH="+stage.deltaH);
							
//console.log(stageData.cStages+":adjusting rTip: "+stage.rTip+">"+minTip+" mach="+(stageData.U/stage.mach)+", item.t="+item.t+", stage.v="+stage.v+", stage.mach="+stage.mach);
							// do not allow supersonic speed => create compressor with one-speed gear
							if (false && (stage.v/stage.mach) > 2.2) {
								stage.v = stageData.v = orgAxialSpeed;
								stage.rTip = orgTip;
								stageData.cStages = orgStages;
								area =  stage.flowM3 / stage.blockageFactor / stage.v;
								stage.U = stage.v/stageData.flowCoefficientMin;
								stageData.rpm = stage.rpm = 60*stage.U/(stage.rTip*2*Math.PI);
								stageData.constantDeltaH = (stageData.grossPower / stageData.cStages) / stageData.massFlowInKg;
								break;
							}
						}
						if (flowCoefficientMeanOrg != stageData.flowCoefficientMean) {
							console.log("Bad geometry, decreased stage loading coefficient from "+flowCoefficientMeanOrg+" to "+stageData.flowCoefficientMean
										+" to increase hub/tip to min "+stageData.minHubToTip);
						}
						area = stage.flowM3 / stage.blockageFactor / stage.v;
						stage.rHub = Math.sqrt((Math.PI*stage.rTip*stage.rTip-area)/Math.PI);
						stage.rMid = Math.sqrt((stage.rTip*stage.rTip+stage.rHub*stage.rHub)/2);
//if (stageData.stages.length < 2) console.log(stageData.stages.length+":area="+area+", tip="+stage.rTip);
						if (stageData.constantDiameter == 'inner') {
							stageData.rHub = stage.rHub;
						}
						else if (stageData.constantDiameter == 'outer') {
							stageData.rTip = stage.rTip;
						}
						else {	// stageData.constantDiameter == 'mean'
							stageData.rMid = stage.rMid;
						}
						stageData.rpmCount = 1;
						stageData.rpmStages = 1;
						stageData.hubToTipRatio = stage.rHub / stage.rTip;
console.log("stageData.cStages="+stageData.cStages+", stageData.constantDeltaH="+stageData.constantDeltaH+", stage="+JSON.stringify(stage));
if (!stage.v) throw new Error("v="+stage.v);
					}
					else {
						// area/2 = PI*(rTip*rTip-rMid*rMid)
						// => rTip = sqrt(area/(2*PI)+rMid*rMid)
						// area/2 = PI*(rMid*rMid-rHub*rHub)
						// => rHub = sqrt(rMid*rMid-area/(2*PI))
						if (stageData.constantDiameter == 'inner') {
							stage.rHub = stageData.rHub;
							stage.rMid = Math.sqrt(stage.rHub*stage.rHub+area/(2*Math.PI));
							stage.rTip = Math.sqrt(stage.rHub*stage.rHub+area/Math.PI);
						}
						else if (stageData.constantDiameter == 'outer') {
							stage.rTip = stageData.rTip;
							stage.rMid = Math.sqrt(stage.rTip*stage.rTip-area/(2*Math.PI));
							stage.rHub = Math.sqrt(stage.rTip*stage.rTip-area/Math.PI);
						}
						else {
							// mean
							stage.midFlowCoefficient = stageData.flowCoefficientMean;
							stage.midStageLoadingCoefficient = stageData.loadCoefficientMean;
							if (Number.isNaN(stage.midStageLoadingCoefficient)) throw new Error("midStageLoadingCoefficient="+stage.midStageLoadingCoefficient);
							stage.rMid = stageData.rMid;
							stage.rTip = Math.sqrt(area/(2*Math.PI)+stage.rMid*stage.rMid);
							stage.rHub = Math.sqrt(stage.rMid*stage.rMid-area/(2*Math.PI));
						}
						if (Number.isNaN(stage.rHub)) {
							throw new Error("Impossible gemetry: decrease rpm or double number of units");
						}
						stage.U = stage.rTip*2*Math.PI*rpm/60;
						stageData.rpmStages++;
					}
					stageData.hubToTipRatioMax = stage.hubToTipRatio = stage.rHub / stage.rTip;
					stage.stageLoadingCoefficient = stage.hDeltaPower/(stage.U*stage.U);
					stage.flowCoefficient = stage.v/stage.U;
					if (typeof stage.midFlowCoefficient === 'undefined') {
						stage.midStageLoadingCoefficient = stage.stageLoadingCoefficient *((stage.rMid/stage.rTip)**2);
						if (Number.isNaN(stage.midStageLoadingCoefficient)) throw new Error("midStageLoadingCoefficient="+stage.midStageLoadingCoefficient);
						stage.midFlowCoefficient = stage.flowCoefficient * stage.rMid/stage.rTip;
					}
//console.log(stageData.stages.length+": stageData.rMid="+stageData.rMid+" stage="+JSON.stringify(stage));
					stageData.getDeltaH( stageData, stage, item );
				}
				else if (stageData.constantDeltaH) {
					stage.hDeltaKinetic = stageData.hDeltaKinetics.length > stageData.stages.length ? stageData.hDeltaKinetics[stageData.stages.length] : 0
					stage.hDeltaPower = getStageDeltaH(stageData.constantDeltaH, stageData.stages.length, stageData.cStages, stageData.firstToLastDeltaH) ;
					stage.deltaH = (stageData.isCompressor ? 1 : -1)*stage.hDeltaPower + stage.hDeltaKinetic;
					stageData.getDeltaH( stageData, stage, item );
					rpm = stage.U / ((stage.rTip*2*Math.PI) / 60);
					stageData.rpmStages = 1;
					stageData.rpmCount++;
				}
				else {
					stage.U = stage.v / stageData.flowCoefficientMin;
					stageData.getDeltaH( stageData, stage, item );
					rpm = stage.U / ((stage.rTip*2*Math.PI) / 60);
					stageData.rpmStages = 1;
					stageData.rpmCount++;
				}
				stage.rpm = rpm;
			}
			stage.flowCoefficient = stage.v/stage.U;
			//stage.deltaH = stage.U * stage.U * stage.stageLoadingCoefficient;
			if (typeof item.s === 'undefined') {
				item.s = Module.PropsSI('S', 'P', item.p, 'H', item.h, name);
			}
			stage.stageLoadingCoefficient = stage.hDeltaPower / (stage.U*stage.U);
			stage.midStageLoadingCoefficient = stage.hDeltaPower / ((stage.U*stage.rMid/stage.rTip)**2);
			if (Number.isNaN(stage.midStageLoadingCoefficient)) throw new Error("midStageLoadingCoefficient="+stage.midStageLoadingCoefficient);
			stage.UMach = stage.U/stage.mach;
			stage.vMach = stage.v/stage.mach;
//if (stageData.maxStressExceeded) console.log("Horizontal stage #"+stageData.stages.length+":"+JSON.stringify(stage));
			return stage;
	}
	function nextCompressorStage(stageData, prev, rpm, efficiency ) {
		stage = getCompressorStage(stageData, prev, rpm );
		
		if (stage == null) {
			console.log("stage == null");
			return null;
		}
//if (stageData.stages.length == 0) console.log("stage0="+JSON.stringify(stage));
		stageData.stages.push(stage);
		stageData.items.push(prev);
		//stageData.cStagesRemaining = (stageData.hEnd - prev.h - 0.5*stage.v*stage.v)/stage.deltaH;

		var next = {};
if (typeof stage.deltaH === 'undefined'  || !prev.v || !prev.p) {
	console.log("Bad stage:"+JSON.stringify(stage));
	console.log("Or bad item:"+JSON.stringify(prev));
	return null;
}
		next.h = stage.hOut;
		next.d = stage.dOut;
		next.p = stage.pOut;
		next.s = stage.sOut;
		next.t = Module.PropsSI('T','P', next.p, 'H', next.h, name);
		next.speedOfSound = stage.machOut;
		next.v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
/*		
		const hActualWork = stage.hDeltaPower * (stageData.isCompressor ? efficiency : -1/efficiency) + stage.hDeltaKinetic;
		const s = prev.s ? prev.s : Module.PropsSI('S','P', prev.p, 'H', prev.h, name);	// use h for wet gas!
		const pMax = Module.PropsSI('P','S', s, 'H', stageData.isCompressor ? stage.deltaH : hActualWork, name);
//console.log("hActualWork="+hActualWork+"="+stage.deltaH+" * "+efficiency+", prev.h="+prev.h+"=>pMax="+pMax);//+", "+JSON.stringify(stage));
//console.log("prev="+JSON.stringify(prev));
		if (stageData.constantDeltaH) {
			if (stage.isLast && stage.pOut) {
				next.p = stage.pOut;
				next.h = stage.hOut;
			}
			else {
				next.p = Module.PropsSI('P', 'H', prev.h+hActualWork, 'S', s, name);
				next.h = prev.h+stage.deltaH;
			}
			next.t = Module.PropsSI('T','P', next.p, 'H', next.h, name);
			next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', next.p, 'H', next.h, name)
			next.v = stageData.v;
if (!s || !next.p || !next.h || !next.t || !next.v) {
	console.log("s="+s+"=>next="+JSON.stringify(next)+", prev="+JSON.stringify(prev)+", efficiency="+efficiency+", rpm="+rpm+" stages="+JSON.stringify(stageData.stages));
	throw new Error('Internal error, see console log');
}
		}
		else {
			if (!testResult( prev.h+hActualWork, prev.p+(pMax-prev.p)/3, pMax, hActualWork*0.01, function(p) {
				next.p = p;
				next.h = Module.PropsSI('H','P', p, 'S', s, name)+ hHeating;
				next.t = Module.PropsSI('T','P', p, 'H', next.h, name);
				next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'H', next.h, name)
				if (next.speedOfSound == Infinity) {
					next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'T', next.t+0.5, name);
					if (next.speedOfSound == Infinity) {
						console.log(JSON.stringify(stageData));
						console.log("testResult("+prev.h+"+"+hActualWork+", "+prev.p+"+"+(pMax+"-"+prev.p)+"/"+3+", "+pMax+", "+hActualWork+"*"+0.01+")");
						console.log("Bad data: next="+JSON.stringify(next)+", prev="+JSON.stringify(prev)); //+"; stage="+JSON.stringify(stage));
						next.p = xyz; // break
					}
				}
				const c1 = stage.v/Math.cos(stage.midα1);
				next.v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
				var nextC1 = next.v/Math.cos(stage.midα1);
if (!s || !p || !next.h || !stage.v || !next.t) {
	console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(nextC1*nextC1 - c1*c1)));
	next.p = xyz; // break
}
				return next.h + 0.5*(nextC1*nextC1 - c1*c1);
			})) {
	console.log("testResult == false: "+JSON.stringify(next));
				testResult( prev.h+hActualWork, prev.p+(pMax-prev.p)/2, pMax, hActualWork*0.01, function(p) {
					next.p = p;
					next.h = Module.PropsSI('H','P', p, 'S', s, name)+ hHeating;
					next.t = Module.PropsSI('T','P', p, 'H', next.h, name);
					next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'H', next.h, name)
					if (next.speedOfSound == Infinity) {
						next.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', p, 'T', next.t+0.5, name);
						if (next.speedOfSound == Infinity) {
							console.log("Stuck inside the vaporization line?: "+JSON.stringify(next));
						}
					}
					next.v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
					nextC1 = next.v/Math.cos(stage.midα1);
console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(nextC1*nextC1 - c1*c1)));
					return next.h + 0.5*(nextC1*nextC1 - c1*c1);
				});
				return null;
			}
		}
*/
		const hV = Module.PropsSI('H','P',next.p,'Q',1,name); 	// vapor
		if (next.h < hV) {
			const hL = Module.PropsSI('H','P',next.p,'Q',0,name); // liquid
			next.wetness = (hV-next.h) / (hV-hL);
			if (next.wetness > 0.15) {
				console.log("WARNING: next.wetness="+next.wetness+" > 0.15!!!!"); 
			}
		}
		if (typeof next.s === 'undefined') {
			next.s = Module.PropsSI('S','P', next.p, 'H', next.h, name);
		}
		//next.d = Module.PropsSI('D','P', next.p, 'H', next.h, name);
		if (next.d === Infinity) {
			next.d = Module.PropsSI('D','P', next.p, 'T', next.t+0.5, name);
		}
		next.hRemaining = stageData.isCompressor ? stageData.hEnd - (prev.h + stage.hKineticOut) : (prev.h + stage.hKineticOut)-stageData.hEnd;
//console.log("stage.wasLast="+stage.wasLast);
		if (stage.isLast) {
/*
			const v = stageData.constantDeltaH ? stageData.v : stageData.vMach*next.speedOfSound;
			const flowM3 = stageData.massFlowInKg /next.d;
			stage.blockageFactor = getBlockageFactor(stageData, stageData.stages.length, stage.aspectRatio);
			const area =  flowM3/stage.blockageFactor / (v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length-1] : stageData.horizontalVector));
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length-1]);

			if (stageData.constantRpm) {
				next.d = Module.PropsSI('D','P', next.p, 'T', next.t, name);
				next.flowM3 = stageData.massFlowInKg /next.d;
				const area =  next.flowM3/stage.blockageFactor / (next.v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length-1] : stageData.horizontalVector));
				next.rTip = Math.sqrt(area/(2*Math.PI)+stageData.rMid*stageData.rMid);
				next.rHub = Math.sqrt(stageData.rMid*stageData.rMid-area/(2*Math.PI));
				next.hubToTipRatio = next.rHub / next.rTip;
			}
			else 
			if (stageData.maxStressExceeded) {
				// area = PI * ((midLine+x)^2 - (midLine-x)^2)
				// => area = PI * (midLine^2 + 2*x*midLine+x^2 - (midLine^2 - 2*x*midLine+x^2))
				// => area = PI * 4 *x*midLine
				// x = area / (midLine*PI*4);
				const x = area / (stageData.midLine*Math.PI*4);
				next.rTip = stageData.midLine + x;
				next.rHub = stageData.midLine - x;
				next.hubToTipRatio = stage.rHub / stage.rTip;
console.log("x="+x+", stage.rTip="+stage.rTip+", stage.rHub="+stage.rHub);
			}
			else {
				next.d = Module.PropsSI('D','P', next.p, 'T', next.t, name);
				next.flowM3 = stageData.massFlowInKg /next.d;
				next.hubToTipRatio = stageData.getStageHubToTipRatio(next);
				const area =  next.flowM3/stage.blockageFactor / (next.v*(stageData.horizontalVectors ?  stageData.horizontalVectors[stageData.stages.length-1] : stageData.horizontalVector));
//if (!area) console.log(stageData.stages.length+": null area!!!, hv="+stageData.horizontalVectors[stageData.stages.length-1]);
				next.rTip = Math.sqrt(area/(Math.PI*(1-next.hubToTipRatio*next.hubToTipRatio)));
				next.rHub = next.rTip * next.hubToTipRatio;
			}
*/
			next.rTip = stage.rTipOut;
			next.rHub = next.rHubOut;
			stageData.hpExit = next;
console.log("stageData.hpExit="+JSON.stringify(stageData.hpExit));
			return null;
		}
if (!next.p || next.p == null) {
	console.log(JSON.stringify(next));
	var x = xyz;	// break
}
//console.log(JSON.stringify(next));
		return next;
	}

	// LP: hub/tip = starts from v=0.25Mach, v/w=0.3, hub/tip=0.5, keep: 
	// Calculated h defines new p, t and speed of sound 
	// If (h/w^2)/(v/w)=2/3 == (h/w^2)*(w/v)=2/3 == h = w*v*2/3
	function getCompressorStages( data, isFirst, massFlow, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, cUnits )
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		return getCompressorStagesI( true, data, isFirst, massFlow*1000, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, cUnits );
	}

	function getTurbinStages( data, isFirst, massFlow, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, cUnits )
	{	
		if (!data.isForward) {
			if (isFirst) isFirst = false;
			else isFirst = true;
		}
		// turbin stages are calculated in backward!
		stageData = getCompressorStagesI( false, data, isFirst, massFlow*1000, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, cUnits );
		return stageData;
	}

	// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf
	// β1 angle  flowX component (=V) in blade inlet
	// β2 angle of flowX component (=V) in blade exit
	// α1 angle of absolute flow in blade inlet
	// α2 angle of flowX component (=V) in blade exit, THIS IS THE TOP STEED AND SETS THE UPPER LIMIT IF SPEED < 1 Mach
	// γ Stagger angle, actual angle status rotor to the flowX direction 
	// Ψ Stage loading factor  
	// Φ Flow coefficient
	// V = Vx = X component of abosulte flow speed == V
	// U = rotational speed
	// Vabs1 = absolute flow speed at rotor inlet
	// Vabs2 = absolute flow speed at rotor exit == TOP SPEED == eg. we can set it 0.95 MACH!
	// tan(β1)=(Reaction + Ψ/2)/Φ,  tan(β2)=(Reaction - Ψ/2)/Φ
	// Reaction=0.5 (for calculus, we will keep speeding up, but that is made by shorter stator length
	// => β1 = atan((1/2 + Ψ/2)/Φ), 
	//    β2 = atan((1/2 - Ψ/2)/Φ)
	// Vabs2^2 = (U-tan(β2)*V)^2 + V^2) == (V/Φ-tan(β2)*V)^2 + V^2 == V^2 * ((1/Φ-tan(β2))^2 + 1) 
	// => V = sqrt(Vabs2^2/((1/Φ-tan(β2))^2 + 1))
	// SET Vabs2 = Mach 0.9
	// 
	function setFlowSpeedForNewRpm(stageData, stage) {
		stage.v = stageData.v ? stageData.v : stageData.vMach*stage.mach;
		stage.U = stageData.U ? stageData.U : stage.v/stageData.flowCoefficientMin;
	}
	
	function calcCompressorStages( stageData, item )
	{
		stageData.stages = [];
		stageData.items = [];
		stageData.rpm = stageData.constantRpm ? stageData.rpm : 0;
		stageData.rpmStages = 0;
		stageData.rpmCount = 0;
//console.log("calcCompressorStages: efficiencies:"+JSON.stringify(stageData.stageEfficiencies)+", \r\nARs: "+JSON.stringify(stageData.aspectRatios)+", stageData.v="+stageData.v);
//console.log("calcCompressorStages: ARs:"+JSON.stringify(stageData.aspectRatios));
		var i;
		for (i = 0; i < 100; i++) {
			if (typeof item.s === 'undefined') {
				item.s = Module.PropsSI('S', 'P', item.p, 'H', item.h, name);
			}
if (!item.p) {
	console.trace(i+": item: "+JSON.stringify(item));
	var x = xyz;	// break;
}		
//console.log(i+": item="+JSON.stringify(item));
			item = nextCompressorStage(stageData, item, stageData.constantRpm ? stageData.rpm : 0, 
				typeof stageData.stageEfficiencies[stageData.stages.length] !== 'undefined' ? stageData.stageEfficiencies[stageData.stages.length] : stageData.efficiency );
			if (item == null || !item.v || !item.p) {
				console.log(i+": item: "+JSON.stringify(item));
				break;
			}
			const lastStage = stageData.stages[stageData.stages.length-1];
			if (lastStage.isLast || item.hRemaining < Math.abs(lastStage.deltaH)) {
				console.log("lastStage.isLast="+lastStage.isLast+" item.hRemaining < lastStage.deltaH == "+(item.hRemaining < Math.abs(lastStage.deltaH)));
				break;
			}
		}
	}
	function toPoint(x,y) {
		// y may be undefined!
		//if (x == null || typeof x === 'undefined'|| typeof y === 'undefined') throw new Error("Bad data: x="+x+", y="+y);
		//if (y > 1.3 && x > 1.8 && x < 2) throw new Error("Stop!");
		var obj = {};
		obj.x = x;
		obj.y = y;
		return obj;
	}
	// See https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf page 15
	var blockageFactor = 0.86;
	var referenceAR = 1.7;
	function getBlockageFactor(stageData, stageNum, AR ) {
		var ret;
		if (stageNum == 0) ret = 1;
		else {
			if (stageData.blockageFactors.length >= stageNum) ret = stageData.blockageFactors[stageNum-1];
			else if (stageData.blockageFactors.length == stageNum) ret = stageData.blockageFactors[stageNum-1];
			else {
				if (stageNum <= 4) ret = 0.9 + 0.025*(4-stageNum);
				else if (stageNum <= 6) ret = 0.9 - 0.01*(stageNum-4);
				else if (stageNum <= 8) ret = 0.87 + 0.005*(8-stageNum);
				else if (stageNum <= 12) ret = 0.86 + 0.0025*(12-stageNum);
				else ret = 0.86 - 0.005/8*(stageNum-12);
				if (typeof AR === 'undefined') {
					AR = stageNum <= stageData.stages.length ? stageData.stages[stageNum-1].aspectRatio : 3;
				}
				ret = 1 - (1-ret)*referenceAR/AR;
			}
		}
		if (typeof ret === 'undefined' || Number.isNaN(ret)) throw Error("ret="+ret);
		return ret;
	}
	// density and speed of sound are not necessaryly available near tripple point
	function initCryogenicInlet( stageData, first )
	{
		var v = stageData.inletC1 ? stageData.inletC1 : stageData.v; // / Math.cos(stageData.inletα1); // inletα1 == 0
		var inlet = {};
		const hKinetic = 0.5*v*v;
		inlet.hKinetic = hKinetic;
		const deltaKinetic = 0.5*first.v*first.v - hKinetic;
		inlet.hDeltaKinetic = deltaKinetic;
		inlet.v = v;
		inlet.h = first.h + deltaKinetic;  
		// only a part (97%) of pressure drop transforms to kinetic energy, 
		var h = first.h + deltaKinetic/stageData.diffuserEfficiency;
		inlet.hLoss = Math.abs(inlet.h - h);	// enthalpy lost as heat
		inlet.s = first.s;		// initial value for wet cases
		inlet.p = Module.PropsSI('P','S', first.s, 'H', h, name);
		if (inlet.p === Infinity) {
			inlet.p = Module.PropsSI('P','S', first.s, 'Q', 1, name);
			if (inlet.p === Infinity) {
				while (inlet.p === Infinity) {
					increaseLowPressure = true;
					// a small part of gas was frozen, it probably does not matter and we can ignore it
					h += 100;
					inlet.p = Module.PropsSI('P','S', first.s, 'H', h, name);
				}
				const hLiq = Module.PropsSI('H','P', inlet.p, 'Q', 0, name);
				const hGas = Module.PropsSI('H','P', inlet.p, 'Q', 1, name);
				inlet.wetness = 1 - (inlet.h -  hLiq)/(hGas -  hLiq);
				inlet.t = Module.PropsSI('T','P', inlet.p, 'H', h, name);
				inlet.d = Module.PropsSI('D','P', inlet.p, 'H', h, name);//'T', inlet.t, name);
				while (inlet.d === Infinity) {
					h += 500;
					inlet.d = Module.PropsSI('D','P', inlet.p, 'H', h, name);//'T', inlet.t, name);
				}
				inlet.visc = Module.PropsSI('VISCOSITY', 'P', inlet.p, 'H', h, name);
				inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', h, name);
				while (inlet.speedOfSound === Infinity || inlet.visc === Infinity) {
					h += 500;
					if (inlet.visc === Infinity) {
						inlet.visc = Module.PropsSI('VISCOSITY', 'P', inlet.p, 'H', h, name);
					}
					if (inlet.speedOfSound === Infinity) {
						inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', h, name);
					}
				}
				console.log("Increased inlet enthaply by "+(h-inlet.h)+", inlet="+JSON.stringify(inlet));
			}
			else {
				// its wet!
				const s = Module.PropsSI('S','P', inlet.p, 'Q', 1, name);
				if (s !== Infinity) inlet.s = s;
				inlet.t = Module.PropsSI('T','S', inlet.s, 'Q', 1, name);
				inlet.d = Module.PropsSI('D','S', inlet.s, 'Q', 1, name);
				inlet.visc = Module.PropsSI('VISCOSITY', 'S', inlet.s, 'Q', 1, name);
				const hLiq = Module.PropsSI('H','P', inlet.p, 'Q', 0, name);
				const hGas = Module.PropsSI('H','P', inlet.p, 'Q', 1, name);
				inlet.wetness = 1 - (inlet.h -  hLiq)/(hGas -  hLiq);
				console.log("inlet is wet: "+JSON.stringify(inlet));
			}
		}
		else {
			inlet.s = Module.PropsSI('S','P', inlet.p, 'H', inlet.h, name);
			inlet.t = Module.PropsSI('T','P', inlet.p, 'H', inlet.h, name);
			inlet.d = Module.PropsSI('D','P', inlet.p, 'H', inlet.h, name);
			inlet.visc = Module.PropsSI('VISCOSITY', 'P', inlet.p, 'T', inlet.t, name);
		}
		if (inlet.d === Infinity) {
			inlet.d = Module.PropsSI('D','P', inlet.p, 'T', inlet.t+1, name);
		}
		if (inlet.visc === Infinity) {
			inlet.visc = Module.PropsSI('VISCOSITY', 'P', inlet.p, 'T', inlet.t+1, name);
		}
		if (!inlet.p || !first.s || inlet.d === Infinity) {
			console.trace("Could not read density of cryogenic "+name+": "+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
			var x = foo;	// break!!!
		}
		// is fluid inside the saturation curve or below tripple point
		// snow flakes and mist will vaporise inside the compressor
		if (typeof inlet.speedOfSound === 'undefined') inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
		if (inlet.speedOfSound === Infinity) {
			inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'T', inlet.t+1, name);
		}
		inlet.h0 = inlet.h + 0.5*(inlet.v**2);
		if (Math.abs(inlet.h0-stageData.hStagnIn) > 1) {
			console.log(JSON.stringify(inlet)+" != org stageData.inlet:"+JSON.stringify(stageData.inlet));
			throw new Error("Inlet has bad stagnation entahlpy!!!");
		}
		inlet.flowM3 = stageData.massFlowInKg /inlet.d;
		stageData.inlet = inlet;
		return inlet;
	}
	function transformToStaticValues( item, v) {
		// save stagnation values
		if (typeof item.h0 == 'undefined') {
			item.h0 = item.h;
			item.t0 = item.t;
			item.p0 = item.p;
			item.d0 = item.d;
		}
		item.v = v;
		item.h = item.h0 - 0.5*(v**2);
		item.p = Module.PropsSI('P','S', item.s, 'H', item.h, name);	// assume 100% efficiency!
		item.t = Module.PropsSI('T','P', item.p, 'H', item.h, name);
		item.d = Module.PropsSI('D','P', item.p, 'H', item.h, name);
	}

	function verifyStaticValues(item) {
		// save stagnation values
		const v = item.v;
		if (typeof item.h0 == 'undefined') {
			if (item.h != item.h0 - 0.5*(v**2)) throw new Error("bad stagnation value");
			if (item.p0 && item.p0 != Module.PropsSI('P','S', item.s, 'H', item.h0, name)) throw new Error("bad stagnation value");
			if (item.t0 && item.t0 != Module.PropsSI('T','S', item.s, 'H', item.h0, name)) throw new Error("bad stagnation value");
			if (item.d0 && item.d0 != Module.PropsSI('D','S', item.s, 'H', item.h0, name)) throw new Error("bad stagnation value");
		}
	}

	var increaseLowPressure = false;
	var prevHeatPumpHighP;
// TBD: design by the type subsonic, transonic, supersonic => subsonic => stage 1 vMach<=0.9, transonic => stage 1 vMach <= 1.2, supersonic => stage 1 vMach <= 1.5
// Rule: each stage produces equal amout of power, chose the lowest number of stages matching with the selected type
// All other params are irrelevant before CFD optimization phase
	function getCompressorStagesI( isCompressor, data, isFirst, massFlowInKg, title, inletPipeDiameter, exitPipeDiameter, stageEfficiency, grossPower, cUnits )
	{	
		increaseLowPressure = false;
		function getSheetValues(title, name, data, decimalsOrDiv, decimals)
		{
			var i, ret = [];
			ret.push(title);
			for (i = 0; i < data.length; i++) {
				var val = typeof data[i][name] === 'function' ? data[i][name](i, data[i]) : data[i][name];
				if (typeof val  === 'undefined') ret.push(' ');
				else if (typeof val === 'string') {
					ret.push(val);
				}
				else if (decimalsOrDiv >= 1000) {
					ret.push(decimals ? myRound(val/decimalsOrDiv, decimals) : Math.round(val/decimalsOrDiv));
				}
				else {
					ret.push(decimalsOrDiv ? myRound(val, decimalsOrDiv) : myRound(val));
				}
			}
			return ret;
		}
		//getMetrics();
		var i = isFirst ? data.items.length-1 : 0;
		var first = data.items[i];
		var last = data.items[i == 0 ? data.items.length-1 : 0];
		if ((isCompressor && first.p > last.p) || (!isCompressor && first.p < last.p)) {
			const tmp = first;
			first = last;
			last = tmp;
		}
		var stageData = {};
		stageData.isCompressor = isCompressor;
		stageData.cUnits = cUnits;
		stageData.rotorStaggerAngles = [];
		stageData.rotorHubStaggerAngles = [];
		stageData.rotorTipStaggerAngles = [];
		stageData.statorStaggerAngles = [];
		stageData.soliditiesInHub = [];
		stageData.hDeltaKinetics = [];
		// we could estimate these losses for the first loop
		stageData.hHubInletAcceleration = 0;
		//stageData.inletPressureDrop = 0;
		//stageData.exitPressureDrop = 0;
		stageData.diffuserEfficiency = getFloatParam('diffuserEfficiency', 0.97);
		// 6*4 design for both: 0.48, 0.33, 0.20, 1, 0.325:
		stageData.title = title;
		stageData.flowCoefficientMax = 0.60;	// flow coefficient max
		const isCold = title.indexOf("Cold") == 0;
		const isHot = title.indexOf("Hot") == 0;
		const isHp = title.indexOf("Heat Pump Compressor") == 0;
		const isHpTurbin = title.indexOf("Heat Pump Turbin") == 0;
		var cType = (isCold ? 'cold' : isHot ? 'hot' : 'hp') + (isCompressor ? '' : 'Turbin');
		var cType2 = (isCold ? 'Cold' : isHot ? 'Hot' : 'Hp') + (isCompressor ? '' : 'Turbin');
		var cType3 = (isCold ? 'cold' : isHot ? 'hot' : 'hp') + (isCompressor ? 'Compressor' : 'Turbin');
		blockageFactor = getFloatParam('blockageFactor'+cType2, 0.87);
		referenceAR = getFloatParam('referenceAR'+cType2, 1.7);
		
		cascadeStageLoss = (1-blockageFactor)/(1 - 0.86);	// 	
		stageData.firstToLastDeltaH = getFloatParam('firstToLastDeltaH_'+cType2, 1);
		//stageData.flowCoefficientMin = getFloatParam(cType+'FlowCoefficient', 0.44); 	// 0.33 => β2=50, 0.4 => β2=45 degree (β2~tip stagger angle)
		stageData.flowCoefficientMean = getFloatParam(cType+'FlowCoefficient', 0.44); 	// 0.33 => β2=50, 0.4 => β2=45 degree (β2~tip stagger angle)
		//stageData.stageLoadingCoefficientMin = getFloatParam(cType+'LoadCoefficient', 0.20); // 0.19
		stageData.stageLoadingCoefficientMean = getFloatParam(cType+'LoadCoefficient', 0.20); // 0.19
		stageData.spacingRatio = getFloatParam(cType+'SpacingRatio', 0.65); // 0.19
		// Smaller gap for loawer loading 
		// TBD: typical spacing ratio s/C = 0.65 - 0.75 => s = C*cos(staggerAngle)*
		// rotorStatorGap = C*cos(staggerAngle)*0.7/(C*cos(staggerAngle)*0.7 + C) == cos(staggerAngle)*spacingRatio/(cos(staggerAngle)*spacingRatio+1);
		//rotorStatorGap = C*cos(staggerAngle)*0.7/(C*cos(staggerAngle)*0.7 + C) == cos(staggerAngle)*spacingRatio/(cos(staggerAngle)*spacingRatio+1);
		stageData.rotorStatorGap = isCompressor ? getFloatParam('rotorStatorGap', 20)/100 : getFloatParam('rotorStatorGapTurbin', 40)/100;
		stageData.hasIGV = isCompressor && $('#'+cType+'HasIGV').prop('checked');
		stageData.hasOGV = false; //!isCompressor && $('#'+cType+'HasIGV').prop('checked');
		stageData.IGV_AR = getFloatParam(cType+'IGV_AR', 3);
		if (stageData.IGV_AR < 2.5) stageData.IGV_AR = 2.5;
		stageData.relativeBladeWidth = 1/(1 + stageData.rotorStatorGap);	//Before 0.30
		if (stageData.relativeBladeWidth < 0.5 || stageData.relativeBladeWidth > 0.95) {
			stageData.relativeBladeWidth = 1/1.2;
			
		}
		stageData.powerOfAcceleration = 0;
		stageData.minHubToTip = getFloatParam('minHubToTip'+cType2, 0.55); // 2/3; //  sideOfGeneratorShaft ? 0.5 : 
		stageData.maxHubToTip = getFloatParam('maxHubToTip'+cType2, 0.99); // 2/3; //  sideOfGeneratorShaft ? 0.5 : 
		stageData.maxAspectRatio = getFloatParam('maxAspectRatio'+cType2, 5);
		stageData.tMaxToChord = getFloatParam('tMaxToChord'+cType2, 0.2);
		//stageData.aspectRatio =  getFloatParam('aspectRatio'+cType2, 1.25); //getFloatParam(first.t > 273 ? 'aspectRatio' : 'aspectRatioCyro', 1.2);	// 
		stageData.hubToTipRatio = getFloatParam('hubToTipRatio'+cType2, 0.50); // 2/3; //  sideOfGeneratorShaft ? 0.5 : 
		stageData.hubToTipRatioMax = getFloatParam('hubToTipRatioMax'+cType2, 0.9);
		stageData.minTipRe = getFloatParam('minTipRe'+cType2, 50000000);
		stageData.maxReactionInRoot = getFloatParam('maxReactionInRoot'+cType2, 0.5);
		stageData.reaction = parseFloat($('#'+cType+'Reaction').val());
		stageData.isShrouded = !isCompressor;
		stageData.minChordLength = parseFloat($('#minChordLengthMm').val(), 30)/1000;

		//stageData.t2cInMiddleFlow = getFloatParam('t2cInMiddleFlow', 0.05);
		stageData.constantDiameter = $('#'+cType+'CID').prop('checked') ? 'inner' : $('#'+cType+'CMD').prop('checked') ? 'mean' : 'outer'; // outer, mean
		stageData.solidity = getFloatParam('solidity'+cType2, 2);
		stageData.cStages = getIntParam('cStages'+cType2, 0);

		if (isHpTurbin) {
			// The rest of params are shared with heat pump compressor:
			// tipGapMmHp, tipGapPercentHp, tipGapPercentHp, rotorStatorGapHP, hpCompressorType, cStressMaxMPaHp, maxTipThicknessHp
			cType = 'hp';
			cType2 = 'Hp';
			cType3 = 'hpCompressor';
		}

//console.log("stageData.constantDiameter="+stageData.constantDiameter);		
		stageData.tipGapMm = $('#tipGapMm'+cType2).val();
		stageData.tipGapPercent = $('#tipGapPercent'+cType2).val();
		stageData.rearSolidity = stageData.solidity; //getFloatParam('lastSolidity'+cType2, 2);

		stageData.constantRpm = true; // $('#'+cType3+'TypeConstantRpm').prop('checked');	// the other options do not work any more!
		stageData.singleRpm = $('#'+cType3+'TypeSingleRpm').prop('checked');
		if (typeof stageData.constantRpm === 'undefined') stageData.constantRpm = false;
		stageData.generatorRpm = parseInt($('input[name='+cType+'Rpm]:checked').val());
		if (stageData.constantRpm) stageData.rpm = stageData.generatorRpm;
		else if (stageData.singleRpm) {
			stageData.constantRpm = true;	// use the rpm of first stage
			stageData.rpm = 0;
		}
		stageData.getStageHubToTipRatio = function(item) {
			var ret;
			const hNow = item.h + 0.5*item.v*item.v;
			ret = (item.t < 273 || stageData.hubToTipRatioMax == stageData.hubToTipRatio) || !stageData.hStagnIn ? stageData.hubToTipRatio :
				stageData.hubToTipRatio  + (stageData.hubToTipRatioMax-stageData.hubToTipRatio)*(hNow - stageData.hStagnIn) / (stageData.hStagnOut-stageData.hStagnIn);
			if (Number.isNaN(ret)) { // || ret > 0.99
				console.log("hNow="+hNow+", stageData.hubToTipRatio="+stageData.hubToTipRatio+", stageData="+JSON.stringify(stageData));
				throw new Error("Error in getStageHubToTipRatio: hub/tip="+ret);
			}
			return ret;
//console.log(stageData.stages.length+": hNow="+hNow+" part="+(hNow - stageData.hStagnIn)+" / "+(stageData.hStagnOut-stageData.hStagnIn)+" => ret="+ret); 
		}
		stageData.machMaxSpeed = getFloatParam('machMaxSpeed', 0.95);		// < 0.8 => subsonic, <= 1.2 => transonic, Relative MACH number in rotor tip, TOP SPEED OF GAS RELATIVE TO BLADE AND STAGE: Use Vrel1(β1) instead Vasb2!!!!
		if (maxAN2EXP8 = getFloatParam('maxAN2EXP8')) {
			stageData.maxAN2 = maxAN2EXP8*100000000;
		}
		stageData.cStressMaxMPa = getFloatParam(first.t < 200 ? 'cStressMaxMPaCold' : 'cStressMaxMPa', 568);
		stageData.tempStressMaxMPa = getFloatParam('tempStressMaxMPa', 1173);		// MAR-M 200!
		stageData.tempMaxStressMPaDecr = getFloatParam('tempMaxStressMPaDecr', 1023);
		stageData.tempMaxStressMPaDecrValue = getFloatParam('tempMaxStressMPaDecrValue', 1);
		stageData.maxTipThickness = getFloatParam('maxTipThickness'+cType2, 1 )/1000;
console.log("stageData.maxTipThickness="+stageData.maxTipThickness); 
		stageData.divOptAR = getFloatParam('divOptAR'+cType2, 1.0 );

		//stageData.cStressMaxMPa2 = getFloatParam('cStressMaxMPa2', 568);
		//stageData.tempStressMaxMPa2 = getFloatParam('tempStressMaxMPa2', 923);
		//stageData.bladeCoolingK = getFloatParam('bladeCoolingK', 100);
		stageData.bladeOfStageWidth = getFloatParam('bladeOfStageWidth', 0.25);
		stageData.maxStressExceeded = false;
	    const hotCompressorTypeConstantH = stageData.constantRpm || $('#'+cType3+'TypeConstantH').prop('checked');
console.log("cStages="+stageData.cStages+", grossPower="+grossPower+", hotCompressorTypeConstantH="+hotCompressorTypeConstantH+", constantDiameter="+stageData.constantDiameter); 
if (stageData.cStages == 0) throw new Error("Stage count caanot be zero!");
		if (hotCompressorTypeConstantH && stageData.cStages && grossPower) {
			if (name == 'Hydrogen' && stageData.cStages == 14) {
				$('#cStages').val("55");
				stageData.cStages = 55;
			}
			stageData.grossPower = grossPower;
			stageData.massFlowInKg = massFlowInKg;
			stageData.constantDeltaH = (grossPower / stageData.cStages) / massFlowInKg;
			const meanU = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMean);
			stageData.v = meanU*stageData.flowCoefficientMean;
			stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
//console.log("stageData.constantDeltaH="+stageData.constantDeltaH); 
		}
		else {
			stageData.constantDeltaH = 0;
		}
		stageData.pressureAdjusted = stageData.constantRpm && $('#'+cType+'PressureAdjusted').prop('checked'); //$('#hpCompressorOne').prop('checked');	// adjusted for hub/tip
		if (stageData.pressureAdjusted) {
			var pInlet;
			const pRel = last.p/first.p;
			stageData.firstToLastDeltaH = 1;
			if (gIsHpCompressorOne) {
				stageData.hubToTipRatio = getFloatParam(cType+'HubToTipRatio', 0.90);
				stageData.constantDeltaH = (grossPower / stageData.cStages) / massFlowInKg;
				const meanU = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMean);
				stageData.v = meanU*stageData.flowCoefficientMean;
				var hKinetic = 0.5*stageData.v*stageData.v;	// kinetic energy is almost zero in heat exchanger!
				var rMid = meanU/(2*Math.PI*stageData.rpm/60);
				var area, hubToTip, rHub, rTip;
				console.log("stageData.hubToTipRatio="+stageData.hubToTipRatio+", stageData.v="+stageData.v+", rMid="+rMid+", meanU="+meanU+", massFlowInKg="+massFlowInKg+", stageData.constantDeltaH="+stageData.constantDeltaH);
				var prevS = 0;
				var tInlet, area, d, cLoops = 0;
				first = Object.assign({}, first );	// // make a copy
				while (Math.abs(prevS - first.s) > 0.001)
				{
					tInlet = Module.PropsSI('T', 'S', prevS = first.s, 'H', first.h - hKinetic, name); // approximation, assume constant temperature drop
					testResult( stageData.hubToTipRatio, 50000, 20000000, stageData.hubToTipRatio*0.01, function (p) {
						pInlet = p;
						d = Module.PropsSI('D', 'P', p, 'T', tInlet, name);
						area = massFlowInKg/d/stageData.v;
						rTip = Math.sqrt(area/(2*Math.PI)+rMid*rMid);
						rHub = Math.sqrt(rMid*rMid-area/(2*Math.PI));
						return hubToTip = rHub / rTip;
					}, 15);
					first.s = Module.PropsSI('S', 'P', pInlet, 'T', tInlet, name);	// assume no loss
					cLoops++;
				}
				console.log("loops="+cLoops+", area="+area+", pRel="+pRel+", stageData.v="+stageData.v+", rTip="+rTip+", rHub="+rHub);
				//const hInlet = Module.PropsSI('H', 'P', pInlet, 'T', tInlet, name);
				first.p = Module.PropsSI('P', 'S', first.s, 'T', first.t, name);
			}
			else {
				first = Object.assign({}, first );		// make a copy
				first.p = prevHeatPumpHighP;
				first.s = Module.PropsSI('S', 'P', first.p, 'T', first.t, name);	// assume no loss
			}
			first.h = Module.PropsSI('H', 'P', first.p, 'T', first.t, name);
			first.d = Module.PropsSI('D', 'P', first.p, 'T', first.t, name);
			last = Object.assign({}, last );
			last.p = first.p*pRel;
			last.s = Module.PropsSI('S', 'P', last.p, 'T', last.t, name);	// assume no loss
			last.h = Module.PropsSI('H', 'P', last.p, 'T', last.t, name);
			last.d = Module.PropsSI('D', 'P', last.p, 'T', last.t, name);
			if (isCompressor) {
				prevHeatPumpHighP = last.p;
				if (!gIsHpCompressorOne) {
					console.log("Change hpHighPressureKPa="+prevHeatPumpHighP);
					$('#hpHighPressureKPa').val(Math.round(prevHeatPumpHighP/1000));
				}
			}
			console.log("area="+area+", rTip="+rTip+", rHub="+rHub+", d="+d+", first="+JSON.stringify(first)+", last="+JSON.stringify(last));
		}
		var speedIn = (massFlowInKg/first.d)/(Math.PI*inletPipeDiameter*inletPipeDiameter/4); 
		var speedOut = (massFlowInKg/last.d)/(Math.PI*exitPipeDiameter*exitPipeDiameter/4);

		//speedIn = speedOut = Math.min(speedIn,speedOut); // set the same velocity in the both sides 
		stageData.vPipeOut = speedOut;
		stageData.vPipeIn = speedIn;
		transformToStaticValues( first, speedIn);
		transformToStaticValues( last, speedOut);
		stageData.pIn = first.p;
		stageData.pOut = last.p;
		// d < d0 => if the velocity is the same, we must update the diameters
		inletPipeDiameter = Math.sqrt(4*massFlowInKg/(first.d*speedIn*Math.PI));
		exitPipeDiameter = Math.sqrt(4*massFlowInKg/(last.d*speedOut*Math.PI));

		if (first.t < 273)
		{
			if (hotCompressorTypeConstantH) {
				if (name == 'Hydrogen' && stageData.cStages == 14) {
					$('#cStages'+cType2).val("30");
					stageData.cStages = 33;
				}
				stageData.constantDeltaH = (grossPower / stageData.cStages) / massFlowInKg;
				const meanU = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMean);
				stageData.v = meanU*stageData.flowCoefficientMean;
				stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
//console.log("Cold stageData.constantDeltaH="+stageData.constantDeltaH);
			}
			else {
				stageData.constantDeltaH = 0;
				stageData.machMaxSpeed = getFloatParam('machMaxSpeedCold', 0.95);		// < 0.8 => subsonic, <= 1.2 => transonic, Relative MACH number in rotor tip, TOP SPEED OF GAS RELATIVE TO BLADE AND STAGE: Use Vrel1(β1) instead Vasb2!!!!
			}
		}
		stageData.maxStatorHubAbsSpeed = 0.7;	// ABSOLUTE MACH NUMBER IN STATOR HUB
		stageData.K = 0.55;			// defines <tip section area>/<hub section area>, typical range 0.55-0.65
		stageData.massFlowInKg = massFlowInKg;
		stageData.flowCoefficientToStageLoadingCoefficient = 1;
		stageData.maxRpmStages = 1;
		stageData.vGearMax = 180; // RENK Het Gear: max pitch line velocity 
		stageData.efficiency = stageEfficiency;
		stageData.stageEfficiencies = [];
		stageData.aspectRatios = [];
		stageData.blockageFactors = [];
		const midToTip = Math.sqrt((1 + stageData.hubToTipRatio*stageData.hubToTipRatio)/2);
		stageData.stageLoadingCoefficientMin = stageData.stageLoadingCoefficientMean*(midToTip**2);
		stageData.flowCoefficientMin = stageData.flowCoefficientMean*midToTip;

		stageData.tanβ1 = stageData.isCompressor ? (stageData.reaction + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin :
													(-stageData.reaction + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
		stageData.tanβ2 = stageData.isCompressor ? (stageData.reaction - stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin :
												   (stageData.reaction + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
		if (stageData.reaction == 0.5) {
			stageData.tanα1 = stageData.tanβ2;
			stageData.tanα2 = stageData.tanβ1;
		}
		else {
			stageData.tanα1 = stageData.isCompressor ? (1 - stageData.reaction - stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin :
														(1 - stageData.reaction + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
			stageData.tanα2 = stageData.isCompressor ? (1 - stageData.reaction + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin :
														(-(1 - stageData.reaction) + stageData.stageLoadingCoefficientMin/2)/stageData.flowCoefficientMin;
		}
		stageData.β1deg = 180 * Math.atan(stageData.tanβ1)/Math.PI;
		stageData.β2 = Math.atan(stageData.tanβ2);
		stageData.β2deg = 180 * stageData.β2/Math.PI;
		stageData.β1 = Math.atan(stageData.tanβ1);

		stageData.hubStageLoadingCoefficient = stageData.stageLoadingCoefficientMin/(stageData.hubToTipRatio*stageData.hubToTipRatio);
		stageData.hubFlowCoefficient = stageData.flowCoefficientMin / stageData.hubToTipRatio;
		stageData.hubβ1 = stageData.isCompressor ? Math.atan((stageData.reaction + stageData.hubStageLoadingCoefficient/2)/stageData.hubFlowCoefficient) :
												   Math.atan((-stageData.reaction + stageData.hubStageLoadingCoefficient/2)/stageData.hubFlowCoefficient);
		stageData.hubβ1deg = 180 * stageData.hubβ1/Math.PI;
		stageData.hubα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - stageData.hubStageLoadingCoefficient/2)/stageData.hubFlowCoefficient) :
												   Math.atan(((1-stageData.reaction) + stageData.hubStageLoadingCoefficient/2)/stageData.hubFlowCoefficient);
		{
			const midStageLoadingCoefficient = stageData.stageLoadingCoefficientMean;
			const midFlowCoefficient =  stageData.flowCoefficientMean;
			// keep the axial speed constant!
			//stageData.inletα1 = 0;  // Math.atan(((1-stageData.reaction) - midStageLoadingCoefficient/2)/(midFlowCoefficient));
		}
		// rMid*rMid/(rTip*rTip) = (rTip*rTip+rHub*rHub)/2/(rTip*rTip);
		// => rMid/rTip = sqrt((1+hubToTip*hubToTip)/2);
		/*const midToTip = Math.sqrt((1+stageData.hubToTipRatio*stageData.hubToTipRatio)/2);
		const midStageLoadingCoefficient = stageData.stageLoadingCoefficientMin/(midToTip*midToTip);
		const midFlowCoefficient = stageData.flowCoefficientMin / midToTip;
		stageData.midAplha1 = Math.atan(((1-stageData.reaction) - midStageLoadingCoefficient/2)/(midFlowCoefficient));*/

		// almost ordinary steel:
		stageData.shaftStrength = getFloatParam('shaftStrength',1000)*1000000 * 0.3;	// 0.4 OK for short term, max strength 1000 MPa * 0.3 => long term strength as shaft 300 MPa = 300000000 N/m2, short term 0.4
		stageData.shaftBearingSpace = getFloatParam('bearingSpace',2)/1000;	// 2 mm is probably enough for bearing, but is it enough for bearing oil pipe if used
		//stageData.shaftBearingSpace = 0.002;	// 5 mm is probably enough for bearing, but is it enough for bearing oil pipe if used
		stageData.rInnerShaftCoolingPipe = 0.010;	// 
		stageData.minShaftPipeWidth = getFloatParam('minShaftPipeWidth', 5)/1000;	//

console.log("stageData:"+JSON.stringify(stageData));
		stageData.getDeltaH = function( stageData, stage, item ) {
			//	Cuts down the power if the max tensile stress would exceeded
			const reaction = stageData.reaction ? stageData.reaction : 0.5;
			const hMm = (stage.rTip - stage.rHub) * 1000;
			const absTipGap = stageData.tipGapMm / hMm;
			stage.tipGap = absTipGap > stageData.tipGapPercent/100 ? absTipGap : stageData.tipGapPercent/100;

			var stageLoadingCoefficient = stageData.constantRpm ? stage.stageLoadingCoefficient : stageData.stageLoadingCoefficientMin;
			stage.U = Math.sqrt(Math.abs(stage.hDeltaPower)/ stage.stageLoadingCoefficient);
			stage.flowCoefficient =  stage.v / stage.U;

			if (typeof stage.flowCoefficient === 'undefined') {
				stage.flowCoefficient = stage.v/stage.U;
			}
			const tipβ1 = stageData.isCompressor ? Math.atan((reaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
												   Math.atan((-reaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			stage.machRelTip = stage.v / Math.cos(tipβ1) / stage.mach;	// for blade selection

 			var deltaH = stage.deltaH ? stage.deltaH : typeof stage.hDeltaPower === 'undefined' ? stage.U*stage.U*stageLoadingCoefficient : stage.hDeltaPower;
			if (Number.isNaN(deltaH)) throw new Error("stage.deltaH="+deltaH);
			if (!stageData.isCompressor && deltaH > 0) {
				stage.deltaH = deltaH = -deltaH;
			}
			//if () stage.hDeltaPower = deltaH;
			if (typeof stage.hDeltaPower === 'undefined' || Number.isNaN(stage.hDeltaPower)) throw new Error("stage.hDeltaPower="+stage.hDeltaPower);
			if (!stageData.constantRpm && item.t > 273 && stageData.hubToTipRatioMax != stageData.hubToTipRatio) {
				stageLoadingCoefficient = (stageLoadingCoefficient + stageData.stages.length*0.0082) < 0.3 ? 
					(stageLoadingCoefficient + stageData.stages.length*0.0082) : 0.3;
//console.log("stageLoadingCoefficient="+stageLoadingCoefficient);
				stage.U = Math.sqrt(stage.hDeltaPower/stageLoadingCoefficient);
			}
			// no need to check max tensile stress below 500 Celsius
			var alloyDensity;
			if (item.t > 773) {
				var hRemaining = (stageData.isCompressor ? stageData.hStagnOut - item.h : item.h - stageData.hStagnOut) + 0.5*stage.v*stage.v;
				if (Math.abs(hRemaining) < Math.abs(deltaH)) {
					stage.isLast = true;
				}
				// U^2 = deltaH/stageLoadingCoefficient;
				const efficiency = typeof stageData.stageEfficiencies[stageData.stages.length] !== 'undefined' ? stageData.stageEfficiencies[stageData.stages.length] : stageData.efficiency;
				const hActualWork = stage.hDeltaPower * (stageData.isCompressor ? efficiency : -1/efficiency) + stage.hDeltaKinetic;
				const pOut = Module.PropsSI('P','H', item.h+hActualWork, 'S', item.s, name);
				const tOut = Module.PropsSI('T','H', item.h+deltaH, 'P', pOut, name);
				const tUncooledBlade = item.t + (tOut-item.t)/2; // reaction 50%! //*stageData.bladeOfStageWidth;
				stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				alloyDensity = 8525;		// MAR-M 200: density 8450-8600 kg/m3
				if (tUncooledBlade > stageData.tempStressMaxMPa) {
					stage.bladeCoolingK = tUncooledBlade - stageData.tempStressMaxMPa;
				}
				else if (tUncooledBlade > stageData.tempMaxStressMPaDecr) {
					stage.bladeCoolingK = 0;
					stage.maxTensileStressMPa -= (tUncooledBlade - stageData.tempMaxStressMPaDecr)*stageData.tempMaxStressMPaDecrValue; // default 1 MPa/K
				}
				else {
					alloyDensity = 8001;		// Nimonic 105
					stage.bladeCoolingK = 0;
				}
//console.log("#"+stageData.stages.length+": tUncooledBlade="+tUncooledBlade+", tempMaxStressMPaDecr="+stageData.tempMaxStressMPaDecr+"=>stage.maxTensileStressMPa="+stage.maxTensileStressMPa);
				stage.stageLoadingCoefficient = stageLoadingCoefficient;
/*
	Let's assume cooling down to the max strength area
				const tBladeMax = tUncooledBlade - stageData.bladeCoolingK;
				stage.maxTensileStressMPa = tBladeMax <= stageData.tempStressMaxMPa ? stageData.cStressMaxMPa :
					stageData.cStressMaxMPa2 + 	
					(stageData.cStressMaxMPa-stageData.cStressMaxMPa2)/(stageData.tempStressMaxMPa2-stageData.tempStressMaxMPa)
					* (stageData.tempStressMaxMPa2-tBladeMax);
				if (stage.maxTensileStressMPa > stageData.cStressMaxMPa) stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				if (tUncooledBlade > stageData.tempStressMaxMPa) {
					stage.bladeCoolingK = tUncooledBlade - stageData.tempStressMaxMPa;
				}
				if (stage.centrifugalStressMpa < stage.maxTensileStressMPa) {
					stage.stageLoadingCoefficient = stageLoadingCoefficient;
				}
				else {
					stage.centrifugalStressMpa = stage.maxTensileStressMPa;
					stage.stageLoadingCoefficient = myStressCoefficient*stage.hDeltaPower / stage.centrifugalStressMpa;
				}
*/
			}
			else {
				alloyDensity = item.t < 273 ? 7800 : 8001;		// austenitic steel or Nimonic 105
				stage.stageLoadingCoefficient = stageLoadingCoefficient;
				stage.maxTensileStressMPa = stageData.cStressMaxMPa;
				stage.bladeCoolingK = 0;
			}
			//myStressCoefficient = 0.5*alloyDensity*(1-stage.hubToTipRatio*stage.hubToTipRatio)*K/1000000;
			// dynamic stage chord and aspect ratio calculion based on unused tensile stress
			//stage.tensileStressPercent = Math.round((stage.centrifugalStressMpa / stage.maxTensileStressMPa) * 100)+" %";
			stage.deltaH = deltaH;
			if (Number.isNaN(stage.deltaH)) throw new Error("stage.deltaH="+stage.deltaH);
			if (typeof stage.hDeltaPower === 'undefined') stage.hDeltaPower = deltaH;
			if (Number.isNaN(stage.hDeltaPower)) throw new Error("stage.hDeltaPower="+stage.hDeltaPower);

			// Argon has a very high viscosity  near to the saturation tempreature. 
			// It produces a very low Reynolds number that is not representation for the temp range of the whole stage 
			var visc = Module.PropsSI('V', 'P', item.p, 'T', item.t < 100 ? item.t+1 : item.t, name);
			var dPlus1 = Module.PropsSI('D', 'P', item.p, 'T', item.t < 100 ? item.t+1 : item.t, name);
			if (typeof item.d === 'undefined') item.d = Module.PropsSI('D', 'P', item.p, 'T', item.t, name);
			if (!item.d || typeof item.d === 'undefined') item.d = dPlus1;
			if (visc == Infinity || Number.isNaN(visc)) visc = Module.PropsSI('V', 'P', item.p+1000, 'T', item.t+2, name);
			if (dPlus1 == Infinity || Number.isNaN(dPlus1)) dPlus1 = Module.PropsSI('D', 'P', item.p+1000, 'T', item.t+2, name);
			stage.viscPlus1 = visc;
			stage.dPlus1 = dPlus1;
			stage.dynamicVisc = stage.dPlus1 / stage.viscPlus1;

			stage.s = item.s; // Module.PropsSI('S','P', item.p, 'H', item.h, name);	// use h for wet gas!
			stage.h = item.h;
			if (stageData.stages.length == 0 && stageData.inlet.h != item.h) throw new Error("Bad inlet");

			stage.deltaH = deltaH = (stageData.isCompressor ? 1 : -1)*stage.hDeltaPower + stage.hDeltaKinetic;

//stageData.massFlowInKg /stage.d
			//const area =  stage.flowM3Mid/stage.blockageFactorMid / (xV*(stageData.constantRpm ? 1 : (stageData.horizontalVectors && stageData.horizontalVectors.length>stageData.stages.length ?  stageData.horizontalVectors[stageData.stages.length] : stageData.horizontalVector)));
			var prevDeltaH = 0, cLoops = 0, hubToTip;
			const efficiency = typeof stageData.stageEfficiencies[stageData.stages.length] !== 'undefined' ? stageData.stageEfficiencies[stageData.stages.length] : stageData.efficiency;
			while (Math.abs(deltaH-prevDeltaH) > Math.abs(deltaH/100))
			{
if (cLoops > 2) console.log(stageData.stages.length+": loop="+cLoops+", hDelta error="+(deltaH-prevDeltaH)/deltaH);
				cLoops++;
				const hActualWork = stage.hDeltaPower * (stageData.isCompressor ? efficiency : -1/efficiency) + stage.hDeltaKinetic;
				stage.pMid = Module.PropsSI('P','S', stage.s, 'H', stage.h+hActualWork*(stageData.isCompressor ? reaction : 1 - reaction), name);
				stage.pOut = Module.PropsSI('P','S', stage.s, 'H', stage.h+hActualWork, name);
				stage.hMid = stage.h+stage.deltaH*(stageData.isCompressor ? reaction : 1 - reaction);
				stage.hOut = stage.h+stage.deltaH;
				stage.dOut = Module.PropsSI('D', 'P', stage.pOut, 'H', stage.hOut, name);
				if (stage.pMid === Infinity) {
					// we seems to be still wet
					stage.tOut = Module.PropsSI('T','S', stage.s, 'H', stage.h+hActualWork, name);
					stage.tMid = item.t + (stage.tOut-item.t)*(stageData.isCompressor ? reaction : 1 - reaction);
					stage.pMid = Module.PropsSI('P','T', stage.tMid, 'Q', 1, name) - 100;	// 100 Pa below saturation point
					console.log("h at p,t=("+stage.pMid+","+stage.tMid+") would be :"+Module.PropsSI('H','P', stage.pMid, 'T', stage.tMid, name));
				}
				if (stage.pMid === Infinity) {
					const h = stage.h+hActualWork*(stageData.isCompressor ? reaction : 1 - reaction);
					console.log("h="+h+" wet?, pSat="+Module.PropsSI('P','S', stage.s, 'Q', 1, name));
					const pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, name);
					const tTriplePoint =  Module.PropsSI('T_TRIPLE', '', 0, '', 0, name);
					console.log(stageData.stages.length+": stage="+JSON.stringify(stage));
					console.log("Some part of gas will be frozen in the inlet of "+title+". The gas temperature ("+myRound(item.t,2)+" K) and pressure ("+myRound(item.p)+" Pa) should not be below the tripple point temperature "+myRound(tTriplePoint,2)+" K / "+Math.round(pTriplePoint)+" Pa of "+name+"! Increase the low pressure or decrease the pressure ratio and try again.");
					throw new Error("Too wet??");
				}
				stage.dMid = Module.PropsSI('D','P', stage.pMid, 'H', stage.hMid, name);
				const nextAspectRatio = stageData.aspectRatios.length > stageData.stages.length ? stageData.aspectRatios[stageData.stages.length+1] : stage.aspectRatio;
				stage.blockageFactor = getBlockageFactor(stageData, stageData.stages.length, stage.aspectRatio);
				stage.blockageFactorOut = getBlockageFactor(stageData, stageData.stages.length+1, nextAspectRatio);
				stage.blockageFactorMid = (stage.blockageFactor+stage.blockageFactorOut)/2;
				
				const flowM3Mid = stageData.massFlowInKg /stage.dMid;
				var vMid, vOut; 
				if (stageData.constantDeltaH) {
					vMid = vOut = stageData.v;
				}
				else {
					stage.machMid = Module.PropsSI('SPEED_OF_SOUND','P', stage.pMid, 'H', stage.hMid, name);
					if (stage.machMid === Infinity) {
						stage.machMid = Module.PropsSI('SPEED_OF_SOUND','P', stage.pMid, 'Q', 1, name);
					}
					stage.machOut = Module.PropsSI('SPEED_OF_SOUND', 'P', stage.pOut, 'H', stage.hOut, name);
					if (stage.machOut === Infinity) {
						stage.machOut = Module.PropsSI('SPEED_OF_SOUND','P', stage.pOut, 'Q', 1, name);
					}
					vMid = stageData.vMach*stage.machMid;
					vOut = stageData.vMach*stage.machOut;
				}
				const areaMid =  flowM3Mid/stage.blockageFactorMid / (vMid*(stageData.constantRpm ? 1 : (stageData.horizontalVectors && stageData.horizontalVectors.length>stageData.stages.length ?  stageData.horizontalVectors[stageData.stages.length] : stageData.horizontalVector)));
				const flowM3Out = stageData.massFlowInKg /stage.dOut;
				const areaOut =  flowM3Out/stage.blockageFactorOut / (vOut*(stageData.constantRpm ? 1 : (stageData.horizontalVectors && stageData.horizontalVectors.length>stageData.stages.length ?  stageData.horizontalVectors[stageData.stages.length] : stageData.horizontalVector)));
	if (Number.isNaN(areaOut)) throw new Error("areaOut="+areaOut);
				if (stageData.constantRpm) {
					if (stageData.constantDiameter == 'inner') {
						stage.rHubMid = stage.rHubOut = stageData.rHub;
						stage.rMidMid = Math.sqrt(stage.rHubMid*stage.rHubMid+areaMid/(2*Math.PI));
						stage.rTipMid = Math.sqrt(stage.rHubMid*stage.rHubMid+areaMid/Math.PI);
						stage.rMidOut = Math.sqrt(stage.rHubOut*stage.rHubOut+areaOut/(2*Math.PI));
						stage.rTipOut = Math.sqrt(stage.rHubOut*stage.rHubOut+areaOut/Math.PI);
					}
					else if (stageData.constantDiameter == 'outer') {
						stage.rTipMid = stage.rTipOut = stageData.rTip;
						stage.rMidMid = Math.sqrt(stage.rTipMid*stage.rTipMid-areaMid/(2*Math.PI));
						stage.rHubMid = Math.sqrt(stage.rTipMid*stage.rTipMid-areaMid/Math.PI);
						stage.rMidOut = Math.sqrt(stage.rTipOut*stage.rTipOut-areaOut/(2*Math.PI));
						stage.rHubOut = Math.sqrt(stage.rTipOut*stage.rTipOut-areaOut/Math.PI);
					}
					else {
						// mean
						stage.rMidMid = stage.rMidOut = stageData.rMid;
						stage.rTipMid = Math.sqrt(areaMid/(2*Math.PI)+stage.rMidMid*stage.rMidMid);
						stage.rHubMid = Math.sqrt(stage.rMidMid*stage.rMidMid-areaMid/(2*Math.PI));
						stage.rTipOut = Math.sqrt(areaOut/(2*Math.PI)+stage.rMidOut*stage.rMidOut);
						stage.rHubOut = Math.sqrt(stage.rMidOut*stage.rMidOut-areaOut/(2*Math.PI));
					}
/*if (stageData.stages.length < 2) 
	console.log(stageData.stages.length+":areaIn="+area+", tipIn="+stage.rTip+
		", areaMid="+areaMid+", tipMid="+stage.rTipMid+", areaOut="+areaOut+", tipOut="+stage.rTipOut);*/
				}
				else {
					stage.rTipMid = Math.sqrt(areaMid/(Math.PI*(1-stage.hubToTipRatio*stage.hubToTipRatio)));
					stage.rHubMid = stage.rTipMid * stage.hubToTipRatio;
					stage.rTipOut = Math.sqrt(areaOut/(Math.PI*(1-stage.hubToTipRatio*stage.hubToTipRatio)));
					stage.rHubOut = stage.rTipOut * stage.hubToTipRatio;
					stage.rMidOut = Math.sqrt((stage.rTipOut*stage.rTip+stage.rHubOut*stage.rHubOut)/2);
					stage.rMidMid = Math.sqrt((stage.rTipMid*stage.rTipMid+stage.rHubMid*stage.rHubMid)/2);
				}
				hubToTip = stageData.isCompressor ? stage.rHub / stage.rTip : stage.rHubMid / stage.rTipMid;
				stage.hubToTipRatio = hubToTip;
				stage.hubStageLoadingCoefficient = stage.stageLoadingCoefficient/(hubToTip*hubToTip);
				stage.hubFlowCoefficient = stage.flowCoefficient / hubToTip;
				const hubα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) :
													   Math.atan((-(1-stageData.reaction) + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)); 
				const hubC1 = stage.v/Math.cos(hubα1);
/*
				// first stage accelerates 
				const midC1 = stage.v/Math.cos(stage.midα1);
				const tipα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - stage.stageLoadingCoefficient/2)/(stage.flowCoefficient)) :
														   Math.atan((-(1-stageData.reaction) + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
				const tipC1 = stage.v/Math.cos(tipα1);
*/
				if (stageData.stages.length == 0) {
					// the use min spanwise velocity  as an inlet velocity of the first rotor row
					// the min velocity is that of hub for compressors and the mean velocity for turbins
					// Only the rotor row is able to accelerate fluid for different spanwise velocities or deccelerate to a constant spanwise exit velocity
					const inletC1 = stageData.isCompressor ? hubC1 : stage.v
					if (stageData.isCompressor && stageData.constantDeltaH && (stageData.inletC1 === 'undefined' || (Math.round(stageData.inletC1*10) != Math.round(inletC1*10)))) {
						stageData.inletC1 = inletC1;
						item = inlet = stageData.inlet = initCryogenicInlet(stageData, stageData.first );
						stage.p = inlet.p;
						stage.h = inlet.h;
						stage.t = inlet.t;
						stage.s = inlet.s;
						stage.d = inlet.d;
						visc = Module.PropsSI('V', 'P', item.p, 'T', item.t < 100 ? item.t+1 : item.t, name);
						dPlus1 = Module.PropsSI('D', 'P', item.p, 'T', item.t < 100 ? item.t+1 : item.t, name);
						if (typeof item.d === 'undefined') item.d = Module.PropsSI('D', 'P', item.p, 'T', item.t, name);
						if (!item.d || typeof item.d === 'undefined') item.d = dPlus1;
						if (visc == Infinity || Number.isNaN(visc)) visc = Module.PropsSI('V', 'P', item.p+1000, 'T', item.t+2, name);
						if (dPlus1 == Infinity || Number.isNaN(dPlus1)) dPlus1 = Module.PropsSI('D', 'P', item.p+1000, 'T', item.t+2, name);
						stage.mach = Module.PropsSI('SPEED_OF_SOUND','P', stage.p, 'H', stage.h, name);
						if (stage.mach === Infinity) {
							stage.mach = Module.PropsSI('SPEED_OF_SOUND','P', stage.p, 'T', item.t+0.5, name);
						}
						stage.viscPlus1 = visc;
						stage.dPlus1 = dPlus1;
						stage.dynamicVisc = stage.dPlus1 / stage.viscPlus1;
						stage.flowM3 = inlet.flowM3;
						const area = stage.flowM3 / stage.v; // inlet blockageFactor == 1 
						stageData.rTip = stage.rTip = Math.sqrt(area/(2*Math.PI)+stage.rMid*stage.rMid);
						stageData.rHub = stage.rHub = Math.sqrt(stage.rMid*stage.rMid-area/(2*Math.PI));
						stage.flowCoefficient = stageData.flowCoefficientMin = stageData.flowCoefficientMean*stage.rMid/stage.rTip;
						stage.stageLoadingCoefficient = stageData.stageLoadingCoefficientMin = stageData.stageLoadingCoefficientMean*((stage.rMid/stage.rTip)**2);
						stageData.U = stage.U = stage.rTip*2*Math.PI*stageData.rpm/60;
console.log("init: area="+area+", tip="+stage.rTip);
						continue;
					}
					const inletVx = stageData.inlet.v;
					stage.hKineticIn = 	0.5*(inletVx*inletVx);	// 
					//if ((inletVx*inletVx) != inletVx**2) throw new Error("What???");
					//if (stageData.inlet.h0 != (stageData.inlet.h + 0.5*(stageData.inlet.v**2))) throw new Error("Whaat???");
					stage.h0=stage.h+stage.hKineticIn;
					//if (stage.h0 != (stage.h+0.5*(inletVx**2))) throw new Error("Whaaat???");
					console.log("hStagnIn="+stageData.hStagnIn+", inlet.h0="+(stageData.inlet.h+0.5*(stageData.inlet.v**2))+
							", stage0.h0="+(stage.h+stage.hKineticIn));
					if (Math.round(stage.h0) != Math.round(stageData.first.h0)) throw new Error("Lost enthalpy!");
					//stage.hKineticIn = 	stageData.isCompressor ? 0.5*(hubC1*hubC1) : 0.5*(stage.v*stage.v);	// 
				}
				else {
					stage.hKineticIn = stageData.stages[stageData.stages.length-1].hKineticOut;
					//(0.5*(tipC1*tipC1) + 0.5*(midC1*midC1) + 0.5*(hubC1*hubC1))/3;	// // approximation of spanwise kinetic energy
				}
				if (Number.isNaN(stage.hKineticIn)) throw new Error("error");
				//if (stageData.stages.length < (stageData.cStages-1)) 
				{
					const midOutToTip = stage.rMidOut / stage.rTip;
					const midOutStageLoadingCoefficient = stage.stageLoadingCoefficient/(midOutToTip*midOutToTip);
					const midOutFlowCoefficient = stage.flowCoefficient / midOutToTip;
					const midOutα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - midOutStageLoadingCoefficient/2)/(midOutFlowCoefficient)) :
															  Math.atan((-(1-stageData.reaction) + midOutStageLoadingCoefficient/2)/(midOutFlowCoefficient));
					const midC3 = stage.v/Math.cos(midOutα1);
					
					const hubOutToTip = stage.rHubOut / stage.rTip;
					const hubOutStageLoadingCoefficient = stage.stageLoadingCoefficient/(hubOutToTip*hubOutToTip);
					const hubOutFlowCoefficient = stage.flowCoefficient / hubOutToTip;
					const hubOutα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - hubOutStageLoadingCoefficient/2)/(hubOutFlowCoefficient)) :
															  Math.atan((-(1-stageData.reaction) + hubOutStageLoadingCoefficient/2)/(hubOutFlowCoefficient));
					const hubC3 = stage.v/Math.cos(hubOutα1);

					const tipOutToTip = stage.rTipOut / stage.rTip;
					const tipOutStageLoadingCoefficient = stage.stageLoadingCoefficient/(tipOutToTip*tipOutToTip);
					const tipOutFlowCoefficient = stage.flowCoefficient / tipOutToTip;
					const tipOutα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - tipOutStageLoadingCoefficient/2)/(tipOutFlowCoefficient)) :
															  Math.atan((-(1-stageData.reaction) + tipOutStageLoadingCoefficient/2)/(tipOutFlowCoefficient));
					const tipC3 = stage.v/Math.cos(tipOutα1);
					stage.hKineticOut = (0.5*(tipC3*tipC3) + 0.5*(midC3*midC3) + 0.5*(hubC3*hubC3))/3;	// approximation of spanwise kinetic energy
					if (Number.isNaN(stage.hKineticOut)) throw new Error("error");
				}
				stage.hDeltaKinetic = stage.hKineticIn - stage.hKineticOut;
				prevDeltaH = deltaH;
				stage.deltaH = deltaH = (stageData.isCompressor ? 1 : -1)*stage.hDeltaPower + stage.hDeltaKinetic;
				if (Number.isNaN(stage.hDeltaKinetic) || Number.isNaN(deltaH)) throw new Error("error");

				const hDeltaKineticInExit = stage.hKineticOut - 0.5*(stageData.vPipeOut**2);
				const h0Cur = item.h + stage.deltaH*1.5 + stage.hKineticOut;
	//console.log(stageData.stages.length+": hCur="+hCur+", stageData.hEnd="+stageData.hEnd+", hKineticInExit="+hKineticInExit);
				if ((stageData.isCompressor && h0Cur > stageData.hEnd) || (!stageData.isCompressor && h0Cur < stageData.hEnd))
				{ // !stage.isLast && 
					// this the last stage, let's calc the work (new stage.deltaH) needed to reach the target pHigh,
					// end temperature does not matter, because we can adjust the start temperature, but the end pressure must be the configured pHigh!
					// We assume the pressure rise by speed decreasing is done by constant entropy (constant s)
					//const hActualNow = item.h + stage.hKinetic - 0.5*stageData.vPipeOut*stageData.vPipeOut;
					//const hTarget = Module.PropsSI('H','S', item.s, 'P', stageData.pHigh, name);
//console.log(stageData.stages.length+" before: stage.deltaH="+stage.deltaH+", stage.hDeltaPower="+stage.hDeltaPower+", stage.hDeltaKinetic="+stage.hDeltaKinetic);
					var exit = {};
					{
						const pEnd = stageData.isCompressor ? stageData.pHigh : stageData.pLow;
						const hFrom = stageData.isCompressor ? 0 : stage.hDeltaPower*1.5;
						const hTo = !stageData.isCompressor ? 0 : stage.hDeltaPower*1.5;
						ret = testResult( pEnd, hFrom, hTo, pEnd*0.0001, function(deltaH) {
							const hDeltaPower = deltaH;
							const efficiency = typeof stageData.stageEfficiencies[stageData.stages.length] !== 'undefined' && stageData.stageEfficiencies[stageData.stages.length] 
												? stageData.stageEfficiencies[stageData.stages.length] : stageData.efficiency;
							const hActualWork = hDeltaPower * (stageData.isCompressor ? efficiency : -1/efficiency) + stage.hDeltaKinetic;
							const p = Module.PropsSI('P','S', item.s, 'H', item.h+hActualWork, name);
							stage.deltaH = (stageData.isCompressor ? 1 : -1)*hDeltaPower + stage.hDeltaKinetic;	// 
							const h = item.h+stage.deltaH;
							stage.pOut = p;
							stage.hOut = h;
							stage.sOut = Module.PropsSI('S','P', stage.pOut, 'H', stage.hOut, name);
							exit.h = h + hDeltaKineticInExit; // extra part is transformed to heat
							exit.hDeltaKinetic = hDeltaKineticInExit;
							exit.hLoss = Math.abs(hDeltaKineticInExit*(1-stageData.diffuserEfficiency));

							// only part of kinetic energy change transforms to pressure change in diffuser
							exit.p = Module.PropsSI('P','S', stage.sOut, 'H', h + hDeltaKineticInExit*stageData.diffuserEfficiency, name);
	//  stage.s=3259.111358782942, stage.sMid=undefined, stage.sOut=3258.9541777567847
	if (exit.p === Infinity) {
		console.log("Ignoring Infinite exit.p: deltaH="+stage.deltaH+", efficiency="+efficiency+", item="+JSON.stringify(item)+"; exit="+JSON.stringify(exit));
	}
				//console.log("p="+p+"=>"+JSON.stringify(next)+", hRet="+(next.h + 0.5*(nextC1*nextC1 - c1*c1)));
							return exit.p;
						});
						exit.t = Module.PropsSI('T','P', exit.p, 'H', exit.h, name);
						exit.s = Module.PropsSI('S','P', exit.p, 'H', exit.h, name);
						exit.d = Module.PropsSI('D','P', exit.p, 'H', exit.h, name);
						if (exit.d === Infinity) exit.d = Module.PropsSI('D','P', exit.p, 'Q', 1, name);
						exit.flowM3 = stageData.massFlowInKg /exit.d;
						exit.v = stageData.vPipeOut;
						stageData.hStagnOut = exit.h0 = exit.h + 0.5*(exit.v**2);
						exit.p0 = Module.PropsSI('P','S', exit.s, 'H', exit.h0, name);
						// set final value by actual stagnation enthalpy change
						stage.hDeltaPower = Math.abs(item.h + stage.hKineticIn - exit.h0);	// enthalpy in/out from the system
						if (Number.isNaN(stage.hDeltaPower)) throw new Error("stage.hDeltaPower="+stage.hDeltaPower);
//console.log(stageData.stages.length+" after: stage.deltaH="+stage.deltaH+", stage.hDeltaPower="+stage.hDeltaPower+", hDeltaKineticInExit="+hDeltaKineticInExit+", stage.hDeltaKinetic="+stage.hDeltaKinetic);
					}
					stageData.exit = exit;
console.log("exit: "+JSON.stringify(exit, null, 2)+", stage.hStagnOut="+(stage.hOut+stage.hKineticOut)+", stage.s="+stage.s+", stage.sMid="+stage.sMid+", stage.sOut="+stage.sOut);
					// recalc the last stage with correct in/out power
					const rpm = stage.rpm;
					stage.U = 2*Math.PI*stage.rTip*stage.rpm/60;
					stage.stageLoadingCoefficient = stage.hDeltaPower / (stage.U*stage.U);
					stage.midStageLoadingCoefficient = stage.hDeltaPower / ((stage.U*stage.rMid/stage.rTip)**2);
					stage.flowCoefficient = stage.v/stage.U;
					stage.midFlowCoefficient = stage.flowCoefficient * stage.rMid/stage.rTip;
					stage.hubStageLoadingCoefficient = stage.stageLoadingCoefficient/(hubToTip*hubToTip);
					stage.hubFlowCoefficient = stage.flowCoefficient / hubToTip;
					stage.isLast = true;
					stage.rpm = rpm;
					stage.isLast = true;
				}

			}
			if (stageData.stages.length == stageData.hDeltaKinetics.length) stageData.hDeltaKinetics.push(stage.hDeltaKinetic);
			else stageData.hDeltaKinetics[stageData.stages.length] = stage.hDeltaKinetic;
			
			stage.U = Math.sqrt(Math.abs(stage.hDeltaPower)/ stage.stageLoadingCoefficient);
			stage.flowCoefficient =  stage.v / stage.U;
			stage.pressureRiseCoefficient = 2*(stage.pMid-item.p)/(dPlus1*stage.U*stage.U);

			stage.sMid = Module.PropsSI('S','P', stage.pMid, 'H', stage.hMid, name);
			var visc2 = Module.PropsSI('V', 'P', stage.pMid, 'H', stage.hMid, name);
			if (visc2 == Infinity || Number.isNaN(visc2)) visc2 = Module.PropsSI('V','P', stage.pMid, 'Q', 1, name);
			if (visc2 == Infinity || Number.isNaN(visc2)) visc2 = Module.PropsSI('V', 'P', stage.pMid, 'H', stage.hMid+1000, name);
			stage.dMid = Module.PropsSI('D','P', stage.pMid, 'H', stage.hMid, name);
			if (stage.dMid == Infinity || Number.isNaN(stage.dMid)) stage.dMid = Module.PropsSI('D','P', stage.pMid, 'Q', 1, name);
			if (stage.dMid == Infinity || Number.isNaN(stage.dMid)) stage.dMid = Module.PropsSI('D', 'P', stage.pMid, 'H', stage.hMid+1000, name);
			stage.dynamicVisc2 = stage.dMid / visc2;
			if (stage.dynamicVisc2 == Infinity || Number.isNaN(stage.dynamicVisc2)) throw new Error("stage.dynamicVisc2="+stage.dynamicVisc2);
			stage.sOut = Module.PropsSI('S', 'P', stage.pOut, 'H', stage.hOut, name);
			const visc3 = Module.PropsSI('V', 'P', stage.pOut, 'H', stage.hOut, name);
			stage.dynamicVisc3 = stage.dOut / visc3;
			if (typeof stage.machMid === 'undefined') {
				stage.machMid = Module.PropsSI('SPEED_OF_SOUND','P', stage.pMid, 'H', stage.hMid, name);
				if (stage.machMid === Infinity) {
					stage.machMid = Module.PropsSI('SPEED_OF_SOUND','P', stage.pMid, 'Q', 1, name);
				}
			}
			if (typeof stage.machOut === 'undefined') {
				stage.machOut = Module.PropsSI('SPEED_OF_SOUND', 'P', stage.pOut, 'H', stage.hOut, name);
				if (stage.machOut === Infinity) {
					stage.machOut = Module.PropsSI('SPEED_OF_SOUND','P', stage.pOut, 'Q', 1, name);
				}
			}
			const rMiddle = stage.rMid; // Math.sqrt((stage.rTip*stage.rTip+stage.rHub*stage.rHub)/2);
 			const midToTip = stageData.isCompressor ? rMiddle / stage.rTip : stage.rMidMid / stage.rTipMid;
			const midStageLoadingCoefficient = stage.stageLoadingCoefficient/(midToTip*midToTip); // stageData.constantDiameter != 'mean' || !stage.midStageLoadingCoefficient ? stage.stageLoadingCoefficient/(midToTip*midToTip) : stage.midStageLoadingCoefficient;
			stage.midStageLoadingCoefficient = midStageLoadingCoefficient;
			if (Number.isNaN(stage.midStageLoadingCoefficient)) throw new Error("midStageLoadingCoefficient="+stage.midStageLoadingCoefficient);
			const midFlowCoefficient = stage.flowCoefficient / midToTip; // stageData.constantDiameter != 'mean' || !stage.midFlowCoefficient ? stage.flowCoefficient / midToTip : stage.midFlowCoefficient;
			stage.midFlowCoefficient = midFlowCoefficient;
			//const midToTip = rMiddle/stage.rTip;
			stage.tanβ1 = stageData.isCompressor ? (stageData.reaction + midStageLoadingCoefficient/2)/midFlowCoefficient :
												   (-stageData.reaction + midStageLoadingCoefficient/2)/midFlowCoefficient;
			stage.tanβ2 = stageData.isCompressor ? (stageData.reaction - midStageLoadingCoefficient/2)/midFlowCoefficient :
													(stageData.reaction + midStageLoadingCoefficient/2)/midFlowCoefficient;
			var midβ1 = stage.midβ1 = Math.atan(stage.tanβ1);
			var midβ2 = stage.midβ2 = Math.atan(stage.tanβ2);
			if (stageData.reaction == 0.5) {
				stage.midα1 = midβ2;
				stage.midα2 = midβ1;
				stage.tanα2 = stage.tanβ1;
				stage.tanα1 = stage.tanβ2;
			}
			else {
				stage.midα1 = stageData.isCompressor ? Math.atan(stage.tanα1 = (1 - stageData.reaction - midStageLoadingCoefficient/2)/midFlowCoefficient) :
													   Math.atan(stage.tanα1 = (1 - stageData.reaction + midStageLoadingCoefficient/2)/midFlowCoefficient);
				stage.midα2 = stageData.isCompressor ? Math.atan(stage.tanα2 = (1 - stageData.reaction + midStageLoadingCoefficient/2)/midFlowCoefficient) :
													   Math.atan(stage.tanα2 = (-(1 - stageData.reaction) + midStageLoadingCoefficient/2)/midFlowCoefficient);
			}
			//stageData.isCompressor ? Math.atan(((1-stageData.reaction) - midStageLoadingCoefficient/2)/(midFlowCoefficient)) :
			//							 Math.atan((-(1-stageData.reaction) + midStageLoadingCoefficient/2)/(midFlowCoefficient));
			var bladeHeight = stageData.isCompressor ? (stage.rTip - stage.rHub + stage.rTipMid - stage.rHubMid) / 2 :
													   (stage.rTipMid - stage.rHubMid + stage.rTipOut - stage.rHubOut) / 2;
			const Um = Math.sqrt(Math.abs(stage.hDeltaPower) / midStageLoadingCoefficient);
			if (Number.isNaN(deltaH) || Number.isNaN(Um)) throw new Error("stage.deltaH="+deltaH);
			const U2 = Um*stage.rMid/stage.rMidOut;

		
//console.log("v2="+v2+", v="+stage.v+", deltaH="+stage.deltaH+",  massFlowInKg="+ massFlowInKg);

			stage.rpm = stage.U / (stage.rTip*2*Math.PI/60);
			// F = m*a, the flow makes radial acceleration from C1 to C2, the acceleration is (1-reaction) part of the actual force pushing the fluid
			// The force is constant on blade span 
			stage.statorSolidity = stageData.rearSolidity;
			stage.rotorSolidity = stageData.solidity; // + stageData.cStages > 1 ? (stageData.rearSolidity-stageData.solidity)*stageData.stages.length/(stageData.cStages-1) : 0;
			var myStressCoefficient = Math.abs(stage.maxTensileStressMPa*stageLoadingCoefficient/stage.hDeltaPower);
			var K = myStressCoefficient*1000000/(0.5*alloyDensity*(1-hubToTip*hubToTip));
			if (K >= 0.7) {
				//console.log("Very high K="+K+", max:"+0.7);
				K = 0.7;
			}
			const minK = 1 - (1-0.01)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
			if (K < minK) {
				console.log(stageData.stages.length+":Very low K="+K+", increased it to min K:"+minK+", d=0.01, hubToTip="+hubToTip+", stage.rHub="+stage.rHub+", stage.rTip="+stage.rTip);
				stage.tipToHubSectionArea = 0.01;
				stage.K = K = minK;
			}
			else if (!testResult( K*0.99, 0.05, 1, K*0.01, function (d) {
				stage.tipToHubSectionArea = d;
				// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
				// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
				stage.K = 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
				return stage.K;
			}, 15)) {
				testResult( K*0.99, 0.01, 1, K*0.01, function (d) {
					stage.tipToHubSectionArea = d;
					// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
					// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
					stage.K = 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
					return stage.K;
				}, 15);
				myStressCoefficient = 0.5*alloyDensity*(1-hubToTip*hubToTip)*stage.K/1000000;
				stage.centrifugalStressMpa = Math.abs(myStressCoefficient*stage.hDeltaPower /stage.stageLoadingCoefficient);
if (Number.isNaN(stage.centrifugalStressMpa)) throw new Error("NaN");
				console.log("Allowed K="+K+", hubToTip="+hubToTip+",  set K="+0.45+"=> stage.tipToHubSectionArea="+stage.tipToHubSectionArea+", stage.centrifugalStressMpa="+stage.centrifugalStressMpa);
			}
			/*
			testResult( stage.K, 0.05, 1, stage.K*0.01, function (d) {
				stage.tipToMidSectionArea = d;
				// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
				// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
				stage.K = 1 - (1-d)*(2-midToTip - midToTip*midToTip)/(3*(1-midToTip*midToTip));
				return stage.K;
			}, 12);*/
			myStressCoefficient = 0.5*alloyDensity*(1-stage.hubToTipRatio*stage.hubToTipRatio)*stage.K/1000000;
			stage.centrifugalStressMpa = Math.abs(myStressCoefficient*stage.hDeltaPower / stage.stageLoadingCoefficient);
if (Number.isNaN(stage.centrifugalStressMpa)) throw new Error("NaN");
			if (stage.centrifugalStressMpa > stage.maxTensileStressMPa) {
				console.log("Too high centrifugal stress in stage "+stageData.stages.length+":"+stage.centrifugalStressMpa+" > "+stage.maxTensileStressMPa+", stage.K="+stage.K+", stage.tipToHubSectionArea="+stage.tipToHubSectionArea+", minK="+minK+", K="+K);
			}
			//else console.log("Centrifugal stress of stage "+stageData.stages.length+":"+stage.centrifugalStressMpa+" <= "+stage.maxTensileStressMPa+", stage.K="+stage.K+", stage.tipToHubSectionArea="+stage.tipToHubSectionArea+", minK="+minK+", K="+K);
//OK: console.log("*****"+stageData.stages.length+": d="+stage.tipToHubSectionArea+", K="+stage.K+"; hubToTip="+hubToTip);
			// rTip*rTip - rMiddle*rMiddle = rMiddle*rMiddle - rHub*rHub;	// ever area in both sides =>
			// rMiddle = sqrt((rTip*rTip+rHub*rHub)/2)
			//const unusedTensileStress = (stage.maxTensileStressMPa - stage.centrifugalStressMpa)*1000000;
			const unusedTensileStress = stage.maxTensileStressMPa*1000000;	// we can ignore centrifugal force here
			// Calc first the min width %0.1 from <ero width tip with momentum. 
			// Hub width = almost tip width / 0.15
			// And finally check the momentum in hub.  Elastic section modulus in hub should be much higher than its momentum because of centrifugal force
			// See https://en.wikipedia.org/wiki/Section_modulus
//			const rTip999 = 0.999*stage.rTip;
//			const tip999MomentumPerM = (stage.F*(stage.rTip-stage.rHub)/2000*(stage.rTip*stage.rTip-rTip999*rTip999)/(stage.rTip*stage.rTip-stage.rHub*stage.rHub))
//										/ (stageData.solidity*2*stage.rHub*Math.PI);   // assume that blade is a rectangle
			// Calc the torque force turning the stage in the mid flow radius
			// https://en.wikipedia.org/wiki/Torque: P = Mn*2*PI*rpm/60,  Mn = F*rMidFlow
			// P = stage.deltaH*massFlowInKg; // J/s == Nm/s)
			// => stage.F = stage.deltaH*massFlowInKg / (rMidFlow*2*PI*rpm/60); // N
			// force = gas massFlow * acceleration from c1 to c2 
			stage.F2 = massFlowInKg*stage.v*Math.abs(stage.tanα2-stage.tanα1) / (1-stageData.reaction);
			stage.F = Math.abs(stage.F2 / (stage.rotorSolidity*2*Math.PI*rMiddle)); //  stage.deltaH*massFlowInKg / (rMiddle*2*Math.PI*stage.rpm/60);

/*
			if (stageData.stages.length == 0) {
				stageData.hubα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) : // initial value
														   Math.atan(((1-stageData.reaction) + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
				stageData.hubα2 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) : // outlet value
														   Math.atan((-(1-stageData.reaction) + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient))
				stage.hubC1 = stage.v/Math.cos(stageData.hubα1);
				stage.hubC2 = stage.v/Math.cos(stageData.hubα2);
				const tipα1 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) - stage.stageLoadingCoefficient/2)/(stage.flowCoefficient)) :
													Math.atan(((1-stageData.reaction) + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
				const tipα2 = stageData.isCompressor ? Math.atan(((1-stageData.reaction) + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient)) :
													   Math.atan((-(1-stageData.reaction) + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
				stage.tipC1 = stage.v/Math.cos(tipα1);
				stage.tipC2 = stage.v/Math.cos(tipα2);
				const midα2 = stageData.reaction == 0.5 ? midβ1 : 
									stageData.isCompressor ? Math.atan(((1-stageData.reaction) + midStageLoadingCoefficient/2)/(midFlowCoefficient)) :
															 Math.atan((-(1-stageData.reaction) + midStageLoadingCoefficient/2)/(midFlowCoefficient));
				stage.midC1 = stage.v/Math.cos(stage.midα1);
				stage.midC2 = stage.v/Math.cos(midα2);
				//stageData.inletC1 = stage.hubC1; // stage.v; //  // midC1;
			}
*/
/*
			const tipβ2 = Math.atan((stageData.reaction - stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
			const hubβ2 = Math.atan((stageData.reaction - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
			//const statorTipβ2 = Math.atan((1-stageData.reaction - stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
			//const statorHubβ2 = Math.atan((1-stageData.reaction - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
			const statorβ2 = Math.atan((1-stageData.reaction - midStageLoadingCoefficient/2)/(midFlowCoefficient));
*/
			var staggerAngle, hubStaggerAngle, statorStaggerAngle, tipStaggerAngle = 0;
			if (stageData.rotorStaggerAngles.length > stageData.stages.length) {
				staggerAngle = Math.PI*stageData.rotorStaggerAngles[stageData.stages.length]/180;
				hubStaggerAngle = Math.PI*stageData.rotorHubStaggerAngles[stageData.stages.length]/180;
				tipStaggerAngle = Math.PI*stageData.rotorTipStaggerAngles[stageData.stages.length]/180;
				statorStaggerAngle = Math.PI*stageData.statorStaggerAngles[stageData.stages.length]/180;
			}
			else if (stageData.stages.length > 0) {
				const prevStage = stageData.stages[stageData.stages.length-1];
				if (prevStage.rotorStaggerAngle) {
					staggerAngle = prevStage.rotorStaggerAngle*Math.PI / 180;
					hubStaggerAngle = prevStage.rotorHubStaggerAngle*Math.PI / 180;
					statorStaggerAngle = prevStage.statorStaggerAngle*Math.PI / 180;
				}
			}
			if (typeof staggerAngle === 'undefined')
			{
				const defAngle = Math.PI * 28  / 180;	// 
				staggerAngle = defAngle;
				hubStaggerAngle = Math.PI * 16 / 180
				statorStaggerAngle = defAngle;
			}
			{
				if (stageData.aspectRatios.length > stageData.stages.length) {
					stage.aspectRatio =  stageData.aspectRatios[stageData.stages.length];
					//console.log(stageData.stages.length+":AR="+stage.aspectRatio);
				}
				else {
					// Re(h) exp(6) is between 3 and 5 (instead of 0.5) => Add 0.5 to the the calculated values of 
					// Figure 27 in  https://api.repository.cam.ac.uk/server/api/core/bitstreams/fbfb70fe-58b3-47fb-a338-859384279d7c/content
					const middleMaxThickness = 100*getRotorMidThickness( stage.rMid, stage.rTip, stage.rHub, stage.rotorSolidity, staggerAngle, 
															Math.abs(stage.deltaH*massFlowInKg), stage.rpm, unusedTensileStress, stageData.maxTipThickness )/bladeHeight;
					if (typeof middleMaxThickness === 'undefined') throw Error('middleMaxThickness='+middleMaxThickness);
					const AR_at_1 = 2.25;
					const AR_at_5 = 1.7;
					stage.aspectRatio =  AR_at_1 - (middleMaxThickness-1)/(5-1)*(AR_at_1-AR_at_5);
				}
				var cRe = dPlus1 * ((stage.rTip-stage.rHub)/stage.aspectRatio) * stage.v / Math.cos(midβ1) / visc;
				if (Number.isNaN(cRe)) {
					const pTriplePoint =  Module.PropsSI('P_TRIPLE', '', 0, '', 0, name);
					const tTriplePoint =  Module.PropsSI('T_TRIPLE', '', 0, '', 0, name);
					console.log(stageData.stages.length+":cRe="+cRe+", AR="+stage.aspectRatio+", v="+stage.v+", visc="+visc+", dPlus1="+dPlus1+", item="+JSON.stringify(item)+", stage="+JSON.stringify(stage));
					alert("Some part of gas will be frozen in the inlet of "+title+". The gas temperature ("+myRound(item.t,2)+" K) should not be below the tripple point temperature "+myRound(tTriplePoint,2)+" K of "+name+"! Increase the low pressure or decrease the pressure ratio and try again.");
					throw new Error("cRe="+cRe);
				}
				//if (cRe && cRe < 500000) stage.aspectRatio *= cRe/500000;
				const V1 = stageData.stages.length == 0 ? stageData.inletC1/Math.cos(midβ1) : stage.v/Math.cos(midβ1);
				stage.pressureRiseCoefficient2 = (deltaH - 0.5*(U2*U2 - Um*Um)) / (V1*V1);
				stage.unusedTensileStress = unusedTensileStress;
				const c = bladeHeight/stage.aspectRatio;
				stage.cRe = dPlus1 * c * stage.v / Math.cos(midβ1) / visc;
				var bladeData, cLoop = 0;
/*
				var firstStageAccelerationForcePerM = null;
				if (false && stageData.isCompressor && stageData.stages.length == 0) {
					// the first compressor blade row must accelerate to c1 of each radius
					stage.F2 = massFlowInKg*stage.v*(stageData.tanα2-stageData.tanα1) / (1 - stageData.reaction);
					firstStageAccelerationForcePerM = [];
					const area10 = (stage.rTip*stage.rTip - stage.rHub*stage.rHub)/10;
					const meters = 2*Math.PI*stage.rMid*stage.rotorSolidity;
					var rPrev = 0;
					var c1AccelerationForce = 0;
					var hKinetic = 0;
					for (i = 0; i < 10; i++) {
						const rMomentum = rPrev ? Math.sqrt(area10+rPrev*rPrev) : Math.sqrt(area10/2+stage.rHub*stage.rHub);
						const rToTip = rMomentum/stage.rTip;
						const loadCoefficient = stage.stageLoadingCoefficient/(rToTip*rToTip);
						const flowCoefficient = stage.flowCoefficient / rToTip;
						const alpha1 = Math.atan(((1-stageData.reaction) - loadCoefficient/2)/(flowCoefficient));
						const c1 = stage.v/Math.cos(alpha1);
						//if (i == 0) stageData.hHubInletAcceleration = 0.5*c1*c1 - 0.5*stageData.inletC1*stageData.inletC1;
						hKinetic += 0.5*c1*c1;
						const F = massFlowInKg/10*(c1 - stageData.inletC1);
						firstStageAccelerationForcePerM.push(F/meters);
						c1AccelerationForce += F;
						rPrev = rMomentum;
					}
					hKinetic /= 10;
					stageData.hHubInletAcceleration = hKinetic - 0.5*stageData.inletC1*stageData.inletC1;
					stageData.firstStageAccelerationForcePerM = firstStageAccelerationForcePerM;
					stageData.powerOfAcceleration = (hKinetic - stageData.hHubInletAcceleration - 0.5*stageData.inletC1*stageData.inletC1)*stageData.massFlowInKg;
					stage.hKinetic = hKinetic;

//console.log("c1AccelerationForce="+c1AccelerationForce+" , powerOfAcceleration="+stageData.powerOfAcceleration+", hKinetic="+hKinetic+", deltaH="+deltaH+", firstStageAccelerationForcePerM="+JSON.stringify(firstStageAccelerationForcePerM));
					stage.bladeTipProps = getBladeProperties( stageData, stageData.hasIGV, stage.stageLoadingCoefficient, stage.flowCoefficient, stage.v, stageData.inletC1, stage.tipC1, stage.tipC2, deltaH );
					stage.bladeMidProps = getBladeProperties( stageData, stageData.hasIGV, midStageLoadingCoefficient, midFlowCoefficient, stage.v, stageData.inletC1, stage.midC1, stage.midC2, deltaH );
					stage.bladeHubProps = getBladeProperties( stageData, stageData.hasIGV, stage.hubStageLoadingCoefficient, stage.hubFlowCoefficient, stage.v, stageData.inletC1, stage.hubC1, stage.hubC2, deltaH );

					midβ1 = stage.bladeMidProps.β1;
					midβ2 = stage.bladeMidProps.β2;

					if (!tipStaggerAngle) {
						const tipβ1 = stage.bladeTipProps.β1;
						const tipβ2 = stage.bladeTipProps.β2;
						const tipAngle = getCamberAngle( tipβ1*180/Math.PI, tipβ2*180/Math.PI, stageData.maxTipThickness, c, stage.rotorSolidity*stage.rTip/stage.rMid, true, stage.v/Math.cos(midβ1)/stage.mach );
						tipStaggerAngle = tipAngle.staggerAngle*Math.PI / 180;
					}
console.log("firstStageAccelerationForcePerM="+JSON.stringify(firstStageAccelerationForcePerM));
				}
				else 
*/
				{
					if (!tipStaggerAngle) {
						const tipβ1 = stageData.isCompressor ? Math.atan((stageData.reaction + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient)) :
															   Math.atan((-stageData.reaction + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
						const tipβ2 = stageData.isCompressor ? Math.atan((stageData.reaction - stage.stageLoadingCoefficient/2)/(stage.flowCoefficient)) :
															   Math.atan((stageData.reaction + stage.stageLoadingCoefficient/2)/(stage.flowCoefficient));
						if (stageData.isCompressor) {
							const tipAngle = getCamberAngle( tipβ1*180/Math.PI, tipβ2*180/Math.PI, stageData.maxTipThickness, c, stage.rotorSolidity*stage.rTip/stage.rMid, true, stage.v/Math.cos(midβ1)/stage.mach );
							tipStaggerAngle = tipAngle.staggerAngle*Math.PI / 180;
						}
						else {
							//const tipAngle = getCamberAngle( tipβ1*180/Math.PI, tipβ2*180/Math.PI, stageData.maxTipThickness, c, stage.rotorSolidity*stage.rTip/stage.rMid, true, stage.v/Math.cos(midβ2)/stage.mach );
							tipStaggerAngle = (tipβ1+tipβ2)/2;	// circular
						}
					}
				}
				const hubβ1 = stage.hubβ1 = stage.bladeHubProps ? stage.bladeHubProps.β1 : 
						stageData.isCompressor ? Math.atan((stageData.reaction + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) :
												 Math.atan((-stageData.reaction + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
				const hubβ2 = stage.hubβ2 = stage.bladeHubProps ? stage.bladeHubProps.β2 : 
						stageData.isCompressor ? Math.atan((stageData.reaction - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) :
											     Math.atan((stageData.reaction + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
				if (stageData.reaction == 0.5) {
					stage.hubα1 = hubβ2;
					stage.hubα2 = hubβ1;
				}
				else {
					stage.hubα1 = stageData.isCompressor ? Math.atan((1 - stageData.reaction - stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) :
														   Math.atan((1 - stageData.reaction + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
					stage.hubα2 = stageData.isCompressor ? Math.atan((1 - stageData.reaction + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient)) :
														   Math.atan((-(1 - stageData.reaction) + stage.hubStageLoadingCoefficient/2)/(stage.hubFlowCoefficient));
				}
				while (cLoop < 10) {
					bladeData = 
						getStatorAndRotorBlades( stageData, stage.rMid, stage.rTip, stage.rHub, 
							stage.rMidMid, stage.rTipMid, stage.rHubMid, stage.rMidOut, stage.rTipOut, stage.rHubOut, stage.rotorSolidity, stage.statorSolidity, stage.cRe, stage.cRe, staggerAngle, 
							stage.F2, stage.rpm, unusedTensileStress, stageData.minTipRe, reaction, stageData.maxTipThickness, 
							c, stage.tipToHubSectionArea, stage.tipToMidSectionArea, hubStaggerAngle, tipStaggerAngle, stageData.isCompressor ? null : stage );
					if (stageData.isCompressor) {
						const midAngle = getCamberAngle( midβ1*180/Math.PI, midβ2*180/Math.PI, bladeData.rotor.tMid, c, stage.rotorSolidity, true, stage.v/Math.cos(midβ1)/stage.mach);
						const hubAngle = getCamberAngle( hubβ1*180/Math.PI, hubβ2*180/Math.PI, bladeData.rotor.tRoot, c, stage.rotorSolidity*stage.rMid/stage.rHub, true, stage.v/Math.cos(midβ1)/stage.mach );
						if (Math.abs(staggerAngle - midAngle.staggerAngleRad) < 0.01 && Math.abs(hubStaggerAngle - hubAngle.staggerAngleRad) < 0.01) {
							cLoop = 100; // error less than 1 degree
						}
						stage.staggerAngleRad = staggerAngle = midAngle.staggerAngleRad;
						stage.hubStaggerAngleRad = hubStaggerAngle = hubAngle.staggerAngleRad;
					}
					else {
						stage.staggerAngleRad = staggerAngle = (midβ1+midβ2)/2 * 180 / Math.PI;
						stage.hubStaggerAngleRad = hubStaggerAngle = (hubβ1+hubβ2)/2 * 180 / Math.PI;
						break;
					}
					cLoop++;
				}
				stage.tipToHubSectionArea = stageData.maxTipThickness / bladeData.rotor.tRoot;
				// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
				// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
				stage.K = 1 - (1-stage.tipToHubSectionArea)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
				myStressCoefficient = 0.5*alloyDensity*(1-hubToTip*hubToTip)*stage.K/1000000;
				stage.centrifugalStressMpa = Math.abs(myStressCoefficient*stage.hDeltaPower /stage.stageLoadingCoefficient);
				if (Number.isNaN(stage.centrifugalStressMpa)) throw new Error("Bad centrifugalStressMpa");

				stage.rotor = bladeData.rotor; 
				stage.stator = bladeData.stator;
				stage.hRotor = stageData.isCompressor ? (stage.rTip - stage.rHub + stage.rTipMid - stage.rHubMid) / 2 :
														(stage.rTipMid - stage.rHubMid + stage.rTipOut - stage.rHubOut) / 2;
				stage.hStator = stageData.isCompressor ? (stage.rTipMid - stage.rHubMid + stage.rTipOut - stage.rHubOut) / 2 :
														 (stage.rTip - stage.rHub + stage.rTipMid - stage.rHubMid) / 2;
				if (stageData.aspectRatios.length == stageData.stages.length) 
				{
					stage.cRe = stageData.isCompressor ? dPlus1 * (stage.hRotor/stage.aspectRatio) * stage.v / Math.cos(midβ1) / visc :
														stage.dynamicVisc3 * (stage.hRotor/stage.aspectRatio) * stage.v / Math.cos(midβ2);
					if (stageData.maxAspectRatio && !stageData.isCompressor) {
/*
						const optEffAndAR = getOptimalAR( stageData, stage );
						stage.aspectRatio = optEffAndAR.optimalAR; // / stageData.divOptAR; // alread divided in function
						stage.efficiency = optEffAndAR.efficiency;
						stageData.aspectRatios.push(stage.aspectRatio);
*/
						var aspectRatio = stageData.maxAspectRatio;
						const rotorChord = 2 * stageData.reaction * stage.hRotor / aspectRatio;
						const tMaxToChord = bladeData.rotor.tMid/rotorChord;
						if (stageData.tMaxToChord < tMaxToChord) {
							aspectRatio = stageData.maxAspectRatio * stageData.tMaxToChord / tMaxToChord;		// extend chord to increase relative max thickness
							//console.log(stageData.stages.length+": tMaxToChord decreased from "+tMaxToChord+" to "+stageData.tMaxToChord+", ascpect ratio="+aspectRatio+", chord="+(2 * stageData.reaction * stage.hRotor / aspectRatio)+", bladeData.rotor.tMid="+bladeData.rotor.tMid+", stage.hRotor="+stage.hRotor);
						}
						stage.aspectRatio = aspectRatio;
					}
					else {
						const optEffAndAR = getOptimalAR( stageData, stage );
						stage.aspectRatio = optEffAndAR.optimalAR; // / stageData.divOptAR; // alread divided in function
						stage.efficiency = optEffAndAR.efficiencyDS_DR;
					}
					if ((stage.hRotor/stage.aspectRatio) <  stageData.minChordLength) {
						stage.aspectRatio = stage.hRotor/stageData.minChordLength;
					}
					stageData.aspectRatios.push(stage.aspectRatio);	// max is always best for turbins (at least up to 16!)
				}
				else {
					if (stageData.maxAspectRatio && !stageData.isCompressor) {
						var aspectRatio = stageData.maxAspectRatio;
						const rotorChord = 2 * stageData.reaction * stage.hRotor / aspectRatio;
						const tMaxToChord = bladeData.rotor.tMid/rotorChord;
						if (stageData.tMaxToChord < tMaxToChord) {
							stage.aspectRatio = stageData.maxAspectRatio * stageData.tMaxToChord / tMaxToChord;		// extend chord to increase relative max thickness
							//console.log(stageData.stages.length+": tMaxToChord decreased from "+tMaxToChord+" to "+stageData.tMaxToChord+", ascpect ratio="+aspectRatio+", chord="+(2 * stageData.reaction * stage.hRotor / aspectRatio)+", bladeData.rotor.tMid="+bladeData.rotor.tMid+", stage.hRotor="+stage.hRotor);
						}
					}
					if ((stage.hRotor/stage.aspectRatio) <  stageData.minChordLength) {
						stage.aspectRatio = stage.hRotor/stageData.minChordLength;
					}
					stageData.aspectRatios[stageData.stages.length] = stage.aspectRatio;	// max is always best for turbins (at least up to 16!)
				}

/*
				const optEffAndAR = getOptimalAR_Effciency( cRe, stage.rotor.tMid, bladeHeight, bladeHeight/stage.aspectRatio, 
										getLoadFactor(stage.pressureRiseCoefficient), stage.tipGap ? stage.tipGap : 0.005, stageData.stages.length+1 );
				stage.efficiency = optEffAndAR.efficiency;
*/

				//stage.analyticalLosses = myRound(optEffAndAR.profileLoss*100,1)+'/'+myRound(optEffAndAR.endWallLoss*100,1);
				stage.cRe = stageData.isCompressor ? dPlus1 * (stage.hRotor/stage.aspectRatio) * stage.v / Math.cos(midβ1) / visc :
													 stage.dynamicVisc3 * (stage.hRotor/stage.aspectRatio) * stage.v / Math.cos(midβ2);
//console.log(stageData.stages.length+":cRe="+cRe+", AR="+stage.aspectRatio+", v="+stage.v+", visc="+visc+", dPlus1="+dPlus1+", item="+JSON.stringify(item));
				if (stageData.isCompressor) {
					getEfficiencyWithDF_DR( stageData, stage, stageData.stages.length, true );
					stage.efficiency = stage.efficiencyDS_DR;
				}
				else {
					getEfficiencyWithDF_DR( stageData, stage, stageData.stages.length, false );
					getEfficiencyWithKackerOkapuu( stageData, stage, stageData.stages.length );
				}
				if (stageData.stageEfficiencies.length == stageData.stages.length) {
					stageData.stageEfficiencies.push(stage.efficiency);
				}
				else {
					stageData.stageEfficiencies[stageData.stages.length] = stage.efficiency;
				}
				stage.blades = Math.round(stage.rotorSolidity*2*(stageData.isCompressor ? stage.rMid : stage.rMidMid)*Math.PI/(2*stageData.reaction*bladeHeight/stage.aspectRatio));
				stage.statorBlades = Math.round(stage.statorSolidity*2*(stageData.isCompressor ? stage.rMidMid : stage.rMid)*Math.PI/(2*(1-stageData.reaction)*stage.hStator/stage.aspectRatio));
				// XXXXXXXXXX TBD: select AR as min loss
			}
//console.log("*****"+stageData.stages.length+":rMiddle="+rMiddle+", bladeThicknessIn hub/Middl//e/tip="+stage.bladeThicknessInHub+"/"+stage.bladeThicknessInMiddle+"/"+stage.bladeThicknessInTip+", AR:"+stage.aspectRatio);
			//getEfficiencyWithDF_DR( stageData, stage );
			//stage.stageWidth2h = Math.cos(Math.PI*stage.rotorStaggerAngle/180) / (stageData.relativeBladeWidth/2*stage.aspectRatio);		// e.g: rotor:gap:stator:gap 8:1:8:1 
			return deltaH;
		}

		// https://en.wikipedia.org/wiki/Maraging_steel Grade 350
		//stageData.shaftStrength = 2413000000 * 0.35;	// 0.4 OK for short term, max strength 1000 MPa * 0.3 => long term strength as shaft 300 MPa = 300000000 N/m2, short term 0.4
		// We use β2 as the stagger angle, because β2 seems to be quite near to it in in picture. I did not find any easy way to calc the stagger angle
		//stageData.stageWidth2h = Math.cos(stageData.β2) / (0.35*stageData.aspectRatio);		// e.g: rotor:gap:stator:gap 35:15:35:15 
		stageData.getCompressorMetrics = function(mToPx) {
			const frameTop = [];
			const frameBottom = [];
			var stageData = this;
			var yInletPipe = inletPipeDiameter/2;
			const yExitPipe = exitPipeDiameter/2;
			const frameThickness = Math.min(0.05, Math.max(stages[0].diameterMm, stages[stages.length-1].diameterMm)/1000*0.025); // frame thickness 1% of diameter, OK for ~10000 kPa
			const tipGap = 0.005;
			const gearWidth = stageData.constantRpm ? 1.5 : 0.250; // 
			function getInnerRadius(iStage) {
				iStage++;
				while (iStage < stageData.stages.length) {
					if (stageData.stages[iStage].rShaft) return stageData.stages[iStage].rShaft + stageData.shaftBearingSpace;
					iStage++;
				}
				return stageData.rInnerShaftCoolingPipe;
			}
			var xNextGear, nextBladeBasementFromX;
			var nextBladeBasement = [];
			var metrics = {};
			metrics.rotors = [];
			metrics.stators = [];
			metrics.shafts = [];
			metrics.bladeBasements = [];
			metrics.generatorShaft = [];
			metrics.whiteAreas = [];
			
			var x = 0;
			var nextHookP1 = 0, nextHookP2 = 0;
			var i, p, pb, pb2;
			for (i = 0; i < stageData.stages.length; i++) {
				const stage = stageData.stages[i];
				const rTip = stageData.isCompressor ? stage.rTip : stage.rTipMid;
				const rHub = stageData.isCompressor ? stage.rHub : stage.rHubMid;
				const rTipMid = stageData.isCompressor ? stage.rTipMid : stageData.stages[i].rTipOut;
				const rHubMid = stageData.isCompressor ? stage.rHubMid : stageData.stages[i].rHubOut;
				const nextTip = stageData.isCompressor || i == stageData.stages.length-1 ? stage.rTipOut : stageData.stages[i+1].rTipMid;
				const nextHub = stageData.isCompressor || i == stageData.stages.length-1 ? stage.rHubOut : stageData.stages[i+1].rHubMid;
				const statorWidth = stageData.isCompressor || i == stageData.stages.length-1 ? stage.statorWidth : stageData.stages[i+1].statorWidth;
				const stageWidth = stageData.isCompressor ? stage.width : 
							i == stageData.stages.length-1 ? stage.rotorWidth :
							(stage.rotorWidth + statorWidth)/ stageData.relativeBladeWidth;
				//const nextRotorWidth = i == stageData.stages.length-1 ? 0 : stageData.stages[i+1].rotorWidth;
				const hRotorEdgeShrouding = (stageData.isShrouded ? stage.rotorWidth/4*(1/stageData.relativeBladeWidth-1) : 0);
				const hRotorTailShrouding = (stageData.isShrouded ? stage.rotorWidth/4 : 0);
				const hStatorEdgeShrouding = (stageData.isShrouded ? statorWidth/4*(1/stageData.relativeBladeWidth-1) : 0);
				const hStatorTailShrouding = (stageData.isShrouded ? statorWidth/4 : 0);

							//stage.width * stage.hRotor/(stage.hRotor+stage.hStator) + stageData.stages[i+1].width * stageData.stages[i+1].hStator/(stageData.stages[i+1].hRotor+stageData.stages[i+1].hStator);
				const rInnerShaft = getInnerRadius(i);
				const hubWallWidth = frameThickness + hStatorTailShrouding; // stageWidth*0.04

if (false && i == (stageData.stages.length-1)) {
	console.log( "last rTip:"+ stageData.stages[i].rTip+", exit rTip="+stageData.hpExit.rTip);
}
				const w35 = stageData.isCompressor || i < stageData.stages.length-1 ? stage.rotorWidth/stageWidth : 1;
				const w35s = statorWidth/stageWidth;
				const w30 = w35 - w35*30/35;
				const w50 = w35 / stageData.relativeBladeWidth;
				const w35Y = w35; // w50;
				const w40 = w35+(w50-w35)/3;
				const w60 = w50 + (statorWidth/stageWidth)*10/35;
				const w61 = w60 + 0.01;
				const w65 = w50 + (statorWidth/stageWidth)*15/35;
				const w80 = w50 + (statorWidth/stageWidth)*30/35;
				const w85 = w50 + statorWidth/stageWidth;
				const w85Y = w85; // 1;
				const w55 = w50 + (w85-w50)*5/35;
				const w15 = 1 - w85;
				const w90 = w85+w15/3;
				const w95 = w85+w15*2/3;
				const w96 = w85+w15*11/15;

if (false && i == (stageData.stages.length-1)) 
console.log("stage.rotorWidth="+stage.rotorWidth+", statorWidth="+statorWidth+", stageWidth="+stageWidth+", stageData.relativeBladeWidth="+stageData.relativeBladeWidth+", w96="+w96);
				var points = [];
				if (i == 0) {
					if (yInletPipe < stage.rTip*1.1) yInletPipe = stage.rTip*1.1; 
					p=toPoint(stageData.constantRpm ? -(yInletPipe-stage.rTip) : -stage.width*(yInletPipe-stage.rTip)/(stage.rTip-stageData.stages[1].rTip), yInletPipe+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000);
					frameBottom.push(toPoint(p.x-0.1, p.y));
					frameBottom.push(p);
					frameTop.push(toPoint(p.x-0.1, p.y+frameThickness));
					frameTop.push(toPoint(p.x, p.y+frameThickness));
					frameBottom.push(p=toPoint(x, stage.rTip+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000+hRotorEdgeShrouding));
					frameTop.push(toPoint(p.x, p.y+frameThickness+hRotorTailShrouding));
					xNextGear = p.x-(inletPipeDiameter*2/3+frameThickness+gearWidth); // the gears box is immediately after the pipe turns up 90 degrees
					
					// IGV:
					var p2, p3;
					points.push(p = toPoint(x-(stageData.isCompressor ? stage.width*0.1 : -stage.width*0.35), stage.rShaft+stageData.shaftBearingSpace)); // 
//console.log((stageData.isCompressor ? "Compressor" : "Turbin")+": stageData.hasIGV="+stageData.hasIGV);
					if (stageData.hasIGV) {
						const igvWidth = (stage.rTip-stage.rHub)/(stageData.IGV_AR-2)/stage.width; // 0.40; //
						points.push(toPoint(p.x, stage.rHub*0.94)); 
						points.push(toPoint(x-0.002, stage.rHub)); 
						points.push(toPoint(p.x, stage.rHub)); 
						points.push(toPoint(p.x, stage.rTip+(stageData.constantRpm ? stage.width : stage.rTip-stageData.stages[1].rTip)*0.1+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
						points.push(toPoint(x-stage.width*igvWidth, stage.rTip+(stageData.constantRpm ? stage.width : stage.rTip-stageData.stages[1].rTip)*igvWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
						points.push(toPoint(x-stage.width*igvWidth, stage.rHub-(stageData.constantRpm ? stage.width : stage.rHub-stageData.stages[1].stage.rHub)*igvWidth)); // 45 degrees down
						points.push(toPoint(x-frameThickness, stage.rHub-(stageData.constantRpm ? stage.width : stage.rHub-stageData.stages[1].stage.rHub)*0.40));
						points.push(toPoint(x-frameThickness, stage.rShaft+stageData.shaftBearingSpace)); // 45 degrees down
					}
					else {
						points.push(toPoint(p.x, !stageData.isCompressor ? stage.rHub : stage.rHub-(stageData.constantRpm ? stage.width : stage.rHub-stageData.stages[1].stage.rHub)*0.1));
						points.push(toPoint(p.x-frameThickness, stage.rHub-frameThickness));
						points.push(toPoint(p.x-frameThickness, stage.rShaft+stageData.shaftBearingSpace)); // 45 degrees down
					}
					points.push(p);
					metrics.stators.push(points);

					// middle cone directing flow to compressor
					points = [];
					const frameWidth = frameThickness; // stage.width/6
					if (false && stageData.hasIGV) {
						points.push(p3 = toPoint(x-stage.width*0.325, stage.rHub));
						points.push(p2=toPoint(p3.x-(p3.y-stage.rShaft+0.02), stage.rShaft+0.02)); // continues 45 degrees until top shaft
						points.push(toPoint(p2.x+frameWidth, p2.y));
						points.push(toPoint(p3.x+frameWidth, p3.y));
						points.push(p3);
					}
					else 
					{
						points.push(p3 = toPoint(x-(stageData.isCompressor ? stage.width*0.05 : 0), stage.rHub-(stageData.constantRpm ? stage.width : stage.rHub-stageData.stages[1].stage.rHub)*0.05));
						points.push(p2=toPoint(p3.x-(p3.y-stage.rShaft+0.02), stage.rShaft+0.02)); // continues 45 degrees until top shaft
						points.push(toPoint(p2.x+frameWidth, p2.y));
						points.push(toPoint(p3.x, p3.y-frameWidth ));
						points.push(p3);
					}
					metrics.stators.push(points);

					// Shaft cover and insulation, perhaps about 70 mm
					points = [];
					points.push(p3 = toPoint(x-0.002, stage.rShaft+0.02));
					points.push(p2 = toPoint(Math.min(p2.x,xNextGear+gearWidth), p2.y));
					points.push(toPoint(p2.x, p2.y+0.035));
					points.push(toPoint(p3.x, p3.y+0.035));
					metrics.stators.push(points);	
					// first turbine blade
					if (!stageData.isCompressor) {
						points = [];
						const w35S = stage.statorWidth/stage.width;
						const w30S = w35S*30/35;
						sWidth = stage.width*stage.hStator/(stage.hStator+stage.hRotor);
						points.push(p = toPoint(0, stage.rTip+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
						frameBottom.push(p);
						points.push(p2 = toPoint(stage.statorWidth, stage.rTip-(stage.rTip-stage.rTipMid)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
						frameBottom.push(p2);
						points.push(toPoint(stage.statorWidth, stage.rHub-(stage.rHub-stage.rHubMid)*stageData.relativeBladeWidth));
						// vacuum lock
						points.push(toPoint(stage.statorWidth/stageData.relativeBladeWidth, stage.rHubMid));
						points.push(toPoint(p.x, stage.rHub-stage.width*w35S));
						points.push(p);
						metrics.stators.push(points);
						x = stage.statorWidth/stageData.relativeBladeWidth;
					}
					points = [];
				}
				// rotor blade
				points.push(p = toPoint(x, rTip + hRotorEdgeShrouding));
				points.push(toPoint(x+stage.rotorWidth, rTip-(rTip-rTipMid)*stageData.relativeBladeWidth + hRotorTailShrouding));
				points.push(pb2 = toPoint(x+stage.rotorWidth, rHub-(rHub-rHubMid)*stageData.relativeBladeWidth));
				points.push(pb = toPoint(x,rHub));
				points.push(p);
				metrics.rotors.push(points);
				frameBottom.push(toPoint(x, rTip+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000 + hRotorEdgeShrouding));
				frameBottom.push(toPoint(x+stage.rotorWidth, rTip-(rTip-rTipMid)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000
									+ hRotorTailShrouding));
				if (nextHookP1 && nextHookP2) {
					nextBladeBasement.push(nextHookP1);
					nextBladeBasement.push(nextHookP2);
				}
				nextBladeBasement.push(toPoint(x, rHub ));
				nextBladeBasement.push(toPoint(x+stage.rotorWidth, rHub-(rHub-rHubMid)*stageData.relativeBladeWidth));
if (false && i == (stageData.stages.length-1)) {
	console.log( "metrics.rotors="+JSON.stringify(metrics.rotors));
}
				var p2;
				// next stator
				points = [];
				const pStatorFrom = toPoint(x+stage.rotorWidth/stageData.relativeBladeWidth, rTipMid+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000);
				frameBottom.push(pStatorFrom);
				if (i == stageData.stages.length-1) {
					var points2 = [];
					points.push(pStatorFrom);
					if (stageData.isCompressor) {
						points.push(toPoint(x+stageWidth*w85, rTipMid-(rTipMid-nextTip)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
						points.push(p2 = toPoint(xFrom = x+stageWidth*w85, yFrom = rHubMid-(rHubMid-nextHub)*stageData.relativeBladeWidth));
						//frameBottom.push(p2);
						/*
						points2.push(toPoint(x+stageWidth + nextHub, 0));
						const xDistM = stageWidth*w15/Math.cos(Math.PI/4);
						points2.push(toPoint(x+stageWidth + nextHub-xDistM, 0));
						points2.push(toPoint(p2.x-xDistM, p2.y));	// *0.97
						metrics.stators.push(points2);
						points2 = [];
						*/
					}
					var xFrom, yFrom, xEndWall2;
					if (stageData.isCompressor) {
						const xEndWall = x+stageWidth-stageWidth*w50;
						const xyHook = stageWidth*w50-stageWidth*w35;
						xEndWall2 = xEndWall + Math.max(frameThickness, statorWidth);
						points2.push(p = toPoint(x+stageWidth*w85, nextHub));
						points2.push(toPoint(xEndWall2, nextHub-Math.max(frameThickness, statorWidth)));
						points2.push(toPoint(xEndWall2, stageData.stages[i].rShaft+0.002));
						points2.push(toPoint(xEndWall, stageData.stages[i].rShaft+0.002));
						points2.push(toPoint(xEndWall, rHub-xyHook));
						points2.push(toPoint(xEndWall-xyHook, rHub - (rHub-rHubMid)*stageData.relativeBladeWidth));
						points2.push(toPoint(xEndWall, rHubMid));
						points2.push(p);
					}
					else {
						const xyHook = 0.010;
						const xEndWall = x+stageWidth + xyHook;
						const yEndWall = rHub-(rHub-rHubMid)*stageData.relativeBladeWidth - xyHook;
						points2.push(toPoint(xEndWall, yEndWall));
						points2.push(toPoint(x+stage.rotorWidth, rHub-(rHub-rHubMid)*stageData.relativeBladeWidth));
						points2.push(toPoint(xEndWall, yEndWall-2*xyHook));
						points2.push(toPoint(xEndWall, stageData.stages[i].rShaft+0.002));
						points2.push(toPoint(xEndWall+frameThickness, stageData.stages[i].rShaft+0.002));
						points2.push(toPoint(xFrom = xEndWall+frameThickness, yFrom = nextHub-(rHub-nextHub)*frameThickness/(stageWidth*w35)));
						points2.push(toPoint(xEndWall, yEndWall));
					}
					//points2.push(toPoint(xEndWall*w50, rHub-(rHub-nextHub)*w50)+(stage.tipGap ? stage.tipGap : tipGap));
					metrics.stators.push(points2);

					const xyDistM = frameThickness/Math.cos(Math.PI/4)
					points2 = [];
					const xTo = xFrom+yFrom-(stageData.stages[i].rShaft+0.002);
					points2.push(toPoint(xFrom, yFrom));
					points2.push(toPoint(xTo, stageData.stages[i].rShaft+0.002));
					points2.push(toPoint(xTo-xyDistM, stageData.stages[i].rShaft+0.002));
					points2.push(toPoint(xFrom, yFrom-xyDistM));
					points2.push(toPoint(xFrom, yFrom));
					metrics.stators.push(points2);

					points2 = [];
					// Pipe around shaft:
					const fromShaft = stageData.stages[i].rShaft+0.010;
					points2.push(toPoint(xFrom, fromShaft));
					points2.push(toPoint(xTo*2, fromShaft));				// the shaft goes through the pipes
					points2.push(toPoint(xTo*2, fromShaft+frameThickness));
					points2.push(toPoint(stageData.isCompressor ? xEndWall2 : xFrom, fromShaft+frameThickness));
					points2.push(toPoint(stageData.isCompressor ? xEndWall2 : xFrom, fromShaft));
					metrics.stators.push(points2);
					points.push(p = toPoint(x+stageWidth*w50, rHubMid));
					//frameBottom.push(p);
					points.push(pStatorFrom);
					//if (stageData.isCompressor) frameBottom.push(toPoint(x+stageWidth*w85, rTipMid-(rTipMid-nextTip)*stageData.relativeBladeWidth);
				}
				else {
					//points.push(p = toPoint(x+stageWidth*w85, 
					//						rTipMid-(rTipMid-nextTip)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
					frameBottom.push(toPoint(x+stageWidth*w50, rHubMid+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000 - hStatorEdgeShrouding));
					frameBottom.push(toPoint(x+stageWidth*w85, rHubMid-(rHubMid-nextHub)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000
										- hStatorTailShrouding));
					frameBottom.push(toPoint(x+stageWidth*w85, 
											rTipMid-(rTipMid-nextTip)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000));
					//frameBottom.push(toPoint(x+stageWidth, nextTip+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000 + hRotorEdgeShrouding));
					nextBladeBasement.push(toPoint(x+stageWidth*w50, rHubMid-hStatorEdgeShrouding));
					nextBladeBasement.push(toPoint(x+stageWidth*w85, rHubMid-(rHubMid-nextHub)*stageData.relativeBladeWidth - hStatorTailShrouding));
/*
					points.push(toPoint(x+stageWidth*w85, rHubMid-(rHubMid-nextHub)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000
										- hStatorTailShrouding));
					points.push(toPoint(x+stageWidth*w50, rHubMid+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000 - hStatorEdgeShrouding));
*/
				}
				//points.push(p);
				if (points.length > 0 && (stageData.isCompressor || i < stageData.stages.length-1)) {
					metrics.stators.push(points);
				}
				{
					//const w35 = stage.rotorWidth/stageWidth, w30 = 0.30, w50=0.5, w40=0.4, w60=0.6, w61=0.61, w65=0.65, w80=0.8, w85=0.85, w55=0.55, w15=0.15, w90=0.9, w95=0.95, w96=0.96;
					var p1, p2, p3, stageShaft,k;
					for (k = i; k < stageData.stages.length; k++) {
						if (stageData.stages[k].rShaft) {
							stageShaft = stageData.stages[k].rShaft;
							break;
						}
					}
					if (i < stageData.stages.length-1)
					{
						if (stageData.constantRpm) {
/*
							nextBladeBasement.push(toPoint(x+stageWidth*w85, rHub-hubWallWidth ));
							nextBladeBasement.push(toPoint(x, rHub-hubWallWidth ));
							nextBladeBasement.push(toPoint(x, rHub));
							nextBladeBasement.push(toPoint(x+stageWidth, nextHub));
							nextBladeBasement.push(toPoint(x+stageWidth, nextHub-hubWallWidth));
							nextBladeBasement.push(toPoint(x+stageWidth*w85, rHub-hubWallWidth ));
*/							
							nextBladeBasement.push(toPoint(x+stageWidth, nextHub));
							nextBladeBasement.push(toPoint(x+stageWidth, nextHub-hubWallWidth ));
							//nextBladeBasement.push(toPoint(x+stageWidth*w85, rHub+(nextHub-rHub)*w85-hubWallWidth ));
						}
						else {
							const peek = rHub-(rHub-nextHub)*(stageWidth-0.004)/stageWidth;
							nextBladeBasement.push(toPoint(x+stageWidth-0.004, peek));
//							nextBladeBasement.push(toPoint(x+stageWidth*w85, nextHub ));
							nextHookP1 = toPoint(x+stageWidth, nextHub*w95 );
							nextHookP2 = toPoint(x+stageWidth*w95, nextHub-(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000 );
						}
//						nextBladeBasement.push(toPoint(x+stageWidth*w85, stageShaft));
//						nextBladeBasement.push(toPoint(x+stageWidth*w80, stageShaft));
//						nextBladeBasement.push(toPoint(x+stageWidth*w80, stageData.constantDiameter == 'inner' || stageData.constantRpm ? rHub-hubWallWidth : rHub+(nextHub-rHub)*0.99));
/*
						var  whiteArea = [];
						p1 = toPoint(pb2.x, (rHub >= nextHub ? nextHub*w95 : 2*rHub - nextHub));
						whiteArea.push(p = toPoint(x+stageWidth*w35, stageShaft));
						whiteArea.push(toPoint(x+stageWidth*w80, stageShaft));
						whiteArea.push(toPoint(x+stageWidth*w80, yTemp = stageShaft+(p1.y-stageShaft)*(w90-w80)/(w80-w35)*w90)-0.01);
						whiteArea.push(toPoint(x+stageWidth*w35, stageShaft+(p1.y-stageShaft)*w90));
						whiteArea.push(p);
						metrics.whiteAreas.push(whiteArea);
*/
					}
					else {
						// TBD
						const peek = rHub-(rHub-nextHub)*w65 - 0.001;
						if (stageData.constantRpm) {
							if (stageData.isCompressor) {
								nextBladeBasement.push(toPoint(x+stageWidth*w35, rHub+(nextHub-rHub)*w35));
								nextBladeBasement.push(toPoint(x+stageWidth*w35, rHub+(nextHub-rHub)*w35-hubWallWidth ));
							}
							else {
								nextBladeBasement.push(toPoint(x+stageWidth, nextHub));
								nextBladeBasement.push(toPoint(x+stageWidth, nextHub-hubWallWidth ));
							}
/*
							xStator = x+stage.rotorWidth/stageData.relativeBladeWidth;
							nextBladeBasement.push(toPoint(x+stage.rotorWidth, rHub-stageWidth*0.20));
							nextBladeBasement.push(toPoint(x+stage.rotorWidth, rHub ));
							nextBladeBasement.push(toPoint(xStator-0.001, rHubMid ));
							nextBladeBasement.push(toPoint(x+stage.rotorWidth, rHub-stageWidth*0.20));
							if (stageData.isCompressor) {
								nextBladeBasement.push(toPoint(x+stageWidth*w85, stageShaft));
								nextBladeBasement.push(toPoint(x+stageWidth*w80, stageShaft));
								nextBladeBasement.push(toPoint(x+stage.rotorWidth, rHub-stageWidth*0.30));
							}
*/
						}
						else if (stageData.isCompressor) {
							nextBladeBasement.push(toPoint(x+stageWidth*w35, peek));
							nextBladeBasement.push(toPoint(x+stageWidth*w30, peek-stageWidth*0.05 ));
							//nextHookP1 = toPoint(x+stageWidth, nextHub*w95 );
							//nextHookP2 = toPoint(x+stageWidth*w61, nextHub-tipGap*stage.hBladeMm/1000 );
/*
							nextBladeBasement.push(toPoint(x+stageWidth*w85, stageShaft));
							nextBladeBasement.push(toPoint(x+stageWidth*w80, stageShaft));
							nextBladeBasement.push(toPoint(x+stageWidth*w55, peek-stageWidth*0.05));
*/
						}
/*
						if (stageData.isCompressor) {
							var  whiteArea = [];
							p1 = toPoint(pb2.x, (rHub > nextHub ? nextHub*w95 : 2*rHub - nextHub));
							whiteArea.push(p = toPoint(x+stageWidth*w35, stageShaft));
							whiteArea.push(toPoint(x+stageWidth*w80, stageShaft));
							whiteArea.push(toPoint(x+stageWidth*w60, yTemp = stageShaft+(p1.y-stageShaft)*(w90-w80)/(w80-w35)*w90)-0.01);
							whiteArea.push(toPoint(x+stageWidth*w35, stageShaft+(p1.y-stageShaft)*w90));
							whiteArea.push(p);
							metrics.whiteAreas.push(whiteArea);
						}
*/
					}
					nextBladeBasement.push(toPoint(x+stageWidth*w35, rHub+(nextHub-rHub)*w35-hubWallWidth ));
					nextBladeBasement.push(toPoint(x+stageWidth*w35, stageShaft));
					nextBladeBasement.push(toPoint(x, stageShaft));
					nextBladeBasement.push(toPoint(x, rHub ));
/*
					if (stageData.isCompressor || i < stageData.stages.length-1) {
						nextBladeBasement.push(p1 = toPoint(pb2.x, rHub + (rHub-nextHub)*w95));
						nextBladeBasement.push(p2 = toPoint(x+stageWidth*(w96), stageShaft));
					}
					nextBladeBasement.push(toPoint(nextBladeBasement[0].x, stageShaft));
					nextBladeBasement.push(nextBladeBasement[0]);
*/
					metrics.bladeBasements.push(nextBladeBasement);

/*
					var  whiteArea = [];
					whiteArea.push(p = toPoint(x+stageWidth*w35, stageShaft));
					whiteArea.push(toPoint(x+stageWidth*w80, stageShaft));
					whiteArea.push(toPoint(x+stageWidth*w80, yTemp = stageShaft+(p1.y-stageShaft)*(0.90-0.80)/(0.80-0.35)*w90)-0.01);
					whiteArea.push(toPoint(x+stageWidth*w35, stageShaft+(p1.y-stageShaft)*w90));
					whiteArea.push(p);
					metrics.whiteAreas.push(whiteArea);
*/
					nextBladeBasement = [];
				}
 				if (stage.rpmPower) //  && typeof stage.rGear !== 'undefined'
				{
					points = [];
					//if (stage.rGear) 
					{
						points.push(p = toPoint(xNextGear, stage.rGear));
						points.push(toPoint(xNextGear+gearWidth/2, stage.rGear));
					}
					points.push(toPoint(xNextGear+gearWidth/2, stage.rShaft));
					if (stageData.constantRpm) {
						points.push(toPoint(x+stageWidth+yExitPipe/2, stage.rShaft));
						points.push(toPoint(x+stageWidth+yExitPipe/2, rInnerShaft));
					} 
					else {
						points.push(toPoint(x+stageWidth*(i == stageData.stages.length-1 ? 1.4 : (w96)), stage.rShaft));
						points.push(toPoint(x+stageWidth*(i == stageData.stages.length-1 ? 1.4 : (w96)), rInnerShaft));
					}
					points.push(toPoint(xNextGear, rInnerShaft));
					points.push(p);
					metrics.shafts.push(points);

					points = [];
					const genShaftRadius = stageData.gearCenterDifference - stage.rGear < 0.075 ? stageData.gearCenterDifference - stage.rGear : 0.075;
					points.push(p = toPoint(xNextGear-gearWidth/2-0.01, stageData.gearCenterDifference + genShaftRadius));
					points.push(toPoint(xNextGear, stageData.gearCenterDifference + genShaftRadius));
					//if (stage.rGear) 
					{
						points.push(toPoint(xNextGear, 2*stageData.gearCenterDifference - stage.rGear));
						points.push(toPoint(xNextGear+gearWidth/2, 2*stageData.gearCenterDifference - stage.rGear));
						points.push(toPoint(xNextGear+gearWidth/2, stage.rGear));
						points.push(toPoint(xNextGear, stage.rGear));
					}
					points.push(toPoint(xNextGear, stageData.gearCenterDifference - genShaftRadius));
					points.push(toPoint(xNextGear-gearWidth/2-0.01, stageData.gearCenterDifference - genShaftRadius));
					points.push(p);
					metrics.generatorShaft.push(points);

					xNextGear -= gearWidth;
				}
				//var yStator;
				//frameBottom.push(toPoint(x+stage.rotorWidth, yStator = rTip-(rTip-nextTip)*w35Y)+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000);
				//frameBottom.push(x+stageWidth*(i == stageData.stages.length-1 ? 1 : w85), yStator);

				//frameBottom.push(p=toPoint(x+stageWidth*w35, rTip - (rTip-rTipMid)*(1/stageData.relativeBladeWidth - 1)+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000+hRotorTailShrouding));
				p = stageData.isCompressor ? 
					toPoint(x+stageWidth*w85, rTipMid-(rTipMid-nextTip)*stageData.relativeBladeWidth+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000) :
					toPoint(x+stageWidth*w50, rTipMid+(stage.tipGap ? stage.tipGap : tipGap)*stage.hBladeMm/1000);
				frameTop.push(toPoint(p.x, p.y+frameThickness+hRotorTailShrouding));
				x += stageWidth;
//console.log(i+": rTip="+stage.rTip+"->"+nextTip+", frameBottom.push("+JSON.stringify(p)+"=toPoint(x, "+nextTip+"+"+(stage.tipGap ? stage.tipGap : tipGap)+"*"+(stage.hBladeMm/1000));
				frameTop.push(toPoint(p.x, p.y+frameThickness+hRotorTailShrouding));
				if (i == stageData.stages.length-1) {
					frameBottom.push(p);
					frameBottom.push(p=toPoint(x+((stageData.constantRpm ? yExitPipe/2 : yExitPipe - nextTip)), stageData.constantRpm ? nextTip + yExitPipe/2 : yExitPipe ));
					frameBottom.push(toPoint(p.x+0.1, p.y));
					frameTop.push(toPoint(p.x, p.y+frameThickness+hRotorTailShrouding));
					frameTop.push(toPoint(p.x+0.1, p.y+frameThickness+hRotorTailShrouding));
				}
			}
			metrics.minX = xNextGear + gearWidth - 0.1;
			metrics.maxX = frameBottom[frameBottom.length-1].x + 0.1;
			metrics.maxY = frameTop[stageData.isCompressor ? 0 : frameTop.length-1].y + 0.1;
			const rMax = stageData.isCompressor ? stageData.stages[0].rTip : stageData.stages[stageData.stages.length-1].rTipOut;
			if (metrics.maxY < rMax*1.1) metrics.maxY = rMax*1.1;
			metrics.minY = -metrics.maxY;
			if (metrics.minY*mToPx > -450) metrics.minY = -450/mToPx;
			
			
			//metrics.frame = frameTop.concat(frameBottom.reverse());
			metrics.frame = frameBottom.concat(frameTop.reverse());
			//metrics.frame.push(metrics.frame[0]);
//console.log("frame="+JSON.stringify(metrics.frame));
			return metrics;
		}

		// Axial speed v has increased 2 times faster at rotor exit than mach in p, t 
		// Typical v and mach incerement per stage with the values above is between 1.04 and 1.05
		// => we will decrease v here by 1/1.02 to adjust it to the local mach number
		stageData.vvAbs2Mach = Math.sqrt(Math.pow(stageData.machMaxSpeed,2)/(Math.pow(1/stageData.flowCoefficientMin-stageData.tanβ2,2) + 1)) / 1.0225; 
		stageData.vMach = Math.cos(stageData.β1)*stageData.machMaxSpeed;
		stageData.machRelHub = stageData.vMach / Math.cos(stageData.hubβ1);

if (!first.p || !last.p) console.log("Bad cycledata:"+JSON.stringify(data.items));
		stageData.pHigh = Math.max(last.p0, first.p0);
		stageData.pLow = Math.min(last.p0, first.p0);
		
		stageData.hStagnIn = first.h0;
		stageData.hStagnOut = stageData.hEnd = last.h0;
//console.log("speedOut="+speedOut+", exitPipeDiameter="+exitPipeDiameter+", hEnd="+stageData.hEnd);
		first.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', first.p, 'H', first.h, name);
		if (first.speedOfSound === Infinity) {
			first.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', first.p, 'T', first.t+1, name);
		}
		var inlet = {};
		{
			var vMachInlet = stageData.vMach
			var v = stageData.constantDeltaH ? stageData.v : stageData.vMach*first.speedOfSound;
			//v = stageData.vMachLimitForFirstStage*first.speedOfSound;
			first.s = Module.PropsSI('S','P', first.p, 'H', first.h, name);
			const c1 = !stageData.pressureAdjusted && stageData.inletC1 ? stageData.inletC1 : v; // / Math.cos(stageData.inletα1);
			var hKinetic = 0.5* c1*c1;
			inlet.hKinetic = hKinetic;
			inlet.v = c1;
			inlet.hDeltaKinetic = 0.5*(first.v**2) - hKinetic;

			if (stageData.constantDeltaH) {
				inlet = initCryogenicInlet(stageData, first );
			}
			else {
				var hMin = first.h - hKinetic*1.1;
				var pMin = Module.PropsSI('P','H', hMin, 'S', first.s, name);
				while (pMin == Infinity) {
					vMachInlet = vMachInlet*0.98;
					v = vMachInlet*first.speedOfSound;
					const c1 = v / Math.cos(stageData.hubα1);
					hKinetic = 0.5* c1*c1;
					hMin = first.h - hKinetic*1.1;
					pMin = Module.PropsSI('P','H', hMin, 'S', first.s, name);
				}
				inlet.hLoss = Math.abs(inlet.hDeltaKinetic)*(1-stageData.diffuserEfficiency);

//console.log("First item:"+JSON.stringify(first)+", pMin="+pMin+", hMin="+hMin+", stageData="+JSON.stringify(stageData));
				var ret = testResult(first.h0, pMin, first.p, hKinetic*0.01, function(p) {
					// this is wrong, we should use enthalpy instead of pressure!!!
					inlet.p = p;
					inlet.h = Module.PropsSI('H','P', p, 'S', first.s, name);
					inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'H', inlet.h, name);
					if (inlet.speedOfSound === Infinity) {
						inlet.speedOfSound = Module.PropsSI('SPEED_OF_SOUND','P', inlet.p, 'Q', 1, name);
					}
					//inlet.v = stageData.vMachLimitForFirstStage*inlet.speedOfSound;
					inlet.v = vMachInlet*inlet.speedOfSound;
					inlet.hDeltaKinetic = 0.5*(inlet.v**2) - 0.5*(first.v**2);
					inlet.h += inlet.hDeltaKinetic*(1-stageData.diffuserEfficiency);	// subtract the enthalpy loss 
					inlet.t = Module.PropsSI('T','P', p, 'H', inlet.h, name);
					inlet.d = Module.PropsSI('D','P', p, 'H', inlet.h, name);
					if (inlet.d === Infinity) {
						inlet.d = Module.PropsSI('D','P', p, 'T', inlet.t+0.1, name);
					}

					ret = inlet.h0 = inlet.h + 0.5*inlet.v*inlet.v;

					if (ret === Infinity) {
						console.log("ret === Infinity, inlet="+JSON.stringify(inlet)+", first="+JSON.stringify(first)+", pMin="+pMin+", gas:"+name);
					}					
					return ret;
				});
				console.log(title+" inlet:"+JSON.stringify(inlet)+", first="+JSON.stringify(first)+", pMin="+pMin+", gas:"+name);
				if (!ret || inlet.d === Infinity || !inlet.d || typeof inlet.d === 'undefined') {
					console.log("Bad inlet, first:"+JSON.stringify(first));
					return;
				}
			}
		}
		// let's first assume, that we can rotate around the middle line shaft
		var item = inlet;
		stageData.inlet = inlet;
		stageData.first = first;
		stageData.last = last;
		stageData.pOut = last.p;
console.log("inlet="+JSON.stringify(inlet)+", first="+JSON.stringify(first)+", last="+JSON.stringify(last));

		if (typeof last.d === 'undefined') last.d = Module.PropsSI('D','P', last.p, 'T', last.t, name);
		last.flowM3 = stageData.massFlowInKg /last.d;
		if (typeof first.d === 'undefined') first.d = Module.PropsSI('D','P', first.p, 'T', first.t, name);
		first.flowM3 = stageData.massFlowInKg /first.d;

		stageData.horizontalVector = 1;
console.log("inlet="+JSON.stringify(inlet)+", stageData.v="+stageData.v);
		calcCompressorStages( stageData, inlet ); 
		var stages = stageData.stages;
		var i;
		const iLast = stages.length-1;

		if (typeof stageData.exit === 'undefined') {
			stageData.exit = last;
		}
		var outlet = {};
		outlet.h = stages[iLast].hOut;
		outlet.p = stages[iLast].pOut;
		outlet.d = stages[iLast].dOut;
		outlet.s = stages[iLast].sOut;
		outlet.v = stages[iLast].v;
		if (stages[iLast].midα2) {
			outlet.c2 = stages[iLast].v / Math.cos(stages[iLast].midα2);
		}
		if (typeof outlet.visc === 'undefined') {
			outlet.t = Module.PropsSI('T','P', outlet.p, 'H', outlet.h, name);
			outlet.visc = Module.PropsSI('VISCOSITY','P', outlet.p, 'H', outlet.h, name);
		}
		const shaftPipeWidth = stages[0].rTip*0.075*7/6;	// approximation!
/*
		// function returns a very small loss, replace it with configurable constant diffuserEfficiency
		stageData.inletPressureDrop = getCompressorInletOrExitPressureDrop( massFlowInKg, inletPipeDiameter, shaftPipeWidth, first, stages[0].rTip, stages[0].rHub, inlet, inletPipeDiameter-stages[0].rTip );
		stageData.exitPressureDrop = getCompressorInletOrExitPressureDrop( massFlowInKg, exitPipeDiameter, shaftPipeWidth, stageData.exit, stages[iLast].rTip, stages[iLast].rHub, outlet, exitPipeDiameter-stages[iLast].rTip );
		if (stageData.hasIGV) {
			stageData.inletPressureDrop *= 2.5; // assume: end wall loss 40%, profile loss 60%
		}
		if (stageData.hasOGV) {
			stageData.exitPressureDrop *= 2.5; // assume: end wall loss 40%, profile loss 60%
		}
*/
		if (stageData.constantDeltaH) {
			var actualPower = 0;
//			stageData.hDeltaKinetic = [];
//			const hKinetics = [];
var actualPowers = [];
			for (i = 0; i < stages.length; i++) {
				actualPowers.push(stages[i].hDeltaPower*stageData.massFlowInKg);
				actualPower += stages[i].hDeltaPower*stageData.massFlowInKg;
			}
			
//console.log("stageData.hDeltaKinetic="+JSON.stringify(stageData.hDeltaKinetic)+", hKinteics="+JSON.stringify(hKinetics));
var initialStages = stageData.stages;
if (stageData.cStages == 1) {
	console.log("initial stages:"+JSON.stringify(stageData.stages));
}
			const constantDeltaH = (actualPower / stageData.cStages) / massFlowInKg;
console.log("***grossPower="+grossPower+" => actualPower="+actualPower+", actualPowers="+JSON.stringify(actualPowers)+", constantDeltaH:"+stageData.constantDeltaH+"=>"+constantDeltaH);
			//stageData.constantDeltaH = constantDeltaH;
			//stageData.constantDeltaH = (constantDeltaH+stageData.constantDeltaH)/2;
			/*if (!stageData.isCompressor) {
				stageData.constantDeltaH = constantDeltaH; // (constantDeltaH+stageData.constantDeltaH)/2;
			}
			else */
			{
				stageData.constantDeltaH = (constantDeltaH+stageData.constantDeltaH)/2;
			}
			stageData.Um = Math.sqrt(stageData.constantDeltaH/stageData.stageLoadingCoefficientMean);
			stageData.v = stageData.Um*stageData.flowCoefficientMean;
			stageData.hubToTipRatioMax = stageData.hubToTipRatio;		// keep it constant!
			inlet = initCryogenicInlet( stageData, first );
			inlet.flowM3 = stageData.massFlowInKg /inlet.d;
//console.log("First item:"+JSON.stringify(first)+", inlet="+JSON.stringify(inlet));
			calcCompressorStages( stageData, inlet ); 
		}
		item = inlet;
		stageData.inlet = inlet;
		cosAll = 0;
		stages = stageData.stages;
		for (i = 0; i < stages.length; i++) {
			if (!stageData.isCompressor) {
				const h = stages[i].hRotor;
				stages[i].rotorWidth2h =  Math.cos(Math.PI*stages[i].rotorStaggerAngle/180)*2*stages[i].reaction / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].statorWidth2h = (i < stages.length-1) ? stages[i].rotorWidth2h * 2*(1 - stages[i].reaction) * (h+(stages[i+1].rTip-stages[i+1].rHub)) / 2 / h : stages[i-1].statorWidth2h;
				stages[i].rotorWidth = stages[i].rotorWidth2h * h;
				stages[i].statorWidth = stages[i].statorWidth2h * h;
				stages[i].stageWidth2h = (stages[i].rotorWidth2h + stages[i].statorWidth2h) / stageData.relativeBladeWidth;
			}
			else {
				stages[i].rotorWidth2h = Math.cos(Math.PI*stages[i].rotorStaggerAngle/180)*2*stages[i].reaction / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].statorWidth2h = Math.cos(Math.PI*stages[i].statorStaggerAngle/180) / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].rotorWidth = stages[i].rotorWidth2h * stages[i].hRotor;
				stages[i].statorWidth = stages[i].statorWidth2h * stages[i].hStator;
				stages[i].stageWidth2h = (stages[i].rotorWidth2h + stages[i].statorWidth2h) / stageData.relativeBladeWidth;
			}
		}
		if (stageData.constantRpm) {
			stageData.horizontalVector = 1;
		}
		else 
		{
			stageData.horizontalVectors = [];
			for (i = 0; i < stages.length; i++) {
				const cos = (stages[i].rTip-stages[i].rHub)*stages[i].stageWidth2h;
				cosAll += cos;
				if (typeof stageData.hpExit !== 'undefined') {
					const sin = (stages[i].rTip+stages[i].rHub)/2 - (i == (stages.length - 1)  ? (stageData.hpExit.rTip + stageData.hpExit.rHub)/2 : (stages[i+1].rTip + stages[i+1].rHub)/2);
					const r = Math.sqrt(sin*sin + cos*cos);
					stageData.horizontalVectors.push(cos/r);
				}
			}
			stageData.middleLineLength = cosAll;
			// Basic trigonometry: we know the approximate middle line length to turn rotors up
	//console.log("stages:"+JSON.stringify(stages)+", stageData.horizontalVector="+stageData.horizontalVector);
	//console.log("items:"+JSON.stringify(stageData.items));
			const sinAll = (stages[0].rTip+stages[0].rHub)/2 - (stages[stages.length-1].rTip + stages[stages.length-1].rHub)/2;
			const rAll = Math.sqrt(sinAll*sinAll + cosAll*cosAll);

			// now we turn the rotors up because of very strong centrifugal force 
			// The rotors must be in the vertical position straight up, because otherwise the centrifugical force will be pushing rotors to the same direction as the gas compression.
			// so we must turn the rotors up and calclulate everything again 
			stageData.horizontalVector = cosAll/rAll;
console.log("*****stageData.horizontalVector="+stageData.horizontalVector+", stageData.horizontalVectors="+JSON.stringify(stageData.horizontalVectors));
			//stageData.horizontalVectors = null;
		}
		// calc again with rotor rotaing vertically
		calcCompressorStages( stageData, inlet ); 

		if (stageData.constantDeltaH)
		{
			stages = stageData.stages;
			var actualPower = 0;
			for (i = 0; i < stages.length; i++) {
				actualPower += Math.abs(stages[i].deltaH*stageData.massFlowInKg);
			}
			actualPower *= 1.001;
			const constantDeltaH = (actualPower / stageData.cStages) / massFlowInKg;
console.log("***grossPower="+grossPower+" => actualPower="+actualPower+", deltaH:"+stageData.constantDeltaH+"=>"+constantDeltaH);
		}
		item.s = Module.PropsSI('S','P', item.p, 'T', item.t, name);

		stageData.length = 0;
		stages = stageData.stages;
		var rpmPower = 0;
		var prevRmp = -1;
		var totalPower = 0;
		
		
		for (i = 0; i < stages.length; i++) {
/*
			const h = stages[i].hRotor;
			stages[i].rotorWidth2h =  Math.cos(Math.PI*stages[i].rotorStaggerAngle/180) / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
			stages[i].statorWidth2h = (i < stages.length-1) ? stages[i].rotorWidth2h * (1 - stages[i].reaction)/stages[i].reaction * (h+stages[i+1].hRotor)/2 / h : stages[i-1].statorWidth2h;
			stages[i].rotorWidth = stages[i].rotorWidth2h * h;
			stages[i].statorWidth = stages[i].statorWidth2h * h;
			stages[i].stageWidth2h = (stages[i].rotorWidth2h + stages[i].statorWidth2h) / stageData.relativeBladeWidth;
*/
			stages[i].rotorWidth = stages[i].hRotor*Math.cos(Math.PI*stages[i].rotorStaggerAngle/180)*2*stages[i].reaction / stages[i].aspectRatio;
			stages[i].statorWidth = stages[i].hStator*Math.cos(Math.PI*stages[i].statorStaggerAngle/180)*2*(1-stages[i].reaction) / stages[i].aspectRatio
			stages[i].width = (stages[i].rotorWidth+stages[i].statorWidth)/ stageData.relativeBladeWidth
/*			
			if (!stageData.isCompressor) {
				const h = stages[i].hRotor;
				stages[i].rotorWidth2h =  ;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].statorWidth2h = (i < stages.length-1) ? stages[i].rotorWidth2h * 2*(1 - stages[i].reaction) * (h+(stages[i+1].rTip-stages[i+1].rHub)) / 2 / h : stages[i-1].statorWidth2h;
				stages[i].statorWidth = stages[i].statorWidth2h * h;
				stages[i].stageWidth2h = (stages[i].rotorWidth2h + stages[i].statorWidth2h) / stageData.relativeBladeWidth;
			}
			else {
				stages[i].rotorWidth2h = Math.cos(Math.PI*stages[i].rotorStaggerAngle/180)*2*stages[i].reaction / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].statorWidth2h = Math.cos(Math.PI*stages[i].statorStaggerAngle/180) / stages[i].aspectRatio;		// e.g: rotor:gap:stator:gap 8:1:8:1 
				stages[i].rotorWidth = stages[i].rotorWidth2h * stages[i].hRotor;
				stages[i].statorWidth = stages[i].statorWidth2h * stages[i].hStator;
				stages[i].stageWidth2h = (stages[i].rotorWidth2h + stages[i].statorWidth2h) / stageData.relativeBladeWidth;
			}
*/
			const effectiveLoadCoefficient = stages[i].midStageLoadingCoefficient;
			const midToTip = stageData.isCompressor ? stages[i].rMid/stages[i].rTip : stages[i].rMidMid/stages[i].rTipMid;
			stages[i].stageLoadingCoefficient = effectiveLoadCoefficient*midToTip*midToTip;
			//const tanβ2 = (1/2 - stages[i].stageLoadingCoefficient/2)/stages[i].flowCoefficient;
			//const β2 = Math.atan(tanβ2);
			//stages[i].β2deg = 180 * β2/Math.PI;
			//stages[i].width = stages[i].hRotor*stages[i].stageWidth2h*(stageData.horizontalVectors ?  stageData.horizontalVectors[i] : stageData.horizontalVector);
//if (!stages[i].width) console.log(i+"null width!!!, hv="+stageData.horizontalVectors[i])
			stages[i].diameterMm = ((stageData.isCompressor ? stages[i].rTip : stages[i].rTipOut)+0.002)*2*1000;
			stages[i].rTipMm = (stageData.isCompressor ? stages[i].rTip : stages[i].rTipOut)*1000;
			stages[i].rMeanMm = (stageData.isCompressor ? stages[i].rMid : stages[i].rMidOut)*1000;
			const hubToTip = stageData.isCompressor ? (stages[i].rHub/stages[i].rTip) : (stages[i].rHubOut/stages[i].rTipOut);
			stages[i].hBladeMm = stages[i].hRotor*1000;
			stages[i].chordMm = 2 * stageData.reaction * stages[i].hBladeMm / stages[i].aspectRatio;
//console.log(i+": Rotor chordMm="+stages[i].chordMm+"="+(2 * stageData.reaction)+" * "+stages[i].hBladeMm+" / "+stages[i].aspectRatio+", stages[i].rotor.tMid="+stages[i].rotor.tMid);
			//stages[i].hubStageLoadingCoefficient = stages[i].stageLoadingCoefficient/(hubToTip*hubToTip);
			//stages[i].hubFlowCoefficient = stages[i].flowCoefficient / hubToTip;
			//stages[i].hubβ2deg = 180/Math.PI * Math.atan((1/2 - stages[i].hubStageLoadingCoefficient/2)/stages[i].hubFlowCoefficient);
			//const deltaP = i == stages.length-1 ? stageData.hpExit.p : stages[i+1].p - stages[i].p;
			//stages[i].pRiseCoeffcient = 2*deltaP/(stages[i].d*stages[i].U*stages[i].U);
			const tipTanβ1 = stageData.isCompressor ? (stageData.reaction + stages[i].stageLoadingCoefficient/2)/stages[i].flowCoefficient :
													  (stageData.reaction - stages[i].stageLoadingCoefficient/2)/stages[i].flowCoefficient;
			const tipβ1 = Math.atan(tipTanβ1);
			stages[i].machRelTip = stages[i].v / (stages[i].mach * Math.cos(tipβ1));
			//const hubβ1 = Math.atan((stage.reaction + stages[i].hubStageLoadingCoefficient/2)/stages[i].hubFlowCoefficient);
			//stages[i].machRelHub = stages[i].v / (stages[i].mach * Math.cos(hubβ1));
			// deltaH + 0.5*v^2 = 0.5*v2^2  => v2 = sqrt( 2*deltaH + v^2)

/*
	Centrifugal force cannot fix the 

			// let's assume that rotor is in 10 degree agle backward => 
			//stages[i].F = totalBladeMass * U^2 /rTip * sin(10)
			// =>totalBladeMass = stages[i].F/(U^2 /rTip * sin(10))
			const totalBladesMass = stages[i].F / (stages[i].U*stages[i].U*Math.sin(Math.PI/18) / stages[i].rTip);
console.log(totalBladesMass+" = "+stages[i].F+" / ("+(stages[i].U*stages[i].U)+"*"+Math.sin(Math.PI/18)+" / "+stages[i].rTip);
			// Next we calculate blade width from this know mass of all blades
			// <Blade tipArea> = 0.3 * <blade hubArea> 
			// => totalBladeMass = 0.65 * (rTip-rHub)*2*PI*rHub*hubWidth*(hubSolidity=2)
			// => bladeThicknessInHub = totalBladeMas/(0.65 * (rTip-rHub)*2*PI*rHub*2) * density(8);
			stages[i].bladeThicknessInHub = totalBladesMass/(0.65 * 8 * (stages[i].rTip-stages[i].rHub)*2*Math.PI*stages[i].rHub*2);
*/
/* Rotor tips are VERY VERY HOLLOW AND SLIM COMPARED TO THICKNESS IN HUB, d=0.15 => K=0.55

			if (i == 0) {
				var d;
				for (d = 0.1125; d < 0.5; d += 0.025) {
					const K = 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
					console.log("****** d="+d+" => K="+K);
				}
			}
			// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
			// => d=0.1625 => K=0.5516289551934646
			// => d=0.35 => K~0.65
*/
	
			if (!stages[i].centrifugalStressMpa) {
				stages[i].centrifugalStressMpa = 0.5*stages[i].U*stages[i].U*8000*(1-hubToTip*hubToTip)*stages[i].K/1000000; // Nimonics: 8000 kg/m3, austentic steel alloy density 7800kg/m3)
				if (Number.isNaN(stages[i].centrifugalStressMpa)) throw new Error("NaN");
			}
			stages[i].pRatio = stageData.isCompressor ? stages[i].pOut / stages[i].p : stages[i].p / stages[i].pOut;
			if (!stages[i].cRe || typeof stages[i].cRe === 'undefined') {
				// the viscosity very near to sat temp may be very high and not representative value for the whole stage
				var visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t+1, name);
				if (visc == Infinity) {
					visc = Module.PropsSI('V', 'P', stages[i].p, 'T', stages[i].t+1.1, name);	// use gas viscosity, ignore the obvious wetness here
				}
				if (visc != Infinity) {
					stages[i].cRe = stages[i].d * ((stages[i].rTip-stages[i].rHub)/stages[i].aspectRatio) * stages[i].v / Math.cos(stage.midβ1) / visc;
				}
			}
			stages[i].cReText = stages[i].cRe/1000000;
			const area = Math.PI*(stages[i].rTip*stages[i].rTip -  stages[i].rHub*stages[i].rHub);
			stages[i].AN2EXP8=stages[i].rpm*stages[i].rpm*area/100000000;
			stageData.length += stages[i].width;
			if (prevRmp != stages[i].rpm && rpmPower != 0) {

				stages[i-1].rpmPower = rpmPower;
				totalPower += rpmPower;
				rpmPower = 0;
			}
			// 
			const hPowerInOrOut = (stages[i].hOut + stages[i].hKineticOut) - (stages[i].h + stages[i].hKineticIn);
			stages[i].stagePower = Math.abs(hPowerInOrOut)*stageData.massFlowInKg;
			stages[i].h0 = stages[i].h+stages[i].hKineticIn;
			rpmPower += stages[i].stagePower;
			prevRmp = stages[i].rpm;
		}
		totalPower += rpmPower;
		stages[i-1].rpmPower = rpmPower;
		var rPrev = 0, rPrevPrev = 0;
		// Md = 9500 * P / rpm;
		// Wvsall = Md / (max stength) * 0.4;
		// r = pow(2 * Wvsall/PI, 1/3);
		// Ja putkella: r^2*t = 2 * Wvsall/PI, jossa r on ulkohakaisija, ja renkaan paksuus
		// Kun sisähalkaisija tunnettu saadaan t = r-rIn
		var gearCenterDifferenceScale = 1;
		
		for (i = stages.length-1; i >= 0; i--) {
			if (stageData.constantRpm) {
				stages[i].rShaft = stages[0].rTip*0.075; // 0.15;
				stages[i].shaftPipeWidth = stages[0].rTip*0.075*7/6; // 0.175;
			}
			else if (stages[i].rpmPower) {
				// https://www.theseus.fi/bitstream/handle/10024/77283/Hartikainen_Matti.pdf?sequence=1
				const curPower =  stages[i].rpmPower * 1.2; // stages[i].deltaH //
				// stages[i].rpmPower, https://en.wikipedia.org/wiki/Torque: P = Mn*2*PI*rpm/60;
				const Md = 60 * curPower / (2 * Math.PI * stages[i].rpm);
				// Wx = 2*Wi/PI =>
				const Wx = 2 * (Md / stageData.shaftStrength) / Math.PI;
				if (rPrev == 0) {
					if (stageData.rInnerShaftCoolingPipe == 0) {
						stages[i].rShaft = Math.pow(Wx, 1/3);
					}
					else {
						testResult( Wx, stageData.rInnerShaftCoolingPipe, 0.20+stageData.rInnerShaftCoolingPipe, Wx*0.01, function (r) {
							stages[i].rShaft = r;
							return (Math.pow(r,4)-Math.pow(stageData.rInnerShaftCoolingPipe,4)) / r;
						});
						stages[i].shaftPipeWidth = stages[i].rShaft - stageData.rInnerShaftCoolingPipe;
					}
				}
				else {
					// http://rmseura.tkk.fi/opetusmonisteita/RLP_L.pdf: Ympyrärengaspoikkileikkauksen vääntö:
					// Wi = PI * (Dout^4 - Din^4) / (16*Dout) where Dout outer diameter of pipe and Din inner diameter
					// => Wi = PI*(Rout^4 - Rin^4) / (2*Rout); 
					testResult( Wx, rPrev, rPrev+(rPrev-rPrevPrev), Wx*0.01, function (r) {
						stages[i].rShaft = r;
						return (Math.pow(r,4)-Math.pow(rPrev,4)) / r;
					});
					stages[i].shaftPipeWidth = stages[i].rShaft - rPrev;
				}
				if (stages[i].shaftPipeWidth < stageData.minShaftPipeWidth) {
					if (stageData.gearCenterDifference) {
						const rGear  =  stageData.generatorRpm * stageData.gearCenterDifference / (stages[i].rpm + stageData.generatorRpm);
						const minShaft = stages[i].rShaft;
						stages[i].rShaft += (stageData.minShaftPipeWidth-stages[i].shaftPipeWidth);
						if (stages[i].rShaft > rGear) {
							stages[i].rShaft = rGear > minShaft ? rGear : minShaft;
						}
					}
					else {
						stages[i].rShaft += (stageData.minShaftPipeWidth-stages[i].shaftPipeWidth);	// never here???
					}
					stages[i].shaftPipeWidth = stageData.minShaftPipeWidth;
				}
				// This is now always the same as the actual power
				const torqueUpToPower = (stages[i].U/stages[i].rTip) * stageData.shaftStrength * Math.PI/2 * (Math.pow(stages[i].rShaft,4)-Math.pow(rPrev,4)) / stages[i].rShaft;
				stages[i].usedTorquePower = Math.round(100*stages[i].rpmPower/torqueUpToPower);
				// Next we calc the centrifugal tangential stress in pipe shft as % of max allowed
				// 3-15 Stresses in Rotating Rings Shigley's Mechanical Engineering Design, Eighth Edition. p.110
				// https://www.academia.edu/41460327/Shigleys_Mechanical_Engineering_Design_8th_Edition
				// 
				// σ = ρ * ω^2*(3 + ν)/8*(ri^2 + ro^2 + ri^2*ro^2/r^2 - (1 + 3 * ν) * r^2 / (3 + ν))
				// ρ = mass density, σ = tangential stress, ω = angular speed radians/s, 
				// ν = material's Poisson's ratio (0.3 for maranging steel), ri=inner radius, ro=outer radious,
				// r = inner radius (stress seems to be higher in the inner radius
				if (rPrev) {
					const ω = 2 * Math.PI * stages[i].rpm / 60;
					const ρ = 7700; // typical value for steel
					const ν = 0.3; // for maranging steel (steel 0.28 - 0.33
					const ro = stages[i].rShaft;
					const ri = rPrev;
					const r = ri;
	//if (i == 0) console.log("ω="+ω+", ρ="+ρ+", ν="+ν+", ro="+ro+", ri="+ri);
					stages[i].shaftTangentialStressOfMax =  ρ*ω*ω*(3 + ν)/8*(ri*ri + ro*ro + ri*ri*ro*ro/r*r - (1 + 3 * ν) * r*r / (3 + ν))
													 * 100 / stageData.shaftStrength;
				}
//console.log(i+":shaftTangentialStressOfMax %:"+stages[i].shaftTangentialStressOfMax);
				// Math.sqrt(stages[i].rpmPower/(stageData.shaftStrength*Math.PI) + rPrev*rPrev);
				rPrevPrev = rPrev;
				rPrev = stages[i].rShaft + stageData.shaftBearingSpace; // add 2 mm pipe thickness for bearings between pipes
				
				if (stageData.gearCenterDifference) {
					// rpm * rGear = 3000 * (diffShafts-rGear)
					// => rGear*(rpm + 3000) = 3000*diffShafts
					// => rGear = 3000*diffShafts / (rpm + 3000);
					stages[i].rGear  =  stageData.generatorRpm * stageData.gearCenterDifference / (stages[i].rpm + stageData.generatorRpm);
//console.log("*** stage "+i+": rGear="+stages[i].rGear+", rShaft="+stages[i].rShaft);
					if (stages[i].rGear < stages[i].rShaft) {
//console.log("***** stage "+i+": Gear radius cannot be less than stage shaft:"+stages[i].rGear+" < "+stages[i].rShaft+" => use stronger steel for stage shafts");
						if (gearCenterDifferenceScale <  stages[i].rShaft/stages[i].rGear) {
//console.log("***** New stageData.gearCenterDifference:"+stageData.gearCenterDifference+" => "+(stages[i].rShaft/stages[i].rGear));
							gearCenterDifferenceScale = stages[i].rShaft/stages[i].rGear;
						}
					}
				}
				else {
					if (typeof sideOfGeneratorShaft !== 'undefined') {
						stageData.height = 2 * stageData.stages[0].rTip + 0.052; // 50 mm for frame, 2 mm for tip gap
						stageData.gearCenterDifference = stageData.height / 2 + 0.10; // Generator shaft diameter 15 cm, 5 cm for margin
						stages[i].rGear  =  stageData.generatorRpm * stageData.gearCenterDifference / (stages[i].rpm + stageData.generatorRpm);
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) {
							stageData.gearCenterDifference *= stageData.vGearMax/vGear;
							stages[i].rGear *= stageData.vGearMax/vGear;
						}
					}
					else {
						stages[i].rGear = stages[i].rShaft*(stageData.constantDeltaH ? 2 : 1.5);	// add some space for sprockets
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) {
							stages[i].rGear *= stageData.vGearMax/vGear;	// scale down
						}
						const minRpm = stageData.generatorRpm*4;
						stageData.gearCenterDifference = stages[i].rGear * ((stages[i].rpm<minRpm ? minRpm : stages[i].rpm) + stageData.generatorRpm) / stageData.generatorRpm;
console.log("*** stage "+i+": minRpm="+minRpm+", rGear="+stages[i].rGear+", rShaft="+stages[i].rShaft+", stageData.generatorRpm="+stageData.generatorRpm+", stageData.gearCenterDifference="+stageData.gearCenterDifference+
							"part:"+(((stages[i].rpm<minRpm ? minRpm : stages[i].rpm) + stageData.generatorRpm) / stageData.generatorRpm));
					}
				}
				stages[i].vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
				stages[i].vShaft = stages[i].U * stages[i].rShaft / stages[i].rTip; // bearings contact velocity
				var k = i-1;
				while (k >= 0 && typeof stages[k].vGear === 'undefined') {
					stages[k].vGear = stages[k].U * stages[i].rGear / stages[k].rTip; // gear Pitch line velocity
					stages[k].vShaft = stages[k].U * stages[i].rShaft / stages[k].rTip; // bearings contact velocity
					k--;
				}
//console.log("rPrev="+rPrev+", stages["+i+"].rShaft="+stages[i].rShaft+". stages[i].rpmPower="+stages[i].rpmPower);
			}
			const nextPressure = stages[i].pOut;
			const pressureForce = Math.PI*(stages[i].rHub*stages[i].rHub - stages[i].rShaft*stages[i].rShaft)*(nextPressure-stages[i].p);
			stages[i].shaftPush = pressureForce + stages[i].F;
//console.log("nextPressure="+nextPressure+", p="+stages[i].p+", pressureForce="+pressureForce+", diff="+(nextPressure-stages[i].p)+"; stages[i].shaftPush="+stages[i].shaftPush+", stages[i].rShaft="+stages[i].rShaft);
		}
		for (i = stages.length-1; i >= 0; i--) {
			stages[i].rShaftMm = stages[i].rShaft*1000;
		}
		if (!stageData.constantRpm && gearCenterDifferenceScale > 1) {
			stageData.gearCenterDifference = 0;
			for (i = stages.length-1; i >= 0; i--) {
				if (stages[i].rpmPower) {
					if (stageData.gearCenterDifference) {
						// rpm * rGear = 3000 * (diffShafts-rGear)
						// => rGear*(rpm + 3000) = 3000*diffShafts
						// => rGear = 3000*diffShafts / (rpm + 3000);
						stages[i].rGear  =  stageData.generatorRpm * stageData.gearCenterDifference / (stages[i].rpm + stageData.generatorRpm);
						if (stages[i].rGear < stages[i].rShaft) {
							console.log("stage "+i+": Gear radius cannot be less than stage shaft:"+stages[i].rGear+" < "+stages[i].rShaft+" => use stronger steel for stage shafts");
						}
					}
					else {
						stages[i].rGear = stages[i].rShaft*1.2;	// add some space for sprockets
						const vGear = stages[i].U * stages[i].rGear / stages[i].rTip; // gear Pitch line velocity
						if (vGear > stageData.vGearMax) stages[i].rGear *= stageData.vGearMax/vGear;	// scale down
						stageData.gearCenterDifference = (stages[i].rGear * (stages[i].rpm + stageData.generatorRpm) / stageData.generatorRpm)*gearCenterDifferenceScale;
					}
				}
			}
		}
		var stageProps = [];
		/*[{"flowM3":719.3554187114403,"mach":472.8455859277404,"v":216.47949592530023,"rTip":1.4709655790313987,"rHub":1.029675905321979,"U":655.9984725009098,
			"rpm":4258.647559707064,"stageLoadingCoefficient":0.2,"flowCoefficient":0.33,"deltaH":86066.79918470538,"UMach":1.3873418554046915,"vMach":0.45782281228354815,
			"p":83333.16541505809,"t":542.5115676655989,"h":565516.0364540833,"d":0.5173553713201356,"β2deg":50.47736872882888,"width":0.6409065284242838,
			"hubStageLoadingCoefficient":0.4081632653061225,"hubFlowCoefficient":0.4714285714285715,"hubβ2deg":32.11672348673144,"pRatio":1.547774080462195,
			"cRe":1492681.078958619,"AN2EXP8":0.18733186587945871,"rpmPower":32030825.663454242,"rShaft":0.11920533192181018,"shaftPipeWidth":0.01,"usedTorquePower":"0.30",
			"rGear":0.14156252472063413,"vGear":63.13186474510021},
		*/
		var titles = [];
		titles.push(title);
		if (isHp) {
			if (gIsHpCompressorOne) {
				titles.push(gHeatExchangers.cooler.pLowFluid+" HE"); //to "+gHeatExchangers.cooler.pHighFluid+' heat exchanger');
				titles.push("Internal HE"); // gHeatExchangers.internal.pLowFluid+" to "+gHeatExchangers.internal.pHighFluid+' heat exchanger');
			}
			else {
				titles.push("Water HE2"); //gHeatExchangers.heater1.pLowFluid+" to "+gHeatExchangers.heater1.pHighFluid+' heat exchanger');
			}
		}
		titles.push('Pipe in');

		var maxStallMargin = 0;
		for (i = 0; i < stages.length; i++) {
			//getEfficiencyWithDF_DR( stageData, stages[i], i );
			titles.push('Stage '+(i+1));
			var stage = stages[i];
			if (i == 0 && typeof stage.meanFlowC1 !== 'undefined') {
				stage.v = stage.meanFlowC1;
			}
			if (stage.stallMargin > maxStallMargin) maxStallMargin = stage.stallMargin;
			var c = stage.hRotor / stage.aspectRatio * 2 * stage.reaction;
			var cStator = stage.hStator / stage.aspectRatio * 2 * (1-stage.reaction);
			stage.bladeMaxThicknessHub = myRound(100 * stage.rotor.tRoot/c, 1);
			stage.bladeMaxThicknessMid = myRound(100 * stage.rotor.tMid/c, 1);
			//stator.tRootPercent = myRound(100 * stage.stator.tRoot/(c*stage.stator.rootChordScale), 1);
			stage.statorMaxThicknessMid = myRound(100 * stage.stator.tMid/cStator, 1);
			//stage.hubTipReaction = myRound(stage.rotor.rootReaction,2)+'/'+myRound(stage.rotor.tipReaction,2);
			stages[i].tipGapPercent = stages[i].tipGap*100; // NOT: stages[i].aspectRatio *  tipGap/h => tipGap/c
			stages[i].UMach = myRound(stages[i].U/stages[i].mach,2);
			stages[i].getEfficiency = function( i, stage ){
				//const loadingFactor = getLoadFactor(stage.pressureRiseCoefficient);	// must be the top value
				//stage.efficiency = 1-getStageLoss(i, stage.cRe, stage.chordMm * stage.bladeMaxThicknessMid/100, stage.hBladeMm, stage.chordMm, stage.tipGap ? stage.tipGap : 0.005, loadingFactor);
				return myRound(stage.efficiency, 3);
			};
			stages[i].getPressureRiseCoeffcient = function( i, stage ){
				const x = stage.p*(stage.pRatio-1)/(stage.d*stage.U*stage.U);
				console.log("pressureRiseCoeffcient="+x);
				return x;
			};
		}
		titles.push('Pipe out');
		if (isHp) {
			if (gIsHpCompressorOne) {
65
				titles.push("Water HE1"); // gHeatExchangers.heater1.pLowFluid+" to "+gHeatExchangers.heater1.pHighFluid+' heat exchanger');
			}
			else {
				titles.push("Water HE2"); // gHeatExchangers.heater2.pLowFluid+" to "+gHeatExchangers.heater2.pHighFluid+' heat exchanger');
				titles.push("Internal HE"); // gHeatExchangers.internal.pLowFluid+" to "+gHeatExchangers.internal.pHighFluid+' heat exchanger');
				titles.push(gHeatExchangers.cooler.pLowFluid+" HE");
			}
		}
		if (stageData.exit) last = stageData.exit;
		stageProps.push(titles);
		first.diameter = inletPipeDiameter;
		first.diameterMm = inletPipeDiameter*1000;
		first.pRatio = stageData.isCompressor ? stages[0].p / first.p : first.p / stages[0].p;
		if (typeof first.h0 === 'undefined') first.h0 = first.h+0.5*(first.v**2);
		first.hDeltaKinetic = stageData.inlet.hDeltaKinetic;
		first.sLoss = stages[0].s - first.s;
//console.log("first.hDeltaKinetic="+first.hDeltaKinetic);
		last.diameter = exitPipeDiameter;
		last.diameterMm = exitPipeDiameter*1000;
		last.pRatio = stageData.isCompressor ? last.p / stageData.hpExit.p : stageData.hpExit.p / last.p;
		last.h0 = last.h+0.5*(last.v**2);
		last.sLoss = last.s - stages[stages.length-1].sOut;
		//stages[stages.length-1].pRatio /= last.pRatio;
		var data = [];

		if (isHp) {
			if (gIsHpCompressorOne) {
				var he = gHeatExchangers.cooler;
				data.push({t:he.tColdHigh, p:he.pHigh, h:Module.PropsSI('H', 'P', he.pHigh, 'T', he.tColdHigh, he.pHighFluid), 
						   v:he.speedHighP, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.pHighFluidMassFlowKg/Module.PropsSI('D', 'P', he.pHigh, 'T', he.tColdHigh, he.pHighFluid),
						   pRatio:(he.pHigh-he.pDropHigh)/he.pHigh, stagePower:he.deltaH*he.pHighFluidMassFlowKg});
				he = gHeatExchangers.internal;
				data.push({t:he.tCold, p:he.pLow, h:Module.PropsSI('H', 'P', he.pLow, 'T', he.tCold, he.pLowFluid), 
						   v:he.speed, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.flow, pRatio:(he.pLow-he.pDropLow)/he.pLow, stagePower:he.deltaH*he.massFlowKg});
			}
			else {
				var he = gHeatExchangers.heater1;
				data.push({t:he.tHot, p:he.pLow, h:Module.PropsSI('H', 'P', he.pLow, 'T', he.tHot, he.pLowFluid), 
						   v:he.speed, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.massFlowKg/Module.PropsSI('D', 'P', he.pLow, 'T', he.tHot, he.pLowFluid),
						   pRatio:(he.pLow-he.pDropLow)/he.pLow, stagePower:he.deltaH*he.pHighFluidMassFlowKg});
			}
		}

		data.push( first );
		data = data.concat(stages);
		data.push( last );
		if (isHp) {
			if (gIsHpCompressorOne) {
				var he = gHeatExchangers.heater1;
				data.push({t:he.tHot, p:he.pLow, h:Module.PropsSI('H', 'P', he.pLow, 'T', he.tHot, he.pLowFluid), 
						   v:he.speed, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.massFlowKg/Module.PropsSI('D', 'P', he.pLow, 'T', he.tHot, he.pLowFluid),
						   pRatio:(he.pLow-he.pDropLow)/he.pLow,stagePower:he.deltaH*he.pHighFluidMassFlowKg});
			}
			else {
				var he = gHeatExchangers.heater2;
				data.push({t:he.tHot, p:he.pLow, h:Module.PropsSI('H', 'P', he.pLow, 'T', he.tHot, he.pLowFluid), 
						   v:he.speed, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.massFlowKg/Module.PropsSI('D', 'P', he.pLow, 'T', he.tHot, he.pLowFluid),
						   pRatio:(he.pLow-he.pDropLow)/he.pLow, stagePower:he.deltaH*he.pHighFluidMassFlowKg});
				he = gHeatExchangers.internal;
				data.push({t:he.tHotHigh, p:he.pHigh, h:Module.PropsSI('H', 'P', he.pHigh, 'T', he.tHotHigh, he.pHighFluid), 
						   v:he.speedHighP, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.massFlowKg/Module.PropsSI('D', 'P', he.pHigh, 'T', he.tHot, he.pHighFluid),
						   pRatio:(he.pHigh-he.pDropHigh)/he.pHigh,stagePower:he.deltaH*he.massFlowKg});
				he = gHeatExchangers.cooler;
				data.push({t:he.tColdHigh, p:he.pHigh, h:Module.PropsSI('H', 'P', he.pHigh, 'T', he.tColdHigh, he.pHighFluid), 
						   v:he.speedHighP, diameterMm:2000*Math.sqrt(he.totalCrossAreaM2/Math.PI), 
						   flowM3:he.pHighFluidMassFlowKg/Module.PropsSI('D', 'P', he.pHigh, 'T', he.tColdHigh, he.pHighFluid),
						   pRatio:(he.pHigh-he.pDropHigh)/he.pHigh,stagePower:he.deltaH*he.pHighFluidMassFlowKg});
			}
		}
		var eff = 0; //, analyticEff = 0, usedEff = 0;
		var totalPower = 0;
		for (i = 0; i < stages.length; i++) {
			totalPower += stages[i].stagePower
		}
		var hDeltaKinetic = stageData.inlet.hDeltaKinetic; // stageData.stages[0].hKineticIn - 0.5*(first.v**2);
		first.hDeltaKinetic = myRound(-hDeltaKinetic, 0);
		var totalPowerMismatch = 0;
		var cBladesTotal = 0;
		for (i = 0; i < stages.length; i++) {
			var p0, h0;
			if (stageData.isCompressor) stages[i].efficiency = stages[i].efficiencyDS_DR;
			var stageEfficiency = stages[i].efficiency;
			var h0Out = stages[i].hOut + stages[i].hKineticOut;
			var h0In = stages[i].h + stages[i].hKineticIn;

			if (i == 0) {
				// include diffuser loss in the first stage
				h0In = first.h0;
				/*
				inlet/exit enthalpy loss can be ignored, it extends pressure range for compressors and decreases it for turbins 
				stages[i].efficiency = stageEfficiency = stageData.isCompressor ? 
					stages[i].efficiency - stageData.inlet.hLoss/stages[i].hDeltaPower :
					stages[i].hDeltaPower / (stages[i].hDeltaPower/stages[i].efficiency+stageData.inlet.hLoss);
				console.log("inlet loss:"+(stageData.inlet.hLoss/stages[i].hDeltaPower));
				*/
			}			
			else if (i == (stages.length-1)) {
				// include diffuser loss in the last stage
				h0Out = last.h0;
				/*
				inlet/exit enthalpy loss can be ignored, it extends pressure range for compressors and decreases it for turbins 
				stages[i].efficiency = stageEfficiency = stageData.isCompressor ? 
					stages[i].efficiency - stageData.exit.hLoss/stages[i].hDeltaPower :
					stages[i].hDeltaPower / (stages[i].hDeltaPower/stages[i].efficiency+stageData.exit.hLoss);
				console.log("exit loss:"+(stageData.exit.hLoss/stages[i].hDeltaPower));
				*/
			}
			totalPowerMismatch += Math.abs(h0Out-h0In) - stages[i].hDeltaPower;
			if (Math.round(Math.abs(h0Out-h0In)) != Math.round(stages[i].hDeltaPower)) {
				const a = Math.abs(h0Out-h0In);
				const b = stages[i].hDeltaPower;
				const diff = a - b;
				const stage = stages[i];
				console.log(i+": power mismatch: "+a+"-"+b+"="+diff+", totalPowerMismatch="+totalPowerMismatch);
			}
			eff += stageEfficiency*stages[i].stagePower/totalPower;
			hDeltaKinetic += stages[i].hDeltaKinetic;
			stages[i].hDeltaKinetic = myRound(-stages[i].hDeltaKinetic, 0);
			cBladesTotal += stages[i].blades + stages[i].statorBlades;
			stages[i].sLoss = stages[i].sOut - stages[i].s;
			//analyticEff += stages[i].efficiency*stages[i].stagePower/totalPower; 
			//usedEff += stageData.stageEfficiencies[i]*stages[i].stagePower/totalPower; 
		}
		hDeltaKinetic += stageData.exit.hDeltaKinetic;
		stageData.exit.hDeltaKinetic = myRound(-stageData.exit.hDeltaKinetic, 0);
		const hKineticError = 100*((0.5*(first.v**2)+hDeltaKinetic) - (0.5*(last.v**2)))/(stageData.exit.h0 - stageData.first.h0) 
		console.log("hKineticError="+hKineticError+"; hDeltaKinetic="+hDeltaKinetic+" => "+(0.5*(first.v**2)+hDeltaKinetic)+"=="+(0.5*(last.v**2)));
		const h0Eff100 = Module.PropsSI('H', 'P', stageData.exit.p0, 'S', stageData.first.s, name); // + 0.5*(stageData.exit.v**2);
		stageData.adiabaticEfficiency = stageData.isCompressor ? 
			(h0Eff100 - stageData.first.h0) / (stageData.exit.h0 - stageData.first.h0) : 
			(first.h0-stageData.exit.h0) / (stageData.first.h0-h0Eff100);

		if (Math.abs(totalPowerMismatch)>10) throw new Error("power mismatch: "+totalPowerMismatch+">10");
		if (eff > 1) throw new Error("Efficiency > 1");
		var averageEfficiency = myRound(eff,3);

		stageProps.push(getSheetValues('Temp K', 't', data ));
		stageProps.push(getSheetValues('P kPa', 'p', data, 1000 ));
		stageProps.push(getSheetValues('Vx m/s', 'v', data));
		stageProps.push(getSheetValues('Diameter mm', 'diameterMm', data));
		stageProps.push(getSheetValues('Gas flow m3/s', 'flowM3', data));
		stageProps.push(getSheetValues(stageData.isCompressor ? 'P2/P1' : 'P1/P2', 'pRatio', data, 2));
		stageProps.push(getSheetValues('Enthalpy kJ/kg', 'h', data, 1000));
		stageProps.push(getSheetValues('Stagn.enthalpy kJ/kg', 'h0', data, 1000));
		stageProps.push(getSheetValues('Entropy loss J/kg/K', 'sLoss', data, 2));
		stageProps.push(getSheetValues('Delta kinetic J/kg', 'hDeltaKinetic', data, 0));
		stageProps.push(getSheetValues('Power MW', 'stagePower', data, 1000000, 2));
		//if (!stageData.isCompressor) 
		stageProps.push(getSheetValues('Efficiency', 'efficiency', data, 3 ));
		//if (stageData.isCompressor) stageProps.push(getSheetValues('Efficiency (DF, eqDR)', 'efficiencyDS_DR', data, 3 ));
		stageProps.push(getSheetValues('Blockage factor', 'midBlockage', data, 2));
		//stageProps.push(getSheetValues('Analytical efficiency', 'getEfficiency', data));
		if (stageData.rpmCount > 1) stageProps.push(getSheetValues('rpm', 'rpm', data));
		stageProps.push(getSheetValues('rTip mm', 'rTipMm', data));
		stageProps.push(getSheetValues('Mean radius mm', 'rMeanMm', data));
		stageProps.push(getSheetValues('Hub/Tip', 'hubToTipRatio', data, 2));
		//stageProps.push(getSheetValues('Hub/Tip reaction', 'hubTipReaction', data));
		stageProps.push(getSheetValues('Rotor mean height mm', 'hBladeMm', data));
		stageProps.push(getSheetValues('Rotor chord mm', 'chordMm', data));
		stageProps.push(getSheetValues('Aspect ratio h/c', 'aspectRatio', data, 2));
		stageProps.push(getSheetValues('Rotor blades', 'blades', data));
		stageProps.push(getSheetValues('Stator blades', 'statorBlades', data));
		stageProps.push(getSheetValues('Rotor mean tMax/c %', 'bladeMaxThicknessMid', data));
		stageProps.push(getSheetValues('Rotor hub tMax/c %', 'bladeMaxThicknessHub', data));
		stageProps.push(getSheetValues('Stator mean tMax/c %', 'statorMaxThicknessMid', data));
		stageProps.push(getSheetValues('Tip gap ε/h %', 'tipGapPercent', data,2));
		stageProps.push(getSheetValues('Tip stagger angle °', 'rotorTipStaggerAngle', data));
		stageProps.push(getSheetValues('Mid stagger angle °', 'rotorStaggerAngle', data));
		stageProps.push(getSheetValues('Hub stagger angle °', 'rotorHubStaggerAngle', data));
		stageProps.push(getSheetValues(stageData.isCompressor ? 'Rotor β1/β2 °' : 'Rotor β2/β3 °', 'midβ12dec', data));
		if (stageData.isCompressor) stageProps.push(getSheetValues('Suction side β1/β2 °', 'midβ12θdec', data));
		//if (stageData.reaction != 0.5) 
		{
			stageProps.push(getSheetValues(stageData.isCompressor ? 'Stator α2/α3°' : 'Stator  α1/α2°', 'midα12dec', data));
		}
		if (stageData.reaction != 0.5 || !stageData.isCompressor) {
			stageProps.push(getSheetValues('Reaction', 'reaction', data,2));
		}
		//stageProps.push(getSheetValues('α2/α3 °', 'midα12dec', data));
		if (true) //stageData.constantDeltaH) 
		{
			//stageProps.push(getSheetValues('Aspect ratio', 'aspectRatio', data, 3));
			//stageProps.push(getSheetValues('Mach m/s', 'mach', data ));
			stageProps.push(getSheetValues(stageData.isCompressor ? 'vRel tip inlet Mach' : 'vRel tip outlet Mach', 'machRelTipActual', data, 2));
			if (stageData.isCompressor) stageProps.push(getSheetValues('max ss vRel Mach', 'vMaxMach', data, 2));
			//stageProps.push(getSheetValues('Tip U Mach', 'UMach', data));
			//stageProps.push(getSheetValues('vRel hub inlet', 'machRelHub', data, 2));
		}
		
		//stageProps.push(getSheetValues('P coeff.', 'pRiseCoeffcient', data, 3));
	
		stageProps.push(getSheetValues('Re(c) EXP06', 'cReText', data, 2 ));
		if (!stageData.constantRpm) {
			stageProps.push(getSheetValues('Shaft radius mm', 'rShaftMm', data));
			stageProps.push(getSheetValues('Shaft torque %', 'usedTorquePower', data));
			//stageProps.push(getSheetValues('Shaft cent. stress %', 'shaftTangentialStressOfMax', data));
			stageProps.push(getSheetValues('uShaft m/s', 'vShaft', data, 1 ));
			stageProps.push(getSheetValues('uGear m/s', 'vGear', data, 1 ));
			stageProps.push(getSheetValues('Shaft load kN', 'shaftPush', data, 1000));
		}
		stageProps.push(getSheetValues('Blade bending kN/m', 'F', data, 1000, true));
		stageProps.push(getSheetValues('Bending stress MPa', 'maxTensileStressMPa', data));
		stageProps.push(getSheetValues('Centrifugal stress MPa', 'centrifugalStressMpa', data));
		//stageProps.push(getSheetValues('Centr. stress of max', 'tensileStressPercent', data));
		//stageProps.push(getSheetValues('Max stress mid/hub %', 'totalTensileStressPercentMidHub', data));
		if (stages[stages.length-1].bladeCoolingK) {
			stageProps.push(getSheetValues('Blade cooling K', 'bladeCoolingK', data));
		}
		stageProps.push(getSheetValues('Tip load coefficient', 'stageLoadingCoefficient', data, 2));
		stageProps.push(getSheetValues('Tip flow coefficient', 'flowCoefficient', data, 2));
		stageProps.push(getSheetValues('Mean load coefficient', 'midStageLoadingCoefficient', data, 2));
		stageProps.push(getSheetValues('Mean flow coefficient', 'midFlowCoefficient', data, 2));
		stageProps.push(getSheetValues('Hub load coefficient', 'hubStageLoadingCoefficient', data, 2));
		stageProps.push(getSheetValues('Hub flow coefficient', 'hubFlowCoefficient', data, 2));
		//stageProps.push(getSheetValues('Static pressure rise3', 'pressureRiseCoefficient3', data, 2));
		//stageProps.push(getSheetValues('Δp/(d∙U²)', 'getPressureRiseCoeffcient', data, 2));
		if (stageData.isCompressor) stageProps.push(getSheetValues('Diffusion factor DF', 'DF_lbl', data, 2));
		if (stageData.isCompressor) stageProps.push(getSheetValues("DF approximation", 'DF', data, 2));
		//stageProps.push(getSheetValues('Diffusion ratio DR', 'DR', data, 2));
		if (stageData.isCompressor) stageProps.push(getSheetValues('Equivalent DR', 'eqDR', data, 2));
		if (stageData.isCompressor) stageProps.push(getSheetValues('deHaller Num', 'deHallerNum', data, 2));
		stageProps.push(getSheetValues('AN2 E08', 'AN2EXP8', data, 2));
		//stageProps.push(getSheetValues('Static pressure rise', 'pressureRiseCoefficient', data, 2));
		if (stageData.isCompressor) {
			stageProps.push(getSheetValues('Static pressure rise', 'pressureRiseCoefficient2', data, 2));
			stageProps.push(getSheetValues('Rotor/stator loss %', 'rotorStatorLossPercents', data));
			stageProps.push(getSheetValues('Profile/endwall loss %', 'profileEndwallLossPercents', data));
		}
		else {
			stageProps.push(getSheetValues('Rotor/Stator loss %', 'rotorStatorLossPercents', data));
			stageProps.push(getSheetValues('Profile/trailing loss %', 'profileTrailingLossPercents', data));
			stageProps.push(getSheetValues('Clearance/secondary loss %', 'clearanceSecondaryLossPercents', data));
		}
		//stageProps.push(getSheetValues('Loss in rotor hub %', 'rotorHubLossPercent', data,1));
		//stageProps.push(getSheetValues('Analytical loss %', 'analyticalLosses', data));
		if (stageData.isCompressor) stageProps.push(getSheetValues('Hub % of stall', 'stallMargin', data));
		//stageProps.push(getSheetValues('Cp', 'Cp', data, 2));
		//stageProps.push(getSheetValues('CpMax', 'CpMax', data, 2));

		{
			const sFirst = stages[0];
			const sLast = stages[stages.length - 1];
			const h0Out = sLast.hOut + sLast.hKineticOut;
			const h0In = sFirst.h + sFirst.hKineticIn;
			const p0Out = Module.PropsSI('P', 'H', h0Out, 'S', sLast.sOut, name);
			const h0OutS = Module.PropsSI('H', 'P', p0Out, 'S', sFirst.s, name);
			stageData.adiabaticEfficiencyOfStages = 
				stageData.isCompressor ? (h0OutS - h0In) / (h0Out - h0In) : (h0In - h0Out) / (h0In - h0OutS);
		}

		stageData.stageProps = stageProps;
		var test;
		if (!testResult( stageData.adiabaticEfficiency, eff*0.90, 0.999, stageData.adiabaticEfficiency/5000, 
			function (stageEfficiency) {
				stageData.averageEfficiency = stageEfficiency;
				const ret = first.wetness ? 
					doWetAdiabaticProcessWithS( name, stageData.first.p0, stageData.exit.p0, first.wetness, stageEfficiency ) :
					doAdiabaticProcessWithS( name, stageData.first.p0, stageData.exit.p0, stageData.first.t0, stageEfficiency );
				test = ret;
				return ret.efficiency;
			}))
		{
			console.log(name+": First="+JSON.stringify(stageData.first)+", exit="+JSON.stringify(stageData.exit)+", items="+JSON.stringify(test.items));
		}
		//verifyStaticValues(stageData.first);
		//verifyStaticValues(stageData.exit);

		console.log("stageData.adiabaticEfficiencyOfStages="+stageData.adiabaticEfficiencyOfStages);
		console.log(name+": Adiabatic efficiency:"+stageData.adiabaticEfficiency+" => Average efficiency changed from "+eff+" to "+stageData.averageEfficiency+", p1/p2="+(stageData.first.p0/stageData.exit.p0));

//console.log("stages="+JSON.stringify(stageData.stages));
//console.log("First="+JSON.stringify(first)+"\r\n, exit="+JSON.stringify(stageData.exit));
//console.log("items="+JSON.stringify(test.items));

//		stageData.averageEfficiency = eff;
		//eff = stageData.averageEfficiency;
		//stageData.averageAnalyticEfficiency = analyticEff;

		/*
			"flowCoefficientMin":0.33,"stageLoadingCoefficientMin":0.2,"flowCoefficientToStageLoadingCoefficient":1,"massFlowInKg":411.25,"maxRpmStages":1,"aspectRatio":1.2,
			"hubToTipRatio":0.7,"machMaxSpeed":0.95,"maxStatorHubAbsSpeed":0.7,"vGearMax":180,"isCompressor":true,"efficiency":0.955,
			"tanβ1":1.8181818181818181,"tanβ2":1.2121212121212122,"β1deg":61.18920625702693,"β2":0.8809962820612887,
			"β2deg":50.47736872882888,"β1":1.0679531158670357,"shaftStrength":300000000,"shaftBearingSpace":0.002,"rInnerShaftCoolingPipe":0.01,
			"minShaftPipeWidth":0.01,"generatorRpm":3000,"stageWidth2h":1.515197511418009,"vvAbs2Mach":0.44774847167095166,"vMach":0.45782281228354815,
			"speedOut":8.807401930615992,"pHigh":2517078.5346587086,"hEnd":202141.21278021956}	*/

		const machMax = Math.max(stages[0].machRelTipActual,stages[1].machRelTipActual);
		stageData.titles = [
			stageData.cUnits +" * "+Math.round(totalPower/1000000)+" MW Axial "+(machMax <= 0.90 ? "Subsonic " : machMax < 1.20 ? "Intersonic " : "Supersonic ")+(title.indexOf("Cold")==0 ? "Cryogenic ": "")+(isHp ? title : (stageData.isCompressor ? "Compressor" : "Turbin"))+(stageData.constantRpm ? " synchronized with Motor-Generator" : " with "+stageData.rpmCount+" pipe shafts and active tip gap control"),
			"Fluid: "+name,
			"Adiabatic efficiency: "+myRound(stageData.adiabaticEfficiency,3)+" (=>stage efficiency: "+myRound(stageData.averageEfficiency,6)+"), average stage efficiency "+
				(stageData.isCompressor ? " by DF and eqDR: " : " by Kacker and Okapuu:")+averageEfficiency,  //+" (analytical: "+myRound(stageData.averageAnalyticEfficiency,3)+")", 
			(stageData.isCompressor ? "P-out/P-in: "+myRound(last.p/first.p,2)+" (max: ~"+myRound(last.p/first.p*getMaxRelativePressureRise(stageData),2)+")":
									  "P-in/P-out: "+myRound(first.p/last.p,2))+", Mass flow: "+Math.round(stageData.massFlowInKg)+" kg/s",
			"Constant axial velocity: "+(stageData.constantDeltaH ? (myRound(stages[1].v)+" m/s")+" (<="+(myRound(stages[1].v/stages[stageData.isCompressor ? 1 : stages.length-1].mach,2))+" mach)" : (myRound(stageData.vMach,3)+" mach")),
			(stageData.rpmCount == 1 ? "Rpm: "+stages[0].rpm : stageData.rpmCount+" shafts")+", "+stageData.stages.length+" stages, reaction: 50 %, mean line solidity: "+stageData.solidity, //+" - "+stageData.rearSolidity,
			//"Tip stage loading coefficients: "+ stageData.stageLoadingCoefficientMin + " - "+ stageData.flowCoefficientMin,
			//"Hub: Max stage loading coefficient: "+myRound(stageData.stages[0].hubStageLoadingCoefficient,2)+ ", max flow coefficient: "+myRound(stageData.stages[0].hubFlowCoefficient,2),
			"Adaptive aspect ratio (h/c); Hub/Tip ratio"+(stageData.hubToTipRatioMax == stageData.hubToTipRatio ? ": "+myRound(stageData.hubToTipRatio,2) : "s from "+myRound(stageData.hubToTipRatio,2)+" to "+myRound(stageData.hubToTipRatioMax,2)),
			"Stage power distribution first/last: "+myRound(stageData.firstToLastDeltaH,3),
			//"Relative velocity on blade tip inlet surface: "+stageData.machMaxSpeed+" mach",
			//"Relative velocity on blade hub inlet surface: "+myRound(stageData.machRelHub,3)+" mach",
			//"Tip/hub stagger angle of 1st stage blade: "+ myRound(stages[0].rotorTipStaggerAngle, 1)+'/'+ myRound(stages[0].rotorHubStaggerAngle, 1)+'°',
			//"Tip/hub solidity of 1st stage: "+ myRound(stageData.solidityInTip, 2)+'/'+ myRound(stageData.solidityInHub, 2)+' (when axial width is constant)'
		];
		//+", Tip of 1st blade: "+(myRound(stages[0].U/stages[0].mach,2))+" mach")
		if (stageData.isCompressor) {
			stageData.titles.push("Max suction side relative velocity: "+(myRound(Math.max(stages[0].vMaxMach, stages[1].vMaxMach),2))+ " Mach"); //+" mach (absolute "+(myRound(stages[0].vMaxMachAbs,2))+" mach)");
		}
		else {
			stageData.titles.push("Max relative exit velocity of the last rotor: "+(myRound(stages[stages.length-1].vMaxMach,2))+ " Mach"); //+" mach (absolute "+(myRound(stages[0].vMaxMachAbs,2))+" mach)");
		}
		if (maxStallMargin && stageData.isCompressor) {
			stageData.titles.push("Max stall margin: "+Math.round(maxStallMargin)+" %");
		}
		if (stageData.inlet.wetness) {
			stageData.titles.push("Wetness of fluid in inlet: "+myRound(stageData.inlet.wetness*100,1)+ "%");
		}
		stageData.titles.push("Total number of stator and rotor blades: "+cBladesTotal);
		if (isHp && gIsHpCompressorOne) {
			stageData.titles.push("Size and cost of 4 heat exchangers: "+Math.round(gCycleData.heVolumeM3)+" m3, "+Math.round(gCycleData.heCost/1000000)+" million Eur");
		}
		
		//stageData.titles.push("Stall margin in the hub of the 1st stage: "+Math.round(stages[0].stallMargin)+" %");
		//stageData.titles.push("Absolute velocity in 1st stator hub: "+(myRound(stages[0].hubMach,2))+" mach"+(stages[0].reaction > 0.5 ? " (with reaction: "+(myRound(stages[0].reaction,2))+")" : ""));

		//if (!stageData.constantDeltaH) 
		stageData.height = 2 * (stageData.stages[0].rTip + 0.052); // 50 mm for frame, 2 mm for tip gap
		
		const updateCompressorEfficiencies = document.getElementById('updateCompressorEfficiencies').checked;
		const updateTurbinEfficiencies = document.getElementById('updateTurbinEfficiencies').checked;
		averageEfficiency = myRound(stageData.averageEfficiency,3);	// use the efficiency calculated from the adiabatic efficiency
		if (title.indexOf("Cold")==0) {
			if (stageData.isCompressor && $("#cLowEfficiency").val() != averageEfficiency) {
console.log("Efficiency mismatch: "+$("#cLowEfficiency").val()+" != "+averageEfficiency);
				if (updateCompressorEfficiencies) {
					$("#cLowEfficiency").val(averageEfficiency);
					redrawTpGraf = true;
				}
			}
			else if (!stageData.isCompressor && $("#tLowEfficiency").val() != averageEfficiency) {
				if (updateTurbinEfficiencies) {
					$("#tLowEfficiency").val(averageEfficiency);
					redrawTpGraf = true;
				}
			}
		}
		else if (title.indexOf("Hot")==0) {
			if (stageData.isCompressor && $("#cEfficiency").val() != averageEfficiency) {
console.log("Efficiency mismatch: "+$("#cEfficiency").val()+" != "+averageEfficiency);
				if (updateCompressorEfficiencies) {
					$("#cEfficiency").val(averageEfficiency);
					redrawTpGraf = true;
				}
			}
			else if (!stageData.isCompressor && $("#tEfficiency").val() != averageEfficiency) {
				if (updateTurbinEfficiencies) {
					$("#tEfficiency").val(averageEfficiency);
					redrawTpGraf = true;
				}
			}
		}

		//console.log("stages:"+JSON.stringify(stageData.stages));

		console.log(title+ " compressor stages: "+stageData.stages.length+", rpm speeds: "+stageData.rpmCount+
			", efficiency: "+myRound(stageData.adiabaticEfficiency,3)+", power: "+Math.round(totalPower/1000000)+" MW"+
			", compressor length, height, width: "+myRound(stageData.length,2)+", "+myRound(stageData.height,2)+", "+myRound(stageData.height,2)+" m");
		console.log("pHigh pipe diameter:"+exitPipeDiameter+", calculated gas properties:"+JSON.stringify(stageData.exit));
		//console.log("pHigh pipe expected, properties:"+JSON.stringify(last));
		console.log("pLow pipe diameter="+inletPipeDiameter+", gas properties:"+JSON.stringify(first));
		//console.log(JSON.stringify(stageData.stages, null, 2));
		return stageData;
	}
	// Calcs tip, mid and hub properties of first blade row, that accelerates the absolute inlet velocity inletC1 to absolute C2 
	function getBladeProperties( stageData, hasIGV, stageLoadingCoefficient, flowCoefficient, v, inletC1, C1, C2, deltaH )
	{	
		const hKinetic = 0.5*(C1*C1 - inletC1*inletC1);
		var props = {};
/*		props.testC2 = v/Math.cos(Math.atan(((1-reaction) + stageLoadingCoefficient/2)/(flowCoefficient)));
		props.C2 = C2;
		props.v = v;
		props.tested = [];*/
		
		props.loadCoefficient = stageLoadingCoefficient*(deltaH+hKinetic)/deltaH;	// additional load needed by acceleration
		if (hasIGV) {
			props.flowCoefficient = flowCoefficient;
			// reaction must be decreased to match with expected absolute blade outlet velocity C2
			testResult( C2, 1, 0, C2/100, function (reaction) {
					props.reaction = reaction;
					const alpha1 = stageData.isCompressor ? Math.atan(((1-props.reaction) - props.loadCoefficient/2)/(props.flowCoefficient)) : 
														    Math.atan(((1-props.reaction) + props.loadCoefficient/2)/(props.flowCoefficient));
					const vxIn = inletC1*Math.cos(alpha1);
					props.flowCoefficient = flowCoefficient * vxIn/v;
					const alpha2 = stageData.isCompressor ? Math.atan(((1-props.reaction) + props.loadCoefficient/2)/(props.flowCoefficient)) :
															Math.atan((-(1-props.reaction) + props.loadCoefficient/2)/(props.flowCoefficient));
					const testC = v/Math.cos(alpha2);
					//props.tested.push(testC);
					return testC;
				}, 12);
		}
		else {
			props.flowCoefficient = flowCoefficient * inletC1/v;
			testResult( C2, 1, 0, C2/100, function (reaction) {
					props.reaction = reaction;
					const alpha2 = stageData.isCompressor ? Math.atan(((1-props.reaction) + props.loadCoefficient/2)/(props.flowCoefficient)) :
															Math.atan((-(1-props.reaction) + props.loadCoefficient/2)/(props.flowCoefficient));
					const testC = v/Math.cos(alpha2);
					//props.tested.push(testC);
					return testC;
				}, 12);
		}
		props.β1 = stageData.isCompressor ? Math.atan((props.reaction + props.loadCoefficient/2)/(props.flowCoefficient)) :
											Math.atan((-props.reaction + props.loadCoefficient/2)/(props.flowCoefficient));
		props.β2 = stageData.isCompressor ? Math.atan((props.reaction - props.loadCoefficient/2)/(props.flowCoefficient)) :
											Math.atan((props.reaction + props.loadCoefficient/2)/(props.flowCoefficient));
/*
		props.oldLoadCoefficient = stageLoadingCoefficient;
		props.oldFlowCoefficient = flowCoefficient;
		props.hKinetic = hKinetic;
		props.deltaH = deltaH;
		props.inletC1 = inletC1;
		props.C1 = C1;
console.log("props="+JSON.stringify(props));*/
		return props;
	}
	function toPlusMinPI( rad ) {
		if (rad > Math.PI) rad - 2*Math.PI;
		return rad;
	}

	function getEfficiencyWithKackerOkapuu( stageData, stage, iStage ) 
	{
		const hRotor = stage.hRotor; // (stage.rTipMid-stage.rHubMid + stage.rTipOut-stage.rHubOut) / 2;
		const hStator = stage.hStator; // (stage.rTip-stage.rHub + stage.rTipMid-stage.rHubMid) / 2;
		const loadCoefficient = stage.midStageLoadingCoefficient;
		const flowCoefficient = stage.midFlowCoefficient;
		const Vx = stage.v;
		const tMaxStator = stage.stator.tMid;
		const tMaxRotor = stage.rotor.tMid;
		var reaction = stageData.reaction ? stageData.reaction : 0.5;
/*
	Exit angle of the last rotor row does not really matter,
	different kinetic span wise velocities sum up to one pressure in the pipe, but higher velocity produces somewhat 
	higher end wall loss.  Perhaps we should use constant 0.97 loss for the end wall?
OLD:	
		// If exit angle α3=0, then tan(β3) = 1/flowCoefficient, because loadCoefficient and flowCoefficient are fixed by turbin geometry,
		// we use reaction to set exit angle α3=0 => reaction + loadCoefficient/2 = 1
		if (iStage == (stageData.cStages-1) && !stageData.hasOGV) {
			reaction = 1 - loadCoefficient/2;
		}
*/
		stage.reaction = reaction;
		const c1 = 2*reaction * hRotor / stage.aspectRatio;
		const c2 = 2*(1-reaction)*hStator / stage.aspectRatio;
		// The angle in of the first Stator is zero without IGV
		stage.α1 = toPlusMinPI(Math.atan((loadCoefficient/2 - (1-reaction))/flowCoefficient));
		const α1 = iStage == 0 ? 0 : stageData.stages[iStage-1].α1; // out angle of previous stage or incoming fluid
		const α2 = toPlusMinPI(Math.atan(((1-reaction) + loadCoefficient/2)/flowCoefficient));
		const β2 = toPlusMinPI(Math.atan((loadCoefficient/2 - reaction)/flowCoefficient));
		const β3 = toPlusMinPI(Math.atan((reaction + loadCoefficient/2)/flowCoefficient));
		const vRelInStator = Vx / Math.cos(α1);
		const vRelOutStator = Vx / Math.cos(α2);
		const vRelInRotor = Vx / Math.cos(β2);
		const vRelOutRotor = Vx / Math.cos(β3);

		//if ((iStage == (stageData.cStages-1) && !stageData.hasIGV) || iStage == 0) 
		stage.midβ12dec = Math.round(β2*180/Math.PI)+'/'+Math.round(β3*180/Math.PI);
		stage.midα12dec = Math.round(-α1*180/Math.PI)+'/'+Math.round(-α2*180/Math.PI);
		stage.midα2 = toPlusMinPI(Math.atan((-(1-reaction) + loadCoefficient/2)/flowCoefficient));
		
		// turbin flow is reverse to compressor => ins and outs are swapped
		const rRe = vRelInRotor*stage.dynamicVisc3*c1;
		const sRe = vRelInStator*stage.dynamicVisc2*c2;
		var p0rel_in_stator, p0_rel_out_stator, p0rel_in_rotor, p0_rel_out_rotor;
		const prevRelp0s = typeof stage.prevRelp0s !== 'undefined' ? stage.prevRelp0s : globalPrevRelp0s;
		if (typeof prevRelp0s.s1 === 'undefined' || stage.s != prevRelp0s.s1 || stage.sMid != prevRelp0s.s2 || stage.sOut != prevRelp0s.s3) {
			// todo relative static pressures from 
			// p1, p2, p3, h1, h2, h3, s1, s2, s3 !!!!!
			prevRelp0s.s1 = stage.s;
			prevRelp0s.s2 = stage.sMid;
			prevRelp0s.s3 = stage.sOut;
			prevRelp0s.p0rel_in_stator = Module.PropsSI('P','S', stage.s, 'H', stage.h+vRelInStator**2/2, name);
			prevRelp0s.p0_rel_out_stator = Module.PropsSI('P','S', stage.sMid, 'H', stage.hMid+vRelOutStator**2/2, name);
			prevRelp0s.p0rel_in_rotor = Module.PropsSI('P','S', stage.sMid, 'H', stage.hMid+vRelInRotor**2/2, name);
			prevRelp0s.p0_rel_out_rotor = Module.PropsSI('P','S', stage.sOut, 'H', stage.hOut+vRelOutRotor**2/2, name);
		}
		stage.statorLoss = loss_model_KO( 'stator', sRe, α1, α2, c2, c2/stage.statorSolidity, hStator, stage.tipGap, tMaxStator, 
										  vRelInStator/stage.mach, vRelOutStator/stage.machMid, stage.rHub/stage.rTip, 
										  stage.p, prevRelp0s.p0rel_in_stator, stage.pMid, prevRelp0s.p0_rel_out_stator );
		stage.rotorLoss = loss_model_KO( 'rotor', rRe, β2, β3, c1, c1/stage.rotorSolidity, hRotor, stage.tipGap, tMaxRotor, 
								         vRelInRotor/stage.machMid, vRelOutRotor/stage.machOut, stage.rHubMid/stage.rTipMid, 
										 stage.pMid, prevRelp0s.p0rel_in_rotor, stage.pOut, prevRelp0s.p0_rel_out_rotor );

		stage.inletBlockage = stageData.stages.length > 0 ? stageData.stages[stageData.stages.length-1].blockageFactor : 1;
		stage.midBlockage = ((stageData.blockageFactors && stageData.blockageFactors.length > stageData.stages.length ?  
								stageData.blockageFactors[stageData.stages.length] :
								stage.inletBlockage) + stage.inletBlockage)/2;
		stage.endWallLoss = getCascadedStageLoss( reaction * (stage.rotorLoss.Y_s+stage.rotorLoss.Y_cl), stageData.stages.length, stage.aspectRatio, stage.midBlockage) + 
							getCascadedStageLoss((1-reaction)*(stage.statorLoss.Y_s+stage.statorLoss.Y_cl), stageData.stages.length, stage.aspectRatio, stage.inletBlockage);
		stage.blockageFactor = getStageBlockageFactor(stageData, stage.endWallLoss);
		if (stageData.blockageFactors.length == stageData.stages.length) stageData.blockageFactors.push(stage.blockageFactor);
		else stageData.blockageFactors[stageData.stages.length] = stage.blockageFactor;
		stage.midBlockage = (stage.blockageFactor + stage.inletBlockage)/2;

		//{"Y":0.04210104604681516,"Y_p":0.01584169583498661,"Y_s":0.013940041169545907,"Y_cl":0.006032683313607755,"Y_te":0.006286625728674888}
		stage.profileLoss = getCascadedStageLoss(reaction*(stage.rotorLoss.Y_p),stageData.stages.length, stage.aspectRatio, stage.midBlockage) + 
							getCascadedStageLoss((1-reaction)*(stage.statorLoss.Y_p),stageData.stages.length, stage.aspectRatio, stage.inletBlockage);
		stage.trailingLoss = getCascadedStageLoss(reaction*(stage.rotorLoss.Y_te),stageData.stages.length, stage.aspectRatio, stage.midBlockage) + 
							getCascadedStageLoss((1-reaction)*(stage.statorLoss.Y_te),stageData.stages.length, stage.aspectRatio, stage.inletBlockage);
		stage.clearanceLoss = getCascadedStageLoss( reaction * (stage.rotorLoss.Y_cl), stageData.stages.length, stage.aspectRatio, stage.midBlockage) + 
							getCascadedStageLoss((1-reaction)*(stage.statorLoss.Y_cl), stageData.stages.length, stage.aspectRatio, stage.inletBlockage);
		stage.secondaryLoss = getCascadedStageLoss( reaction * (stage.rotorLoss.Y_s), stageData.stages.length, stage.aspectRatio, stage.midBlockage) + 
							getCascadedStageLoss((1-reaction)*(stage.statorLoss.Y_s), stageData.stages.length, stage.aspectRatio, stage.inletBlockage);

		const loss = (getCascadedStageLoss(reaction*stage.rotorLoss.Y, stageData.stages.length, stage.aspectRatio, stage.midBlockage) +
								getCascadedStageLoss((1-reaction)*stage.statorLoss.Y, stageData.stages.length, stage.aspectRatio, stage.inletBlockage));
		stage.clearanceSecondaryLossPercents = myRound(stage.clearanceLoss*100,1)+'/'+myRound(stage.secondaryLoss*100,1);
		stage.profileTrailingLossPercents = myRound(stage.profileLoss*100,1)+'/'+myRound(stage.trailingLoss*100,1);
		stage.profileEndwallLossPercents = myRound((stage.profileLoss+stage.trailingLoss)*100,1)+'/'+myRound((stage.secondaryLoss+stage.clearanceLoss)*100,1);
		stage.rotorStatorLossPercents = 
			myRound(getCascadedStageLoss( reaction * stage.rotorLoss.Y, stageData.stages.length, stage.aspectRatio, stage.midBlockage)*100,1)+'/'+
			myRound(getCascadedStageLoss((1-reaction)*stage.statorLoss.Y, stageData.stages.length, stage.aspectRatio, stage.inletBlockage)*100,1);
//console.log("KO: loadCoefficient="+loadCoefficient+", flowCoefficient="+flowCoefficient+", β2="+(180/Math.PI*β2)+", β3="+(180/Math.PI*β3)+", KO eff stator:"+JSON.stringify(stage.statorLoss)+", rotor:"+JSON.stringify(stage.rotorLoss));
		stage.efficiency = 1 - loss;
	}
	function getLossWithKackerOkapuu( stageData, stage, aspectRatio, iStage,  reaction, loadCoefficient, flowCoefficient, hRotor, hStator, 
										tMaxRotor, tMaxStator, hubToTipStator, hubToTipRotor, Vx ) 
	{
		const c1 = 2*reaction * hRotor / aspectRatio;
		const c2 = 2*(1-reaction) * hStator / aspectRatio;
		const α3 = toPlusMinPI(Math.atan((loadCoefficient/2 - (1-reaction))/flowCoefficient));
		const α2 = toPlusMinPI(Math.atan(((1-reaction) + loadCoefficient/2)/flowCoefficient));
		const β3 = toPlusMinPI(Math.atan((reaction + loadCoefficient/2)/flowCoefficient));
		const β2 = toPlusMinPI(Math.atan((loadCoefficient/2 - reaction)/flowCoefficient));
		const vRelInStator = Vx / Math.cos(α3);
		const vRelOutStator = Vx / Math.cos(α2);
		const vRelInRotor = Vx / Math.cos(β2);
		const vRelOutRotor = Vx / Math.cos(β3);
		// turbin flow is reverse to compressor => ins and outs are swapped
		const rRe = vRelInRotor*stage.dynamicVisc3*c1;
		const sRe = vRelInStator*stage.dynamicVisc2*c2;
		var p0rel_in_stator, p0_rel_out_stator, p0rel_in_rotor, p0_rel_out_rotor;
		const prevRelp0s = typeof stage.prevRelp0s !== 'undefined' ? stage.prevRelp0s : globalPrevRelp0s;
		if (typeof prevRelp0s.s1 === 'undefined' || stage.s != prevRelp0s.s1 || stage.sMid != prevRelp0s.s2 || stage.sOut != prevRelp0s.s3) {
			// todo relative static pressures from 
			// p1, p2, p3, h1, h2, h3, s1, s2, s3 !!!!!
			prevRelp0s.s1 = stage.s;
			prevRelp0s.s2 = stage.sMid;
			prevRelp0s.s3 = stage.sOut;
			prevRelp0s.p0rel_in_stator = Module.PropsSI('P','S', stage.s, 'H', stage.h+vRelInStator**2/2, name);
			prevRelp0s.p0_rel_out_stator = Module.PropsSI('P','S', stage.sMid, 'H', stage.hMid+vRelOutStator**2/2, name);
			prevRelp0s.p0rel_in_rotor = Module.PropsSI('P','S', stage.sMid, 'H', stage.hMid+vRelInRotor**2/2, name);
			prevRelp0s.p0_rel_out_rotor = Module.PropsSI('P','S', stage.sOut, 'H', stage.hOut+vRelOutRotor**2/2, name);
		}
		const statorLoss = loss_model_KO( 'stator', sRe, α3, α2, c2, c2/stage.statorSolidity, hStator, stage.tipGap, tMaxStator, 
										  vRelInStator/stage.mach, vRelOutStator/stage.machMid, hubToTipStator, 
										  stage.p, prevRelp0s.p0rel_in_stator, stage.pMid, prevRelp0s.p0_rel_out_stator );
		const rotorLoss = loss_model_KO( 'rotor', rRe, β2, β3, c1, c1/stage.rotorSolidity, hRotor, stage.tipGap, tMaxRotor, 
								         vRelInRotor/stage.machMid, vRelOutRotor/stage.machOut, hubToTipRotor, 
										 stage.pMid, prevRelp0s.p0rel_in_rotor, stage.pOut, prevRelp0s.p0_rel_out_rotor );
		stage.inletBlockage = stageData.stages.length > 0 ? stageData.stages[stageData.stages.length-1].blockageFactor : 1;
		stage.midBlockage = ((stageData.blockageFactors && stageData.blockageFactors.length > stageData.stages.length ?  
								stageData.blockageFactors[stageData.stages.length] :
								stage.inletBlockage) + stage.inletBlockage)/2;
		const loss =  getCascadedStageLoss(reaction*rotorLoss.Y, iStage, aspectRatio, stage.midBlockage) +
					  getCascadedStageLoss((1-reaction)*statorLoss.Y, iStage, aspectRatio, stage.inletBlockage);
					 
//console.log("KO: loss="+loss+", loadCoefficient="+loadCoefficient+", flowCoefficient="+flowCoefficient+", β2="+(180/Math.PI*β2)+", β3="+(180/Math.PI*β3)+", KO eff stator:"+JSON.stringify(statorLoss)+", rotor:"+JSON.stringify(rotorLoss));
		return loss;
	}

	function getOptimalAR( stageData, stage ) {
		const hRotor = stage.hRotor;
		const hStator = stage.hStator;
		var c = hRotor / stage.aspectRatio;
		const iStage = stageData.stages.length;
		const orgAR = stage.aspectRatio;
		const cOrg = c;
		var cPrev = 0;
		var prevAR = 0;
		if (stageData.stages.length > 0) {
			const prevStage = stageData.stages[stageData.stages.length-1];
			cPrev = (prevStage.rTip-prevStage.rHub)/prevStage.aspectRatio;
			prevAR = prevStage.aspectRatio;
		}
		const Re = stage.cRe / c;
		const tMaxStator = stage.stator.tMid;
		const tMaxRotor = stage.rotor.tMid;
		var maxAspectRatio = stageData.maxAspectRatio;
/*
		const maxChord = 2 * stageData.reaction * hRotor / maxAspectRatio;
		const tMaxToChord = tMaxRotor/maxChord;
		if (stageData.tMaxToChord < tMaxToChord) {
			maxAspectRatio *= stageData.tMaxToChord / tMaxToChord;		// extend chord to increase relative max thickness
			if (c > hRotor/maxAspectRatio) c = 0.5 * hRotor/maxAspectRatio;
		}
*/
		var cMin =  cPrev ? cPrev*0.5 : c*0.3;
		var cMax =  hRotor / maxAspectRatio;
		const loadCoefficient = stage.midStageLoadingCoefficient;
		const flowCoefficient = stage.midFlowCoefficient;
		const Vx = stage.v;
		const reaction = stageData.reaction ? stageData.reaction : 0.5;
		const blockageFactor = stageData.stages.length > 0 ? stageData.blockageFactors[stageData.stages.length-1] : 1;
		const isCompressor = stageData.isCompressor;

		var bestLoss = getLossDF_DRe( stageData, isCompressor,
			reaction, loadCoefficient, flowCoefficient, Vx, stage.rotorSolidity, stage.statorSolidity, 2*reaction*c, 2*(1-reaction)*c*hStator/hRotor, 
			hRotor, hStator, tMaxRotor, tMaxStator, stage.tipGap, stage.rMid, stage.rMidMid, stage.rMidOut, stage.dPlus1, stage.dMid, stage.dOut, stage.mach, 
			stage.machMid, stage.machOut, stage.dynamicVisc, stage.dynamicVisc2, stage.dynamicVisc3, iStage, blockageFactor, stage );

		const orgEff = 1 - bestLoss;
		var i;
var trace = '#'+iStage+': cOrg='+c+", cMin="+cMin+", bestLoss="+bestLoss+", ";
		for (i = 0; i < 12; i++) {
			var cTest = (c+cMax)/2;
			var loss = getLossDF_DRe( stageData, isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, stage.rotorSolidity, stage.statorSolidity, 2*reaction*cTest, 
						2*(1-reaction)*cTest*hStator/hRotor, 
						hRotor, hStator, tMaxRotor, tMaxStator, stage.tipGap, stage.rMid, stage.rMidMid, stage.rMidOut, stage.dPlus1, stage.dMid, stage.dOut, stage.mach, stage.machMid, stage.machOut,
						stage.dynamicVisc, stage.dynamicVisc2, stage.dynamicVisc2, iStage, blockageFactor, stage);
			if (loss > bestLoss) cMax = cTest;
			else {
				bestLoss = loss;
				c = cTest;
			}
			cTest = (c+cMin)/2;
			loss = getLossDF_DRe( stageData, isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, stage.rotorSolidity, stage.statorSolidity, 2*reaction*cTest, 2*(1-reaction)*cTest*hStator/hRotor, 
						hRotor, hStator, tMaxRotor, tMaxStator, stage.tipGap, stage.rMid, stage.rMidMid, stage.rMidOut, stage.dPlus1, stage.dMid, stage.dOut, stage.mach, stage.machMid, stage.machOut,stage.dynamicVisc, 
						stage.dynamicVisc2, stage.dynamicVisc3, iStage, blockageFactor, stage );
			if (loss > bestLoss) cMin = cTest;
			else {
				bestLoss = loss;
				c = cTest;
			}
trace += i+": c="+c+", loss="+loss+", bestLoss="+bestLoss;
		}
		c = c*stageData.divOptAR;
		ret = {};
		ret.optimalAR = hRotor / c;
		//if (prevAR && ret.optimalAR > prevAR) ret.optimalAR = prevAR;
		ret.efficiency = 1 - bestLoss;
/*if (iStage >=2 && iStage <= 5) {
	var losses = [];
	for (AR = ret.optimalAR - 1; AR <= ret.optimalAR+1; AR += 0.1) {
		cTest = hRotor/AR;
		var loss = getLossDF_DRe( stageData, isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, stage.rotorSolidity, stage.statorSolidity, 2*reaction*cTest, 
						2*(1-reaction)*cTest*hStator/hRotor, 
						hRotor, hStator, tMaxRotor, tMaxStator, stage.tipGap, stage.rMid, stage.rMidMid, stage.dPlus1, stage.dMid, stage.mach, stage.machMid, stage.machOut,
						stage.dynamicVisc, stage.dynamicVisc2, iStage );
		losses.push(loss);
	}
	trace += "best AR="+ret.optimalAR+", bestLoss="+bestLoss+", losses from "+(ret.optimalAR - 1)+" to "+(ret.optimalAR + 1)+": "+JSON.stringify(losses);
	console.log(trace);
}*/
//console.log(stageData.stages.length+":getOptimalAR_EffciencyByDS_DR: AR: "+orgAR+"=>"+(ret.optimalAR/stageData.divOptAR)+", efficiency: "+orgEff+"=>"+ret.efficiency+", Re="+(Re*cOrg)+"=>"+(Re*c)+", c="+cOrg+"=>"+c);
if (typeof ret.optimalAR === 'undefined' || Number.isNaN(ret.optimalAR)) {
	trace += ", ret="+JSON.stringify(ret)+",  c="+c+", loss="+loss+", bestLoss="+bestLoss;
	console.log(trace);
	throw new Error("Bad AR");
}

if (Number.isNaN(ret.efficiency)) throw new Error("Internal error");
		return ret;
	}
		
	function getOptimalAR_Effciency( orgReC, bladeThicknessInMiddleMm, hBladeMm, orgChord, loadFactor, tipClearance, stageNumber ) {
		var c = orgChord;
		const Re = orgReC / c;
		const orgAR = hBladeMm / orgChord;
		var cMin =  c/2;
		var cMax =  c*2;
		var bestLoss = getStageLoss(stageNumber ? stageNumber : 1, Re*c, bladeThicknessInMiddleMm, hBladeMm, c, tipClearance ? tipClearance : 0.005, loadFactor ? loadFactor : 0.01/0.014);
		var i;
		for (i = 0; i < 10; i++) {
			var cTest = (c+cMax)/2;
			var loss = getStageLoss(stageNumber ? stageNumber : 1, Re*cTest, bladeThicknessInMiddleMm, hBladeMm, cTest, tipClearance ? tipClearance : 0.005, loadFactor ? loadFactor : 0.01/0.014);
			if (loss.loss > bestLoss.loss) cMax = cTest;
			else {
				bestLoss = loss;
				c = cTest;
			}
			cTest = (c+cMin)/2;
			var loss = getStageLoss(stageNumber ? stageNumber : 1, Re*cTest, bladeThicknessInMiddleMm, hBladeMm, cTest, tipClearance ? tipClearance : 0.005, loadFactor ? loadFactor : 0.01/0.014);
			if (loss.loss > bestLoss.loss) cMin = cTest;
			else {
				bestLoss = loss;
				c = cTest;
			}
		}
		ret = {};
		ret.optimalAR = hBladeMm / c;
		ret.efficiency = 1 - bestLoss.loss;
		ret.profileLoss = bestLoss.profileLoss;
		ret.endWallLoss = bestLoss.endWallLoss;
/*
		var cBest = orgChord;
		const c05 = orgChord*0.05;
		for (c = orgChord*2;; c -= c05) {
			const loss = getStageLoss(stageNumber ? stageNumber : 1, Re*c, bladeThicknessInMiddleMm, hBladeMm, c, tipClearance ? tipClearance : 0.005, loadFactor ? loadFactor : 0.01/0.014);
//log += myRound(hBladeMm/c)+":"+myRound(loss)+", ";
			if (bestLoss == -1) bestLoss = loss;
			else if (bestLoss > loss) {
				bestLoss = loss;
				cBest = c;
			}
			else if (c < 2.5) {
				break;
			}
		}
//console.log(log);
		ret = {};
		ret.optimalAR = hBladeMm / cBest;
		ret.efficiency = 1 - bestLoss;
*/
//console.log("getOptimalAR_Effciency( Re="+myRound(Re*c)+", tMm="+myRound(bladeThicknessInMiddleMm)+", h="+myRound(hBladeMm)+", c="+myRound(c)+", tipClearance="+tipClearance+", loadFactor="+loadFactor+" =>ret="+JSON.stringify(ret) );
//console.log("getOptimalAR_Effciency: AR: "+orgAR+"=>"+ret.optimalAR+", efficiency: "+ret.efficiency+", Re="+(Re*orgChord)+"=>"+(Re*c)+", c="+orgChord+"=>"+c);
		return ret;
	}
	// Analytical loss model from https://api.repository.cam.ac.uk/server/api/core/bitstreams/fbfb70fe-58b3-47fb-a338-859384279d7c/content
	function getStageLoss(stageNumber, Re, bladeThicknessInMiddleMm, hBladeMm, chordMm, tipClearance, loadFactor) {
		// assume e/h == 0.005 (0.5 %)
		const zeroThicknessProfileLoss = 0.0339 * loadFactor;	// reaction = 0.5 => rotor loss +stator loss
		const profileLossByThicnessPercent = 0.0129/(4.7*1.16) * loadFactor; // rotor + stator 
		const endwallTipClearanceLossByPercent = (0.0113*1.04/(1.2*1.16)) * loadFactor; // 25/4;
		const endwallLossAtZeroClearance = 0.0242*1.04 * loadFactor; // effective AR = 1.16 - 0.12; 
		const maxThickness = bladeThicknessInMiddleMm / chordMm;
		const AR = hBladeMm / chordMm;
		const tipClearanceC = tipClearance * AR;
		const effAR = (hBladeMm - chordMm * 0.076*Math.pow(loadFactor,1.9)) / chordMm;
		
		// 1. Calc the baseline efficiency:
		// 1.1 decrement the loss difference (0.003) because higher base line stage loading coefficient (0.44) and flow coefficient (0.6) (compared to 0.25 and 0.5)
		// 2. Scale it to actual Re(c)
		// 3. Add the scaled cumulative stage loss 
//		const baseLineLossAtRefRe = zeroThicknessProfileLoss + zeroThicknessProfileLossByAR * AR + profileLossByThicnessPercent*maxThickness*100 
//			+ endwallLossAtZeroClearance / AR + (endwallTipClearanceLossByPercent + endwallTipClearanceLossByAR*AR)*tipClearance*100;
		//const nRef = -0.19;
		//var scaleToRe = Math.pow(Re, n ? n : nRef)/Math.pow(referenceRe,nRef);
		const scaleAtReferenceRe = 2; // 2.0206896551724136;		// Reference constats measured at Re(c) 474137.93103448276 

		const scaleToRe = scaleToReferenceReynoldsNum( Re, scaleAtReferenceRe );
		//scaleToRe = 1;
		// Endwall loss is about 50% less dependent on Re(c) => 
		const scaleToStageNum = 1; // getCascadedStageLoss( 1, stageNumber, chordMm/hBladeMm );
		var ret = {};
		ret.profileLoss = (zeroThicknessProfileLoss + profileLossByThicnessPercent*maxThickness*100)*scaleToRe*scaleToStageNum;
		ret.endWallLoss = (endwallLossAtZeroClearance / effAR + endwallTipClearanceLossByPercent*tipClearanceC*100/effAR)*scaleToRe*scaleToStageNum;
		ret.loss = ret.profileLoss + ret.endWallLoss;
		if (ret.loss < 0) {
			console.log(myRound(AR,3)+" loss: "+JSON.stringify(ret)+"="+(zeroThicknessProfileLoss*scaleToRe)+"+"+((profileLossByThicnessPercent*maxThickness*100)*scaleToRe)+
			"+"+((endwallTipClearanceLossByPercent*tipClearanceC*100/effAR)*scaleToRe)+"+"+(endwallLossAtZeroClearance/effAR*scaleToRe)+", Re="+myRound((Re/1000000),3)+", scaleToRe="+scaleToRe+", effAR="+effAR+", effRe="+effRe+", loadFactor="+loadFactor);
		}
	
//console.log(trace);		
		//console.log(stageNumber+": ARopt="+getOptimalAR_Effciency(bladeThicknessInMiddleMm, hBladeMm, tipClearance)+", loss at refernce Re(c) of maxThickness="+maxThickness+", tipClearance="+tipClearance+" => "+baseLineLossAtRefRe+" * (scaleToRe="+scaleToRe+") referenceLoss="+referenceLoss+" => stage 1 loss at Re="+myRound(ReExp6)+" = "+baseLineLoss+", actual loss of stage #"+stageNumber+"="+actualLoss);
		return ret;
	}
	//
	// https://api.repository.cam.ac.uk/server/api/core/bitstreams/fbfb70fe-58b3-47fb-a338-859384279d7c/content
	// 
	function scaleToReferenceReynoldsNum( Re, scaleAtReferenceRe )
	{
		const a = [[0.1,2.7], [0.2,2.42], [0.3,2.22], [0.4,2.08], [0.5,2.0], [0.6,1.92], [0.7,1.85], [0.8,1.805], [0.9,1.770], 
				   [1.0,1.75], [2.0,1.6], [3.0,1.50], [4.0,1.433], [5.0,1.37], [6.0,1.325], [7.0,1.295], [8.0,1.28], [9.0,1.27], [10,1.26], [11,1.26]]
		var scaleToRe = getArrayCoefficient( a, Re/1000000 )/scaleAtReferenceRe;
//console.log("Re="+Re+", scaleAtReferenceRe="+scaleAtReferenceRe+" => scaleToRe="+scaleToRe);
		return scaleToRe;
	/*
	
		// same scale for profile and end wall loss
		const lossByReExp6 = [[0.1, 0.2,  0.3,  0.4, 0.5, 0.6,  0.7, 0.8,  0.9,   1.0, 2.0, 3.0,  4.0,   5.0, 6.0,  7.0,   8.0,  9.0,  10],		// ReExp6
							  [2.7, 2.42, 2.22, 2.08,2.0, 1.92, 1.85,1.805,1.770, 1.75,1.6, 1.50, 1.433, 1.37,1.325,1.295, 1.28, 1.27, 1.26]
							  //,[2.7,  2.4, 2.2, 2.1,2.0, 1.96,1.93,1.905,1.8875,1.875,1.8, 1.755,1.715,1.68,1.655,1.6425,1.635,1.63,1.625]
							  ];
//							  [2.35, 2.2, 2.1, 2.05, 2.0, 1.96,1.93,1.905,1.8875,1.875,1.8, 1.755,1.715,1.68,1.655,1.6425,1.635,1.63,1.625]];
		var scaleToRe = 100, effRe = 0;
		const ReExp6 = Re/1000000;
		if (ReExp6 > lossByReExp6[0][0]) {
			if (ReExp6 >= lossByReExp6[0][lossByReExp6[0].length-1]) {
				scaleToRe = lossByReExp6[1][lossByReExp6[0].length-1]/scaleAtReferenceRe;
			}
			else {
				var i;
				for (i = 0; i < lossByReExp6[0].length -1; i++) {
					if (ReExp6 >= lossByReExp6[0][i] && ReExp6 <= lossByReExp6[0][i+1]) {
						effRe = lossByReExp6[1][i] + (lossByReExp6[1][i+1]-lossByReExp6[1][i])*((ReExp6 - lossByReExp6[0][i])/(lossByReExp6[0][i+1]-lossByReExp6[0][i]));
						scaleToRe = effRe/scaleAtReferenceRe;
						break;
					}
				}
			}
		}
//console.log("Re="+Re+", scaleAtReferenceRe="+scaleAtReferenceRe+" => scaleToRe="+scaleToRe);
		return scaleToRe;
*/
	}

	var cascadeStageLoss = 1;
	const stageLoss = [0.004/0.056, 0.002/0.060, 0.0015/0.062, 0.00075/0.0635, 0.00055/0.06425, 0.0004/0.06475, 0.00025/0.06500, 0.00015/0.06515]; // 
	const cascadedLossFactors = [];

	function getCascadedStageLoss( actualLoss, stageNumber, AR, blockageFactor ) 
	{
		if (blockageFactor) return actualLoss / blockageFactor;
throw new Error("bad blockageFactor:"+blockageFactor);
		var curCascadeStageLoss = 1;
		if (AR) curCascadeStageLoss = referenceAR/AR;

		var i;
		for (i = 0; i < stageLoss.length && i < (stageNumber-1); i++) {
//trace += (cumulativeStageLoss+" + "+(stageLoss[i]*actualLoss)+" = "+(cumulativeStageLoss + stageLoss[i]*actualLoss)+", ");
			//referenceLoss += stageLoss[i]*referenceLoss;
			actualLoss += curCascadeStageLoss*stageLoss[i]*actualLoss;
//trace += ("=>actualLoss="+actualLoss+", ");
		}
		return actualLoss;
	}
	// TURBO-19-1026-REF.pdf:  When AR* = (h-blockage)/c =>,  For cantlevered end wall and low pressure rise coefficients: 
	// blockage/c ~= 4*endWallLoss*(h-blockage)/c => blockage/(h-blockage) = 4*endWallLoss  => 1/(h/blockage-1)=4*endWallLoss => 1/(4*endWallLoss)+1=h/blockage => blockage = h/(1/(4*endWallLoss)+1)
	// => blockage/h = 1/(1/(4*endWallLoss)+1) ~= 4*endWallLoss
	function getStageBlockageFactor( stageData, endWallLoss ) {
/*
		var i;
		if (cascadedLossFactors.length == 0) {
			// skip the first one, it must be included in the initial blockage of the stage
			for (i = 0; i < stageLoss.length; i++) {
				if (i == 0) cascadedLossFactors.push(1 + 1*stageLoss[i]);
				else cascadedLossFactors.push(cascadedLossFactors[i-1] + cascadedLossFactors[i-1]*stageLoss[i]);
			}
			// cascadedLossFactors=[1.0714285714285714,1.1071428571428572,1.1339285714285714,1.1473214285714286,1.1571428571428573,1.164291230005516,1.1687692731978447,1.171460223174509]
			// 1/1.171460223174509 = 0.853 (typical work done factor)
			console.log("cascadedLossFactors="+JSON.stringify(cascadedLossFactors));
		}
		var curBlockage = 0; // 1 - (stageData.stages.length > 0 ? stageData.stages[stageData.stages.length-1].blockageFactor : 1);
		var sumOfEndWallLoss = 0;
		var k = 0;
		for (i = 1; i <= stageData.stages.length; i++) {
			sumOfEndWallLoss += stageData.stages[stageData.stages.length-i].endWallLoss;
			const curEndWallLoss = sumOfEndWallLoss/i;
//console.log(stageData.stages.length+": getStageBlockageFactor, i="+i+", curBlockage="+curBlockage+", curEndWallLoss="+curEndWallLoss+", rel blockage:"+(4*curEndWallLoss*cascadedLossFactors[i]));
			// Relative blockage:  blockage/h = 1/(1/(4*endWallLoss)+1)
			if (curBlockage < 1/(1/(4*curEndWallLoss)+1)*cascadedLossFactors[k]) curBlockage = 1/(1/(4.2*curEndWallLoss)+1)*cascadedLossFactors[k];
			if (k < (cascadedLossFactors.length-1)) k++;
		}
*/
		var curBlockage = 1/(1/(4.2*endWallLoss)+1);
		return 1 - curBlockage;
	}
	function getNextBlockageFactor( blockageFactor, iStage ) {
		return blockageFactor; // (iStage < stageLoss.length ? (1+stageLoss[iStage]) : 1) * blockageFactor;
	}
	
	function drawCompressorSide(ctx, metrics, stageData, xPx, yPx, mToPx, upSide ) {
		var side = upSide ? -1 : 1;
		function toX( xM ) { return xPx + xM*mToPx; }
		function toY( yM ) { return yPx + side*yM*mToPx; }
		function fillPoints(points, color, hasBorderLine) {
			if (typeof points === 'undefined') return; // not exists
			const region = new Path2D();
			var i;
			for (i = 0; i < points.length; i++) {
				const p = points[i];
				if (i == 0) region.moveTo(toX(p.x),toY(p.y)); 
				else region.lineTo(toX(p.x),toY(p.y)); 
			}
			region.closePath();
			ctx.fillStyle = color;
			ctx.fill(region);
			if (hasBorderLine) {
				ctx.beginPath();
				for (i = 0; i < points.length; i++) {
					const p = points[i];
					if (i == 0) ctx.moveTo(toX(p.x),toY(p.y)); 
					else ctx.lineTo(toX(p.x),toY(p.y)); 
				}
				ctx.closePath();
				ctx.stroke();
			}
		}
		ctx.strokeStyle = 'black';
		ctx.lineWidth = 1;
		const rpmColors = ['#FCB1AD', '#E5E7E7', '#FCA09C', '#D5D8D8', '#FC8782', '#C0C3C3', '#FB6A64', '#B2B6B6', '#FB4A43', '#A9ACAC', '#FB4A43', '#999C9C', '#FB4A43', '#8E9090', '#FB4A43', '#808181', '#FB4A43', '#747575'];
		const frameColor = '#393939';
		const generatorColor = '#FBCC43';
		
		var iRpm = 0;
		var rpmColor = rpmColors[0];
//console.log("metrics.bladeBasements:"+JSON.stringify(metrics.bladeBasements));
		var k;
		for (k = 0; k < metrics.rotors.length; k++) {
			fillPoints( metrics.rotors[k], rpmColor);
			fillPoints( metrics.bladeBasements[k], rpmColor);

			if (stageData.stages[k].rpmPower) {
				if (iRpm < metrics.shafts.length) {
					//fillPoints( metrics.bladeBasements[iRpm], rpmColor);
					fillPoints( metrics.shafts[iRpm], rpmColor );
//console.log(iRpm+": "+rpmColor+", points:"+JSON.stringify(metrics.shafts[iRpm]));
				}
				else {
//console.log("k="+k+", iRpm="+iRpm+" stage="+JSON.stringify(stageData.stages[i]));
				}
				iRpm++;
				rpmColor = rpmColors[iRpm % rpmColors.length];
			}
		}
		for (k = 0; k < metrics.stators.length; k++) {
			fillPoints( metrics.stators[k], frameColor );
		}
		if (upSide) {
			for (k = 0; k < metrics.generatorShaft.length; k++) {
				fillPoints( metrics.generatorShaft[k], generatorColor );
			}
		}
		//console.log("fillPoints( metrics.frame, frameColor );...");
		fillPoints( metrics.frame, frameColor );
		for (k = 0; k < metrics.whiteAreas.length; k++) {
			fillPoints( metrics.whiteAreas[k], 'white' );
		}
	}
	function drawXCoordinate( cm, x, xPx, height  ) {
		const text = x + ' m';
		const ctx = cm.ctx;
		ctx.fillText( text, xPx+2, 2*height/3);
		ctx.beginPath();
		ctx.moveTo(xPx, height/2);
		ctx.lineTo(xPx, 0 );
		ctx.stroke();
		
		ctx.fillText( text, xPx+2, cm.pxHeight-1);
		ctx.beginPath();
		ctx.moveTo(xPx, cm.pxHeight-height/2);
		ctx.lineTo(xPx, cm.pxHeight );
		ctx.stroke();
	}
	function drawYCoordinate( cm, y, yPx, height ) {
		const text = y + ' m';
		const ctx = cm.ctx;
		const width = ctx.measureText(text).width;

		ctx.fillText( text, 2, yPx-2);
		ctx.beginPath();
		ctx.moveTo(0, yPx);
		ctx.lineTo(height/2, yPx);
		ctx.stroke();
		
		ctx.fillText( text, cm.pxWidth-width-1, yPx-2);
		ctx.beginPath();
		ctx.moveTo(cm.pxWidth-height/2, yPx);
		ctx.lineTo(cm.pxWidth, yPx);
		ctx.stroke();
	}
	function getStageDataSheetArea(ctx, stageData, modelText, titleFont, cellFont, cellHeightPx, x, y )
	{
		const stageProps = stageData.stageProps;
		var points = [];
		ctx.font = titleFont;
		var cellWidthPx = ctx.measureText(modelText).width;
		const height = stageProps.length*cellHeightPx;
		const width = cellWidthPx*0.7+stageProps[0].length*cellWidthPx;
		points.push(toPoint(x, y));
		points.push(toPoint(x+height, y));
		points.push(toPoint(x+height, y+width));
		points.push(toPoint(x, y+width));
		return points;
	}

	function printStageDataSheet(ctx, stageData, modelText, titleFont, cellFont, cellHeightPx, x, y, tblId, drawOnPicture ) 
	{
		const stageProps = stageData.stageProps;
		var i, j, cellWidthPx = 0;
		var tbl = '';
		for (i = 0; i < stageProps.length; i++) {
			const row = stageProps[i];
			ctx.font = titleFont;
			if (drawOnPicture && cellWidthPx == 0) {
				cellWidthPx = ctx.measureText(modelText).width;
				const region = new Path2D();
				region.moveTo(x,y-cellHeightPx);
				region.lineTo(x+cellWidthPx*(0.7+row.length),y-cellHeightPx);
				region.lineTo(x+cellWidthPx*(0.7+row.length),y+cellHeightPx*(stageProps.length-1));
				region.lineTo(x,y+cellHeightPx*(stageProps.length-1));
				region.closePath();
				ctx.fillStyle = 'white';
				ctx.fill(region);
				ctx.fillStyle = 'black';
			}
			if (tblId) {
//console.log("row[1]="+row[1]+"#");
				if (row[1] && row[1]!=' ') {
					tbl += "<tr><th>"+row[0]+"</th>";
				}
				else {
					tbl += "<tr><th colspan=\"2\">"+row[0]+"</th>";
				}
			}
			if (drawOnPicture) ctx.fillText( row[0], x, y+i*cellHeightPx);
			
			ctx.font = i == 0 ? titleFont : cellFont;
			for (j = 1; j < row.length; j++) 
			{
				if (j != 1 || (row[j] && row[1]!=' ')) {
					if (tblId) {
						if (i == 0) {
							tbl += "<th>"+row[j]+"</th>";
						}
						else {
							tbl += "<td>"+row[j]+"</td>";
						}
					}
				}
				if (drawOnPicture) ctx.fillText( row[j], cellWidthPx*0.7+j*cellWidthPx, y+i*cellHeightPx);
			}
			if (tblId) {
				tbl += "</tr>";
			}
		}
		if (tblId) {
			$("#"+tblId).html(tbl);
		}
//console.log(tbl);
	}

	var gTotalPower = 0;
	var doingEfficiencyScan = false;
	function drawCompressor( canvasId, stageData, mToPx ) {
		const cm = stageData.getCompressorMetrics(mToPx);
		const canvas = document.getElementById(canvasId);
		const xPx = -cm.minX*mToPx;
		const yPx = cm.maxY*mToPx;
		function toX( xM ) { return xPx + xM*mToPx; }
		function toY( yM ) { return yPx + yM*mToPx; }

		if (canvas.width && canvas.height) {
			canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height); 
		}
		canvas.width = Math.round((cm.maxX - cm.minX)*mToPx);
		canvas.height = Math.round((cm.maxY - cm.minY)*mToPx);
//console.log("canvas.width="+canvas.width+", canvas.height="+canvas.height);
		const ctx = canvas.getContext("2d");
		cm.pxWidth = canvas.width;
		cm.pxHeight = canvas.height;
		cm.ctx = ctx;
		cm.mToPx = mToPx;
		// Upside:
		drawCompressorSide( ctx, cm, stageData, xPx,  yPx, mToPx, true );
		// clear the sheet data area on the lower half picture
		//cm.whiteAreas.push(getStageDataSheetArea(ctx, stageData, "12345678", "bold 11px Courier New", "bold 11px Courier New", 11, 20,  canvas.height/2+40 ));
		// Downside:
		drawCompressorSide( ctx, cm, stageData, -cm.minX*mToPx,  cm.maxY*mToPx, mToPx, false );
		var x; 
		ctx.lineWidth = 1;
		ctx.fillStyle = 'black'; 
		ctx.strokeStyle = 'black'; 
		ctx.font = "10px Arial";
		for (x = Math.floor(cm.minX); x <= Math.floor(cm.maxX); x += 1) {
			drawXCoordinate( cm, x, toX(x), 10 );
		}
		for (x = Math.floor(cm.minY); x <= Math.floor(cm.maxY); x += 1) {
			drawYCoordinate( cm, x, toY(x), 10);
		}
		printStageDataSheet(ctx, stageData, "12345678", "bold 11px Arial", "bold 11px Arial", 11, 20,  canvas.height/2+40, canvasId.replace("Image", "Data"));
		var i;
		if (stageData.titles && stageData.titles.length > 0) {
			const x = 30; // 2*canvas.width/3
			var y = 20; // toY(stageData.stages[0].rShaft+0.37)+20; // 20;
			ctx.font = "bold 14px Arial";
			//ctx.fillText( stageData.titles[0], canvas.width - ctx.measureText(stageData.titles[0]).width-30, y);
			ctx.fillText( stageData.titles[0], 30, y);
			y += 28;
			ctx.font = "12px Arial";
			for (i = 1; i < stageData.titles.length; i++) {
				textOnWhite( ctx, stageData.titles[i], x, y);
				y += 14;
			}
		}
		if (canvasId == 'hotCompressorImage' || canvasId == 'coldCompressorImage' || canvasId == 'hpCompressorImage1' || canvasId == 'hpCompressorImage2' ||
			canvasId == 'hotTurbinImage' || canvasId == 'coldTurbinImage' || canvasId == 'hpTurbinImage') {
			const image = new Image(); // Create new img element
			image.addEventListener("load", (e) => {
					console.log("Image loded: "+canvasId);
					const imgagePosY = toY(stageData.stages[0].rShaft)+20;
//console.log("***imagePosY:"+imgagePosY);
					ctx.drawImage(image, 0, imgagePosY);
					doingEfficiencyScan = true;
					var stageLoading, flowCoefficient;
					var hubStageLoading, hubFlowCoefficient;
					var prevStageLoading = -1;
					var prevFlowCoefficient = -1;
					var i, iTo = -1, previ = -1;
					var iRpmTo = -1;
					const lastSeparated = stageData.stages[stageData.stages.length-1].stagePower <  stageData.stages[stageData.stages.length-2].stagePower;
					function showTipHubOnLine( i, xFrom,yFrom,xTo,yTo, xMid, yMid ) {
//console.log(i+":(",xFrom+","+yFrom+"),(",xTo+","+yTo+")");
								var yDiff = Math.abs((yFrom-yTo)/40);
								var xDiff = Math.abs((xFrom-xTo)/40);
								if (xDiff > 10) xDiff = 10;
								if (yDiff > 10) yDiff = 10;
								ctx.beginPath();
								ctx.moveTo( xFrom-yDiff, yFrom-xDiff);
								ctx.lineTo( xFrom+yDiff, yFrom+xDiff);
								ctx.stroke();
								ctx.beginPath();
								ctx.moveTo( xMid-yDiff, yMid-xDiff);
								ctx.lineTo( xMid+yDiff, yMid+xDiff);
								ctx.stroke();
								ctx.beginPath();
								ctx.moveTo( xTo-yDiff, yTo-xDiff);
								ctx.lineTo( xTo+yDiff, yTo+xDiff);
								ctx.stroke();
					}
					function getStageLoadingPosY( stageLoading ) {
						return imgagePosY + (name == 'TEST_Helium' ? 
								(5 + (300-5)*(2.4-stageLoading)/2.4) : 
								(stageData.isCompressor ? (5 + (204-5)*(0.6-stageLoading)/0.6) : 
														 (-25 + (342)*(3.0-stageLoading)/3.0)));
					}
					function getFlowCoefficientPosX( flowCoefficient ) {
						return name == 'TEST_Helium' ? 42 + (350-42)*flowCoefficient/1 : 
								(stageData.isCompressor ? (42 + (463-42)*flowCoefficient/1) :
													       (40 + (402)*flowCoefficient/1.3));
					}
					var bestLoss = 1, bestLoadCoefficient = 0, bestFlowCoefficient = 0, bestHub = null, bestHubToTip, bestStages = 0;
					var stagesText = '';
					var bestMachLoss = 1, bestMachLoadCoefficient = 0, bestMachFlowCoefficient = 0, bestMachHubToTip, bestStallMargin = 2, bestMachStallMargin=2;
					var iTest = 0;
					//const errors = {};
					//const effs = [];
					var error;
					{
						var stageTested = false;
						var loadCoefficient, flowCoefficient;
						const isCompressor = stageData.isCompressor;
						ctx.font = "8px Arial";
						// TurbinSmithChart.jpg
						const flowCoefficientFrom = isCompressor ? 0.2 : 0.2;
						const flowCoefficientTo = isCompressor ? 1.3 : 1.3;
						const flowCoefficientStep = isCompressor ? 0.025 : 0.05;
						for (flowCoefficient = flowCoefficientFrom; flowCoefficient < flowCoefficientTo; flowCoefficient += flowCoefficientStep) {
							var stallCount = 0;
							var isStall = false, isMidStall = false;
							var iStage = 0; // stageData.isCompressor ? 0 : stageData.stages.length - 1 ;
							const loadCoefficientFrom = isCompressor ? 0.1 : 0.1;
							const loadCoefficientTo = isCompressor ? 1 : 2.8;
							const loadCoefficientStep = isCompressor ? 0.025 : 0.1;
							var hub = null;
							for (loadCoefficient = loadCoefficientFrom; loadCoefficient <= loadCoefficientTo; loadCoefficient += loadCoefficientStep) {
								var iCheck = iStage;
								if (!stageData.isCompressor && !isRedraw) iCheck = stageData.stages.length-2;
								var tryNext = false;
								var exit = false;
								var isMach = false;
								var losses = [];
								var hubTipRange = '';
								error = null;
								if (iStage < 0 || iStage == stageData.stages.length) {
									console.log(loadCoefficient+'/'+flowCoefficient+': iStage='+iStage);
									break; 
								}
								for (;;) {
									const stage = stageData.stages[iCheck];
									if (!stageData.isCompressor && !stage.prevRelp0s) stage.prevRelp0s = {};	// stage spesific thermodynamic property cache
									const reaction = stageData.reaction ? stageData.reaction : 0.5;
									const staggerAngleRad = stage.rotorStaggerAngle*Math.PI/180;
									const AR = stage.aspectRatio;
									const cOrg = stage.hRotor / AR;
									var selfTest = false;
									if (false && !stageTested) {
										flowCoefficient = stage.midFlowCoefficient;
										loadCoefficient = stage.midStageLoadingCoefficient;
										stageTested = true;
										selfTest = true;
									}
									const U = Math.sqrt(stage.hDeltaPower/loadCoefficient);
									const Vx = U*flowCoefficient;
									const rMid = U / (2*Math.PI*stage.rpm/60);
									const ndHalfArea = stage.flowM3/Vx/2;
									const midArea = rMid*rMid*Math.PI;
									// ndArea/2 == rMid^2 - rHub^2 => rHub = sqrt(rMid^2 - ndArea/2)
									// ndArea/2 == rTip^2 - rMid^2 => rTip = sqrt(rMid^2 + ndArea/2)
									if (midArea < ndHalfArea) {
										// bad geometry, try next stage
	/*									if (stageData.isCompressor) iStage++;	// try next stage
										else iStage--;							// try previous one
										loadCoefficient -= isCompressor ? 0.025 : 0.1;
										isStall = true;	
	*/
										error = "midArea_lt_ndHalfArea";
										tryNext = true;
										break;
									}
									const rHub = Math.sqrt((midArea - ndHalfArea)/Math.PI);
									const rTip = Math.sqrt((midArea + ndHalfArea)/Math.PI);
									if (Number.isNaN(rHub) || Number.isNaN(rTip)) {
										error = "rHub_or_rTip_eq_NaN";
										tryNext = true;
										break;
									}
									const hubToTipRatio = rHub/rTip;
									if (iStage == iCheck) {
										const firstHubToTipRatio = iStage == 0 ? hubToTipRatio : getStageHubToTipRatio( stageData.stages[0], loadCoefficient, flowCoefficient );
										const lastHubToTipRatio = getStageHubToTipRatio( stageData.stages[stageData.stages.length-1], loadCoefficient, flowCoefficient );
										if (firstHubToTipRatio < stageData.minHubToTip || firstHubToTipRatio > stageData.maxHubToTip ||
											lastHubToTipRatio < stageData.minHubToTip || lastHubToTipRatio > stageData.maxHubToTip)
										{ 
											//console.log(loadCoefficient+'/'+flowCoefficient+': hub2tip_out_of_range');
											error = "hub2tip_out_of_range";
											tryNext = true;
											break;
										}
										hubTipRange = myRound(firstHubToTipRatio,2) + ' - ' + myRound(lastHubToTipRatio,2);
									}
	/*
									if (hubToTipRatio < stageData.minHubToTip) { // 0.5
										// bad geometry, try next stage
										if (stageData.isCompressor) iStage++;	// try next stage
										else iStage--;							// try previous one
										loadCoefficient -= isCompressor ? 0.025 : 0.1;
										isStall = true;
										continue;
									}
	*/
									const flowM3Mid = stageData.massFlowInKg /stage.dMid;
									const areaMid =  flowM3Mid/Vx/stage.blockageFactorMid;
									const flowM3Out = stageData.massFlowInKg /stage.dOut;
									const areaOut =  flowM3Out/Vx/stage.blockageFactorOut;
									var rTipMid, rHubMid, rHubMid, rTipOut, rHubOut, rHubOut;
									if (stageData.constantDiameter == 'inner') {
										rHubMid = rHubOut = rHub;
										rMidMid = Math.sqrt(rHubMid*rHubMid+areaMid/(2*Math.PI));
										rTipMid = Math.sqrt(rHubMid*rHubMid+areaMid/Math.PI);
										rMidOut = Math.sqrt(rHubOut*rHubOut+areaOut/(2*Math.PI));
										rTipOut = Math.sqrt(rHubOut*rHubOut+areaOut/Math.PI);
									}
									else if (stageData.constantDiameter == 'outer') {
										rTipMid = rTipOut = rTip;
										rMidMid = Math.sqrt(rTipMid*rTipMid-areaMid/(2*Math.PI));
										rHubMid = Math.sqrt(rTipMid*rTipMid-areaMid/Math.PI);
										rMidOut = Math.sqrt(rTipOut*rTipOut-areaOut/(2*Math.PI));
										rHubOut = Math.sqrt(rTipOut*rTipOut-areaOut/Math.PI);
									}
									else {
										// mean
										rMidMid = rMidOut = rMid;
										rTipMid = Math.sqrt(areaMid/(2*Math.PI)+rMidMid*rMidMid);
										rHubMid = Math.sqrt(rMidMid*rMidMid-areaMid/(2*Math.PI));
										rTipOut = Math.sqrt(areaOut/(2*Math.PI)+rMidOut*rMidOut);
										rHubOut = Math.sqrt(rMidOut*rMidOut-areaOut/(2*Math.PI));
									}
									if (Number.isNaN(rHubOut) || Number.isNaN(rHubOut)) {
										error = "rHubOut_or_rTipOut_eq_NaN";
										tryNext = true;
										//console.log(loadCoefficient+'/'+flowCoefficient+': rHubOut_or_rTipOut_eq_NaN');
										break;
									}
									const hRotor = isCompressor ? (rTip-rHub + rTipMid-rHubMid)/2 : (rTipOut-rHubOut + rTipMid-rHubMid)/2;
									var c = hRotor / AR;
									const hubToTip = isCompressor ? rHub / rTip : rHubMid / rTipMid;
									const midToTip = isCompressor ? rMid / rTip : rMidMid / rTipMid;
									const alloyDensity = stage.t < 273 ? 7800 : 8001;		// austenitic steel or Nimonic 105 or 8525 if MAR-M 200: density 8450-8600 kg/m3
									var myStressCoefficient = stage.maxTensileStressMPa*loadCoefficient/stage.hDeltaPower;
									var K = myStressCoefficient*1000000/(0.5*alloyDensity*(1-hubToTipRatio*hubToTipRatio));
									var midK = myStressCoefficient*1000000/(0.5*alloyDensity*(1-midToTip*midToTip));
									var tipToHubSectionArea, tipToMidSectionArea;
									if (K >= 0.7) {
										K = 0.7;
									}
									const minK = 1 - (1-0.01)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
									if (K < minK) {
	//console.log("K="+K+"< minK="+minK+"=>tipToHubSectionArea = 0.01, midK="+midK);
										tipToHubSectionArea = 0.01;
										K = minK;
									}
									else if (!testResult( K, 0.0025, 1, K*0.02, function (d) {
										tipToHubSectionArea = d;
										// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
										// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
										return 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
										//myStressCoefficient = 0.5*alloyDensity*(1-hubToTipRatio*hubToTipRatio)*K/1000000;
									}, 12)) {
	console.log("K="+K+"> minK="+minK+"=>tipToHubSectionArea = 0.01, midK="+midK);
										testResult( 0.45, 0.0025, 1, 0.45*0.02, function (d) {
											tipToHubSectionArea = d;
											// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
											// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
											return 1 - (1-d)*(2-hubToTip - hubToTip*hubToTip)/(3*(1-hubToTip*hubToTip));
										}, 12);
										//myStressCoefficient = 0.5*alloyDensity*(1-hubToTipRatio*hubToTipRatio)*K/1000000;
									}
										if (midK > 1) {
										tipToMidSectionArea = 1;
									}
									else if (midK < minK) {
										tipToMidSectionArea = 0.01;
	console.log("midK="+midK+"< minK="+minK+"=>tipToMidSectionArea = 0.01");
									}
									else if (!testResult( midK, 0.005, 1, midK*0.02, function (d) {
											tipToMidSectionArea = d;
											// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf Page 29: Typical K range 0.55-0.65 => 
											// K = 1 - (1-d)*(2 - b - b^2)/(3*(1-b^2)), where b=rHub/rTip and d=>tip sectional area>/(hub sectional area>, r=radius, t=thickness
											return 1 - (1-d)*(2-midToTip - midToTip*midToTip)/(3*(1-midToTip*midToTip));
										}, 12))
									{
	console.log("K="+K+", midK="+midK+", minK="+minK+"=>tipToMidSectionArea = "+tipToMidSectionArea);
									}
									var tanα1, tanα2;
									const hStator = isCompressor ? (rTipMid-rHubMid + rTipOut-rHubOut)/2 : (rTipMid-rHubMid + rTip-rHub)/2;
									var foundValue = false;
									
									const β1 = stageData.isCompressor ? Math.atan(tanα2 = (reaction + loadCoefficient/2)/flowCoefficient) :
																		Math.atan(tanα2 = (-reaction + loadCoefficient/2)/flowCoefficient);
									const β2 = stageData.isCompressor ? Math.atan(tanα1 = (reaction - loadCoefficient/2)/flowCoefficient) :
																		Math.atan(tanα2 = (reaction + loadCoefficient/2)/flowCoefficient);
									const hubStageLoadingCoefficient = Math.pow(rMid/rHub,2)*loadCoefficient;
									const hubflowCoefficient = flowCoefficient * rMid / rHub;
									const hubU = U*rHub/rMid;
									const hubβ1 = stageData.isCompressor ? Math.atan((reaction + hubStageLoadingCoefficient/2)/hubflowCoefficient) :
																		   Math.atan((-reaction + hubStageLoadingCoefficient/2)/hubflowCoefficient);
									const hubβ2 = stageData.isCompressor ? Math.atan((reaction - hubStageLoadingCoefficient/2)/hubflowCoefficient) :
																		   Math.atan((reaction + hubStageLoadingCoefficient/2)/hubflowCoefficient);
									const tipU = rTip*2*Math.PI*stage.rpm/60;
									const tipStageLoadingCoefficient = stage.hDeltaPower/(tipU*tipU);
									const tipFlowCoefficient = Vx/tipU;
									const tipβ1 = stageData.isCompressor ? Math.atan(tanα2 = (reaction + tipStageLoadingCoefficient/2)/tipFlowCoefficient):
																		   Math.atan(tanα2 = (-reaction + tipStageLoadingCoefficient/2)/tipFlowCoefficient);
									const tipβ2 = stageData.isCompressor ? Math.atan(tanα1 = (reaction - tipStageLoadingCoefficient/2)/tipFlowCoefficient) :
																		   Math.atan(tanα1 = (reaction + tipStageLoadingCoefficient/2)/tipFlowCoefficient);
									var tipStaggerAngle;
									var turbinAngles = null;
									if (stageData.isCompressor) {
										const tipAngle = getCamberAngle( tipβ1*180/Math.PI, tipβ2*180/Math.PI, stageData.maxTipThickness, c, stage.rotorSolidity*rTip/rMid, true, stage.v/Math.cos(β1)/stage.mach );
										tipStaggerAngle = tipAngle.staggerAngle*Math.PI / 180;
										if (reaction != 0.5) {
											tanα1 = ((1-reaction) - loadCoefficient/2)/flowCoefficient;
											tanα2 = ((1-reaction) + loadCoefficient/2)/flowCoefficient;
										}
									}
									else {
										tipStaggerAngle = (tipβ1+tipβ2)/2;
										turbinAngles = {};
										turbinAngles.midβ1 = β1;
										turbinAngles.midβ2 = β2;
										turbinAngles.hubβ1 = hubβ1;
										turbinAngles.hubβ2 = hubβ2;
										if (reaction == 0.5) {
											turbinAngles.midα1 = β2;
											turbinAngles.midα2 = β1;
											turbinAngles.hubα1 = hubβ2;
											turbinAngles.hubα2 = hubβ1;
										}
										else {
											turbinAngles.midα2 = Math.atan(tanα2 = (-(1-reaction) + loadCoefficient/2)/flowCoefficient);
											turbinAngles.midα1 = Math.atan(tanα1 = ((1-reaction) + loadCoefficient/2)/flowCoefficient);
											turbinAngles.hubα2 = Math.atan((-(1-reaction) + hubStageLoadingCoefficient/2)/hubflowCoefficient);
											turbinAngles.hubα1 = Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/hubflowCoefficient);
										}
									}
									var midStaggerAngle = 0;
									var hubStaggerAngle = 0;
									var tMid = stage.rotor.tMid*c/cOrg;
									var tRoot = stage.rotor.tRoot*c/cOrg;
									var blades, maxLoops = 0;
									const cRe = Vx*c*(isCompressor ? stage.dynamicVisc : stage.dynamicVisc2);
									const F2 = stageData.massFlowInKg*Vx*Math.abs(tanα2-tanα1) / (1-reaction);

									while (maxLoops < 4) {
										if (stageData.isCompressor) {
											const midCamber = getCamberAngle( β1*180/Math.PI, β2*180/Math.PI, tMid, c, stage.rotorSolidity, true, stage.v/Math.cos(β1)/stage.mach );
											const hubCamber = getCamberAngle( hubβ1*180/Math.PI, hubβ2*180/Math.PI, tRoot, c, stage.rotorSolidity*rMid/rHub, true, stage.v/Math.cos(β1)/stage.mach );
											if (hubCamber.staggerAngleRad > 0 && hubCamber.staggerAngleRad < midCamber.staggerAngleRad) {
												hubStaggerAngle = hubCamber.staggerAngleRad;
											}
											else if (!hubStaggerAngle) hubStaggerAngle = midCamber.staggerAngleRad;
											midStaggerAngle = midCamber.staggerAngleRad;
											if (Number.isNaN(hubStaggerAngle)) hubStaggerAngle = (hubβ1+hubβ2)/2;
										}
										else {
											hubStaggerAngle = (hubβ1+hubβ2)/2;
											midStaggerAngle = (β1+β2)/2;
										}
										blades = 
											getStatorAndRotorBlades( stageData, rMid, rTip, rHub, rMidMid, rTipMid, rHubMid, rMidOut, rTipOut, rHubOut, stage.rotorSolidity, stage.statorSolidity, cRe, cRe, midStaggerAngle, 
												F2, stage.rpm, stage.unusedTensileStress, stageData.minTipRe, reaction, 
												stageData.maxTipThickness, c, tipToHubSectionArea, tipToMidSectionArea, hubStaggerAngle, tipStaggerAngle, turbinAngles );
										if (!stageData.isCompressor || 
											 Math.abs(tMid - blades.rotor.tMid)/blades.rotor.tMid < 0.02 || 
											 Math.abs(tRoot - blades.rotor.tRoot)/blades.rotor.tRoot < 0.02 ) 
										{
											break;
										}
										tMid = blades.rotor.tMid;
										tRoot = blades.rotor.tRoot;
										maxLoops++;
									}
									//console.log("blades:"+JSON.stringify(blades));
									const tMaxRotor = blades.rotor.tMid;
									const tMaxStator = blades.stator.tMid;

									if (tMaxRotor/c > stageData.tMaxToChord) {
										c = tMaxRotor/stageData.tMaxToChord;
									}
									try 
									{
										var loss = isCompressor ? 
											getLossDF_DRe( stageData, isCompressor,
												reaction, loadCoefficient, flowCoefficient, Vx, stage.rotorSolidity, stage.statorSolidity, 2*reaction*c, 2*(1-reaction)*c*hStator/hRotor, 
												hRotor, hStator, tMaxRotor, tMaxStator, stage.tipGap, rMid, rMidMid, rMidOut, stage.dPlus1, stage.dMid, stage.dOut, stage.mach, 
												stage.machMid, stage.machOut, stage.dynamicVisc, stage.dynamicVisc2, stage.dynamicVisc3, iStage, stage.midBlockage, 
												stage, rHub/rTip, rHubMid/rTipMid ) :
											getLossWithKackerOkapuu( stageData, stage, hRotor/c, iStage,  reaction, loadCoefficient, flowCoefficient, hRotor, hStator, 
																	 tMaxRotor, tMaxStator, rHub/rTip, rHubMid/rTipMid, Vx ) ;
										losses.push(loss);
										if (isCompressor && iCheck == iStage) {
											const α2 = isStall ? Math.atan((U-Math.tan(β2)*Vx)/Vx) : Math.atan((hubU-Math.tan(hubβ2)*Vx)/Vx);
											var ΔZ = 2*reaction*c*stageData.rotorStatorGap	// 0.2 is typical space between blade rows 
												*Math.cos(midStaggerAngle)/Math.cos(hubStaggerAngle); 	// scale the gap to hub, c is equal!
											hub = isStall ?  
												getLossParameters( 
													stage.dynamicVisc, hRotor, 0, c, blades.rotor.tMid, stage.rotorSolidity, β1, β2, 
													Vx, Vx, stage.mach, "Rotor mid", 0, 0,	// do not calc eqDR, cannot do it for root thickness!
													rMid, rMidMid, U, α2, stage.deltaH, stage.dynamicVisc2, ΔZ ) :
												getLossParameters( 
													stage.dynamicVisc, hRotor, 0, c, blades.rotor.tRoot, stage.rotorSolidity*rMid/rHub, hubβ1, hubβ2, 
													Vx, Vx, stage.mach, "Rotor hub", 0, 0,	// do not calc eqDR, cannot do it for root thickness!
													rHub, rHubMid, hubU, α2, stage.deltaH, stage.dynamicVisc2, ΔZ );
		if (selfTest) console.log(flowCoefficient+"/"+loadCoefficient+": Hub stagger angle="+hub.staggerAngle+", hub.Cp="+hub.Cp+", hub.CpMax="+hub.CpMax+", stageTested="+stageTested);
											if (hub != null && (hub.staggerAngle < 2 || hub.Cp > hub.CpMax)) {
		//console.log(flowCoefficient+"/"+loadCoefficient+": Hub stagger angle="+hub.staggerAngle+", hub.Cp="+hub.Cp+", hub.CpMax="+hub.CpMax+", stageTested="+stageTested);
												if (isStall) {
													isMidStall = true;
												}
												else {
													isStall = true;
												}
											}
											{
												var bladeTipLoss = getLossParameters( stage.dynamicVisc, hRotor, stage.tipGap, c, stageData.maxTipThickness, 
																						stage.rotorSolidity*rMid/rTip, tipβ1, tipβ2, Vx, Vx, stage.mach, "Rotor tip" );
												const machRelTip = Vx / (stageData.isCompressor ? Math.cos(tipβ1) : Math.cos(tipβ2)) / stage.mach;
												if (machRelTip > 0.9) isMach = true;
												if (false && selfTest) {
													stage.bladeTipLoss.tipStageLoadingCoefficient = stage.stageLoadingCoefficient;
													stage.bladeTipLoss.tipFlowCoefficient = stage.flowCoefficient;
													stage.bladeTipLoss.rTip = stage.rTip;
													stage.bladeTipLoss.rMid = stage.rMid;
													stage.bladeTipLoss.area = stage.area;
													stage.bladeTipLoss.deltaH = stageData.constantDeltaH;
													
													bladeTipLoss.rTip = rTip;
													bladeTipLoss.rMid = rMid;
													bladeTipLoss.tipStageLoadingCoefficient = tipStageLoadingCoefficient;
													bladeTipLoss.tipFlowCoefficient = tipFlowCoefficient;
													bladeTipLoss.area = ndHalfArea*2;
													bladeTipLoss.deltaH = stage.deltaH;
		console.log("stage.flowM3/Vx="+(stage.flowM3/Vx)+", stage.flowN3/stage.v="+(stage.flowN3/stage.v)+", stage.v="+stage.v+". stage.Vx = "+Vx);
													console.log("SELF:          tip="+JSON.stringify(bladeTipLoss));
													console.log("stage.bladeTipLoss="+JSON.stringify(stage.bladeTipLoss));
														
												}
											}
										}
										else {
											const machRelTip = Vx / (stageData.isCompressor ? Math.cos(tipβ1) : Math.cos(tipβ2)) / stage.mach;
											if (machRelTip > 0.9) isMach = true;
										}
	//console.log(flowCoefficient+"/"+loadCoefficient+": loss="+loss+", isMach="+isMach+", isStall="+isStall+", angles.staggerAngle="+angles.staggerAngle);
									}
									catch (e) 
									{
										if (selfTest) console.log(flowCoefficient+"/"+loadCoefficient+":"+e+", "+e.stack);
										console.log("error: "+e+", loadCoefficient="+loadCoefficient+", flowCoefficient="+flowCoefficient+"\r\n"+e.stack);
										if (foundValue) {
											error = "Exception";
											exit = true;
											console.log(loadCoefficient+'/'+flowCoefficient+': Exception='+e);
											break;
										}
									}
									if (!stagesText) {
										stagesText = (iCheck+1) + (isRedraw ? ', '+(1+Math.round(stageData.stages.length/2))+', '+(stageData.stages.length-1) : '');
									}
									if (!isRedraw) break;
									// take average of the 1st, middle and last-1 efficiency
									if (iCheck == (stageData.stages.length-2)) break;
									else if (iCheck < Math.round(stageData.stages.length/2)) iCheck = Math.round(stageData.stages.length/2);
									else iCheck = stageData.stages.length-2;
								}
								if (exit) break;
								if (tryNext) continue;
								if (losses.length) {
									var loss = 0;
									for (i = 0; i < losses.length; i++) loss += losses[i];
									loss /= losses.length;
									if (loss >= 0.1) {
										loss = 0.099;
									}
									//var eff = Math.round((1 - loss)*100);
									eff = Math.round(loss*1000);
									ctx.fillStyle = 'green';
									if (isStall) {
										ctx.fillStyle = isMach ? 'brown' : 'red';
										stallCount++;
									}
									else if (isMach) {
										if (loss  < bestMachLoss) {
											if (Math.round(loss*1000) < Math.round(bestMachLoss*1000) || (hub && bestMachStallMargin > hub.Cp/hub.CpMax))
											{
												if (hub) bestMachStallMargin = hub.Cp/hub.CpMax;
												bestMachLoss = loss;
												bestMachLoadCoefficient = loadCoefficient;
												bestMachFlowCoefficient = flowCoefficient;
												bestMachHubToTip = hubTipRange;
												bestStages = losses.length;
											}
										}
										ctx.fillStyle = 'blue';
									}
									else if (loss < bestLoss) {
										if (Math.round(loss*1000) < Math.round(bestLoss*1000) || (hub && bestStallMargin > hub.Cp/hub.CpMax))
										{
											if (hub) bestStallMargin = hub.Cp/hub.CpMax;
											bestLoss = loss;
											bestLoadCoefficient = loadCoefficient;
											bestFlowCoefficient = flowCoefficient;
											bestHubToTip = hubTipRange;
											bestStages = losses.length;
										}
									}
									if (selfTest) {
										hub.U = hubU, hub.hubα2 = α2, hub.c = c, hub.hubβ1 = hubβ1, hub.hubβ2 = hubβ2;hub.rHubMid = rHubMid, hub.rotor = blades.rotor;
										hub.ΔZrel = Math.cos(hubStaggerAngle)/Math.cos(midStaggerAngle);
										hub.hubStaggerAngle = hubStaggerAngle; hub.midStaggerAngle = midStaggerAngle;
										stage.hubLoss.rotor = stage.rotor;
										hub.stallMargin = hub.Cp/hub.CpMax*100;
										stage.hubLoss.stallMargin = stage.hubLoss.Cp/stage.hubLoss.CpMax*100;
										console.log("SELF: loss="+loss+", hub="+JSON.stringify(hub));
										console.log("stage.hubLoss="+JSON.stringify(stage.hubLoss));
										flowCoefficient = 0.2;
										loadCoefficient = 0.1;
									}
									else {
										ctx.fillText( eff+'', getFlowCoefficientPosX(flowCoefficient), getStageLoadingPosY(loadCoefficient));
										//effs.push(loadCoefficient+'/'+flowCoefficient+'='+eff);
										foundValue = true;
									}
								}
								
								if (isMidStall) break;
								if (flowCoefficient < 0.45 && stallCount > 6) break;
								if (flowCoefficient < 0.5 && stallCount > 8) break;
								if (flowCoefficient < 0.55 && stallCount > 10) break;
								
								/*if (error) {
									if (!errors[error]) errors[error] = 1;
									else errors[error]++;
								}*/
							}
						}
					}
					//console.log("Smith chart errors:"+JSON.stringify(errors, null, 2 ));
					//console.log("Smith chart effs:"+JSON.stringify(effs));
					
					ctx.fillStyle = 'black'; 
					ctx.strokeStyle = 'black'; 
					ctx.font = "12px Arial";
					const textFromX = stageData.isCompressor ? -0.1 : -0.1;
					const textFromY = stageData.isCompressor ? -0.13 : -0.35;
					ctx.fillText( stageData.isCompressor ? 
									"Compressor stages on Smith's chart. The loss ‰ of 1st stage by its mean-line flow and load coefficients." :
									"Turbin stages on Smith's chart. The loss ‰ of the first high pressure stage by its mean-line flow and load coefficients."
									, getFlowCoefficientPosX(textFromX), getStageLoadingPosY(textFromY));
					ctx.fillText( stageData.isCompressor ? 
										"A green loss means that the 1st stage is subsonic, blue loss values are intersonic and in red ones the hub of the 1st stage would stall, and the loss is for a rear stage." :
										"A green loss means that the 1st stage is subsonic, blue loss values are intersonic and red ones have an impossible geometry."
									, getFlowCoefficientPosX(textFromX), getStageLoadingPosY(textFromY)+12);
					if (bestLoadCoefficient > 0) {
						//console.log("bestHub: "+JSON.stringify(bestHub));
						ctx.fillText( "Best subsonic efficiency "+myRound(1-bestLoss,3)+" of stage"+(bestStages > 1 ? 's ' :' ')+stagesText+" when load coefficient: "+myRound(bestLoadCoefficient,4)+
							" and flow coefficent: "+myRound(bestFlowCoefficient,4)+" (hub/tip: "+bestHubToTip+(stageData.isCompressor ? ", stall margin: "+myRound(bestStallMargin,2) : '')+")",
							getFlowCoefficientPosX(textFromX), getStageLoadingPosY(textFromY)+24);
					}
					if (bestMachLoadCoefficient > 0 && bestMachLoss < bestLoss) {
						ctx.fillText( "Best intersonic efficiency "+myRound(1-bestMachLoss,3)+" of stage"+(bestStages > 1 ? 's ' :' ')+stagesText+" when load coefficient: "+myRound(bestMachLoadCoefficient,2)+
							" and flow coefficent: "+myRound(bestMachFlowCoefficient,2)+" (hub/tip: "+bestMachHubToTip+(stageData.isCompressor ? ", stall margin: "+myRound(bestMachStallMargin,2) : '')+")", 
							getFlowCoefficientPosX(textFromX), getStageLoadingPosY(textFromY)+(bestLoadCoefficient > 0 ? 36 : 24));
					}
					ctx.font = "10px Arial bold";
					var yTipPrev = 0, yHubPrev = 0;
					var iLast = 0
					//if (!stageData.isCompressor) iTo = stageData.stages.length;
					var tipPos = [], hubPos = [], midPos = [];
					
					for (i = 0; i < stageData.stages.length; i++) {
						stageLoading = myRound(stageData.stages[i].stageLoadingCoefficient,3);
						flowCoefficient = myRound(stageData.stages[i].flowCoefficient,3);
						hubStageLoading = myRound(stageData.stages[i].hubStageLoadingCoefficient,3);
						hubFlowCoefficient = myRound(stageData.stages[i].hubFlowCoefficient,3);

						if (Math.abs(stageLoading-prevStageLoading) > 0.01 || Math.abs(prevFlowCoefficient-flowCoefficient)> 0.01 ||
							Math.abs(prevHubStageLoading-hubStageLoading)> 0.01  || Math.abs(prevHubFlowCoefficient-hubFlowCoefficient)> 0.01) 
						{
							var xFrom, xTo, yFrom, yTo;
							ctx.beginPath();
							ctx.moveTo( xFrom=getFlowCoefficientPosX(flowCoefficient), yFrom=getStageLoadingPosY(stageLoading));
							tipPos.push({x:xFrom,y:yFrom});
							midPos.push({x: getFlowCoefficientPosX(stageData.stages[i].midFlowCoefficient), y:getStageLoadingPosY(stageData.stages[i].midStageLoadingCoefficient)});
							// TBD: Split the area to 10 equal areas  
							const rTip = stageData.stages[i].rTip;
							const areaDec = Math.PI*(rTip*rTip - stageData.stages[i].rHub*stageData.stages[i].rHub) / 10;
							var iArea;
							for (iArea = 1; iArea < 10; iArea++) {
								const rCur = Math.sqrt(rTip*rTip - iArea*areaDec/Math.PI);
								const ratio = rTip/rCur;
								const sl = stageLoading*ratio*ratio;
								const fc = flowCoefficient*ratio;
//console.log(iArea+": rTip="+rTip+", rCur="+rCur+"; ratio="+ratio+", sl="+sl+", fc="+fc);
								ctx.lineTo( getFlowCoefficientPosX(fc), getStageLoadingPosY(sl));
							}
							ctx.lineTo( xTo=getFlowCoefficientPosX(hubFlowCoefficient), yTo=getStageLoadingPosY(hubStageLoading));
							hubPos.push({x:xTo,y:yTo});

							ctx.stroke();
							prevStageLoading = stageLoading;
							prevFlowCoefficient = flowCoefficient;
							prevHubStageLoading = hubStageLoading;
							prevHubFlowCoefficient = hubFlowCoefficient;
						}
						else {
							var xFrom=getFlowCoefficientPosX(flowCoefficient), yFrom=getStageLoadingPosY(stageLoading);
							tipPos.push({x:xFrom,y:yFrom});
							var xTo=getFlowCoefficientPosX(hubFlowCoefficient), yTo=getStageLoadingPosY(hubStageLoading);
							hubPos.push({x:xTo,y:yTo});
							midPos.push({x: getFlowCoefficientPosX(stageData.stages[i].midFlowCoefficient), y:getStageLoadingPosY(stageData.stages[i].midStageLoadingCoefficient)});
						}
					}
					ctx.font = "12px Arial";
					for (iFrom = 0, iTo = 0; iTo <= tipPos.length; iTo++) {
						if (iTo < tipPos.length) {
							showTipHubOnLine(iTo, tipPos[iTo].x, tipPos[iTo].y, hubPos[iTo].x, hubPos[iTo].y, midPos[iTo].x, midPos[iTo].y);
						}
						if (iTo == tipPos.length || Math.abs(tipPos[iTo].y - tipPos[iFrom].y) > 12 ||
							(stageData.isCompressor && iTo > 0 && (tipPos[iTo].y-tipPos[iTo-1].y)>12))
						{
							const text = (iTo-iFrom) == 1 ? "Tip#"+iTo : "Tips#"+(iFrom+1)+'-'+iTo;
							ctx.fillText(text, tipPos[iFrom].x-ctx.measureText(text).width, tipPos[iFrom].y );
							iFrom = iTo;
						}
					}
					var yPrev = 0;
					for (iFrom = 0, iTo = 0; iTo <= hubPos.length; iTo++) {
						if (iTo == hubPos.length || (Math.abs(hubPos[iTo].y - hubPos[iFrom].y) > 12)
							|| (stageData.isCompressor && iTo > 0 && (hubPos[iTo].y-hubPos[iTo-1].y)>12)) 
						{// && Math.abs(hubPos[iTo].y - yPrev) > 12)) {
							const text = (iTo-iFrom) == 1 ? "Hub#"+iTo : "Hubs#"+(iFrom+1)+'-'+iTo;
							if (stageData.isCompressor) {
								ctx.fillText(text, hubPos[iFrom].x, hubPos[iFrom].y+12 );
							}
							else {
								ctx.fillText(text, hubPos[iTo-1].x, hubPos[iTo-1].y+(Math.abs(yPrev - hubPos[iTo-1].y) < 12 ? 0 : 12));
							}
							yPrev = hubPos[iTo-1].y;
							iFrom = iTo;
						}
					}
/*
					if (i == (previ+1)) {
						if (i > iTo && i > iLast) {
							ctx.fillText( ((iLast+1)<i ? "Tips#"+(iLast+1)+'-': "Tip#")+i, getFlowCoefficientPosX(flowCoefficient)+6, getStageLoadingPosY(stageLoading)+6);
							ctx.fillText( ((iLast+1)<i ? "Hubs#"+(iLast+1)+'-': "Hub#")+i, getFlowCoefficientPosX(hubFlowCoefficient), getStageLoadingPosY(hubStageLoading)+12);
							iLast = i;
						}
					}
					else if (i > iTo && i > iLast) {
						if (iLast == (previ+1)) previ++;
						ctx.fillText( ((previ+1) < i ? "Tips#"+(previ+1)+'-' : "Tip#") +i, getFlowCoefficientPosX(flowCoefficient), getStageLoadingPosY(stageLoading)+12);
						ctx.fillText( ((previ+1) < i ? "Hubs#"+(previ+1)+'-'  : "Hub#")+i, getFlowCoefficientPosX(hubFlowCoefficient), getStageLoadingPosY(hubStageLoading)+12);
						iLast = i;
					}
*/					
					doingEfficiencyScan = false;
			});
			//if (name == 'Helium') image.onload="this.width/=2; this.height/=2;"
			image.src = name == 'TEST_Helium' ? 'SmithChart_Helium.JPG' : (stageData.isCompressor ? 'BaseLineCompressor.JPG' : 'SmithChartTurbin.jpg'); 
		}
		$("#"+canvasId).css('display','block');
//console.log("getCamberAngle_47: "+JSON.stringify(getCamberAngle( 47, 21, 10, 100, 1/2, true )));
	}
/*
		{
			const elem = document.getElementById("baseLineCompressor");
console.log("baseLineCompressor top="+elem.offsetTop+", left="+elem.offsetLeft+", width="+elem.naturalWidth+", height="+elem.naturalHeight);
		}
*/
	function getStageHubToTipRatio( stage, loadCoefficient, flowCoefficient )
	{
		const U = Math.sqrt(stage.hDeltaPower/loadCoefficient);
		const Vx = U*flowCoefficient;
		const rMid = U / (2*Math.PI*stage.rpm/60);
		const ndHalfArea = stage.flowM3/Vx/2;
		const midArea = rMid*rMid*Math.PI;
		// ndArea/2 == rMid^2 - rHub^2 => rHub = sqrt(rMid^2 - ndArea/2)
		// ndArea/2 == rTip^2 - rMid^2 => rTip = sqrt(rMid^2 + ndArea/2)
		if (midArea < ndHalfArea) {
			return 1;
		}
		const rHub = Math.sqrt((midArea - ndHalfArea)/Math.PI);
		const rTip = Math.sqrt((midArea + ndHalfArea)/Math.PI);
		if (Number.isNaN(rHub) || Number.isNaN(rTip)) {
			return 1;
		}
		return rHub/rTip;
	}
								

	function stagesToHtmlTable( stageData )
	{
		//const tmp = {"flowM3":4173.533301242276,"speedOfSound":438.5292933044679,"v":142.52202032395206,"rTip":4.615800092373975,"rHub":3.4618500692804814,"w":431.884910072582,"rpm":893.4956052158383,"h":483243.00598183315,"t":464.66160353971225,"p":48895.79446968536,"d":0.35447548938912926,"flowCoefficient":0.33,"stageLoadingCoefficient":0.2,"deltaH":37304.91510968045,"wMach":0.9848484848484848};
	}
//console.log("Ψ="+stageLoadingCoefficient+", Φ="+flowCoefficient+", s/c="+solidity+" midβ2="+midβ2+", midβ1="+midβ1+"= > approximateDF="+approximateDF+", approximateDR="+approximateDR);
	function getLoadFactor(pressureRiseCoefficient) {
	
		return 1;
/*
		// For analytical efficiency calculation
		pressureRiseCoefficient *= 100/2;		// pressure rise of rotor when reaction=0.5
		var loadingFactor = 10/14;

		if (pressureRiseCoefficient > 30) {
			if (pressureRiseCoefficient < 35) loadingFactor = (10+(pressureRiseCoefficient-30)/5) / 14;
			else if (pressureRiseCoefficient < 38) loadingFactor = (11+(pressureRiseCoefficient-35)/3) / 14;
			else if (pressureRiseCoefficient < 40.5) loadingFactor = (12+2*(pressureRiseCoefficient-38)/2.5) / 14;
			else if (pressureRiseCoefficient < 42) loadingFactor = (14+4*(pressureRiseCoefficient-40.5)/1.5) / 14;
			else loadingFactor = (18+4.5*(pressureRiseCoefficient-42)/1) / 14;
		}
if (loadingFactor > 1) 
{
	console.log("loadingFactor("+pressureRiseCoefficient+")="+loadingFactor);
}
*/
		return loadingFactor;
	}

	function getEfficiencyWithDF_DR( stageData, stage, stageIndex, stallCheck )
	{
		// https://moodle.polymtl.ca/file.php/1047/HDVo/Module_04_-_Axial_Flow_Comp.pdf
		// Calc first mid flow angles with reaction 0.5
		// => β1 = atan((stage.reaction + Ψ/2)/Φ), 
		//    β2 = atan((stage.reaction - Ψ/2)/Φ)
		// With work done: 
		// Ψ = Φ*(tan(midβ1)-tan(midβ2)) 
		// => tan(midβ1) = Ψ / Φ + tan(midβ2);
		// Reaction = 1/2*Φ*(tan(midβ1)+tan(midβ2));
		// => Reaction = 1/2*Φ*(Ψ/(Φ) + 2 * tan(midβ2));
		// => Reaction = Ψ / (2) + Φ*tan(midβ2);
		// => midβ2 = atan((Reaction - Ψ/(2))/Φ):
		const hasIGV = stageData.hasIGV;	// without IGV the relative  sunction side speed increases 50%  and the power used bu the first stage 200%!!!
		const hubStageLoadingCoefficient = Math.pow(stage.rMid/stage.rHub,2)*stage.midStageLoadingCoefficient;
		const hubU = stage.U*stage.rHub/stage.rTip;
		const midU = stage.U*stage.rMid/stage.rTip;
		var reaction = stage.reaction = stageData.reaction ? stageData.reaction : 0.5;
		var hubβ2 = stageData.isCompressor ? Math.atan((reaction - hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient) :
											 Math.atan((reaction + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient)
		var hubα2 = stageData.isCompressor ? Math.atan((hubU-Math.tan(hubβ2)*stage.v)/stage.v) 
											: Math.atan((hubU+Math.tan(hubβ2)*stage.v)/stage.v);
		var hubMach = stage.v/Math.cos(hubα2)/stage.machMid;
		const isLast = stageData.stages.length == (stageData.cStages-1);
		const isFirst = stageData.stages.length == 0;
		if (hubMach > 0.9 && stageData.isCompressor) {
			const hubFlowCoefficient = stage.midFlowCoefficient*stage.rMid/stage.rHub;
			var newHubMach;
			// check firstm that the max mach number is possible to achive
			stage.reaction = reaction = 0.8;	// max reaction
			hubα2 = Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient);
			newHubMach = stage.v/Math.cos(hubα2)/stage.mach;
			if (newHubMach < 0.9) {
				testResult( 0.9, 0.8, 0.5, 0.9*0.002, function(testReaction) {
					reaction = testReaction;
					//hubβ2 = Math.atan((reaction - hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient);
					//hubα2 = Math.atan((hubU-Math.tan(hubβ2)*stage.v)/stage.v);
					hubα2 = Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/stage.midFlowCoefficient);
					newHubMach = stage.v/Math.cos(hubα2)/stage.mach;
					return newHubMach;
				});
			}
			console.log(reaction+":hubβ2="+(180*hubβ2/Math.PI)+", hubα2="+(180*hubα2/Math.PI));
			console.log("Absolute mach number of hub inlet="+hubMach+"=>"+newHubMach+", increased the reaction "+stageData.reaction+"=>"+reaction+", hubStageLoadingCoefficient="+hubStageLoadingCoefficient+", hubFlowCoefficient="+hubFlowCoefficient);
			hubMach = newHubMach;
		}
		stage.hubMach = hubMach;
		var midβ1 = stage.bladeMidProps ? stage.bladeMidProps.β1 : 
			(stageData.isCompressor ? Math.atan((reaction + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient) :
								      Math.atan((-reaction + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient));
		const midβ2 = stage.bladeMidProps ? stage.bladeMidProps.β2 : 
			(stageData.isCompressor ? Math.atan((reaction - stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient) :
									  Math.atan((reaction + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient));
		const midα1 = typeof stage.bladeMidProps === 'undefined' && reaction == 0.5 ? midβ2 : 
			(stageData.isCompressor ? Math.atan(((1-reaction) - stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient) :
									  Math.atan(((1-reaction) + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient));
		stage.midα1 = midα1;
		const midα2 = typeof stage.bladeMidProps === 'undefined' && reaction == 0.5 ? midβ1 : 
			(stageData.isCompressor ? Math.atan(((1-reaction) + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient) :
									  Math.atan((-(1-reaction) + stage.midStageLoadingCoefficient/2)/stage.midFlowCoefficient));
		var c1 = stage.v, meanFlowC1 = stage.v, tipC1 = stage.v, tipC2 = stage.v;
		if (stageData.isCompressor && !hasIGV && isFirst) {
			c1 = stageData.inletC1;	// 1st blade row must accelerate to the actual c1
			midβ1 = Math.atan(midU/c1);
			console.log("deltaH in LE="+((1-2*Math.tan(midβ1)*stage.midFlowCoefficient)*midU*midU*stageData.massFlowInKg/1000000));
		}
		stage.midβ12dec = Math.round(midβ1*180/Math.PI)+'/'+Math.round(midβ2*180/Math.PI);
		stage.midα12dec = Math.round(-midα2*180/Math.PI)+'/'+Math.round(-midα1*180/Math.PI);
		stage.midα2 = midα2;	// isLast ? 0 : 
		//stage.midα12dec = Math.round(midα2*180/Math.PI)+'/'+Math.round(midα1*180/Math.PI);
		//const α1 = Math.atan((midU-Math.tan(midβ1)*stage.v)/stage.v);
		//const α2 = Math.atan((midU-Math.tan(midβ2)*stage.v)/stage.v);
		//console.log("TEST α1, α2, reaction="+reaction+", "+α1+"=="+midα1+"; "+α2+"=="+midα2);
		const h = (stage.rTip-stage.rHub + stage.rTipMid-stage.rHubMid) / 2;
		const c = h / stage.aspectRatio;
		const tMax = stage.rotor.tMid;
		const isNACA65 = stage.machRelTip <= 0.9; 
		const dynamicVisc = stage.dynamicVisc; // stage.cRe/c/(stage.v/Math.cos(midβ1));
		var vMid = vOut = stage.v;	// axial velocity
		stage.rotorAspectRatio = stage.aspectRatio / (2*reaction);
		const hStator = stage.hStator; // (stage.rTipMid-stage.rHubMid + stage.rTipOut-stage.rHubOut) / 2;
		if (typeof stageData.rotorStaggerAngles.length === 'undefined') {
			stageData.rotorStaggerAngles = [];
			stageData.statorStaggerAngles = [];
			stageData.rotorHubStaggerAngles = [];
			stageData.rotorTipStaggerAngles = [];
			console.log("init tables : "+(typeof stageData.rotorStaggerAngles.length));
		}
		// 
		if (stage.rotor.tRoot) {
			const hubβ1 = !hasIGV && stageData.stages.length == 0 ? Math.atan(hubU/c1) : stage.bladeHubProp ? stage.bladeHubProps.β1 : 
				(stageData.isCompressor ? Math.atan((reaction + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient) :
										  Math.atan((-reaction + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient));
			const hubβ2 = stage.bladeHubProp ?  stage.bladeHubProps.β2 : (stageData.isCompressor ? 
				Math.atan((reaction - hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient) :
				Math.atan((reaction + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient));
			const hubα1 = reaction == 0.5 ? midβ2 : 
				(stageData.isCompressor ? Math.atan(((1-reaction) - hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient):
										  Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/stage.hubFlowCoefficient));
			var hubC1 = c1;
			if (stageData.stages.length == 0 && hasIGV) {
				// the absolute velocity after IGV is the same in tip, mean flow, and hub.
				// => only hub has the the normal axial velocity, the axial velocity in mean flow and tip  Vx*cos(hubαx)/cos(hubα1)
				meanFlowC1 = stageData.inletC1 * Math.cos(midα1);
				stage.meanFlowC1 = meanFlowC1;
				hubC1 = stageData.inletC1 * Math.cos(hubα1);
			}
			/*var hub = getCamberAngle( hubβ1*180/Math.PI, hubβ2*180/Math.PI, stage.rotor.tRoot, 
										2*stage.rotor.rootReaction*c, stage.rotorSolidity*stage.rMid/stage.rHub, isNACA65, 
										stageData.stages.length<3 ? "Rotor hub" : null);*/
			const ΔZ = 2*reaction*c*stageData.rotorStatorGap	// 0.2 is typical space between blade rows 
						*Math.cos(stage.staggerAngleRad)/Math.cos(stage.hubStaggerAngleRad); 	// scale the gap to hub, c is equal!
			// make stall chack with the higest static entahlpy rise => hDeltaPower when accelerating 1st stage and elsewhere hDelta including decrease of kinetic enthalpy
			const hub = stageData.isCompressor ? 
				getLossParameters( 
					dynamicVisc, h, 0, 2*reaction*c, stage.rotor.tRoot, stage.rotorSolidity*stage.rMid/stage.rHub, hubβ1, hubβ2, 
					hubC1, vMid, stage.mach, "Rotor hub", 0, 0,	// do not calc eqDR, cannot do it for root thickness!
					stage.rHub, stage.rHubMid, stallCheck ? hubU : null, hubα2, stageData.stages.length == 0 ? stage.hDeltaPower : stage.deltaH, stage.dynamicVisc2, ΔZ ) :
				getLossParameters( 
					stage.dynamicVisc2, h, 0, 2*reaction*c, stage.rotor.tRoot, stage.rotorSolidity*stage.rMidMid/stage.rHubMid, hubβ1, hubβ2, 
					hubC1, vMid, stage.machMid, "Rotor hub", 0, 0,	// do not calc eqDR, cannot do it because of root thickness!
					stage.rHubMid, stage.rHubOut );
			if (stageData.stages.length == 0) {
				stage.hubLoss = hub; hub.U = hubU, hub.hubα2 = hubα2, hub.c = c, hub.hubβ1 = hubβ1, hub.hubβ2 = hubβ2;hub.rHubMid = stage.rHubMid; hub.ΔZrel = Math.cos(stage.hubStaggerAngleRad)/Math.cos(stage.staggerAngleRad);
				hub.hubStaggerAngleRad=stage.hubStaggerAngleRad; hub.midStaggerAngleRad=stage.staggerAngleRad;
			}
			if (stageData.isCompressor) {
				stage.stallMargin = 100 * hub.Cp / hub.CpMax;
				if (Number.isNaN(stage.stallMargin)) throw new Error("Stall margin == NaN");
				stage.Cp = hub.Cp;
				stage.CpMax = hub.CpMax;
			}
			stage.rotorHubStaggerAngle = stageData.isCompressor ? hub.staggerAngle : (hubβ1 + hubβ2)/2 * 180 / Math.PI;
			if (Number.isNaN(hub.staggerAngle)) console.log(JSON.stringify(hub));

			if (stageData.rotorHubStaggerAngles.length == stageData.stages.length) stageData.rotorHubStaggerAngles.push(stage.rotorHubStaggerAngle);
			else stageData.rotorHubStaggerAngles[stageData.stages.length] = stage.rotorHubStaggerAngle;
		}
		const bladeLoss = 
			stageData.isCompressor ? 
				getLossParameters( dynamicVisc, h, stage.tipGap, 2*reaction*c, tMax, stage.rotorSolidity, midβ1, midβ2, meanFlowC1, vMid, stage.mach, "Rotor",
											 stage.d, stage.dMid, stage.rMid, stage.rMidMid ) : 
				getLossParameters( stage.dynamicVisc2, h, stage.tipGap, 2*reaction*c, tMax, stage.rotorSolidity, midβ1, 
								   midβ2, meanFlowC1, vOut, stage.machMid, "Rotor", stage.dMid, stage.dOut, stage.rMidMid, stage.rMidOut );
										 // stallCheck ? 2*Math.PI*stage.rMid*stage.rpm/60 : null, midα2, stage.deltaH, stage.dynamicVisc2 );
		stage.rotorStaggerAngle = stageData.isCompressor ? bladeLoss.staggerAngle : (midβ1 + midβ2)/2 * 180 / Math.PI;
		const statorLoss = stageData.isCompressor ? 
							getLossParameters( stage.dynamicVisc2, hStator, isLast ? 0 : stage.tipGap, 2*(1-reaction)*c*hStator/h, isLast ? stage.stator.tMid/2 : stage.stator.tMid, 
											 stage.statorSolidity, midα2, midα1, vMid, vOut, stage.machMid, "Stator",
											 stage.dMid, stage.dOut, stage.rMidMid, stage.rMidOut) :
							getLossParameters( stage.dynamicVisc3, hStator, isFirst ? 0 : stage.tipGap, 2*(1-reaction)*c*hStator/h, isFirst ? stage.stator.tMid/2 : stage.stator.tMid, 
											 stage.statorSolidity, midα2, midα1, vMid, isFirst ? c1 : vOut, stage.mach, "Stator",
											 stage.d, stage.dMid, stage.rMid, stage.rMidMid);
		stage.statorStaggerAngle = stageData.isCompressor ? statorLoss.staggerAngle : (midα1 + midα2)/2 * 180 / Math.PI;
		stage.midβ12θdec = Math.round(bladeLoss.midβ1θ*180/Math.PI)+'/'+Math.round(bladeLoss.midβ2θ*180/Math.PI);
		if (stageData.statorStaggerAngles.length == stageData.stages.length) stageData.statorStaggerAngles.push(stage.statorStaggerAngle);
		else {
			stageData.statorStaggerAngles[stageData.stages.length] = stage.statorStaggerAngle;
		}
		const stageNum = stageData.stages.length;
		const inletBlockage = stageData.stages.length > 0 ? stageData.stages[stageData.stages.length-1].blockageFactor : 1;
		stage.inletBlockage = inletBlockage;
		stage.profileLoss = getCascadedStageLoss(reaction * bladeLoss.profileLoss, stageNum, stage.aspectRatio, inletBlockage); 
		stage.endWallLoss = getCascadedStageLoss(reaction * bladeLoss.endWallLoss, stageNum, stage.aspectRatio, inletBlockage);
		stage.midBlockage = ((stageData.blockageFactors && stageData.blockageFactors.length > stageData.stages.length ?  
								stageData.blockageFactors[stageData.stages.length] :
								getStageBlockageFactor(stageData, stage.endWallLoss)) + inletBlockage)/2;
		stage.endWallLoss += getCascadedStageLoss((1-reaction) * statorLoss.endWallLoss, stageNum, stage.aspectRatio, stageData.isCompressor ? stage.midBlockage : inletBlockage);
		stage.profileLoss += getCascadedStageLoss((1-reaction) * statorLoss.profileLoss, stageNum, stage.aspectRatio, stageData.isCompressor ? stage.midBlockage : inletBlockage);

		/* IGV is not an ordinary stator, we just assume the IGV profile loss to be 1.5 the end wall loss:
			Diffusor algorithm does not work for accelerating fluid.  Algorith for turbin stators would work better
		if (hasIGV && stageData.stages.length == 0 && (stageData.inlet.p - stage.p) > 10 ) {
			const igvTip = stage.rTip+h;
			const igvHub = stage.rHub-h;
			// rTip^2 - rMid^2 == rMid^2 - rHub^2 => rMid = sqrt(rTip^2+rHub^2)/2;
			const igvMid = Math.sqrt(igvTip*igvTip+igvHub*igvHub)/2;
			const igvArea = Math.PI*(igvTip*igvTip-igvHub*igvHub);
			const inlet = stageData.first;
			var pIGV, dIGV, vIGV;
			// IGV:  area = massFlow / (dIn*vIn);
			var ret = testResult(igvArea, stage.p, inlet.p, igvArea*0.01, function(p) {
					pIGV = p;
					dIGV = Module.PropsSI('D','P', p, 'S', inlet.s, name);
					hIGV = Module.PropsSI('H','P', p, 'S', inlet.s, name);
					vIGV = Math.sqrt(2*(inlet.h - hIGV));
//console.log("p="+p+": "+stageData.massFlowInKg+"/("+dIGV+"*"+vIGV+")="+(stageData.massFlowInKg/(dIGV*vIGV)));
					return stageData.massFlowInKg/(dIGV*vIGV);
				});
			const igvLoss = getLossParameters(dynamicVisc, 3*h, 0, h, 0, stage.rotorSolidity, 0, midα1, vIGV, meanFlowC1, stage.mach, "IVG", dIGV, stage.d, igvMid, stage.rMid);
			console.log("igvLoss profileLoss="+igvLoss.profileLoss+"*"´+(hIGV-stage.h)+"/"+stage.deltaH+"), igvArea="+igvArea+", actualArea="+(stageData.massFlowInKg/(dIGV*vIGV))+", vIGV="+vIGV+", dIGV="+dIGV+", igvLoss="+JSON.stringify(igvLoss));
			//console.log("Stator  ="+(statorLoss.profileLoss+statorLoss.endWallLoss)+", profile="+statorLoss.profileLoss+", endWall="+statorLoss.endWallLoss+", eqDR="+statorLoss.eqDR+", DF="+statorLoss.DF);
			if (igvLoss.profileLoss < 0.05) {	// sanity check???
				stage.profileLoss += igvLoss.profileLoss*(hIGV-stage.h)/stage.deltaH;	// scale the loss to fluid acceleration 'work' of IGV 
			}
			//stage.endWallLoss += igvLoss.endWallLoss;
		}
		*/
		stage.blockageFactor = getStageBlockageFactor(stageData, stage.endWallLoss);
		if (stageData.isCompressor) {
			if (stageData.blockageFactors.length == stageData.stages.length) stageData.blockageFactors.push(stage.blockageFactor);
			else stageData.blockageFactors[stageData.stages.length] = stage.blockageFactor;
		}
		stage.DF = reaction * bladeLoss.DF + (1-reaction) * statorLoss.DF;
		stage.DF_lbl = reaction * bladeLoss.DF_lbl + (1-reaction) * statorLoss.DF_lbl;
		stage.DR = reaction * bladeLoss.DR + (1-reaction) * statorLoss.DR;
		stage.eqDR = reaction * bladeLoss.eqDR + (1- reaction) * statorLoss.eqDR;
		stage.deHallerNum = reaction * bladeLoss.deHallerNum + (1-reaction) * statorLoss.deHallerNum;
		stage.pressureRiseCoefficient3 = 1 - stage.deHallerNum*stage.deHallerNum;
		//var Cp = (ΔhStage - 0.5*(U2*U2 - U*U)) / ((vRel1*vRel1 + V2*V2)/2);

		if (stageData.isCompressor) {
			stage.vMaxMach = bladeLoss.vSSmaxMach;
			if (stage.vMaxMach < bladeLoss.vRel1Mach) stage.vMaxMach = bladeLoss.vRel1Mach;
			if (stage.vMaxMach < statorLoss.vRel1Mach) stage.vMaxMach = statorLoss.vRel1Mach;
			if (stage.vMaxMach < statorLoss.vSSmaxMach) stage.vMaxMach = statorLoss.vSSmaxMach;
		}
		if (stageData.rotorStaggerAngles.length == stageData.stages.length) stageData.rotorStaggerAngles.push(stage.rotorStaggerAngle);
		else stageData.rotorStaggerAngles[stageData.stages.length] = stage.rotorStaggerAngle;

		if (stage.rotorHubStaggerAngle) {
			//const rotorWidthInHub = stage.rHub/stage.rMid*Math.cos(stage.rotorHubStaggerAngle/180*Math.PI)/Math.cos(stage.rotorStaggerAngle/180*Math.PI);
			stage.solidityInHub = stage.rotor.rootSolidity; // solidity / rotorWidthInHub;
			if (stageData.soliditiesInHub.length == stageData.stages.length) stageData.soliditiesInHub.push(stage.solidityInHub);
			else stageData.soliditiesInHub[stageData.stages.length] = stage.solidityInHub;
		}
/*
	We cannot calc mean line loss for tip or hub
		if (stallCheck)
		{
			const tipβ1 = Math.atan((stage.rotor.tipReaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			const tipβ2 = Math.atan((stage.rotor.tipReaction - stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			//const tipα1 = reaction == 0.5 ? tipβ2 : Math.atan(((1-reaction) - stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			//const tipα2 = reaction == 0.5 ? tipβ1 : Math.atan(((1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			const bladeTipLoss = getLossParameters( dynamicVisc, h, stage.tipGap, 2*stage.rotor.tipReaction*c, stageData.maxTipThickness, 
									stage.rotorSolidity, tipβ1, tipβ2, stage.v, vMid, stage.mach, "Rotor tip",
									stage.d, stage.dMid, stage.rMid, stage.rMidMid );
			stage.rotorTipStaggerAngle = bladeTipLoss.staggerAngle;
			if (stage.vMaxMach < bladeTipLoss.vSSmaxMach) stage.vMaxMach = bladeTipLoss.vSSmaxMach;
			if (stage.vMaxMach < bladeTipLoss.vRel1Mach) stage.vMaxMach = bladeTipLoss.vRel1Mach;
			// Constant axial width =>
			if (stageData.stages.length == 0) {
				//const rotorWidthInTip = stage.rTip/stage.rMid*Math.cos(stage.rotorTipStaggerAngle/180*Math.PI)/Math.cos(stage.rotorStaggerAngle/180*Math.PI);
				//stageData.solidityInTip = stageData.solidity / rotorWidthInTip;
				stageData.solidityInTip = stage.rTip/stage.rMid*stage.rotorSolidity*stage.rotor.tipReaction/reaction;
				stageData.solidityInHub = stage.rotor.rootSolidity;
			}
		}
		else 
*/
		{
			const tipβ1 = !hasIGV && stageData.stages.length == 0 ? Math.atan(stage.U/c1) : 
				(stageData.isCompressor ? Math.atan((reaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
										  Math.atan((-reaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient));
			const tipβ2 = stage.bladeTipProps ?  stage.bladeTipProps.β2 : 
				(stageData.isCompressor ? Math.atan((reaction - stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
										Math.atan((reaction + stage.stageLoadingCoefficient/2)/stage.flowCoefficient));
			stage.machRelTipActual = stageData.isCompressor ? stage.v / Math.cos(tipβ1) / stage.mach : 
															  stage.v / Math.cos(tipβ2) / stage.machOut; // exit velocity
			if (stageData.isCompressor && hasIGV && stageData.stages.length == 0) {
				const tipα1 = reaction == 0.5 ? tipβ2 : Math.atan(((1-reaction) - stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
				// the absolute velocity after IGV is the same in tip, mean flow, and hub.
				// => only hub has the the normal axial velocity, the axial velocity in mean flow and tip  Vx*cos(hubαx)/cos(hubα1)
				tipC1 = stageData.inletC1 * Math.cos(tipα1);
			}
			/*
			else if (!stageData.isCompressor && hasIGV && isLast) {
				const tipα1 = reaction == 0.5 ? tipβ2 : 
					stageData.isCompressor ? Math.atan(((1-reaction) - stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
											 Math.atan(((1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
				// the absolute velocity before OGV is the same in tip, mean flow, and hub.
				// => only hub has the the normal axial velocity, the axial velocity in mean flow and tip  Vx*cos(hubαx)/cos(hubα1)
				tipC2 = stageData.inletC1 * Math.cos(tipα1);
			}*/
			//const tipα1 = reaction == 0.5 ? tipβ2 : Math.atan(((1-reaction) - stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			//const tipα2 = reaction == 0.5 ? tipβ1 : Math.atan(((1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			const bladeTipLoss = stageData.isCompressor ? 
									getLossParameters( dynamicVisc, h, stage.tipGap, 2*reaction*c, stageData.maxTipThickness, 
													stage.rotorSolidity*stage.rMid/stage.rTip, tipβ1, tipβ2, tipC1, vMid, stage.mach, "Rotor tip" ) :
									getLossParameters( stage.dynamicVisc2, h, stage.tipGap, 2*reaction*c, stageData.maxTipThickness, 
													stage.rotorSolidity*stage.rMidMid/stage.rTipMid, tipβ1, tipβ2, vMid, tipC2, stage.machMid, "Rotor tip" );
			stage.rotorTipStaggerAngle = stageData.isCompressor ? bladeTipLoss.staggerAngle : (tipβ1 + tipβ2)/2 * 180 / Math.PI;
			if (stageData.rotorTipStaggerAngles.length == stageData.stages.length) stageData.rotorTipStaggerAngles.push(stage.rotorTipStaggerAngle);
			else stageData.rotorTipStaggerAngles[stageData.stages.length] = stage.rotorTipStaggerAngle;

			if (stageData.stages.length==0) stage.bladeTipLoss = bladeTipLoss;
			if (stageData.isCompressor) {
				if (stage.vMaxMach < bladeTipLoss.vSSmaxMach) stage.vMaxMach = bladeTipLoss.vSSmaxMach;
				if (stage.vMaxMach < bladeTipLoss.vRel1Mach) stage.vMaxMach = bladeTipLoss.vRel1Mach;
			}
			else {
				stage.vMaxMach = tipC2/Math.cos(tipβ2) / stage.machOut;
			}
		}
		if (stageData.isCompressor && stageIndex < 2) {
			const tipα1 = stageData.isCompressor ? Math.atan(((1-reaction) - stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
												Math.atan(((1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);

			const tipα2 = stageData.isCompressor ? Math.atan(((1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient) :
												Math.atan((-(1-reaction) + stage.stageLoadingCoefficient/2)/stage.flowCoefficient);
			const statorRootLoss = stageData.isCompressor ? 
				getLossParameters( stage.dynamicVisc2, hStator, 0, 2*(1-reaction)*c*hStator/h, stage.stator.tRoot, 
								  stage.statorSolidity, tipα2, tipα1, vMid, vOut, stage.machMid, "Stator root") :
				getLossParameters( stage.dynamicVisc3, hStator, 0, 2*(1-reaction)*c*hStator/h, stage.stator.tRoot, 
								  stage.statorSolidity, tipα2, tipα1, vOut, vMid, stage.machOut, "Stator root");
			if (stageData.isCompressor) {
				if (stage.vMaxMach < statorRootLoss.vSSmaxMach) stage.vMaxMach = statorRootLoss.vSSmaxMach;
				if (stage.vMaxMach < statorRootLoss.vRel1Mach) stage.vMaxMach = statorRootLoss.vRel1Mach;
			}
		}
		var loss = stage.profileLoss + stage.endWallLoss;
		stage.profileEndwallLossPercents = myRound(stage.profileLoss*100,1)+'/'+myRound(stage.endWallLoss*100,1);
										   
		stage.rotorStatorLossPercents = myRound(getCascadedStageLoss( reaction * (bladeLoss.profileLoss + bladeLoss.endWallLoss), stageNum, stage.aspectRatio, stageData.isCompressor ? inletBlockage : stage.midBlockage)*100,1)+'/'+
									    myRound(getCascadedStageLoss( (1-reaction) * (statorLoss.profileLoss + statorLoss.endWallLoss), stageNum, stage.aspectRatio, stageData.isCompressor ? stage.midBlockage : inletBlockage )*100,1);
		stage.efficiencyDS_DR = 1 - loss;
		if (!stage.efficiencyDS_DR) {
			console.log("stage:"+JSON.stringify(stage));
			throw new Error("Could not calc efficiency");
		}
		return stage.efficiencyDS_DR;
	}

	function getCamberAngle( β1Deg, β2Deg, tMax, c, solidity, isNACA65, vMach, trace )
	{
		const TONC = tMax/c;
		const SONC = solidity;  // should be 1/solidity (but, this match better with the tables)
		isNACA65 = vMach < 0.7;
		var ret = {};
		
		ret.β1Deg = β1Deg;
		ret.β2Deg = β2Deg;
		ret.vMach = vMach;
		ret.solidity = solidity;

		// Calc incidence angle iRef and deviation angle δRef from flow (in degrees) to get surface speed on leading and tailing edge (vLE and vTE)
		// There is some confusion in the literature with the meaning of α1/α2, but here α1/α2 are for rotor the relative flow speeds β1 and β2 
		// and the abolute flow speeds α2/α3 for stator => The incidence and deviation angles must be added here to α1/α2 
		// Otherwise the known loss factors would increase the efficiency and nothing would make sense!
		var Ksh = isNACA65 ? 1 : 0.7; //NACA65 series airfoil for subsonic or DCA half circle for intersonic (and supersonic)
		// K_i_t = -0.0214+19.17*TONC-122.3*TONC^2+312.5*TONC^3; 
		var Kit = -0.0214 + 19.17*(TONC)-122.3*Math.pow(TONC,2) + 312.5*Math.pow(TONC,3); // a compressor blade thickness correction factor
		// i_0_10 = (0.0325-0.0674/SONC)+(-0.002364+0.0913/SONC)*rel_ang_in+(1.64e-5-2.38e4/SONC)*rel_ang_in^2;
		var i010 = 0.0325-0.0764*solidity + (-0.002364+0.0913*solidity)*β1Deg + (0.0000164-0.000238*solidity)*β1Deg*β1Deg;
		// n = (-0.063+0.02274/SONC)+(-0.0035+0.0029/SONC)*rel_ang_in-(3.79e-5+1.11e5/SONC)*rel_ang_in^2;
		var n = -0.063+0.02274*solidity + (-0.0035+0.0029*solidity)*β1Deg - (0.0000379+0.0000111*solidity)*β1Deg*β1Deg;
		ret.n = n;
		ret.i010 = i010;
		// Calc deviation angle δ
		// K_del_t = 0.0142+6.172*TONC+36.61*TONC^2;
		var Kδ = 0.0142 + 6.172*(TONC)+36.61*Math.pow(TONC,2); // a compressor blade thickness correction factor
		// del_0_10 = (-0.0443+0.1057/SONC)+(0.0209-0.0186/SONC)*rel_ang_in+(-0.0004+0.00076/SONC)*rel_ang_in^2;
		var δ010 = -0.0443+0.1057*solidity + (0.0209-0.0186*solidity)*β1Deg + (-0.0004+0.00076*solidity)*β1Deg*β1Deg;
								
		var mBladeType = isNACA65 ? 
			//  0.17-3.33e-4*(1.0-0.1*rel_ang_in)*rel_ang_in;
			0.017 - 0.000333*(1.0-0.1*β1Deg)*β1Deg : 
			//  0.249+7.4e-4*rel_ang_in-1.32e-5*rel_ang_in^2+3.16e-7*rel_ang_in^3;
			0.249+0.00074*β1Deg - 0.0000132*Math.pow(β1Deg,2)+0.000000316*Math.pow(β1Deg,3);
		//  b = 0.9655-2.538e-3*rel_ang_in+4.221e-5*rel_ang_in^2-1.3e-6*rel_ang_in^3; 
		var b = 0.9655 - 0.002538*β1Deg + 0.00004221*β1Deg*β1Deg - 0.0000013*β1Deg*β1Deg*β1Deg;
		
		var m = mBladeType / Math.pow(solidity,b);
		if (trace) {
			ret.mNACA = (0.017 - 0.000333*(1.0-0.1*β1Deg)*β1Deg) / Math.pow(solidity,b);
			ret.mDCA = (0.249+0.00074*β1Deg - 0.0000132*Math.pow(β1Deg,2)+0.000000316*Math.pow(β1Deg,3)) / Math.pow(solidity,b);
		}
		var machCorrelation = 0; //-1 + (vMach <= 0.7 ? 0 : 10*(vMach - 0.7));	// ~Boyle, Axial-Flow-Compressors, 
		ret.m = m;
		ret.δ010 = δ010;
		ret.b = b;

		// https://www.netl.doe.gov/sites/default/files/gas-turbine-handbook/2-0.pdf Page 4/33
		ret.camberAngle = 1.2*(β1Deg - β2Deg); // Boyle: camber angle = β1 - β2! "The camber angle θ is the turning angle of the camber line."
		var  iLoop;
		// iterate to the correct camber angle
		for (iLoop = 0; iLoop < 20; iLoop++) {
			const prevCamber = ret.camberAngle
			ret.iRef = Ksh*Kit*i010 + machCorrelation + n*ret.camberAngle;
			ret.δRef = Ksh*Kδ*δ010 + m*ret.camberAngle;
			ret.camberAngle = (β1Deg-ret.iRef) - (β2Deg-ret.δRef); // β1´ - β2´
			if (Math.abs(ret.camberAngle-prevCamber)*100 < ret.camberAngle) {
				break;
			}
		}
		if (false && (ret.camberAngle < 0 || ret.camberAngle > 90)) {
			ret.camberAngle = 0; //1.2*(β1Deg - β2Deg); // Boyle: camber angle = β1 - β2! "The camber angle θ is the turning angle of the camber line."
			for(iLoop = 0; iLoop < 20; iLoop++) {
				const prevCamber = ret.camberAngle
				ret.iRef = Ksh*Kit*i010 + machCorrelation + n*ret.camberAngle;
				ret.δRef = Ksh*Kδ*δ010 + m*ret.camberAngle;
				ret.camberAngle = (β1Deg-ret.iRef) - (β2Deg-ret.δRef); // β1´ - β2´
				if (Math.abs(ret.camberAngle-prevCamber)*100 < ret.camberAngle) {
					console.log(iLoop+":iRef="+ret.iRef+", δRef="+ret.δRef+"=> camberAngle="+ret.camberAngle);
					break;
				}
			}
		}
		//if (ret.camberAngle > 360) ret.camberAngle -= 360;
		ret.iLoop = iLoop;
		ret.midβ1θ = (β1Deg-ret.iRef)/180*Math.PI;
		ret.midβ2θ = (β2Deg-ret.δRef)/180*Math.PI;
		ret.liftNACA = ret.camberAngle/2;
		ret.staggerAngle = β1Deg - ret.camberAngle/2;
		//ret.staggerAngle2 = getAngleOfAttack_NACA65( solidity, ret.liftNACA );
//console.log("ret.staggerAngle="+ret.staggerAngle+", ret.staggerAngle2="+ret.staggerAngle2);
		ret.staggerAngleRad = ret.staggerAngle*Math.PI/180;
		ret.angleOfAttack = β1Deg - ret.staggerAngle;
		if (false && ret.staggerAngle < 0) {
			ret.TONC = TONC;
			ret.β1Deg = β1Deg;
			ret.β2Deg = β2Deg;
			ret.midβ1θDec = (β1Deg+ret.iRef);
			ret.midβ2θDec = (β2Deg+ret.δRef);
			ret.angleOfAttack = getAngleOfAttack_NACA65( solidity, ret.liftNACA );
			console.log(trace+": negative staggerAngle="+JSON.stringify(ret));
			//throw Error("Negative angle of attack!!");
		}
		/*else if (trace) {
			console.log(trace+": staggerAngle="+JSON.stringify(ret));
		}*/
		//else console.log("getCamberAngle:"+JSON.stringify(ret));
//if (title.indexOf('Hub') == 0) console.log("tMax/c: "+tMax+"/"+c+"="+tMax/c+"=>Kit="+Kit+", Kδ="+Kδ+"=>camberAngle="+camberAngle);
		return ret;
	}

	// Wright, P I och Miller, D C. An Improved Compressor Performance
	// Prediction Model, ACGI,DIC,Rolls-Royce, Derby, 1991. ??
	function getLossParameters( dynamicVisc, h, tipGap, c, tMax, solidity, β1, β2, axV1, axV2, mach1, title, d1, d2, r1, r2, U, α2, ΔhStage, dynamicVisc2, ΔZ )
	{
		if (Number.isNaN(c)) throw new Error("c="+c);
		if (Number.isNaN(dynamicVisc) || Number.isNaN(h)
			 || Number.isNaN(tipGap) || Number.isNaN(c) || Number.isNaN(tMax) || Number.isNaN(solidity) || Number.isNaN(β1) 
			 || Number.isNaN(β2) || Number.isNaN(axV1) || Number.isNaN(axV2)) // || Number.isNaN(d1) || Number.isNaN(d2))
		{
			const foo = xyz;	// break here
		}
		var β1Deg = β1*180/Math.PI;
		var β2Deg = β2*180/Math.PI;
		var vRel1 = axV1/Math.cos(β1);						// relative inlet flow velocity 
		var isNACA65 = vRel1 / mach1 <= 0.9; 
		var ret = getCamberAngle( β1Deg, β2Deg, tMax, c, solidity, isNACA65, vRel1/mach1, title == 'Rotor' ? 'Rotor' : null );
		
		// assume constant axial speed stage.v everywhere

		var vLE = axV1/Math.cos(ret.midβ1θ);	// relative suction side inlet velocity on the rotor blade leading edge or absolute if stator
		var axMach1 = axV1/mach1;
		var vTE = axV2/Math.cos(ret.midβ2θ);	// relative suction side  xit velocity on the rotor blade tailing edge
		var vRel2 = axV2/Math.cos(β2);			// relative exit flow velocity 
		var deltaVrel = vRel1 - vRel2;
		var vSSmax = vRel1 + (vLE-vTE)/(2*solidity);		// max suction side speed
		ret.DF = (vSSmax - vRel2) / vRel1;	// Lieblein's approximation of diffusion factor

		ret.DR = vSSmax / vTE;
		ret.vSSmaxMach = vSSmax/mach1;
		ret.vRel1Mach = vRel1/mach1;
		ret.vSSmax = vSSmax;
		ret.deHallerNum = vRel2 / vRel1;

		//C_theta_in = Cm_in*tand(rel_ang_in);
		//C_theta_out = Cm_out*tand(rel_ang_out);
		//gamma = (r_in*C_theta_in-r_out*C_theta_out)*2*SONC/(rel_vel_in*(r_in+r_out));
		const C_theta_in = axV1*Math.tan(β1);
		const C_theta_out = axV2*Math.tan(β2);
		const gamma = (r1*C_theta_in-r2*C_theta_out) / (solidity*vRel1*(r1+r2)/2);
		//% Lieblein's diffusion factor
		ret.DF_lbl = 1-ret.deHallerNum+Math.abs(gamma)/2;
		//ret.DF = (vSSmax-vRel2)/vRel1;    	// produces 0.04-0.06 lower DF values => smaller endwall loss
		//ret.DF = ret.DF_lbl;	// produces ~0.005% % lower round trip efficiency

		/* And yet another incorrect axial compressor diffusion factor suggested by Google AI,
		it's incorrect because it is not divided by (r1+r2)/2
		ε = (1 - V2/V1) + (r2ω2 - r1ω1) / (2 * V1)
		where:
		V1 and V2 are the absolute (or relative) velocities at the blade inlet and outlet, respectively. 
		r1 and r2 are the radii at the blade inlet and outlet. 
		ω1 and ω2 are the angular velocities at the blade inlet and outlet. 
		*/

		// Koch & Smith equivalent diffusion ratio
		// This source code is based on https://pdfcoffee.com/axial-flow-compressor-10-pdf-free.html by Niclas Falc
		if (typeof d1 !== 'undefined' && d1) {
			const TONC = tMax/c;
			const SONC = 1/solidity;	// s/c
			//gamma = (r_in*C_theta_in-r_out*C_theta_out)*2*SONC/(rel_vel_in*(r_in+r_out));
			var Γ = gamma; // (r1*C_theta_in - r2*C_theta_out)*2*SONC/(vRel1*(r1+r2));
			var AVDR = d2*axV2/(d1*axV1);
			// Ap_star = (1-0.4458*TONC/(SONC*cosd((rel_ang_in+rel_ang_out)/2)))*(2+1/AVDR)/3;
			var ApStar = (1-0.4458*TONC/(SONC*Math.cos((β1+β2)/2)))*(2 + 1/AVDR)/3;
			// rho_ratio = 1-(Max^2/(1-Max^2))*(1-Ap_star-0.2445/SONC*gamma*sind(rel_ang_in));
			var densityRatio = 1 - (axMach1*axMach1) / (1 - axMach1*axMach1) * (1 - ApStar - 0.2445/SONC * Γ * Math.sin(β1));
			// Deq_star_ks = 1/dH*(1+0.7688*TONC+0.6024*abs(gamma))*
			// sqrt((sind(rel_ang_in)-0.2445/SONC*gamma)^2+(cosd(rel_ang_in)/(Ap_star*rho_ratio)));
			ret.eqDR = vRel1/vRel2*(1 + 0.7688 * TONC + 0.6024 * Math.abs(Γ)) * 
				Math.sqrt(Math.abs(Math.pow(Math.sin(β1) - 0.2445/SONC*Γ, 2)+Math.cos(β1) / (ApStar * densityRatio)));

			if (typeof ret.eqDR === 'undefined' || Number.isNaN(ret.eqDR)) {// || ret.eqDR > 15) {
				console.log(title+": Γ = "+Γ+", AVDR ="+AVDR+", ApStar = "+ ApStar+", densityRatio ="+densityRatio+", d1="+d1+", d2="+d2+", r1="+r1+", r2="+r2+", vRel1/vRel2="+vRel1/vRel2+", "+(vLE - r2*vTE) / vRel1);
				console.log("ret.eqDR:"+ret.eqDR+"="+(vRel1/vRel2*(1 + 0.7688 * TONC) + 0.6024 * Math.abs(Γ))+" * "+
									Math.sqrt(Math.abs(Math.pow(Math.sin(β1) - 0.2445/SONC * Γ, 2)+Math.cos(β1) / (ApStar * densityRatio))));
				throw Error("eqDR="+ret.eqDR);
			}
			/** The mean line values makes sense, but the algorithm cannot be used for rotor hub or stator tip
			if (title == 'Rotor') {
				console.log(title+": Γ = "+Γ+", AVDR ="+AVDR+", ApStar = "+ ApStar+", densityRatio ="+densityRatio+", d1="+d1+", d2="+d2+", r1="+r1+", r2="+r2+", vRel1/vRel2="+vRel1/vRel2+", "+(vLE - r2*vTE) / vRel1);
				console.log("ret.eqDR:"+ret.eqDR+"="+(vRel1/vRel2*(1 + 0.7688 * tMax/c) + 0.6024 * Γ)+" * "+
									Math.sqrt(Math.abs(Math.pow(Math.sin(β1) - 0.2445 * SONC * Γ, 2)+Math.cos(β1) / (ApStar * densityRatio))));
			}*/
		}
		if (typeof ret.eqDR !== 'undefined') {
			var profileLossParam = getProfileLossParam( ret.eqDR, vRel1/mach1);
			var endWallLossParam = getEndWallLossParam( ret.DF_lbl, h*tipGap/c);
			var cRe = dynamicVisc * c * vRel1;
			if (cRe == 0) throw new Error("dynamicVisc="+dynamicVisc+", c="+c+",vRel1="+vRel1);
			var scaleToRe = scaleToReferenceReynoldsNum( cRe, 1.75 );  // relative loss at Re(c)=1000000
			ret.scaleToRe = scaleToRe;
			ret.cRe = cRe;
			var profileLoss = scaleToRe*2*profileLossParam * Math.pow(ret.deHallerNum,2) / Math.cos(β2);
			var endWallLoss = scaleToRe*endWallLossParam * Math.pow(ret.deHallerNum,2) * c / h;  // Math.pow(vLE/vTE,2));  // );
			//var endWallLoss = endWallLossParam * Math.pow(ret.deHallerNum,2) * c / h;  // Math.pow(vLE/vTE,2));  // );
//			if (c < 0.001 || Number.isNaN(profileLoss + endWallLoss) || (profileLoss + endWallLoss)>1
//				|| typeof profileLoss === 'undefined' || typeof endWallLoss === 'undefined') throw new Error("Bad chord="+c+", vRel1="+vRel1+", scaleToRe="+scaleToRe+", cRe="+cRe+"; profileLoss="+profileLoss+", endWallLoss="+endWallLoss);
			ret.profileLoss = profileLoss;
			ret.endWallLoss = endWallLoss;
			if ((profileLoss+endWallLoss)>10) {
				console.log(title+": ret="+JSON.stringify(ret)+", profileLossParam="+profileLossParam+", endWallLossParam="+endWallLossParam);
			}
			if (Number.isNaN(ret.profileLoss + ret.endWallLoss)) throw new Error("Internal error");
		}

		// See Koch, C.C. Stalling Preuusre Rise Capability of Axial Flow Compressor Stages, Aircraft Engine Group, General Electric Co., 1981. 
		// Li, Jian; Teng, Jinfang; Ferlauto, Michele; Zhu, Mingmin; Qiang, Xiaoqing:
		//		An improved stall prediction model for axial compressor stage based on diffuser analogy, 2022
		// https://iris.polito.it/retrieve/580ec40f-1a42-42d8-8f74-841adc5600cd/postprint.pdf
		if (typeof U !== 'undefined') {
			// stall/surge limit by Koch et al
			var s = c/solidity;
			var U2 = U*r2/r1;
			var V2 = axV2/Math.cos(α2);	// absolute stator inlet
			var Re1 = dynamicVisc * c * vRel1; 
			var Re2 = dynamicVisc2 * c * V2; 
			// actual static pressure rise coefficient
//console.log("Cp = ("+ΔhStage+" - 0.5*("+U2*U2+" - "+U*U+")) / (("+vRel1*vRel1+" + "+V2*V2+")/2");
			var Cp = (ΔhStage - 0.5*(U2*U2 - U*U)) / ((vRel1*vRel1 + V2*V2)/2);
			var Vmin = (β2+α2) <= Math.PI/2 && β2 >= 0 ? V2*Math.sin(β2+α2) :
						  (β2+α2) > Math.PI/2 ? V2 : U2;
			var Fef = (V2*V2 + 2.5*Vmin*Vmin + 0.5*U2*U2) / (4*V2*V2);
			var ReStage = (Re1*vRel1*vRel1 + Re2*V2*V2) / (vRel1*vRel1 + V2*V2);
			ret.maxSolidity = Math.pow(ReStage, 1/6) / 9;
			// => "max solidity" = Math.pow(ReStage, 1/6) / 9; => on %1 line
			var camberAngleRad = ret.camberAngle * Math.PI / 180;
			var Rc = c / 2 / Math.sin(camberAngleRad/2);
			var Xc = Rc * Math.cos(ret.midβ1θ) + s / 2;
			var Yc = Rc * Math.sin(ret.midβ1θ);
			var k1 = -Math.tan(β1);
			var k2 = -Math.tan(β2);
			var Xa = (Xc + k1*Yc - Math.sqrt(Math.abs(Rc*Rc*(k1*k1+1) - Math.pow(k1*Xc-Yc,2))))/(k1*k1+1);
//console.log("Xa = "+Xa+" =("+(Xc + k1*Yc - Math.sqrt(Rc*Rc*(k1*k1+1) - Math.pow(k1*Xc-Yc,2)))+")/("+(k1*k1+1)+")");
//console.log("Xa = ("+Xc+" + "+k1+"*"+Yc+" - Math.sqrt("+(Rc*Rc*(k1*k1+1) - Math.pow(k1*Xc-Yc,2))+"))/("+k1*k1+"+1");
if (Number.isNaN(Xa)) throw new Error("Xa="+Xa);
			var funcβ2 = k2*(Rc*Math.cos(β2)-s/2)+Rc*Math.sin(β2);
			var Xb = Xc - (k2*funcβ2 + Math.sqrt(Rc*Rc*(k2*k2+1) - Math.pow(funcβ2,2)))/(k2*k2+1);
			var Ya = k1*Xa;
			var Yb = k2*(Xb-Xc+s/2-Rc*Math.cos(β2))+Yc+Rc*Math.sin(β2);
			var κA = Math.atan((Ya-Yc)/(Xc-Xa));
			var κB = Math.atan((Yb-Yc)/(Xc-Xb));
			var κ2 = ret.midβ2θ;
			// κA-κB < 0 !!! when the loading is very low
			var modLg2 = solidity*Math.abs(κA-κB)/2/(Math.sin(camberAngleRad/2)*Math.cos(κ2));
if (modLg2 < 0 && !doingEfficiencyScan) console.log("modLg2: "+modLg2+"="+solidity+"*("+κA+"-"+κB+")/2/(Math.sin("+camberAngleRad+"/2)*Math.cos("+κ2+"))"+
			"\r\ncamberAngle:"+JSON.stringify(ret));
			var BL = Math.pow(ReStage, 1/6) / solidity;	// this should be at least 9 => %1
			var modCh = getStallingPressureRiseCoefficientModCh(modLg2, getBlockagePercent(BL));
			var refCamberAngleRad = (0.0165 * Math.pow(ret.staggerAngle,2) - 2.029 * ret.staggerAngle + 72.97)
							 * Math.PI / 180;	// to radians
			var Fcam = Math.pow( 
				(camberAngleRad * Math.sin(refCamberAngleRad/2)*Math.cos(κ2-refCamberAngleRad/2+camberAngleRad/2))
				/ (refCamberAngleRad*Math.sin(camberAngleRad/2)*Math.cos(κ2)), 2);
			if (typeof ΔZ === 'undefined') {
				ΔZ = c*stageData.rotorStatorGap;	// 0.2 is typical space between blade rows 
			}
			var Z = Math.round(2*Math.PI*r1/s);		// number of blades on row
			var g = Math.PI*(r1+r2)/2*(Math.cos(ret.midβ1θ)+Math.cos(ret.midβ2θ))/Z;
			var Fεg = fTipClearanceAveragePitchlineGap( h*tipGap / g );
			var FΔZs = fNormalizedAxialSpacing( ΔZ / s );
			ret.s = s;
			ret.εg = ΔZ / s; ret.FΔZs = FΔZs;
			ret.Cp = Cp;
			ret.CpMax = modCh*Fcam*Fεg*FΔZs*Fef;
if ((Number.isNaN(ret.CpMax) || ret.CpMax < 0 || ret.Cp < 0) && !doingEfficiencyScan) console.log("Cp="+ret.Cp+", CpMax="+ret.CpMax+" = "+modCh+"*"+Fcam+"*"+Fεg+"*"+FΔZs+"*"+Fef);
		}
//console.log(title+": c="+c+", tMax/c="+(tMax/c)+", aspectRatio="+(h/c)+", iRef="+iRef+"("+(Ksh*Kit*i010)+"+"+(n*camberAngle)+"), δRef="+δRef+"("+(Ksh*Kδ*δ010)+"+"+(m*camberAngle)+"), vLE="+vLE+", vTE="+vTE+", vSSmax="+vSSmax+", DF="+ret.DF+", DR="+ret.DR+", profileLossParam="+profileLossParam+",endWallLossParam ="+endWallLossParam
//			+", profileLoss="+JSON.stringify(ret)+", solidity="+solidity+", deHallerNum="+deHallerNum);
		return ret;
	}
	function fTipClearanceAveragePitchlineGap( εg ) {
		const a = [[0,1.215],[0.01,1.14],[0.02,1.085],[0.04,1.035],[0.1,0.92],[0.12,0.89],[0.13,0.88],[0.14,0.865],[0.15,0.84]];
		return getArrayCoefficient( a, εg );
	}
	
	function fNormalizedAxialSpacing( deltaZ_s ) {
		const a = [[0,1.19],[0.1,1.06+0.02*3/12],[0.2,1.0305],[0.3,1.01],[0.4,0.995],[0.5,0.89],[0.6,0.88],[0.7,0.865],[0.8,0.865]];
		return getArrayCoefficient( a, deltaZ_s );
	}
	// An improved stall prediction model for axial compressor stage based on diffuser analogy, 2022
	// Figure 9: Effects of blockage indicator on static-pressure-rise coefficient
	// BL >= 9 => Rec >= 531441
	function getBlockagePercent(BL) {
		if (BL >= 9) return 1;
		else if (BL >= 8) return  1 + 1*(9-BL);
		else if (BL >= 7) return  2 + 3*(8-BL);
		else if (BL >= 5.5) return  5 + 4*(7-BL);
		else return  13 + 8/3*(4.75-BL);
	}
	// An improved stall prediction model for axial compressor stage based on diffuser analogy, 2022
	// Figure 8: Correlations of static-pressure-rise coefficient at different blockage
	function getStallingPressureRiseCoefficientModCh(modLg2, blockagePercent)
	{
		const blockagePercent1 = [[0.5*3/12, 0.2],[0.5, 1.3/17],[1, 0.5+0.25/17],[1.5, 0.6+0.2/17]];
		const blockagePercent9 = [[0.5*7/12, 0.2],[0.5, 0.2+1.3/17],[1, 0.4],[1.5, 0.4+1.2/17],
								 [2.0 ,0.5+0.45/17],[2.5, 0.5+1.2/17]];
		const blockagePercent13= [[0.5,0.2], [1.0, 0.3+0.7/17], [1.5, 0.4+0.35/17], 
								  [2.0, 0.4+1.2/17], [2.5, 0.5+0.2/17]];
		if (blockagePercent <= 1) {
			return getArrayCoefficient( blockagePercent1, modLg2 );
		}
		else if (blockagePercent <= 9) {
			const modCh1 =  getArrayCoefficient( blockagePercent1, modLg2 );
			const modCh2 =  getArrayCoefficient( blockagePercent9, modLg2 );
			return modCh1*(9 - blockagePercent)/8 + modCh2*(blockagePercent-1)/8;
		}
		else {
			const modCh1 =  getArrayCoefficient( blockagePercent9, modLg2 );
			const modCh2 =  getArrayCoefficient( blockagePercent13, modLg2 );
			return modCh1*(13 - blockagePercent)/4 + modCh2*(blockagePercent-9)/4;
		}
	}
	function getArrayCoefficient( xyVals, xVal )
	{
		var i;
		for (i = 0; i < xyVals.length; i++) {
			if (xVal <= xyVals[i+1][0] || (i+2) == xyVals.length) {
				return xyVals[i][1] + (xyVals[i+1][1] - xyVals[i][1])
					* (1 - (xyVals[i+1][0]-xVal)/(xyVals[i+1][0]-xyVals[i][0]));
			}
		}
		throw new Error("getArrayCoefficient: i="+i+", xyVals="+JSON.stringify(xyVals)+", xVal="+xVal );
	}
	
	function getCpD(Lg2) {
		if (Lg2 <= 0.5) {
			return 0.081 + (0.271-0.081)*Lg2/0.5;
		}
		else if (Lg2 <= 1) {
			return 0.271 + (0.391-0.271)*(Lg2-0.5)/0.5;
		}
		else if (Lg2 <= 1.5) {
			return 0.391 + (0.473 - 0.391)*(Lg2-1)/0.5;
		}
		else if (Lg2 <= 2) {
			return 0.473 + (0.528 - 0.473)*(Lg2-1.5)/0.5;
		}
		else if (Lg2 <= 2.5) {
			return 0.528 + (0.575 - 0.528)*(Lg2-2)/0.5;
		}
		else if (Lg2 <= 3) {
			return 0.575 + (0.615 - 0.575)*(Lg2-2.5)/0.5;
		} 
		else if (Lg2 <= 3.5) {
			return 0.615 + (0.637 - 0.615)*(Lg2-3)/0.5;
		} 
	}
	function getCpDivCpDByTipGapDivAvePitchlineGap( tipGap, pitchLineGap )
	{
		const x = tipGap / pitchLineGap;
	}

	function getProfileLossParam( DR, inletMach)
	{
		const machFactor = 0.005 * (inletMach - 0.3)/0.7;
		var profileLossParam;
		if (DR <= 1.2) profileLossParam = 0.0085+machFactor;
		else if (DR <= 1.4) profileLossParam = 0.0085+0.0025/0.2*(DR-1.2)+machFactor;
		else if (DR <= 1.6) profileLossParam = 0.0105+0.0035/0.2*(DR-1.4)+machFactor;
		else if (DR <= 1.8) profileLossParam = 0.014+0.0065/0.2*(DR-1.6)+machFactor;
		else if (DR <= 2) profileLossParam = 0.0205+0.01/0.2*(DR-1.8)+machFactor;
		else if (DR <= 2.2) profileLossParam = 0.0305+0.0125/0.2*(DR-2)+machFactor;
		else profileLossParam = 0.043+0.014/0.2*(DR-2.2)+machFactor;
	
//console.log("machFactor="+machFactor+", inletMach="+inletMach+", vRelMach="+inletMach+" => profileLossParam="+profileLossParam);
		return profileLossParam;
	}
	// https://moodle.polymtl.ca/pluginfile.php/1035680/mod_resource/content/1/MEC8250-2020-Kidikian-Part-01-02.pdf
	function getEndWallLossParam( DF, tipGap)
	{
		var low, inc, base;
		if (DF <= 0.35) {
			if (tipGap <= 0.02) {
				low = 0.036;
				inc = 0.004/0.02;
				base = 0;
			}
			else if (tipGap <= 0.04) {
				low = 0.04;
				inc = 0.008/0.02;
				base = 0.02;
			}
			else if (tipGap <= 0.07) {
				low = 0.048;
				inc = 0.02/0.03;
				base = 0.04;
			}
			else {
				low = 0.068;
				inc = 0.024/0.03;
				base = 0.07;
			}
		}
		else if (DF <= 0.4) {
			if (tipGap <= 0.02) {
				low = 0.039;
				inc = 0.004/0.02;
				base = 0;
			}
			else if (tipGap <= 0.04) {
				low = 0.044;
				inc = 0.008/0.02;
				base = 0.02;
			}
			else if (tipGap <= 0.07) {
				low = 0.057;
				inc = 0.02/0.03;
				base = 0.04;
			}
			else {
				low = 0.079;
				inc = 0.025/0.03;
				base = 0.07;
			}
		}
		else if (DF <= 0.45) {
			if (tipGap <= 0.02) {
				low = 0.041;
				inc = 0.011/0.02;
				base = 0;
			}
			else if (tipGap <= 0.04) {
				low = 0.052;
				inc = 0.022/0.02;
				base = 0.02;
			}
			else if (tipGap <= 0.07) {
				low = 0.077;
				inc = 0.03/0.03;
				base = 0.04;
			}
			else {
				low = 0.107;
				inc = 0.035/0.03;
				base = 0.07;
			}
		}
		else if (DF <= 0.5) {
			if (tipGap <= 0.02) {
				low = 0.048;
				inc = 0.025/0.02;
				base = 0;
			}
			else if (tipGap <= 0.04) {
				low = 0.052;
				inc = 0.022/0.02;
				base = 0.02;
			}
			else if (tipGap <= 0.07) {
				low = 0.107;
				inc = 0.06/0.03;
				base = 0.04;
			}
			else {
				low = 0.142;
				inc = 0.07/0.03;
				base = 0.07;
			}
		}
		else {
			if (tipGap <= 0.02) {
				low = 0.065;
				inc = 0.055/0.02;
				base = 0;
			}
			else if (tipGap <= 0.04) {
				low = 0.125;
				inc = 0.08/0.02;
				base = 0.02;
			}
			else if (tipGap <= 0.07) {
				low = 0.167;
				inc = 0.12/0.03;
				base = 0.04;
			}
			else {
				low = 0.212;
				inc = 0.14/0.03;
				base = 0.07;
			}
		}
// const ret = 
// console.log("getEndWallLossParam( "+DF+", "+tipGap+")="+ret+"="+low+" + "+inc+" * "+(tipGap-base));
		return low + inc * (tipGap-base);
	}
	// See Fig. 25  Design angles of attack (α1 - γ) for NACA 65 series, https://www.netl.doe.gov/sites/default/files/gas-turbine-handbook/2-0.pdf 
	function getAngleOfAttack_NACA65( solidity, lift ) {
		// values of solidity 1.2
		const  aoa12 = [[0,4], [4,7], [8,10], [12,14], [15,15], [18,19], [21,21.5], [24,24], [27,26]];
		var angleOfAttack;
		var i;
		for (i = 1; i < aoa12.length; i++) {
			if (aoa12[i][0] > lift) {
				break;
			}
		}
		if (i == aoa12.length) {
			i--;
		}
		angleOfAttack = aoa12[i-1][1]+(aoa12[i][1] - aoa12[i-1][1])*(lift-aoa12[i-1][0])/(aoa12[i][0] - aoa12[i-1][0]);
		if (solidity < 1.2) {
			angleOfAttack *= (24+(solidity-1.0)*10)/26;	// scale to lower solidity
		}
		else if (solidity > 1.2) {
			angleOfAttack *= (26+(solidity-1.2)*2.5/2)/26;// scale to lower solidity
		}
		return angleOfAttack;
	}

/*
Mean line algorithm cannot be usedto ceck spanwise efficiencies

	function testEfficiencyWithDF_DR( loadiCoefficient, flowCoefficient, averageVx, cMid, sMid, rTip, rHub, getMaxThicknessRotor, getMaxThicknessStator,
									  tipGap, dIn, dMid, dOut, viscIn, viscMid, machIn, machMid, rpm, iStage, stagePower )
	{
		const rMid = Math.sqrt((rTip*rTip + rHub*rHub)/2);
		const areaIn = Math.PI(rTip*rTip - rHub*rHub);
		const areaMid = areaIn*dMid/dIn;
		const areaOut = areaIn*dOut/dIn;
		const rTipMid = Math.sqrt(0.5 * areaMid/Math.PI - rMid * rMid);
		const rHubMid = Math.sqrt((rMid * rMid - 0.5 * areaMid/Math.PI));
		var ret = {profileLoss : 0, endWallLoss : 0, deHallerMin : 100, eqDR : 0, DF : 0, deHallerNum : 0, staggerAngle};

		const U = rTip*Math.PI*2*rpm/60;
		const flowCoefficientTip = averageVx/U;
		const loadCoefficientTip = loadCoefficient*Math.pow(rMid/rTip,2);
		const rTip2 = Math.sqrt(0.5 * areaMid/Math.PI + rMid * rMid);
		const β1 = Math.atan((reaction + loadCoefficientTip/2)/tflowCoefficientTip);
		const machRelTip = averageVx/Math.cos(β1)/machIn;
		//const isNACA65 = machRelTip <= 0.9;
		
		// TBD search endwall loss minimum c = sMid - x*(span-0.5);
		// TBD check the stall/surge conditions, deHaller>0.72, etc.
		var span = 0;
		while (span <= 1) 
		{
			const r1 = Math.sqrt(span > 0.5 ? ((span - 0.5) * areaIn/Math.PI + rMid * rMid) : (rMid * rMid -  (0.5 - span) * areaIn/Math.PI));
			const r2 = Math.sqrt(span > 0.5 ? ((span - 0.5) * areaMid/Math.PI + rMid * rMid): (rMid * rMid - (0.5 - span) * areaMid/Math.PI));
			const r3 = Math.sqrt(span > 0.5 ? ((span - 0.5) * areaOut/Math.PI + rMid * rMid): (rMid * rMid - (0.5 - span) * areaOut/Math.PI));
			const Vx = averageVx;
			const Ur = r1*Math.PI*2*rpm/60;
			const Us = r2*Math.PI*2*rpm/60;
			const flowCoefficientR = Vx/Ur;
			const loadCoefficientR = loadCoefficient*Math.pow(rMid/r1,2);
			const rotorLoss = getRotorLoss( isCompressor, reaction, loadCoefficientR, flowCoefficientR, Vx, getChordLen('rotor',r1), rMid/r1*s, rTip-rHub, 
										getMaxThicknessRotor(reaction, span), span == 1 ? tipGap : 0, r1, r2, dIn, dMid, machIn, viscIn );
			const flowCoefficientS = Vx/Us;
			const loadCoefficientS = loadCoefficient*Math.pow(rMid/r2,2);
			const statorLoss = getStatorLoss(  stageData, reaction, loadCoefficientS, flowCoefficientS, Vx, getChordLen('stator',r2), rMid/r2*s, rTipMid-rHubMid, 
										getMaxThicknessStator(reaction, span), span == 0 ? tipGap : 0, r2, r3, dMid, dOut, machMid, viscMid );
			if (span > 0 && span < 1) {
				ret.profileLoss += (rotorLoss.profleLoss + statorLoss.profileLoss)/10;
				ret.eqDR += (rotorLoss.eqDR + statorLoss.eqDR)/20;
				ret.deHallerNum += (rotorLoss.deHallerNum + statorLoss.deHallerNum)/20;
				ret.eqDR += (rotorLoss.eqDR + statorLoss.eqDR)/20;
			}
			else {
				ret.endWallLoss += (rotorLoss.endWallLoss + statorLoss.endWallLoss)/2;
				ret.DF += (rotorLoss.eqDR + statorLoss.eqDR)/4;
			}
			if (span == 0 || span == 0.95) span += 0.05;
			else span += 0.1;
		}
		ret.profileLoss = getCascadedStageLoss( ret.profileLoss, iStage);
		ret.endWallLoss = getCascadedStageLoss( ret.endWallLoss, iStage);
		ret.efficiency = 1 - ret.profileLoss - ret.endWallLoss;
		return ret;
	}
*/
	var globalPrevRelp0s = {};
	function getLossDF_DRe( stageData, isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, rotorSolidity, statorSolidity, 
				c1, c2, height1, height2, tMaxRotor,tMaxStator, tipGap, r1, r2, r3, d1, d2, d3, mach1, mach2, mach3,
				dynamicVisc1, dynamicVisc2, dynamicVisc3, iStage, blockageFactor, stage, hubToTip3, hubToTip2 ) 
	{
		if (isCompressor) {
			const rotorLoss = getRotorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c1, rotorSolidity, height1, tMaxRotor, tipGap, r1, r2, d1, d2, mach1, dynamicVisc1 );
			const statorLoss = getStatorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c2, statorSolidity, height2, tMaxStator, tipGap, r1, r2, d1, d2, mach2, dynamicVisc2 );
			const ret = getCascadedStageLoss(rotorLoss + statorLoss, iStage, height1/c1, blockageFactor );
			if (Number.isNaN(ret)) throw new Error("Internal error");
			return ret;
		}
		else {
			const ret = getLossWithKackerOkapuu( stageData, stage, stage.hRotor/c1, iStage,  reaction, loadCoefficient, flowCoefficient, stage.hRotor, stage.hStator, 
										tMaxRotor, tMaxStator, stage.rHub/stage.rTip, stage.rHubMid/stage.rTipMid, Vx );
			return ret;
/*		
			const rotorLoss = getRotorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c1, rotorSolidity, height1, tMaxRotor, tipGap, r2, r1, d2, d3, mach2, dynamicVisc2 );
			const statorLoss = getStatorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c2, statorSolidity, height2, tMaxStator, tipGap, r3, r2, d1, d2, mach1, dynamicVisc1 );
			const ret = getCascadedStageLoss(rotorLoss + statorLoss, iStage, height1/c1, blockageFactor );
			if (Number.isNaN(ret)) throw new Error("Internal error");
*/
		}
	}
	function getStatorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c, solidity, h, tMax, tipGap, r1, r2, d1, d2, mach, dynamicVisc )
	{
		const α1 = isCompressor ? Math.atan(((1-reaction) - loadCoefficient/2)/flowCoefficient) :
											Math.atan(((1-reaction) + loadCoefficient/2)/flowCoefficient);
		const α2 = isCompressor ? Math.atan(((1-reaction) + loadCoefficient/2)/flowCoefficient) :
											Math.atan((-(1-reaction) + loadCoefficient/2)/flowCoefficient);
	
		var ret = getLossParameters( dynamicVisc, h, tipGap, c, tMax, solidity, α2, α1, Vx, Vx, mach, "stator", d1, d2, r1, r2 );
		if (Number.isNaN(ret.profileLoss + ret.endWallLoss)) throw new Error("Internal error");
		return (ret.profileLoss + ret.endWallLoss)*(1-reaction);	// scale rotor loss to stage loss 
	}

	function getRotorLoss( isCompressor, reaction, loadCoefficient, flowCoefficient, Vx, c, solidity, h, tMax, tipGap, r1, r2, d1, d2, mach, dynamicVisc1, U, ΔhStage, dynamicVisc2 )
	{
		const β1 = isCompressor ? Math.atan((reaction + loadCoefficient/2)/flowCoefficient) :
											Math.atan((-reaction + loadCoefficient/2)/flowCoefficient);
		const β2 = isCompressor ? Math.atan((reaction - loadCoefficient/2)/flowCoefficient) : 
											Math.atan((reaction + loadCoefficient/2)/flowCoefficient);
		var ret;
		if (dynamicVisc2 && isCompressor) {
			const α2 = Math.atan(((1-reaction) + loadCoefficient/2)/flowCoefficient);
			ret = getLossParameters( dynamicVisc1, h, tipGap, c, tMax, solidity, β1, β2, Vx, Vx, mach, "rotor", d1, d2, r1, r2, U, α2, ΔhStage, dynamicVisc2 );
		}
		else {
			ret = getLossParameters( dynamicVisc1, h, tipGap, c, tMax, solidity, β1, β2, Vx, Vx, mach, "rotor", d1, d2, r1, r2 );
		}
		const loss = (ret.profileLoss + ret.endWallLoss)*reaction; // scale stator loss to stage loss 
		if (typeof loss === 'undefined' || Number.isNaN(loss) || loss > 1) {
			throw new Error("Internal error");
		}
		return loss;
	}

	function testModel(cRe, AR, hubToTip, Vx, c, t, p, deltaH)
	{
		const canvas = document.getElementById("smithsChart");
		if (canvas.width && canvas.height) {
			canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height); 
		}
		canvas.width = 400;
		canvas.height = 300;

		const image = new Image(); // Create new img element
		image.addEventListener("load", (e) => {
			console.log("Image loded");
			const imgagePosY = 100;
			function getStageLoadingPosY( stageLoading ) {
				return imgagePosY + (name == 'TEST_Helium' ? (5 + (300-5)*(2.4-stageLoading)/2.4) :  (5 + (204-5)*(0.6-stageLoading)/0.6));
			}
			function getFlowCoefficientPosX( flowCoefficient ) {
				return name == 'TEST_Helium' ? 42 + (350-42)*flowCoefficient/1 : 42 + (463-42)*flowCoefficient/1;
			}
//console.log("***imagePosY:"+imgagePosY);
			ctx.drawImage(image, 0, imgagePosY);
			ctx.font = "8px Arial";

			testEfficiencyWithDF_DR( loadiCoefficient, flowCoefficient, averageVx, getChordLen, s, rTip, rHub, getMaxThickness,
									  tipGap, dIn, dMid, dOut, viscIn, viscMid, machIn, machMid, rpm, iStage );
		});
		ctx.strokeStyle = 'black'; 

		image.src = 'BaseLineCompressor.JPG';
		$("#"+canvasId).css('display','block');
	}
	
/*	
*/
	// http://airfoiltools.com/airfoil/details?airfoil=n63010a-il#polars
	// NACA 63A010 AIRFOIL, cordinates of symmetric upper half:
	const NACA63A010 = 
		   [[0.000000, 0.000000],
			// [0.005000, 0.008160],[0.007500, 0.009830],[0.012500, 0.012500],[0.025000, 0.017370],
			[0.050000, 0.024120],
			//[0.075000, 0.029170],
			[0.100000, 0.033240],
			[0.150000, 0.039500],[0.200000, 0.044000],[0.250000, 0.047140],[0.300000, 0.049130],
			[0.350000, 0.049950],[0.400000, 0.049680],[0.450000, 0.048370],[0.500000, 0.046130],
			[0.550000, 0.043110],[0.600000, 0.039430],[0.650000, 0.035170],[0.700000, 0.030440],
			[0.750000, 0.025450],[0.800000, 0.020400],[0.850000, 0.015350],[0.900000, 0.010300],
			[0.950000, 0.005250],[1.000000, 0.000210]];
	var sectionModulusNACA63A010 = 0;
	const tMaxNACA63A010 = 0.1;		// max thickness of the model blade (chord 1 m, max thickess 0.1 m)
	// scale 10% thickness to the actual one 
	function getBladeMaxThicknessNACA63A0XX(neededSectionModulusPerM ) {
		if (sectionModulusNACA63A010 == 0) {
			var i, j;
			for (i = 0; i < 20; i++) {
				for (j = 1; j < 6; j++) {
					var h = 2 * (NACA63A010[i][1]+j*(NACA63A010[i+1][1]-NACA63A010[i][1])/5);
if (!h || Number.isNaN(h)) throw Error("Bad h="+h);
					sectionModulusNACA63A010 += 0.01 * h*h;
				}
			}
			sectionModulusNACA63A010 = sectionModulusNACA63A010 / 6;
console.log("sectionModulusNACA63A010="+sectionModulusNACA63A010+", section modulus of 0.075 sheet:"+(0.075*0.075/6));
		}

/*
			const hubMomentumPerM = stage.F*(rMiddle-stage.rHub) / (hubSolidity*2*stage.rHub*Math.PI)/Math.cos(staggerAngle)*Math.cos(staggerAngle-hubStaggerAngle);
			stage.bladeThicknessInHub = Math.sqrt(6*hubMomentumPerM/unusedTensileStress);
*/
		// t^2/neededSectionModulusPerM == tMaxNACA63A010^2/sectionModulusNACA63A010 =>
		// t = sqrt(neededSectionModulusPerM*tMaxNACA63A010^2/sectionModulusNACA63A010) 
		var tMax = Math.sqrt((tMaxNACA63A010*tMaxNACA63A010)*Math.abs(neededSectionModulusPerM)/sectionModulusNACA63A010);
		if (Number.isNaN(tMax)) {
			console.log("getBladeMaxThicknessNACA63A0XX="+tMax+"=Math.sqrt(("+tMaxNACA63A010*tMaxNACA63A010+")*"+neededSectionModulusPerM+"/"+sectionModulusNACA63A010+")");
			throw new Error("error");
		}
		return tMax;
	}
	//
	// 	Let's strech both ends of NACA63A010 airfoil on a circular arc with in/out angles α1/α2 and the same thickness in same X-cordinate.
	// 
	var circularSectionModulusCache = {};
	function getBladeMaxThicknessCircularNACA63A0XX(neededSectionModulusPerM, α1, α2 ) {
		const key = α1+'_'+α2;
		var sectionModulusNACA63A010 = circularSectionModulusCache.key;
		if (typeof sectionModulusNACA63A010 === 'undefined') {
			sectionModulusNACA63A010 = 0;
			const radStep = (α2 - α1)/20;
			var α = α1 + radStep/2;
			var i;
			// divide the streched circular airfoil to 20 parts each having the same width (5 cm)
			for (i = 0; i < 20; i++) {
				// The thickness of section modulus is to the direction of the rotation (90 degrees from the axial direction) => divide the thickness by cos(|α|)!
				var h = 2 * (NACA63A010[i][1]+(NACA63A010[i+1][1])/2/Math.cos(Math.abs(α)));
				sectionModulusNACA63A010 += 0.05 * h*h;
				α = α + radStep;
			}
			sectionModulusNACA63A010 = sectionModulusNACA63A010 / 6;
			circularSectionModulusCache.key = sectionModulusNACA63A010;
		}
//console.log("sectionModulusNACA63A010="+sectionModulusNACA63A010+", section modulus of 0.075 sheet:"+(0.075*0.075/6));
		var tMax = Math.sqrt((tMaxNACA63A010*tMaxNACA63A010)*Math.abs(neededSectionModulusPerM)/sectionModulusNACA63A010);
		if (Number.isNaN(tMax)) {
			console.log("getBladeMaxThicknessNACA63A0XX="+tMax+"=Math.sqrt(("+tMaxNACA63A010*tMaxNACA63A010+")*"+neededSectionModulusPerM+"/"+sectionModulusNACA63A010+")");
			throw new Error("error");
		}
		return tMax;
	}

//var traceStatorAndRotorBlades = true;
	function getStatorAndRotorBlades( stageData, rMidIn, rTipIn, rHubIn, rMidMid, rTipMid, rHubMid, rMidOut, rTipOut, rHubOut, 
									rotorSolidity, statorSolidity, cReRotor, cReStator, midStaggerAngle, radialForce, rpm, maxTensileStress, 
								    minRe, reaction, tMaxTip, c, tipToHubSectionArea, tipToMidSectionArea, hubStaggerAngle, tipStaggerAngle, 
									turbinAngles )
	{
		var rotor = {};
		var stator = {};
		var rTip, rMid, rHub, rTipS, rMidS, rHubS;
		if (stageData.isCompressor) {
			rTip = (rTipIn+rTipMid)/2; rMid = (rMidIn+rMidMid)/2; rHub = (rHubIn+rHubMid)/2;
			rTipS = (rTipOut+rTipMid)/2; rMidS = (rMidOut+rMidMid)/2; rHubS = (rHubOut+rHubMid)/2;
		}
		else {
			rTip = (rTipOut+rTipMid)/2; rMid = (rMidOut+rMidMid)/2; rHub = (rHubOut+rHubMid)/2;
			rTipS = (rTipIn+rTipMid)/2; rMidS = (rMidIn+rMidMid)/2; rHubS = (rHubIn+rHubMid)/2;
		}
		// keep this simple, ignore spanwise Re change because of relative/absolute velocity
		// Assume solidity to be the constant for blade span (c and s both increase by radius)
		// increase chord of rotor root up to maxReaction or until stator exceeds minRe 
		// Mach limit is easily exceeded if the reaction is changed from 0.5!!!!! => keep the man reaction
/*		if (true || minRe > cReStator) {
			rotor.rootReaction = meanReaction;
		}
		else if (minRe/cReStator < (1-maxReaction)/(1-meanReaction))
		{
			rotor.rootReaction = maxReaction;
		}
		else {
			rotor.rootReaction = 1 - (1-meanReaction)*minRe/cReStator;
		}*/
		rotor.rootSolidity =  rTip/rMid*rotorSolidity; //*rotor.rootReaction/meanReaction;
		//rotor.rootChordScale = rotor.rootReaction/meanReaction;

		// Mach limit is easily exceeded if the reaction is changed from 0.5!!!!! => keep the man reaction
		/*if (true && minRe > cReRotor) {
			rotor.tipReaction = meanReaction;
		}
		else if (minRe/cReRotor < (1-maxReaction)/(1-meanReaction))
		{
			rotor.tipReaction = 1 - maxReaction;
		}
		else {
			rotor.tipReaction = minRe/cReRotor*(1-meanReaction);
		}*/
		//rotor.tipChordScale = rotor.tipReaction/meanReaction;
		stator.rootSolidity = rMidS/rTipS*statorSolidity; //*(1-rotor.tipReaction)/(1-meanReaction);
		//stator.rootChordScale = (1-rotor.tipReaction)/(1-meanReaction);
		//stator.hubChordScale = (1-rotor.rootReaction)/(1-meanReaction);
		var area10 = (rTip*rTip - rHub*rHub)/10; // ignore *PI
		var area10S = (rTipS*rTipS - rHubS*rHubS)/10; // ignore *PI
		// start from %5 flow
		var rMomentum, rMomentumS; 		// rMomentum*rMomentum - rHub*rHub == area10/2;
		var rPrev = 0, rPrevS = 0;
		// Calc the torque force turning the stage in the mid flow radius
		// https://en.wikipedia.org/wiki/Torque: P = Mn*2*PI*rpm/60,  Mn = F*rMidFlow
		// P = stage.deltaH*massFlowInKg; // J/s == Nm/s)
		// => stage.F = stage.deltaH*massFlowInKg / (rMidFlow*2*PI*rpm/60); // N
		// OR: M*deltaH = m*(v2^2-v1^2)/2 
		// => a=v2-v1 => F = m*a, a = c2 - c1 + aplha12!
		// 
		const forcePerM = radialForce/(rMid*2*Math.PI*rotorSolidity); //P / (2*Math.PI*rpm/60*10); // * (hubStaggerAngle ? Math.cos(staggerAngle-hubStaggerAngle) : 1);	// turn force vector to the direction of rotation
		const forcePerM_S = radialForce/(rMidS*2*Math.PI*statorSolidity); //P / (2*Math.PI*rpm/60*10); // * (hubStaggerAngle ? Math.cos(staggerAngle-hubStaggerAngle) : 1);	// turn force vector to the direction of rotation
//if (traceStatorAndRotorBlades) console.log("rotorHubMomentum: "+rotorHubMomentum+" = "+(rMomentum-rHub)+"*"+F+"/("+2*Math.PI*rHub*rotor.rootSolidity+")");
		var curReaction = reaction; //rotor.rootReaction - (rotor.rootReaction-meanReaction)*(rMomentum-rHub)/(rMid-rHub);
		var rotorHubMomentum = 0;
		var rotorMidMomentum = 0;
		var statorMidMomentum = 0; 
		var statorRootMomentum = 0;
		var k = 0;
//*Math.cos(staggerAngle)
		for (;;) {
			rMomentum = rPrev ? Math.sqrt(area10+rPrev*rPrev) : Math.sqrt(area10/2+rHub*rHub);
			rMomentumS = rPrevS ? Math.sqrt(area10S+rPrevS*rPrevS) : Math.sqrt(area10S/2+rHubS*rHubS);
			if (rMomentum > rTip) break;
			// stagger angle seems to increase in sync with the radius!
			//curStaggerAngle = rMomentum > rMid ? midStaggerAngle + (tipStaggerAngle - midStaggerAngle)*(rMomentum-rMid)/(rTip-rMid) :
			//									 hubStaggerAngle + (midStaggerAngle - hubStaggerAngle)*(rMomentum-rHub)/(rMid-rHub);
			const F = forcePerM/10; // + (firstStageAccelerationForcePerM ? firstStageAccelerationForcePerM[k] : 0);
			const F_S = forcePerM_S/10; // + (firstStageAccelerationForcePerM ? firstStageAccelerationForcePerM[k] : 0);
			rotorHubMomentum += (rMomentum-rHub)*F;
//if (traceStatorAndRotorBlades) console.log("rotorHubMomentum: "+rotorHubMomentum +"="+(rMomentum-rHub)+"*"+F+"/("+2*Math.PI*rHub*rotor.rootSolidity+")");
			if (rMomentum > rMid) {
				//curReaction = reaction; //meanReaction + (meanReaction-rotor.tipReaction)*(rMomentum-rMid)/(rTip-rMid);
				rotorMidMomentum += (rMomentum-rMid)*F;
			}
			else {
				//curReaction = reaction;  //rotor.rootReaction - (rotor.rootReaction-meanReaction)*(rMomentum-rHub)/(rMid-rHub);
				statorMidMomentum += (rMidS-rMomentumS)*F_S*(1-curReaction); // /(2*Math.PI*rMid*statorSolidity) * Math.cos(midStaggerAngle - curStaggerAngle);
			}
			statorRootMomentum += (rTipS-rMomentumS)*F_S*(1-curReaction);// /(2*Math.PI*rTip*stator.rootSolidity) -curStaggerAngle);
			rPrev = rMomentum;
			rPrevS = rMomentumS;
			k++;
			if (k > 10) throw Error("Unexpected error");
		}
//		traceStatorAndRotorBlades = false;
/*
		rotor.P=P;
		rotor.F=F;
		rotor.neededSectionModulus = rotorHubMomentum/maxTensileStress;
		rotor.maxTensileStress = maxTensileStress;
		rotor.rotorHubMomentum = rotorHubMomentum;
*/
		// turn the radial force to the blade stagger angle
		rotor.tRoot = stageData.isCompressor ? getBladeMaxThicknessNACA63A0XX(rotorHubMomentum*Math.cos(hubStaggerAngle)/maxTensileStress) :
											   getBladeMaxThicknessCircularNACA63A0XX(rotorHubMomentum/maxTensileStress, turbinAngles.hubβ1, turbinAngles.hubβ2 );
		if (tMaxTip > rotor.tRoot) {
			rotor.tRoot = tMaxTip;
		}
		rotor.tMid = stageData.isCompressor ? getBladeMaxThicknessNACA63A0XX(rotorMidMomentum*Math.cos(midStaggerAngle)/maxTensileStress) :
											  getBladeMaxThicknessCircularNACA63A0XX(rotorMidMomentum/maxTensileStress, turbinAngles.midβ1, turbinAngles.midβ2 );
		if (tMaxTip > rotor.tMid) rotor.tMid = tMaxTip;
if (!rotor.tMid || Number.isNaN(rotor.tMid)) throw new Error("error");
		if (tipToHubSectionArea && tipToMidSectionArea) {
			rotor.tipChordScale = rotor.rootChordScale = 1;
			rotor.tipToHubSectionArea = rotor.tipChordScale*tMaxTip / (rotor.rootChordScale*rotor.tRoot);
			rotor.tipToMidSectionArea = rotor.tipChordScale*tMaxTip / 1*rotor.tMid;
			if (rotor.tipToHubSectionArea > tipToHubSectionArea) {
				//console.log("Max centrifugal stress exceeded, multiplying root thickness by "+rotor.tipToHubSectionArea/tipToHubSectionArea);
				rotor.tRoot *= rotor.tipToHubSectionArea/tipToHubSectionArea;
				rotor.tipToHubSectionArea = tipToHubSectionArea;
			}
			if (rotor.tipToMidSectionArea > tipToMidSectionArea)
			{
				console.log("Max centrifugal stress exceeded, multiplying mid thickness by "+rotor.tipToMidSectionArea/tipToMidSectionArea);
				rotor.tMid *= rotor.tipToMidSectionArea/tipToMidSectionArea;
			}
		}
		stator.tRoot = stageData.isCompressor ? getBladeMaxThicknessNACA63A0XX(statorRootMomentum*Math.cos(tipStaggerAngle)/maxTensileStress) :
												getBladeMaxThicknessCircularNACA63A0XX(statorRootMomentum/maxTensileStress, turbinAngles.hubα1, turbinAngles.hubα2 );
		stator.tMid = stageData.isCompressor ? getBladeMaxThicknessNACA63A0XX(statorMidMomentum*Math.cos(midStaggerAngle)/maxTensileStress) :
											   getBladeMaxThicknessCircularNACA63A0XX(statorMidMomentum/maxTensileStress, turbinAngles.midα1, turbinAngles.midα2 );
		var ret = {};
		ret.rotor = rotor;
		ret.stator = stator;
//console.log("blades:"+JSON.stringify(ret));		
		return ret;
	}

	function getRotorMidThickness( rMid, rTip, rHub, rotorSolidity, staggerAngle, P, rpm, maxTensileStress, tMaxTip )
	{
		var area10 = (rTip*rTip - rHub*rHub)/10; // ignore *PI
		// start from %5 flow
		var rMomentum = Math.sqrt(area10/2+rHub*rHub); 		// rMomentum*rMomentum - rHub*rHub == area10/2;
		var rPrev = rMomentum;
		// Calc the torque force turning the stage in the mid flow radius
		// https://en.wikipedia.org/wiki/Torque: P = Mn*2*PI*rpm/60,  Mn = F*rMidFlow
		// P = stage.deltaH*massFlowInKg; // J/s == Nm/s)
		// => stage.F = stage.deltaH*massFlowInKg / (rMidFlow*2*PI*rpm/60); // N
		var rF10 = P / (2*Math.PI*rpm/60)/10/Math.cos(staggerAngle);	// turn force vector to the direction of rotation
		var F = rF10/rMomentum;
		var rotorMidMomentum = 0;
		for (;;) {
			rMomentum = Math.sqrt(area10+rPrev*rPrev);
			if (rMomentum > rTip) break;
			F = rF10/rMomentum;
			if (rMomentum > rMid) {
				rotorMidMomentum += (rMomentum-rMid)*F/(2*Math.PI*rMid*rotorSolidity);
			}
			rPrev = rMomentum;
		}
		var tMid =  getBladeMaxThicknessNACA63A0XX(rotorMidMomentum/maxTensileStress);
		if (tMaxTip && tMid < tMaxTip) tMid = tMaxTip;
		return tMid;
	}

	/*
	*	1st stage is nearest to stall => calc pressure rise of first stage when its stall margin is 99%
	*/
	function getMaxRelativePressureRise(stageData)
	{
		const stage = stageData.stages[0]; // first stage stalls first
		const hubToTip = stage.rHub/stage.rTip;
		const hubU = stage.U*hubToTip;
		const reaction = stageData.reaction;
		const chord = stage.h / stage.aspectRatio;
		const p2Org = stageData.stages[1].p;		// approximate estimation!!!
		var p2;
		var maxAxialV, deltaH;
		testResult( 99, p2Org, p2Org*1.5, 1, function (p) {
			p2 = p;
			const h2 = Module.PropsSI('H','S', stage.s, 'P', p2, name);
			deltaH = (h2-stage.h)/stage.efficiency;	// actual power
			const hubStageLoadingCoefficient = deltaH / (hubU*hubU);
			var hubβ1, hubβ2, hubα1, hubα2, hubFlowCoefficient;
			// There is always the same result, because any axial velocity automaticaly returns the same enthalpy change
			//testResult( deltaH, stage.v*1.5, stage.v*0.5, deltaH*0.01, function (c1) 
			{
				const c1 = stage.v*stage.deltaH/deltaH;		// match to the available power
				maxAxialV = c1;
				hubFlowCoefficient = c1 / hubU;
				hubβ1 = stageData.isCompressor ? Math.atan((reaction + hubStageLoadingCoefficient/2)/hubFlowCoefficient) :
												 Math.atan((-reaction + hubStageLoadingCoefficient/2)/hubFlowCoefficient);
				hubβ2 = stageData.isCompressor ? Math.atan((reaction - hubStageLoadingCoefficient/2)/hubFlowCoefficient) :
												 Math.atan((reaction + hubStageLoadingCoefficient/2)/hubFlowCoefficient);
				hubα1 = reaction == 0.5 ? hubβ2 : 
					stageData.isCompressor ? Math.atan(((1-reaction) - hubStageLoadingCoefficient/2)/hubFlowCoefficient) :
											 Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/hubFlowCoefficient);
				hubα2 = reaction == 0.5 ? hubβ1 : 
					stageData.isCompressor ? Math.atan(((1-reaction) + hubStageLoadingCoefficient/2)/hubFlowCoefficient) :
											 Math.atan((-(1-reaction) + hubStageLoadingCoefficient/2)/hubFlowCoefficient);
				// deltaH is the kinetic enthalpy change / reaction, if the reaction does not change, 
				//return 1/2*c1*c1*(1/Math.pow(Math.cos(hubα2),2) - 1/Math.pow(Math.cos(hubα1),2))/reaction;	
			}
			//);
			const ΔZ = 2*reaction*chord*stageData.rotorStatorGap	// 0.2 is typical space between blade rows 
						*Math.cos(stage.hubStaggerAngleRad)/Math.cos(stage.staggerAngleRad); 	// scale the gap to hub, c is equal!
			if (Number.isNaN(ΔZ)) throw Error("Bad hub ΔZ");

			// make stall chack with the higest static entahlpy rise => hDeltaPower when accelerating 1st stage and elsewhere hDelta including decrease of kinetic enthalpy
			const hub = getLossParameters( 
				stage.dynamicVisc, stage.h, 0, 2*stage.reaction*chord, stage.rotor.tRoot, stage.rotorSolidity*stage.rMid/stage.rHub, hubβ1, hubβ2, 
				maxAxialV, maxAxialV, stage.mach, "Rotor hub", 0, 0,	// do not calc eqDR, cannot do it for root thickness!
				stage.rHub, stage.rHubMid, hubU, hubα2, deltaH, stage.dynamicVisc2, ΔZ );
			const stallMargin = 100 * hub.Cp / hub.CpMax;
//console.log("test max rel p2/p2Org: "+(p2/p2Org)+", Vx/VxOrg="+(maxAxialV/stage.v)+", Cp="+hub.Cp+", CpMax="+hub.CpMax+", hubα1="+(hubα1*180)+", hubα2="+(hubα2*180));
			if (Number.isNaN(stallMargin)) return 200;	
			return stallMargin
		});
console.log("rel power: "+(deltaH*maxAxialV/stage.v/stage.deltaH)+", rel pressure:"+(p2/p2Org));
		return p2 / p2Org;		// approximate estimation!!!
	}



	/*
		const tipLoss = getLoss( "rotor", isNACA65, loadCoefficientTip, flowCoefficientTip, averageVx, getChordLen('rotor',rTip), 
								rMid/rTip*s, rTip-rHub, getMaxThickness('rotor', 1), rTip, rTip2, dIn, dMid, machIn, viscIn );
		ret.midβ12dec = Math.round(midβ1*180/Math.PI)+'/'+Math.round(midβ2*180/Math.PI);
		ret.vMaxMach = tipLoss.vSSmax/machIn;
		ret.rotorTipStaggerAngle = tipLoss.staggerAngle;

		stage.rotorWidthInHub = stage.rHub/stage.rMid*Math.cos(stage.rotorHubStaggerAngle/180*Math.PI)/Math.cos(stage.rotorStaggerAngle/180*Math.PI);
		stage.solidityInHub = solidity / stage.rotorWidthInHub;
	*/

	//const test = getMetrics();
    </SCRIPT>
 </BODY></HTML>
